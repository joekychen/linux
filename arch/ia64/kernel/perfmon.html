<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › perfmon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>perfmon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file implements the perfmon-2 subsystem which is used</span>
<span class="cm"> * to program the IA-64 Performance Monitoring Unit (PMU).</span>
<span class="cm"> *</span>
<span class="cm"> * The initial version of perfmon.c was written by</span>
<span class="cm"> * Ganesh Venkitachalam, IBM Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * Then it was modified for perfmon-1.x by Stephane Eranian and</span>
<span class="cm"> * David Mosberger, Hewlett Packard Co.</span>
<span class="cm"> *</span>
<span class="cm"> * Version Perfmon-2.x is a rewrite of perfmon-1.x</span>
<span class="cm"> * by Stephane Eranian, Hewlett Packard Co.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2005  Hewlett Packard Co</span>
<span class="cm"> *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> *               David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * More information about perfmon available at:</span>
<span class="cm"> * 	http://www.hpl.hp.com/research/linux/perfmon</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/intrinsics.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/perfmon.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/signal.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
<span class="cm">/*</span>
<span class="cm"> * perfmon context state</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_CTX_UNLOADED	1	</span><span class="cm">/* context is not loaded onto any task */</span><span class="cp"></span>
<span class="cp">#define PFM_CTX_LOADED		2	</span><span class="cm">/* context is loaded onto a task */</span><span class="cp"></span>
<span class="cp">#define PFM_CTX_MASKED		3	</span><span class="cm">/* context is loaded but monitoring is masked due to overflow */</span><span class="cp"></span>
<span class="cp">#define PFM_CTX_ZOMBIE		4	</span><span class="cm">/* owner of the context is closing it */</span><span class="cp"></span>

<span class="cp">#define PFM_INVALID_ACTIVATION	(~0UL)</span>

<span class="cp">#define PFM_NUM_PMC_REGS	64	</span><span class="cm">/* PMC save area for ctxsw */</span><span class="cp"></span>
<span class="cp">#define PFM_NUM_PMD_REGS	64	</span><span class="cm">/* PMD save area for ctxsw */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * depth of message queue</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_MAX_MSGS		32</span>
<span class="cp">#define PFM_CTXQ_EMPTY(g)	((g)-&gt;ctx_msgq_head == (g)-&gt;ctx_msgq_tail)</span>

<span class="cm">/*</span>
<span class="cm"> * type of a PMU register (bitmask).</span>
<span class="cm"> * bitmask structure:</span>
<span class="cm"> * 	bit0   : register implemented</span>
<span class="cm"> * 	bit1   : end marker</span>
<span class="cm"> * 	bit2-3 : reserved</span>
<span class="cm"> * 	bit4   : pmc has pmc.pm</span>
<span class="cm"> * 	bit5   : pmc controls a counter (has pmc.oi), pmd is used as counter</span>
<span class="cm"> * 	bit6-7 : register type</span>
<span class="cm"> * 	bit8-31: reserved</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_REG_NOTIMPL		0x0 </span><span class="cm">/* not implemented at all */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_IMPL		0x1 </span><span class="cm">/* register implemented */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_END		0x2 </span><span class="cm">/* end marker */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_MONITOR		(0x1&lt;&lt;4|PFM_REG_IMPL) </span><span class="cm">/* a PMC with a pmc.pm field only */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_COUNTING	(0x2&lt;&lt;4|PFM_REG_MONITOR) </span><span class="cm">/* a monitor + pmc.oi+ PMD used as a counter */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_CONTROL		(0x4&lt;&lt;4|PFM_REG_IMPL) </span><span class="cm">/* PMU control register */</span><span class="cp"></span>
<span class="cp">#define	PFM_REG_CONFIG		(0x8&lt;&lt;4|PFM_REG_IMPL) </span><span class="cm">/* configuration register */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_BUFFER	 	(0xc&lt;&lt;4|PFM_REG_IMPL) </span><span class="cm">/* PMD used as buffer */</span><span class="cp"></span>

<span class="cp">#define PMC_IS_LAST(i)	(pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_END)</span>
<span class="cp">#define PMD_IS_LAST(i)	(pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_END)</span>

<span class="cp">#define PMC_OVFL_NOTIFY(ctx, i)	((ctx)-&gt;ctx_pmds[i].flags &amp;  PFM_REGFL_OVFL_NOTIFY)</span>

<span class="cm">/* i assumed unsigned */</span>
<span class="cp">#define PMC_IS_IMPL(i)	  (i&lt; PMU_MAX_PMCS &amp;&amp; (pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_IMPL))</span>
<span class="cp">#define PMD_IS_IMPL(i)	  (i&lt; PMU_MAX_PMDS &amp;&amp; (pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_IMPL))</span>

<span class="cm">/* XXX: these assume that register i is implemented */</span>
<span class="cp">#define PMD_IS_COUNTING(i) ((pmu_conf-&gt;pmd_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)</span>
<span class="cp">#define PMC_IS_COUNTING(i) ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_COUNTING) == PFM_REG_COUNTING)</span>
<span class="cp">#define PMC_IS_MONITOR(i)  ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_MONITOR)  == PFM_REG_MONITOR)</span>
<span class="cp">#define PMC_IS_CONTROL(i)  ((pmu_conf-&gt;pmc_desc[i].type &amp; PFM_REG_CONTROL)  == PFM_REG_CONTROL)</span>

<span class="cp">#define PMC_DFL_VAL(i)     pmu_conf-&gt;pmc_desc[i].default_value</span>
<span class="cp">#define PMC_RSVD_MASK(i)   pmu_conf-&gt;pmc_desc[i].reserved_mask</span>
<span class="cp">#define PMD_PMD_DEP(i)	   pmu_conf-&gt;pmd_desc[i].dep_pmd[0]</span>
<span class="cp">#define PMC_PMD_DEP(i)	   pmu_conf-&gt;pmc_desc[i].dep_pmd[0]</span>

<span class="cp">#define PFM_NUM_IBRS	  IA64_NUM_DBG_REGS</span>
<span class="cp">#define PFM_NUM_DBRS	  IA64_NUM_DBG_REGS</span>

<span class="cp">#define CTX_OVFL_NOBLOCK(c)	((c)-&gt;ctx_fl_block == 0)</span>
<span class="cp">#define CTX_HAS_SMPL(c)		((c)-&gt;ctx_fl_is_sampling)</span>
<span class="cp">#define PFM_CTX_TASK(h)		(h)-&gt;ctx_task</span>

<span class="cp">#define PMU_PMC_OI		5 </span><span class="cm">/* position of pmc.oi bit */</span><span class="cp"></span>

<span class="cm">/* XXX: does not support more than 64 PMDs */</span>
<span class="cp">#define CTX_USED_PMD(ctx, mask) (ctx)-&gt;ctx_used_pmds[0] |= (mask)</span>
<span class="cp">#define CTX_IS_USED_PMD(ctx, c) (((ctx)-&gt;ctx_used_pmds[0] &amp; (1UL &lt;&lt; (c))) != 0UL)</span>

<span class="cp">#define CTX_USED_MONITOR(ctx, mask) (ctx)-&gt;ctx_used_monitors[0] |= (mask)</span>

<span class="cp">#define CTX_USED_IBR(ctx,n) 	(ctx)-&gt;ctx_used_ibrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)</span>
<span class="cp">#define CTX_USED_DBR(ctx,n) 	(ctx)-&gt;ctx_used_dbrs[(n)&gt;&gt;6] |= 1UL&lt;&lt; ((n) % 64)</span>
<span class="cp">#define CTX_USES_DBREGS(ctx)	(((pfm_context_t *)(ctx))-&gt;ctx_fl_using_dbreg==1)</span>
<span class="cp">#define PFM_CODE_RR	0	</span><span class="cm">/* requesting code range restriction */</span><span class="cp"></span>
<span class="cp">#define PFM_DATA_RR	1	</span><span class="cm">/* requestion data range restriction */</span><span class="cp"></span>

<span class="cp">#define PFM_CPUINFO_CLEAR(v)	pfm_get_cpu_var(pfm_syst_info) &amp;= ~(v)</span>
<span class="cp">#define PFM_CPUINFO_SET(v)	pfm_get_cpu_var(pfm_syst_info) |= (v)</span>
<span class="cp">#define PFM_CPUINFO_GET()	pfm_get_cpu_var(pfm_syst_info)</span>

<span class="cp">#define RDEP(x)	(1UL&lt;&lt;(x))</span>

<span class="cm">/*</span>
<span class="cm"> * context protection macros</span>
<span class="cm"> * in SMP:</span>
<span class="cm"> * 	- we need to protect against CPU concurrency (spin_lock)</span>
<span class="cm"> * 	- we need to protect against PMU overflow interrupts (local_irq_disable)</span>
<span class="cm"> * in UP:</span>
<span class="cm"> * 	- we need to protect against PMU overflow interrupts (local_irq_disable)</span>
<span class="cm"> *</span>
<span class="cm"> * spin_lock_irqsave()/spin_unlock_irqrestore():</span>
<span class="cm"> * 	in SMP: local_irq_disable + spin_lock</span>
<span class="cm"> * 	in UP : local_irq_disable</span>
<span class="cm"> *</span>
<span class="cm"> * spin_lock()/spin_lock():</span>
<span class="cm"> * 	in UP : removed automatically</span>
<span class="cm"> * 	in SMP: protect against context accesses from other CPU. interrupts</span>
<span class="cm"> * 	        are not masked. This is useful for the PMU interrupt handler</span>
<span class="cm"> * 	        because we know we will not get PMU concurrency in that code.</span>
<span class="cm"> */</span>
<span class="cp">#define PROTECT_CTX(c, f) \</span>
<span class="cp">	do {  \</span>
<span class="cp">		DPRINT((&quot;spinlock_irq_save ctx %p by [%d]\n&quot;, c, task_pid_nr(current))); \</span>
<span class="cp">		spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); \</span>
<span class="cp">		DPRINT((&quot;spinlocked ctx %p  by [%d]\n&quot;, c, task_pid_nr(current))); \</span>
<span class="cp">	} while(0)</span>

<span class="cp">#define UNPROTECT_CTX(c, f) \</span>
<span class="cp">	do { \</span>
<span class="cp">		DPRINT((&quot;spinlock_irq_restore ctx %p by [%d]\n&quot;, c, task_pid_nr(current))); \</span>
<span class="cp">		spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); \</span>
<span class="cp">	} while(0)</span>

<span class="cp">#define PROTECT_CTX_NOPRINT(c, f) \</span>
<span class="cp">	do {  \</span>
<span class="cp">		spin_lock_irqsave(&amp;(c)-&gt;ctx_lock, f); \</span>
<span class="cp">	} while(0)</span>


<span class="cp">#define UNPROTECT_CTX_NOPRINT(c, f) \</span>
<span class="cp">	do { \</span>
<span class="cp">		spin_unlock_irqrestore(&amp;(c)-&gt;ctx_lock, f); \</span>
<span class="cp">	} while(0)</span>


<span class="cp">#define PROTECT_CTX_NOIRQ(c) \</span>
<span class="cp">	do {  \</span>
<span class="cp">		spin_lock(&amp;(c)-&gt;ctx_lock); \</span>
<span class="cp">	} while(0)</span>

<span class="cp">#define UNPROTECT_CTX_NOIRQ(c) \</span>
<span class="cp">	do { \</span>
<span class="cp">		spin_unlock(&amp;(c)-&gt;ctx_lock); \</span>
<span class="cp">	} while(0)</span>


<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cp">#define GET_ACTIVATION()	pfm_get_cpu_var(pmu_activation_number)</span>
<span class="cp">#define INC_ACTIVATION()	pfm_get_cpu_var(pmu_activation_number)++</span>
<span class="cp">#define SET_ACTIVATION(c)	(c)-&gt;ctx_last_activation = GET_ACTIVATION()</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="cp">#define SET_ACTIVATION(t) 	do {} while(0)</span>
<span class="cp">#define GET_ACTIVATION(t) 	do {} while(0)</span>
<span class="cp">#define INC_ACTIVATION(t) 	do {} while(0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#define SET_PMU_OWNER(t, c)	do { pfm_get_cpu_var(pmu_owner) = (t); pfm_get_cpu_var(pmu_ctx) = (c); } while(0)</span>
<span class="cp">#define GET_PMU_OWNER()		pfm_get_cpu_var(pmu_owner)</span>
<span class="cp">#define GET_PMU_CTX()		pfm_get_cpu_var(pmu_ctx)</span>

<span class="cp">#define LOCK_PFS(g)	    	spin_lock_irqsave(&amp;pfm_sessions.pfs_lock, g)</span>
<span class="cp">#define UNLOCK_PFS(g)	    	spin_unlock_irqrestore(&amp;pfm_sessions.pfs_lock, g)</span>

<span class="cp">#define PFM_REG_RETFLAG_SET(flags, val)	do { flags &amp;= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)</span>

<span class="cm">/*</span>
<span class="cm"> * cmp0 must be the value of pmc0</span>
<span class="cm"> */</span>
<span class="cp">#define PMC0_HAS_OVFL(cmp0)  (cmp0 &amp; ~0x1UL)</span>

<span class="cp">#define PFMFS_MAGIC 0xa0b4d889</span>

<span class="cm">/*</span>
<span class="cm"> * debugging</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_DEBUGGING 1</span>
<span class="cp">#ifdef PFM_DEBUGGING</span>
<span class="cp">#define DPRINT(a) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (unlikely(pfm_sysctl.debug &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __func__, __LINE__, smp_processor_id(), task_pid_nr(current)); printk a; } \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define DPRINT_ovfl(a) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (unlikely(pfm_sysctl.debug &gt; 0 &amp;&amp; pfm_sysctl.debug_ovfl &gt;0)) { printk(&quot;%s.%d: CPU%d [%d] &quot;, __func__, __LINE__, smp_processor_id(), task_pid_nr(current)); printk a; } \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * 64-bit software counter structure</span>
<span class="cm"> *</span>
<span class="cm"> * the next_reset_type is applied to the next call to pfm_reset_regs()</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">val</span><span class="p">;</span>		<span class="cm">/* virtual 64bit counter value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lval</span><span class="p">;</span>		<span class="cm">/* last reset value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">long_reset</span><span class="p">;</span>	<span class="cm">/* reset value on sampling overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">short_reset</span><span class="p">;</span>    <span class="cm">/* reset value on overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reset_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="cm">/* which other pmds to reset when this counter overflows */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">smpl_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>   <span class="cm">/* which pmds are accessed when counter overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">seed</span><span class="p">;</span>		<span class="cm">/* seed for random-number generator */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask for random-number generator */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* notify/do not notify */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">eventid</span><span class="p">;</span>	<span class="cm">/* overflow event identifier */</span>
<span class="p">}</span> <span class="n">pfm_counter_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * context flags</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* when 1, task will blocked on user notifications */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">system</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* do system wide monitoring */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">using_dbreg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* using range restrictions (debug registers) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_sampling</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* true if using a custom format */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">excl_idle</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* exclude idle task in system wide session */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">going_zombie</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* context is zombie (MASKED+blocking) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trap_reason</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* reason for going into pfm_handle_work() */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_msg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* no message sent on overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">can_restart</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* allowed to issue a PFM_RESTART */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">22</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pfm_context_flags_t</span><span class="p">;</span>

<span class="cp">#define PFM_TRAP_REASON_NONE		0x0	</span><span class="cm">/* default value */</span><span class="cp"></span>
<span class="cp">#define PFM_TRAP_REASON_BLOCK		0x1	</span><span class="cm">/* we need to block on overflow */</span><span class="cp"></span>
<span class="cp">#define PFM_TRAP_REASON_RESET		0x2	</span><span class="cm">/* we need to reset PMDs */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * perfmon context: encapsulates all the state of a monitoring session</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">pfm_context</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">ctx_lock</span><span class="p">;</span>		<span class="cm">/* context protection */</span>

	<span class="n">pfm_context_flags_t</span>	<span class="n">ctx_flags</span><span class="p">;</span>		<span class="cm">/* bitmask of flags  (block reason incl.) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_state</span><span class="p">;</span>		<span class="cm">/* state: active/inactive (no bitfield) */</span>

	<span class="k">struct</span> <span class="n">task_struct</span> 	<span class="o">*</span><span class="n">ctx_task</span><span class="p">;</span>		<span class="cm">/* task to which context is attached */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* which registers overflowed (notification) */</span>

	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">ctx_restart_done</span><span class="p">;</span>  	<span class="cm">/* use for blocking notification mode */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of PMD used            */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of all accessible PMDs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of force reload PMD on ctxsw in */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of all accessible PMCs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of force reload PMC on ctxsw in */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_used_monitors</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of monitor PMC being used */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">PFM_NUM_PMC_REGS</span><span class="p">];</span>	<span class="cm">/*  saved copies of PMC values */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_used_ibrs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* bitmask of used IBR (speedup ctxsw in) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_used_dbrs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* bitmask of used DBR (speedup ctxsw in) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_dbrs</span><span class="p">[</span><span class="n">IA64_NUM_DBG_REGS</span><span class="p">];</span>	<span class="cm">/* DBR values (cache) when not loaded */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_ibrs</span><span class="p">[</span><span class="n">IA64_NUM_DBG_REGS</span><span class="p">];</span>	<span class="cm">/* IBR values (cache) when not loaded */</span>

	<span class="n">pfm_counter_t</span>		<span class="n">ctx_pmds</span><span class="p">[</span><span class="n">PFM_NUM_PMD_REGS</span><span class="p">];</span> <span class="cm">/* software state for PMDS */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">th_pmcs</span><span class="p">[</span><span class="n">PFM_NUM_PMC_REGS</span><span class="p">];</span>	<span class="cm">/* PMC thread save state */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">th_pmds</span><span class="p">[</span><span class="n">PFM_NUM_PMD_REGS</span><span class="p">];</span>	<span class="cm">/* PMD thread save state */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_saved_psr_up</span><span class="p">;</span>	<span class="cm">/* only contains psr.up value */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_last_activation</span><span class="p">;</span>	<span class="cm">/* context last activation number for last_cpu */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_last_cpu</span><span class="p">;</span>		<span class="cm">/* CPU id of current or last CPU used (SMP only) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ctx_cpu</span><span class="p">;</span>		<span class="cm">/* cpu to which perfmon is applied (system wide) */</span>

	<span class="kt">int</span>			<span class="n">ctx_fd</span><span class="p">;</span>			<span class="cm">/* file descriptor used my this context */</span>
	<span class="n">pfm_ovfl_arg_t</span>		<span class="n">ctx_ovfl_arg</span><span class="p">;</span>		<span class="cm">/* argument to custom buffer format handler */</span>

	<span class="n">pfm_buffer_fmt_t</span>	<span class="o">*</span><span class="n">ctx_buf_fmt</span><span class="p">;</span>		<span class="cm">/* buffer format callbacks */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ctx_smpl_hdr</span><span class="p">;</span>		<span class="cm">/* points to sampling buffer header kernel vaddr */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ctx_smpl_size</span><span class="p">;</span>		<span class="cm">/* size of sampling buffer */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ctx_smpl_vaddr</span><span class="p">;</span>	<span class="cm">/* user level virtual address of smpl buffer */</span>

	<span class="n">wait_queue_head_t</span> 	<span class="n">ctx_msgq_wait</span><span class="p">;</span>
	<span class="n">pfm_msg_t</span>		<span class="n">ctx_msgq</span><span class="p">[</span><span class="n">PFM_MAX_MSGS</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">ctx_msgq_head</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ctx_msgq_tail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span>	<span class="o">*</span><span class="n">ctx_async_queue</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> 	<span class="n">ctx_zombieq</span><span class="p">;</span>		<span class="cm">/* termination cleanup wait queue */</span>
<span class="p">}</span> <span class="n">pfm_context_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * magic number used to verify that structure is really</span>
<span class="cm"> * a perfmon context</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_IS_FILE(f)		((f)-&gt;f_op == &amp;pfm_file_ops)</span>

<span class="cp">#define PFM_GET_CTX(t)	 	((pfm_context_t *)(t)-&gt;thread.pfm_context)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define SET_LAST_CPU(ctx, v)	(ctx)-&gt;ctx_last_cpu = (v)</span>
<span class="cp">#define GET_LAST_CPU(ctx)	(ctx)-&gt;ctx_last_cpu</span>
<span class="cp">#else</span>
<span class="cp">#define SET_LAST_CPU(ctx, v)	do {} while(0)</span>
<span class="cp">#define GET_LAST_CPU(ctx)	do {} while(0)</span>
<span class="cp">#endif</span>


<span class="cp">#define ctx_fl_block		ctx_flags.block</span>
<span class="cp">#define ctx_fl_system		ctx_flags.system</span>
<span class="cp">#define ctx_fl_using_dbreg	ctx_flags.using_dbreg</span>
<span class="cp">#define ctx_fl_is_sampling	ctx_flags.is_sampling</span>
<span class="cp">#define ctx_fl_excl_idle	ctx_flags.excl_idle</span>
<span class="cp">#define ctx_fl_going_zombie	ctx_flags.going_zombie</span>
<span class="cp">#define ctx_fl_trap_reason	ctx_flags.trap_reason</span>
<span class="cp">#define ctx_fl_no_msg		ctx_flags.no_msg</span>
<span class="cp">#define ctx_fl_can_restart	ctx_flags.can_restart</span>

<span class="cp">#define PFM_SET_WORK_PENDING(t, v)	do { (t)-&gt;thread.pfm_needs_checking = v; } while(0);</span>
<span class="cp">#define PFM_GET_WORK_PENDING(t)		(t)-&gt;thread.pfm_needs_checking</span>

<span class="cm">/*</span>
<span class="cm"> * global information about all sessions</span>
<span class="cm"> * mostly used to synchronize between system wide and per-process</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">pfs_lock</span><span class="p">;</span>		   <span class="cm">/* lock the structure */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pfs_task_sessions</span><span class="p">;</span>	   <span class="cm">/* number of per task sessions */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pfs_sys_sessions</span><span class="p">;</span>	   <span class="cm">/* number of per system wide sessions */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pfs_sys_use_dbregs</span><span class="p">;</span>	   <span class="cm">/* incremented when a system wide session uses debug regs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pfs_ptrace_use_dbregs</span><span class="p">;</span>	   <span class="cm">/* incremented when a process uses debug regs */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">pfs_sys_session</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span> <span class="cm">/* point to task owning a system-wide session */</span>
<span class="p">}</span> <span class="n">pfm_session_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * information about a PMC or PMD.</span>
<span class="cm"> * dep_pmd[]: a bitmask of dependent PMD registers</span>
<span class="cm"> * dep_pmc[]: a bitmask of dependent PMC registers</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pfm_reg_check_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pm_pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">default_value</span><span class="p">;</span>	<span class="cm">/* power-on default value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">reserved_mask</span><span class="p">;</span>	<span class="cm">/* bitmask of reserved bits */</span>
	<span class="n">pfm_reg_check_t</span>		<span class="n">read_check</span><span class="p">;</span>
	<span class="n">pfm_reg_check_t</span>		<span class="n">write_check</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dep_pmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dep_pmc</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">pfm_reg_desc_t</span><span class="p">;</span>

<span class="cm">/* assume cnum is a valid monitor */</span>
<span class="cp">#define PMC_PM(cnum, val)	(((val) &gt;&gt; (pmu_conf-&gt;pmc_desc[cnum].pm_pos)) &amp; 0x1)</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is initialized at boot time and contains</span>
<span class="cm"> * a description of the PMU main characteristics.</span>
<span class="cm"> *</span>
<span class="cm"> * If the probe function is defined, detection is based</span>
<span class="cm"> * on its return value: </span>
<span class="cm"> * 	- 0 means recognized PMU</span>
<span class="cm"> * 	- anything else means not supported</span>
<span class="cm"> * When the probe function is not defined, then the pmu_family field</span>
<span class="cm"> * is used and it must match the host CPU family such that:</span>
<span class="cm"> * 	- cpu-&gt;family &amp; config-&gt;pmu_family != 0</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">ovfl_val</span><span class="p">;</span>	<span class="cm">/* overflow value for counters */</span>

	<span class="n">pfm_reg_desc_t</span> <span class="o">*</span><span class="n">pmc_desc</span><span class="p">;</span>	<span class="cm">/* detailed PMC register dependencies descriptions */</span>
	<span class="n">pfm_reg_desc_t</span> <span class="o">*</span><span class="n">pmd_desc</span><span class="p">;</span>	<span class="cm">/* detailed PMD register dependencies descriptions */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">num_pmcs</span><span class="p">;</span>	<span class="cm">/* number of PMCS: computed at init time */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">num_pmds</span><span class="p">;</span>	<span class="cm">/* number of PMDS: computed at init time */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">impl_pmcs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of implemented PMCS */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">impl_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* bitmask of implemented PMDS */</span>

	<span class="kt">char</span>	      <span class="o">*</span><span class="n">pmu_name</span><span class="p">;</span>	<span class="cm">/* PMU family name */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">pmu_family</span><span class="p">;</span>	<span class="cm">/* cpuid family pattern used to identify pmu */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* pmu specific flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">num_ibrs</span><span class="p">;</span>		<span class="cm">/* number of IBRS: computed at init time */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">num_dbrs</span><span class="p">;</span>		<span class="cm">/* number of DBRS: computed at init time */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">num_counters</span><span class="p">;</span>	<span class="cm">/* PMC/PMD counting pairs : computed at init time */</span>
	<span class="kt">int</span>           <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>   <span class="cm">/* customized probe routine */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">use_rr_dbregs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* set if debug registers used for range restriction */</span>
<span class="p">}</span> <span class="n">pmu_config_t</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * PMU specific flags</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_PMU_IRQ_RESEND	1	</span><span class="cm">/* PMU needs explicit IRQ resend */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * debug register related type definitions</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibr_mask</span><span class="o">:</span><span class="mi">56</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibr_plm</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibr_ig</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibr_x</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ibr_mask_reg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr_mask</span><span class="o">:</span><span class="mi">56</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr_plm</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr_ig</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr_w</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr_r</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dbr_mask_reg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">val</span><span class="p">;</span>
	<span class="n">ibr_mask_reg_t</span> <span class="n">ibr</span><span class="p">;</span>
	<span class="n">dbr_mask_reg_t</span> <span class="n">dbr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dbreg_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * perfmon command descriptions</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">cmd_func</span><span class="p">)(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">cmd_name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">cmd_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cmd_narg</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">cmd_argsize</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">cmd_getsize</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">sz</span><span class="p">);</span>
<span class="p">}</span> <span class="n">pfm_cmd_desc_t</span><span class="p">;</span>

<span class="cp">#define PFM_CMD_FD		0x01	</span><span class="cm">/* command requires a file descriptor */</span><span class="cp"></span>
<span class="cp">#define PFM_CMD_ARG_READ	0x02	</span><span class="cm">/* command must read argument(s) */</span><span class="cp"></span>
<span class="cp">#define PFM_CMD_ARG_RW		0x04	</span><span class="cm">/* command must read/write argument(s) */</span><span class="cp"></span>
<span class="cp">#define PFM_CMD_STOP		0x08	</span><span class="cm">/* command does not work on zombie context */</span><span class="cp"></span>


<span class="cp">#define PFM_CMD_NAME(cmd)	pfm_cmd_tab[(cmd)].cmd_name</span>
<span class="cp">#define PFM_CMD_READ_ARG(cmd)	(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_ARG_READ)</span>
<span class="cp">#define PFM_CMD_RW_ARG(cmd)	(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_ARG_RW)</span>
<span class="cp">#define PFM_CMD_USE_FD(cmd)	(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_FD)</span>
<span class="cp">#define PFM_CMD_STOPPED(cmd)	(pfm_cmd_tab[(cmd)].cmd_flags &amp; PFM_CMD_STOP)</span>

<span class="cp">#define PFM_CMD_ARG_MANY	-1 </span><span class="cm">/* cannot be zero */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_spurious_ovfl_intr_count</span><span class="p">;</span>	<span class="cm">/* keep track of spurious ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_replay_ovfl_intr_count</span><span class="p">;</span>	<span class="cm">/* keep track of replayed ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_ovfl_intr_count</span><span class="p">;</span> 		<span class="cm">/* keep track of ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_ovfl_intr_cycles</span><span class="p">;</span>		<span class="cm">/* cycles spent processing ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_ovfl_intr_cycles_min</span><span class="p">;</span>		<span class="cm">/* min cycles spent processing ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_ovfl_intr_cycles_max</span><span class="p">;</span>		<span class="cm">/* max cycles spent processing ovfl interrupts */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_smpl_handler_calls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_smpl_handler_cycles</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="n">SMP_CACHE_BYTES</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pfm_stats_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * perfmon internal variables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pfm_stats_t</span>		<span class="n">pfm_stats</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">pfm_session_t</span>		<span class="n">pfm_sessions</span><span class="p">;</span>	<span class="cm">/* global sessions information */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">pfm_alt_install_check</span><span class="p">);</span>
<span class="k">static</span> <span class="n">pfm_intr_handler_desc_t</span>  <span class="o">*</span><span class="n">pfm_alt_intr_handler</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> 	<span class="o">*</span><span class="n">perfmon_dir</span><span class="p">;</span>
<span class="k">static</span> <span class="n">pfm_uuid_t</span>		<span class="n">pfm_null_uuid</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>

<span class="k">static</span> <span class="n">spinlock_t</span>		<span class="n">pfm_buffer_fmt_lock</span><span class="p">;</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pfm_buffer_fmt_list</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pmu_config_t</span>		<span class="o">*</span><span class="n">pmu_conf</span><span class="p">;</span>

<span class="cm">/* sysctl() controls */</span>
<span class="n">pfm_sysctl_t</span> <span class="n">pfm_sysctl</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_sysctl</span><span class="p">);</span>

<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">pfm_ctl_table</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;debug&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">debug</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0666</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;debug_ovfl&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">debug_ovfl</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0666</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;fastctxsw&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">fastctxsw</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0600</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;expert_mode&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">expert_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0600</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">pfm_sysctl_dir</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;perfmon&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">pfm_ctl_table</span><span class="p">,</span>
	<span class="p">},</span>
 	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">ctl_table</span> <span class="n">pfm_sysctl_root</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;kernel&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">child</span>		<span class="o">=</span> <span class="n">pfm_sysctl_dir</span><span class="p">,</span>
	<span class="p">},</span>
 	<span class="p">{}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ctl_table_header</span> <span class="o">*</span><span class="n">pfm_sysctl_header</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cp">#define pfm_get_cpu_var(v)		__ia64_per_cpu_var(v)</span>
<span class="cp">#define pfm_get_cpu_data(a,b)		per_cpu(a, b)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_put_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_reserve_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">vmalloc_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_unreserve_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">vmalloc_to_page</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pfm_protect_ctx_ctxsw</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_unprotect_ctx_ctxsw</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* forward declaration */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">pfmfs_dentry_operations</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">pfmfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_pseudo</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="s">&quot;pfm:&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfmfs_dentry_operations</span><span class="p">,</span>
			<span class="n">PFMFS_MAGIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">pfm_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="s">&quot;pfmfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>    <span class="o">=</span> <span class="n">pfmfs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>  <span class="o">=</span> <span class="n">kill_anon_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pfm_syst_info</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">pmu_owner</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">pfm_context_t</span>  <span class="o">*</span><span class="p">,</span> <span class="n">pmu_ctx</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pmu_activation_number</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">);</span>


<span class="cm">/* forward declaration */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pfm_file_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * forward declarations</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pfm_lazy_save_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ta</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">dump_pmu_state</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pfm_write_ibr_dbr</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cp">#include &quot;perfmon_itanium.h&quot;</span>
<span class="cp">#include &quot;perfmon_mckinley.h&quot;</span>
<span class="cp">#include &quot;perfmon_montecito.h&quot;</span>
<span class="cp">#include &quot;perfmon_generic.h&quot;</span>

<span class="k">static</span> <span class="n">pmu_config_t</span> <span class="o">*</span><span class="n">pmu_confs</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
	<span class="o">&amp;</span><span class="n">pmu_conf_mont</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pmu_conf_mck</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pmu_conf_ita</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pmu_conf_gen</span><span class="p">,</span> <span class="cm">/* must be last */</span>
	<span class="nb">NULL</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">pfm_end_notify_user</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_clear_psr_pp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_rsm</span><span class="p">(</span><span class="n">IA64_PSR_PP</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_set_psr_pp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ssm</span><span class="p">(</span><span class="n">IA64_PSR_PP</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_clear_psr_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_rsm</span><span class="p">(</span><span class="n">IA64_PSR_UP</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_set_psr_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ssm</span><span class="p">(</span><span class="n">IA64_PSR_UP</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pfm_get_psr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_PSR</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_set_psr_l</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_PSR_L</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_freeze_pmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1UL</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_unfreeze_pmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0UL</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_restore_ibrs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ibrs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nibrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nibrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_set_ibr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ibrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">ia64_dv_serialize_instruction</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_restore_dbrs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dbrs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndbrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndbrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_set_dbr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dbrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">ia64_dv_serialize_data</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PMD[i] must be a counter. no check is made</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pfm_read_soft_counter</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PMD[i] must be a counter. no check is made</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_write_soft_counter</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_val</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>  <span class="o">&amp;</span> <span class="o">~</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * writing to unimplemented part is ignore, so we do not need to</span>
<span class="cm">	 * mask off top part</span>
<span class="cm">	 */</span>
	<span class="n">ia64_set_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfm_msg_t</span> <span class="o">*</span>
<span class="nf">pfm_get_new_msg</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">PFM_MAX_MSGS</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_fd=%p head=%d tail=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

 	<span class="n">idx</span> <span class="o">=</span> 	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx=%p head=%d tail=%d msg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">,</span> <span class="n">idx</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq</span><span class="o">+</span><span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfm_msg_t</span> <span class="o">*</span>
<span class="nf">pfm_get_next_msg</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_msg_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx=%p head=%d tail=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_CTXQ_EMPTY</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get oldest message</span>
<span class="cm">	 */</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq</span><span class="o">+</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * and move forward</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">PFM_MAX_MSGS</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx=%p head=%d tail=%d type=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_gen_msg</span><span class="p">.</span><span class="n">msg_type</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_reset_msgq</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx=%p msgq reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">pfm_rvmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">mem</span>  <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>printk("perfmon: CPU%d pfm<em>rvmalloc(%ld)=%p\n", smp</em>processor_id(), size, mem);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pfm_reserve_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">addr</span><span class="o">+=</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">size</span><span class="o">-=</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_rvfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;freeing physical buffer @%p size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mem</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pfm_unreserve_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">addr</span><span class="o">+=</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">size</span><span class="o">-=</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfm_context_t</span> <span class="o">*</span>
<span class="nf">pfm_context_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">ctx_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * allocate context descriptor </span>
<span class="cm">	 * must be able to free with interrupts disabled</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_context_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;alloc ctx @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * init context protection lock</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * context is unloaded</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * initialization of context&#39;s flags</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_block</span>       <span class="o">=</span> <span class="p">(</span><span class="n">ctx_flags</span> <span class="o">&amp;</span> <span class="n">PFM_FL_NOTIFY_BLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span>      <span class="o">=</span> <span class="p">(</span><span class="n">ctx_flags</span> <span class="o">&amp;</span> <span class="n">PFM_FL_SYSTEM_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_no_msg</span>      <span class="o">=</span> <span class="p">(</span><span class="n">ctx_flags</span> <span class="o">&amp;</span> <span class="n">PFM_FL_OVFL_NO_MSG</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * will move to set properties</span>
<span class="cm">		 * ctx-&gt;ctx_fl_excl_idle   = (ctx_flags &amp; PFM_FL_EXCL_IDLE) ? 1: 0;</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * init restart semaphore to locked</span>
<span class="cm">		 */</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_restart_done</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * activation is used in SMP only</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_last_activation</span> <span class="o">=</span> <span class="n">PFM_INVALID_ACTIVATION</span><span class="p">;</span>
		<span class="n">SET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * initialize notification message queue</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_wait</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_zombieq</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_context_free</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;free ctx @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_mask_monitoring</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ovfl_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;masking monitoring for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

	<span class="n">ovfl_mask</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * monitoring can only be masked as a result of a valid</span>
<span class="cm">	 * counter overflow. In UP, it means that the PMU still</span>
<span class="cm">	 * has an owner. Note that the owner can be different</span>
<span class="cm">	 * from the current task. However the PMU state belongs</span>
<span class="cm">	 * to the owner.</span>
<span class="cm">	 * In SMP, a valid overflow only happens when task is</span>
<span class="cm">	 * current. Therefore if we come here, we know that</span>
<span class="cm">	 * the PMU state belongs to the current task, therefore</span>
<span class="cm">	 * we can access the live registers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So in both cases, the live register contains the owner&#39;s</span>
<span class="cm">	 * state. We can ONLY touch the PMU registers and NOT the PSR.</span>
<span class="cm">	 *</span>
<span class="cm">	 * As a consequence to this call, the ctx-&gt;th_pmds[] array</span>
<span class="cm">	 * contains stale information which must be ignored</span>
<span class="cm">	 * when context is reloaded AND monitoring is active (see</span>
<span class="cm">	 * pfm_restart).</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* skip non used pmds */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * we rebuild the full 64 bit value of the counter</span>
<span class="cm">		 	 */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_mask</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;pmd[%d]=0x%lx hw_pmd=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">,</span>
			<span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_mask</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * mask monitoring by setting the privilege level to 0</span>
<span class="cm">	 * we cannot use psr.pp/psr.up for this, it is controlled by</span>
<span class="cm">	 * the user</span>
<span class="cm">	 *</span>
<span class="cm">	 * if task is current, modify actual registers, otherwise modify</span>
<span class="cm">	 * thread save state, i.e., what will be restored in pfm_load_regs()</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_monitors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfUL</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xfUL</span><span class="p">;</span>
		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;pmc[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * make all of this visible</span>
<span class="cm">	 */</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * must always be done with task == current</span>
<span class="cm"> *</span>
<span class="cm"> * context must be in MASKED state when calling</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_restore_monitoring</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ovfl_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>

	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">ovfl_mask</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon.%d: invalid task[%d] current[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">!=</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon.%d: task[%d] current[%d] invalid state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * monitoring is masked via the PMC.</span>
<span class="cm">	 * As we restore their value, we do not want each counter to</span>
<span class="cm">	 * restart right away. We stop monitoring using the PSR,</span>
<span class="cm">	 * restore the PMC (and PMD) and then re-establish the psr</span>
<span class="cm">	 * as it was. Note that there can be no pending overflow at</span>
<span class="cm">	 * this point, because monitoring was MASKED.</span>
<span class="cm">	 *</span>
<span class="cm">	 * system-wide session are pinned and self-monitoring</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">PFM_CPUINFO_GET</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_DCR_PP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* disable dcr pp */</span>
		<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IA64_DCR_PP</span><span class="p">);</span>
		<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pfm_clear_psr_up</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * first, we restore the PMD</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* skip non used pmds */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we split the 64bit value according to</span>
<span class="cm">			 * counter width</span>
<span class="cm">			 */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_mask</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ovfl_mask</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ia64_set_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmd[%d]=0x%lx hw_pmd=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">,</span>
			<span class="n">val</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * restore the PMCs</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_monitors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] pmc[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * must restore DBR/IBR because could be modified while masked</span>
<span class="cm">	 * XXX: need to optimize </span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_restore_ibrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ibrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
		<span class="n">pfm_restore_dbrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_dbrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * now restore PSR</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">PFM_CPUINFO_GET</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_DCR_PP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* enable dcr pp */</span>
		<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">IA64_DCR_PP</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">pfm_set_psr_l</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_save_pmds</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pmds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ia64_srlz_d</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="n">pmds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * reload from thread state (used for ctxw only)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_restore_pmds</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pmds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="n">ovfl_val</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="n">pmds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ovfl_val</span> <span class="o">:</span> <span class="n">pmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ia64_set_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * propagate PMD from context to thread-state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_copy_pmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_val</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;mask=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We break up the 64 bit value into 2 pieces</span>
<span class="cm">		 * the lower bits go to the machine state in the</span>
<span class="cm">		 * thread (will be reloaded on ctxsw in).</span>
<span class="cm">		 * The upper part stays in the soft-counter.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ovfl_val</span><span class="p">;</span>
			 <span class="n">val</span> <span class="o">&amp;=</span> <span class="n">ovfl_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmd[%d]=0x%lx soft_val=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * propagate PMC from context to thread-state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_copy_pmcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;mask=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* masking 0 with ovfl_val yields 0 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_restore_pmcs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pmcs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_uuid_cmp</span><span class="p">(</span><span class="n">pfm_uuid_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">pfm_uuid_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_uuid_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_exit</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_exit</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_exit</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_getsize</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_getsize</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_getsize</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_validate</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_validate</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_validate</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_init</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_init</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_init</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_restart</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_ovfl_ctrl_t</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_restart</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_restart</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_buf_fmt_restart_active</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_ovfl_ctrl_t</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_restart_active</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_restart_active</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span>
<span class="nf">__pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">pfm_uuid_t</span> <span class="n">uuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_buffer_fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pfm_buffer_fmt_t</span><span class="p">,</span> <span class="n">fmt_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfm_uuid_cmp</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/*</span>
<span class="cm"> * find a buffer format based on its uuid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span>
<span class="nf">pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">pfm_uuid_t</span> <span class="n">uuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>
	<span class="n">fmt</span> <span class="o">=</span> <span class="n">__pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">uuid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span>
<span class="nf">pfm_register_buffer_fmt</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* some sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we need at least a handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX: need check validity of fmt_arg_size</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: duplicate sampling format: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> 
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_buffer_fmt_list</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: added sampling format %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>
 	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_register_buffer_fmt</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">pfm_unregister_buffer_fmt</span><span class="p">(</span><span class="n">pfm_uuid_t</span> <span class="n">uuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>

	<span class="n">fmt</span> <span class="o">=</span> <span class="n">__pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">uuid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: cannot unregister format, not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: removed sampling format: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_unregister_buffer_fmt</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_pal_halt_status</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_reserve_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_syswide</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * validity checks on cpu_mask have been done upstream</span>
<span class="cm">	 */</span>
	<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
		<span class="n">is_syswide</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_syswide</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * cannot mix system wide and per-task sessions</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span> <span class="o">&gt;</span> <span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;system wide not possible, %u conflicting task_sessions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  	<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_session</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="k">goto</span> <span class="n">error_conflict</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;reserving system wide session on CPU%u currently on CPU%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">()));</span>

		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_session</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>

		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="o">++</span> <span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">)</span> <span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
		<span class="n">is_syswide</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable default_idle() to go to PAL_HALT</span>
<span class="cm">	 */</span>
	<span class="n">update_pal_halt_status</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_conflict:</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;system wide not possible, conflicting session [%d] on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
  		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_session</span><span class="p">[</span><span class="n">cpu</span><span class="p">]),</span>
		<span class="n">cpu</span><span class="p">));</span>
<span class="nl">abort:</span>
	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_unreserve_session</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_syswide</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * validity checks on cpu_mask have been done upstream</span>
<span class="cm">	 */</span>
	<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;in sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
		<span class="n">is_syswide</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">));</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">is_syswide</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_session</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * would not work with perfmon+more than one bit in cpu_mask</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: invalid release for ctx %p sys_use_dbregs=0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;out sys_sessions=%u task_sessions=%u dbregs=%u syswide=%d cpu=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">,</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
		<span class="n">is_syswide</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if possible, enable default_idle() to go into PAL_HALT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">update_pal_halt_status</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * removes virtual mapping of the sampling buffer.</span>
<span class="cm"> * IMPORTANT: cannot be called with interrupts disable, e.g. inside</span>
<span class="cm"> * a PROTECT_CTX() section.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_remove_smpl_mapping</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0UL</span> <span class="o">||</span> <span class="n">vaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_remove_smpl_mapping [%d] invalid context mm=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;smpl_vaddr=%p size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * does the actual unmapping</span>
<span class="cm">	 */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vm_munmap</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: [%d] unable to unmap sampling buffer @%p size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;do_unmap(%p, %lu)=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free actual physical storage used by sampling buffer</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int</span>
<span class="c">pfm_free_smpl_buffer(pfm_context_t *ctx)</span>
<span class="c">{</span>
<span class="c">	pfm_buffer_fmt_t *fmt;</span>

<span class="c">	if (ctx-&gt;ctx_smpl_hdr == NULL) goto invalid_free;</span>

<span class="c">	/*</span>
<span class="c">	 * we won&#39;t use the buffer format anymore</span>
<span class="c">	 */</span>
<span class="c">	fmt = ctx-&gt;ctx_buf_fmt;</span>

<span class="c">	DPRINT((&quot;sampling buffer @%p size %lu vaddr=%p\n&quot;,</span>
<span class="c">		ctx-&gt;ctx_smpl_hdr,</span>
<span class="c">		ctx-&gt;ctx_smpl_size,</span>
<span class="c">		ctx-&gt;ctx_smpl_vaddr));</span>

<span class="c">	pfm_buf_fmt_exit(fmt, current, NULL, NULL);</span>

<span class="c">	/*</span>
<span class="c">	 * free the buffer</span>
<span class="c">	 */</span>
<span class="c">	pfm_rvfree(ctx-&gt;ctx_smpl_hdr, ctx-&gt;ctx_smpl_size);</span>

<span class="c">	ctx-&gt;ctx_smpl_hdr  = NULL;</span>
<span class="c">	ctx-&gt;ctx_smpl_size = 0UL;</span>

<span class="c">	return 0;</span>

<span class="c">invalid_free:</span>
<span class="c">	printk(KERN_ERR &quot;perfmon: pfm_free_smpl_buffer [%d] no buffer\n&quot;, task_pid_nr(current));</span>
<span class="c">	return -EINVAL;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pfm_exit_smpl_buffer</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">pfm_buf_fmt_exit</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pfmfs should _never_ be mounted by userland - too much of security hassle,</span>
<span class="cm"> * no real gain from having the whole whorehouse mounted. So we don&#39;t need</span>
<span class="cm"> * any operations on the root directory. However, we need a non-trivial</span>
<span class="cm"> * d_name - pfm: will go nicely and kill the special-casing in procfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">pfmfs_mnt</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">init_pfm_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfmfs_mnt</span> <span class="o">=</span> <span class="n">kern_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_fs_type</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pfmfs_mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pfmfs_mnt</span><span class="p">))</span>
			<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_fs_type</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pfm_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">pfm_msg_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_poll: bad magic [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_read: NULL ctx [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check even when there is no message</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_msg_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;message is too small ctx=%p (&gt;=%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_msg_t</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

  	<span class="cm">/*</span>
<span class="cm">	 * put ourselves on the wait queue</span>
<span class="cm">	 */</span>
  	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>


  	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * check wait queue</span>
<span class="cm">		 */</span>

  		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;head=%d tail=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">));</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">PFM_CTXQ_EMPTY</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * check non-blocking read</span>
<span class="cm">		 */</span>
      		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * check pending signals</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
      		<span class="cm">/*</span>
<span class="cm">		 * no message, so wait</span>
<span class="cm">		 */</span>
      		<span class="n">schedule</span><span class="p">();</span>

		<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] back to running ret=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">ret</span><span class="p">));</span>
  	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">pfm_get_next_msg</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_read no msg for ctx=%p [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">abort_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd=%d type=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_gen_msg</span><span class="p">.</span><span class="n">msg_ctx_fd</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_gen_msg</span><span class="p">.</span><span class="n">msg_type</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  	<span class="k">if</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_msg_t</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_msg_t</span><span class="p">);</span>

<span class="nl">abort_locked:</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">abort:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pfm_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_write called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">pfm_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_poll: bad magic [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_poll: NULL ctx [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_poll ctx_fd=%d before poll_wait</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">));</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_CTXQ_EMPTY</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span>  <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_poll ctx_fd=%d mask=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">pfm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_ioctl called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * interrupt cannot be masked when coming here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pfm_do_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fasync_helper</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_async_queue</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_fasync called by [%d] on ctx_fd=%d on=%d async_queue=%p ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
		<span class="n">fd</span><span class="p">,</span>
		<span class="n">on</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_async_queue</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_fasync bad magic [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_fasync NULL ctx [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we cannot mask interrupts during this call because this may</span>
<span class="cm">	 * may go to sleep if memory is not readily avalaible.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We are protected from the conetxt disappearing by the get_fd()/put_fd()</span>
<span class="cm">	 * done in caller. Serialization of this function is ensured by caller.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_do_fasync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>


	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_fasync called on ctx_fd=%d on=%d async_queue=%p ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fd</span><span class="p">,</span>
		<span class="n">on</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_async_queue</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * this function is exclusively called from pfm_close().</span>
<span class="cm"> * The context is not protected at that time, nor are interrupts</span>
<span class="cm"> * on the remote CPU. That&#39;s necessary to avoid deadlocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_syswide_force_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span>   <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_syswide_force_stop for CPU%d  but on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">owner</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected owner [%d] instead of [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">owner</span><span class="p">),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GET_PMU_CTX</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_syswide_force_stop CPU%d unexpected ctx %p instead of %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span>
			<span class="n">GET_PMU_CTX</span><span class="p">(),</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;on CPU%d forcing system wide stop for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">)));</span>
	<span class="cm">/*</span>
<span class="cm">	 * the context is already protected in pfm_close(), we simply</span>
<span class="cm">	 * need to mask interrupts to avoid a PMU interrupt race on</span>
<span class="cm">	 * this CPU</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context_unload returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * unmask interrupts, PMU interrupts are now spurious here</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_syswide_cleanup_other_cpu</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;calling CPU%d for cleanup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">,</span> <span class="n">pfm_syswide_force_stop</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;called CPU%d for cleanup ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * called for each close(). Partially free resources.</span>
<span class="cm"> * When caller is self-monitoring, the context is unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smpl_buf_size</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">smpl_buf_vaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;bad magic for</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_flush: NULL ctx [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * remove our file from the async queue, if we use this mode.</span>
<span class="cm">	 * This can be done without the context being protected. We come</span>
<span class="cm">	 * here when the context has become unreachable by other tasks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We may still have active monitoring at this point and we may</span>
<span class="cm">	 * end up in pfm_overflow_handler(). However, fasync_helper()</span>
<span class="cm">	 * operates with interrupts disabled and it cleans up the</span>
<span class="cm">	 * queue. If the PMU handler is called prior to entering</span>
<span class="cm">	 * fasync_helper() then it will send a signal. If it is</span>
<span class="cm">	 * invoked after, it will find an empty queue and no</span>
<span class="cm">	 * signal will be sent. In both case, we are safe</span>
<span class="cm">	 */</span>
	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d is_current=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">state</span><span class="p">,</span>
		<span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if state == UNLOADED, then task is NULL</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * we must stop and unload because we are losing access to the context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/*</span>
<span class="cm">		 * the task IS the owner but it migrated to another CPU: that&#39;s bad</span>
<span class="cm">		 * but we must handle this cleanly. Unfortunately, the kernel does</span>
<span class="cm">		 * not provide a mechanism to block migration (while the context is loaded).</span>
<span class="cm">		 *</span>
<span class="cm">		 * We need to release the resource on the ORIGINAL cpu.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>

			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * keep context protected but unmask interrupt for IPI</span>
<span class="cm">			 */</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

			<span class="n">pfm_syswide_cleanup_other_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * restore interrupt masking</span>
<span class="cm">			 */</span>
			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * context is unloaded at this point</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
		<span class="p">{</span>

			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;forcing unload</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">		 	* stop and unload, returning with state UNLOADED</span>
<span class="cm">		 	* and session unreserved.</span>
<span class="cm">		 	*/</span>
			<span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * remove virtual mapping, if any, for the calling task.</span>
<span class="cm">	 * cannot reset ctx field until last user is calling close().</span>
<span class="cm">	 *</span>
<span class="cm">	 * ctx_smpl_vaddr must never be cleared because it is needed</span>
<span class="cm">	 * by every task with access to the context</span>
<span class="cm">	 *</span>
<span class="cm">	 * When called from do_exit(), the mm context is gone already, therefore</span>
<span class="cm">	 * mm is NULL, i.e., the VMA is already gone  and we do not have to</span>
<span class="cm">	 * do anything here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_vaddr</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smpl_buf_vaddr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_vaddr</span><span class="p">;</span>
		<span class="n">smpl_buf_size</span>  <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if there was a mapping, then we systematically remove it</span>
<span class="cm">	 * at this point. Cannot be done inside critical section</span>
<span class="cm">	 * because some VM function reenables interrupts.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smpl_buf_vaddr</span><span class="p">)</span> <span class="n">pfm_remove_smpl_mapping</span><span class="p">(</span><span class="n">smpl_buf_vaddr</span><span class="p">,</span> <span class="n">smpl_buf_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * called either on explicit close() or from exit_files(). </span>
<span class="cm"> * Only the LAST user of the file gets to this point, i.e., it is</span>
<span class="cm"> * called only ONCE.</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT: we get called ONLY when the refcnt on the file gets to zero </span>
<span class="cm"> * (fput()),i.e, last task to access the file. Nobody else can access the </span>
<span class="cm"> * file at this point.</span>
<span class="cm"> *</span>
<span class="cm"> * When called from exit_files(), the VMA has been freed because exit_mm()</span>
<span class="cm"> * is executed before exit_files().</span>
<span class="cm"> *</span>
<span class="cm"> * When called from exit_files(), the current task is not yet ZOMBIE but we</span>
<span class="cm"> * flush the PMU state to the context. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
  	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smpl_buf_size</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">smpl_buf_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_possible</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_close called private=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;bad magic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_close: NULL ctx [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d is_current=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">state</span><span class="p">,</span>
		<span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if task == current, then pfm_flush() unloaded the context</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">)</span> <span class="k">goto</span> <span class="n">doit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * context is loaded/masked and task != current, we need to</span>
<span class="cm">	 * either force an unload or go zombie</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The task is currently blocked or will block after an overflow.</span>
<span class="cm">	 * we must force it to wakeup to get out of the</span>
<span class="cm">	 * MASKED state and transition to the unloaded state by itself.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This situation is only possible for per-task mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span> <span class="o">&amp;&amp;</span> <span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * set a &quot;partial&quot; zombie state to be checked</span>
<span class="cm">		 * upon return from down() in pfm_handle_work().</span>
<span class="cm">		 *</span>
<span class="cm">		 * We cannot use the ZOMBIE state, because it is checked</span>
<span class="cm">		 * by pfm_load_regs() which is called upon wakeup from down().</span>
<span class="cm">		 * In such case, it would free the context and then we would</span>
<span class="cm">		 * return to pfm_handle_work() which would access the</span>
<span class="cm">		 * stale context. Instead, we set a flag invisible to pfm_load_regs()</span>
<span class="cm">		 * but visible to pfm_handle_work().</span>
<span class="cm">		 *</span>
<span class="cm">		 * For some window of time, we have a zombie context with</span>
<span class="cm">		 * ctx_state = MASKED  and not ZOMBIE</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_going_zombie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * force task to wake up from MASKED state</span>
<span class="cm">		 */</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_restart_done</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;waking up ctx_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * put ourself to sleep waiting for the other</span>
<span class="cm">		 * task to report completion</span>
<span class="cm">		 *</span>
<span class="cm">		 * the context is protected by mutex, therefore there</span>
<span class="cm">		 * is no risk of being notified of completion before</span>
<span class="cm">		 * begin actually on the waitq.</span>
<span class="cm">		 */</span>
  		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
  		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_zombieq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX: check for signals :</span>
<span class="cm">		 * 	- ok for explicit close</span>
<span class="cm">		 * 	- not ok when coming from exit_files()</span>
<span class="cm">		 */</span>
      		<span class="n">schedule</span><span class="p">();</span>


		<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>


		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_zombieq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
  		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * context is unloaded at this point</span>
<span class="cm">		 */</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;after zombie wakeup ctx_state=%d for</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/*</span>
<span class="cm">	 	 * switch context to zombie state</span>
<span class="cm">	 	 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;zombie ctx for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="cm">/*</span>
<span class="cm">		 * cannot free the context on the spot. deferred until</span>
<span class="cm">		 * the task notices the ZOMBIE state</span>
<span class="cm">		 */</span>
		<span class="n">free_possible</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

<span class="nl">doit:</span>
	<span class="cm">/* reload state, may have changed during  opening of critical section */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the context is still attached to a task (possibly current)</span>
<span class="cm">	 * we cannot destroy it right now</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * we must free the sampling buffer right here because</span>
<span class="cm">	 * we cannot rely on it being cleaned up later by the</span>
<span class="cm">	 * monitored task. It is not possible to free vmalloc&#39;ed</span>
<span class="cm">	 * memory in pfm_load_regs(). Instead, we remove the buffer</span>
<span class="cm">	 * now. should there be subsequent PMU overflow originally</span>
<span class="cm">	 * meant for sampling, the will be converted to spurious</span>
<span class="cm">	 * and that&#39;s fine because the monitoring tools is gone anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smpl_buf_addr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">;</span>
		<span class="n">smpl_buf_size</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_size</span><span class="p">;</span>
		<span class="cm">/* no more sampling */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_is_sampling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d free_possible=%d addr=%p size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">state</span><span class="p">,</span>
		<span class="n">free_possible</span><span class="p">,</span>
		<span class="n">smpl_buf_addr</span><span class="p">,</span>
		<span class="n">smpl_buf_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smpl_buf_addr</span><span class="p">)</span> <span class="n">pfm_exit_smpl_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * UNLOADED that the session has already been unreserved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * disconnect file descriptor from context must be done</span>
<span class="cm">	 * before we unlock.</span>
<span class="cm">	 */</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we free on the spot, the context is now completely unreachable</span>
<span class="cm">	 * from the callers side. The monitored task side is also cut, so we</span>
<span class="cm">	 * can freely cut.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we have a deferred free, only the caller side is disconnected.</span>
<span class="cm">	 */</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All memory free operations (especially for vmalloc&#39;ed memory)</span>
<span class="cm">	 * MUST be done with interrupts ENABLED.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smpl_buf_addr</span><span class="p">)</span>  <span class="n">pfm_rvfree</span><span class="p">(</span><span class="n">smpl_buf_addr</span><span class="p">,</span> <span class="n">smpl_buf_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * return the memory used by the context</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_possible</span><span class="p">)</span> <span class="n">pfm_context_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_no_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">irrelevant</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dontcare</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_no_open called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pfm_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">pfm_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">pfm_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">pfm_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">pfm_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">pfm_no_open</span><span class="p">,</span>	<span class="cm">/* special open code to disallow open via /proc */</span>
	<span class="p">.</span><span class="n">fasync</span>		<span class="o">=</span> <span class="n">pfm_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">pfm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span>		<span class="o">=</span> <span class="n">pfm_flush</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfmfs_delete_dentry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pfmfs_dname</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dynamic_dname</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;pfm:[%lu]&quot;</span><span class="p">,</span>
			     <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">pfmfs_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_delete</span> <span class="o">=</span> <span class="n">pfmfs_delete_dentry</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_dname</span> <span class="o">=</span> <span class="n">pfmfs_dname</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span>
<span class="nf">pfm_alloc_file</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">this</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate a new inode</span>
<span class="cm">	 */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">pfmfs_mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;new inode ino=%ld @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">));</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFCHR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span>  <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span>  <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate a new dcache entry</span>
<span class="cm">	 */</span>
	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">pfmfs_mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">pfmfs_mnt</span><span class="p">);</span>

	<span class="n">d_add</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">alloc_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_file_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENFILE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">=</span> <span class="n">O_RDONLY</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_remap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;CPU%d buf=0x%lx addr=0x%lx size=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_READONLY</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">addr</span>  <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">buf</span>   <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">size</span>  <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate a sampling buffer and remaps it into the user address space of the task</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_smpl_buffer_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rsize</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">user_vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">smpl_buf</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * the fixed header + requested size and align to page boundary</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">rsize</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;sampling buffer rsize=%lu size=%lu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rsize</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * check requested size to avoid Denial-of-service attacks</span>
<span class="cm">	 * XXX: may have to refine this test</span>
<span class="cm">	 * Check against address space limit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len&gt; task-&gt;rlim[RLIMIT_AS].rlim_cur)</span>
<span class="cm">	 * 	return -ENOMEM;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">task_rlimit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">RLIMIT_MEMLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do the easy to undo allocations first.</span>
<span class="cm"> 	 *</span>
<span class="cm">	 * pfm_rvmalloc(), clears the buffer, so there is no leak</span>
<span class="cm">	 */</span>
	<span class="n">smpl_buf</span> <span class="o">=</span> <span class="n">pfm_rvmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smpl_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;Can&#39;t allocate sampling buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;smpl_buf @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smpl_buf</span><span class="p">));</span>

	<span class="cm">/* allocate vma */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;Cannot allocate vma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_kmem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * partially initialize the vma for the sampling buffer</span>
<span class="cm">	 */</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span>	     <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span>	     <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span>	     <span class="o">=</span> <span class="n">VM_READ</span><span class="o">|</span> <span class="n">VM_MAYREAD</span> <span class="o">|</span><span class="n">VM_RESERVED</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span>    <span class="o">=</span> <span class="n">PAGE_READONLY</span><span class="p">;</span> <span class="cm">/* XXX may need to change */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we have everything we need and we can initialize</span>
<span class="cm">	 * and connect all the data structures</span>
<span class="cm">	 */</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span>   <span class="o">=</span> <span class="n">smpl_buf</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_size</span>  <span class="o">=</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* aligned size */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let&#39;s do the difficult operations next.</span>
<span class="cm">	 *</span>
<span class="cm">	 * now we atomically find some area in the address space and</span>
<span class="cm">	 * remap the buffer in it.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="cm">/* find some free area in address space, must have mmap sem held */</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">get_unmapped_area</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;Cannot find unmapped area for size %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;aligned size=%ld, hdr=%p mapped @0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">));</span>

	<span class="cm">/* can only be applied to current task, need to have the mm semaphore held when called */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_remap_buffer</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">smpl_buf</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;Can&#39;t remap buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_file</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * now insert the vma in the vm list for the process, must be</span>
<span class="cm">	 * done with mmap lock held</span>
<span class="cm">	 */</span>
	<span class="n">insert_vm_struct</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span>  <span class="o">+=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span>
							<span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep track of user level virtual address</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">user_vaddr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="nl">error_kmem:</span>
	<span class="n">pfm_rvfree</span><span class="p">(</span><span class="n">smpl_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX: do something better here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_bad_permissions</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">tcred</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">current_uid</span><span class="p">();</span>
	<span class="n">gid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">current_gid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/* inspired by ptrace_attach() */</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cur: uid=%d gid=%d task: euid=%d suid=%d uid=%d egid=%d sgid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">uid</span><span class="p">,</span>
		<span class="n">gid</span><span class="p">,</span>
		<span class="n">tcred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span>
		<span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">,</span>
		<span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>
		<span class="n">tcred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">,</span>
		<span class="n">tcred</span><span class="o">-&gt;</span><span class="n">sgid</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="p">((</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">)</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">sgid</span><span class="p">)</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_PTRACE</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfarg_is_sane</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfarg_context_t</span> <span class="o">*</span><span class="n">pfx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctx_flags</span><span class="p">;</span>

	<span class="cm">/* valid signal */</span>

	<span class="n">ctx_flags</span> <span class="o">=</span> <span class="n">pfx</span><span class="o">-&gt;</span><span class="n">ctx_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx_flags</span> <span class="o">&amp;</span> <span class="n">PFM_FL_SYSTEM_WIDE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * cannot block in this mode</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx_flags</span> <span class="o">&amp;</span> <span class="n">PFM_FL_NOTIFY_BLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot use blocking mode when in system wide monitoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="p">}</span>
	<span class="cm">/* probably more to add here */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_setup_buffer_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctx_flags</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">pfarg_context_t</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">uaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fmt_arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define PFM_CTXARG_BUF_ARG(a)	(pfm_buffer_fmt_t *)(a+1)</span>

	<span class="cm">/* invoke and lock buffer format, if found */</span>
	<span class="n">fmt</span> <span class="o">=</span> <span class="n">pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">ctx_smpl_buf_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] cannot find buffer format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * buffer argument MUST be contiguous to pfarg_context_t</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_arg_size</span><span class="p">)</span> <span class="n">fmt_arg</span> <span class="o">=</span> <span class="n">PFM_CTXARG_BUF_ARG</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_validate</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ctx_flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">fmt_arg</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] after validate(0x%x,%d,%p)=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">ctx_flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">fmt_arg</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* link buffer format and context */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_is_sampling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* assume record() is defined */</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if buffer format wants to use perfmon buffer allocation/mapping service</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_getsize</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ctx_flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">fmt_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * buffer is always remapped into the caller&#39;s address space</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_smpl_buffer_alloc</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/* keep track of user address of buffer */</span>
		<span class="n">arg</span><span class="o">-&gt;</span><span class="n">ctx_smpl_vaddr</span> <span class="o">=</span> <span class="n">uaddr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_init</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">ctx_flags</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">fmt_arg</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_reset_pmu_state</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * install reset values for PMC.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">PMC_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMC_IS_IMPL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMC_DFL_VAL</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * PMD registers are set to 0UL when the context in memset()</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * On context switched restore, we must restore ALL pmc and ALL pmd even</span>
<span class="cm">	 * when they are not actively used by the task. In UP, the incoming process</span>
<span class="cm">	 * may otherwise pick up left over PMC, PMD state from the previous process.</span>
<span class="cm">	 * As opposed to PMD, stale PMC can cause harm to the incoming</span>
<span class="cm">	 * process because they may change what is being measured.</span>
<span class="cm">	 * Therefore, we must systematically reinstall the entire</span>
<span class="cm">	 * PMC state. In SMP, the same thing is possible on the</span>
<span class="cm">	 * same CPU but also on between 2 CPUs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The problem with PMD is information leaking especially</span>
<span class="cm">	 * to user level when psr.sp=0</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is unfortunately no easy way to avoid this problem</span>
<span class="cm">	 * on either UP or SMP. This definitively slows down the</span>
<span class="cm">	 * pfm_load_regs() function.</span>
<span class="cm">	 */</span>

	 <span class="cm">/*</span>
<span class="cm">	  * bitmask of all PMCs accessible to this context</span>
<span class="cm">	  *</span>
<span class="cm">	  * PMC0 is treated differently.</span>
<span class="cm">	  */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">impl_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bitmask of all PMDs that are accessible to this context</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">impl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;&lt;%d&gt; all_pmcs=0x%lx all_pmds=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

	<span class="cm">/*</span>
<span class="cm">	 * useful in case of re-enable after disable</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_ibrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_dbrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_ctx_getsize</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfarg_context_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_context_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>

	<span class="o">*</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfm_uuid_cmp</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx_smpl_buf_id</span><span class="p">,</span> <span class="n">pfm_null_uuid</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fmt</span> <span class="o">=</span> <span class="n">pfm_find_buffer_fmt</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx_smpl_buf_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot find buffer format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* get just enough to copy in user parameters */</span>
	<span class="o">*</span><span class="n">sz</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_arg_size</span><span class="p">;</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;arg_size=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">sz</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * cannot attach if :</span>
<span class="cm"> * 	- kernel task</span>
<span class="cm"> * 	- task not owned by caller</span>
<span class="cm"> * 	- task incompatible with context mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_task_incompatible</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * no kernel task or task not owner by caller</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;task [%d] has not memory context (kernel thread)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_bad_permissions</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;no permission to attach to  [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * cannot block in self-monitoring mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot load a blocking context on self for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">==</span> <span class="n">EXIT_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot attach to  zombie task [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * always ok for self</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_is_stopped_or_traced</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot attach to non-stopped task [%d] state=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * make sure the task is off any CPU</span>
<span class="cm">	 */</span>
	<span class="n">wait_task_inactive</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* more to come... */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_get_task</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* XXX: need to add more checks here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>

		<span class="cm">/* make sure task cannot go away while we operate on it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_task_incompatible</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_put_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_context_create</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfarg_context_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_context_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctx_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* let&#39;s check the arguments first */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfarg_is_sane</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ctx_flags</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx_flags</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">pfm_context_alloc</span><span class="p">(</span><span class="n">ctx_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">pfm_alloc_file</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_file</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx_fd</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * does the user want to sample?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_uuid_cmp</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ctx_smpl_buf_id</span><span class="p">,</span> <span class="n">pfm_null_uuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_setup_buffer_fmt</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">buffer_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d no_msg=%d ctx_fd=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="p">,</span>
		<span class="n">ctx_flags</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_block</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_excl_idle</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_no_msg</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize soft PMU state</span>
<span class="cm">	 */</span>
	<span class="n">pfm_reset_pmu_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">buffer_error:</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
	<span class="n">put_filp</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_buf_fmt_exit</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">error_file:</span>
	<span class="n">pfm_context_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

<span class="nl">error:</span>
	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pfm_new_counter_value</span> <span class="p">(</span><span class="n">pfm_counter_t</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_long_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">is_long_reset</span> <span class="o">?</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">long_reset</span> <span class="o">:</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">short_reset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_seed</span><span class="p">,</span> <span class="n">old_seed</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">seed</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">carta_random32</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PFM_REGFL_RANDOM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_seed</span> <span class="o">=</span> <span class="n">carta_random32</span><span class="p">(</span><span class="n">old_seed</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">-=</span> <span class="p">(</span><span class="n">old_seed</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>	<span class="cm">/* counter values are negative numbers! */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* construct a full 64-bit random value: */</span>
			<span class="n">new_seed</span> <span class="o">|=</span> <span class="n">carta_random32</span><span class="p">(</span><span class="n">old_seed</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">seed</span> <span class="o">=</span> <span class="n">new_seed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">lval</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_reset_regs_masked</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ovfl_regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_long_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reset_others</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * now restore reset value on sampling overflowed counters</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1UL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pfm_new_counter_value</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_long_reset</span><span class="p">);</span>
		<span class="n">reset_others</span>        <span class="o">|=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reset_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot; %s reset ctx_pmds[%d]=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_long_reset</span> <span class="o">?</span> <span class="s">&quot;long&quot;</span> <span class="o">:</span> <span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now take care of resetting the other registers</span>
<span class="cm">	 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">reset_others</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">reset_others</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">reset_others</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pfm_new_counter_value</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_long_reset</span><span class="p">);</span>

		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;%s reset_others pmd[%d]=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">is_long_reset</span> <span class="o">?</span> <span class="s">&quot;long&quot;</span> <span class="o">:</span> <span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_reset_regs</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ovfl_regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_long_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reset_others</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;ovfl_regs=0x%lx is_long_reset=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_long_reset</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_reset_regs_masked</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ovfl_regs</span><span class="p">,</span> <span class="n">is_long_reset</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * now restore reset value on sampling overflowed counters</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1UL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">val</span>           <span class="o">=</span> <span class="n">pfm_new_counter_value</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_long_reset</span><span class="p">);</span>
		<span class="n">reset_others</span> <span class="o">|=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reset_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot; %s reset ctx_pmds[%d]=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_long_reset</span> <span class="o">?</span> <span class="s">&quot;long&quot;</span> <span class="o">:</span> <span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>

		<span class="n">pfm_write_soft_counter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now take care of resetting the other registers</span>
<span class="cm">	 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">reset_others</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">reset_others</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">reset_others</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">pfm_new_counter_value</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_long_reset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pfm_write_soft_counter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ia64_set_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;%s reset_others pmd[%d]=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">is_long_reset</span> <span class="o">?</span> <span class="s">&quot;long&quot;</span> <span class="o">:</span> <span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_write_pmcs</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="n">pmc_pm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smpl_pmds</span><span class="p">,</span> <span class="n">reset_pmds</span><span class="p">,</span> <span class="n">impl_pmds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">reg_flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pmc_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">can_access_pmu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_loaded</span><span class="p">,</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">expert_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_monitor</span><span class="p">,</span> <span class="n">is_counting</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pfm_reg_check_t</span>	<span class="n">wr_func</span><span class="p">;</span>
<span class="cp">#define PFM_CHECK_PMC_PM(x, y, z) ((x)-&gt;ctx_fl_system ^ PMC_PM(y, z))</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_loaded</span> <span class="o">=</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">task</span>      <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>
	<span class="n">impl_pmds</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">impl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm">		 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm">		 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">can_access_pmu</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span> <span class="o">||</span> <span class="n">is_system</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">expert_mode</span> <span class="o">=</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">expert_mode</span><span class="p">;</span> 

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">req</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cnum</span>       <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">;</span>
		<span class="n">reg_flags</span>  <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">;</span>
		<span class="n">value</span>      <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_value</span><span class="p">;</span>
		<span class="n">smpl_pmds</span>  <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_smpl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">reset_pmds</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_reset_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">flags</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">cnum</span> <span class="o">&gt;=</span> <span class="n">PMU_MAX_PMCS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc%u is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pmc_type</span>   <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmc_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">type</span><span class="p">;</span>
		<span class="n">pmc_pm</span>     <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmc_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">pm_pos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">is_counting</span> <span class="o">=</span> <span class="p">(</span><span class="n">pmc_type</span> <span class="o">&amp;</span> <span class="n">PFM_REG_COUNTING</span><span class="p">)</span> <span class="o">==</span> <span class="n">PFM_REG_COUNTING</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">is_monitor</span>  <span class="o">=</span> <span class="p">(</span><span class="n">pmc_type</span> <span class="o">&amp;</span> <span class="n">PFM_REG_MONITOR</span><span class="p">)</span> <span class="o">==</span> <span class="n">PFM_REG_MONITOR</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * we reject all non implemented PMC as well</span>
<span class="cm">		 * as attempts to modify PMC[0-3] which are used</span>
<span class="cm">		 * as status registers by the PMU</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pmc_type</span> <span class="o">&amp;</span> <span class="n">PFM_REG_IMPL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">pmc_type</span> <span class="o">&amp;</span> <span class="n">PFM_REG_CONTROL</span><span class="p">)</span> <span class="o">==</span> <span class="n">PFM_REG_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc%u is unimplemented or no-access pmc_type=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">pmc_type</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wr_func</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmc_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">write_check</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the PMC is a monitor, then if the value is not the default:</span>
<span class="cm">		 * 	- system-wide session: PMCx.pm=1 (privileged monitor)</span>
<span class="cm">		 * 	- per-task           : PMCx.pm=0 (user monitor)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_monitor</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">PMC_DFL_VAL</span><span class="p">(</span><span class="n">cnum</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_system</span> <span class="o">^</span> <span class="n">pmc_pm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc%u pmc_pm=%lu is_system=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cnum</span><span class="p">,</span>
				<span class="n">pmc_pm</span><span class="p">,</span>
				<span class="n">is_system</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_counting</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * enforce generation of overflow interrupt. Necessary on all</span>
<span class="cm">		 	 * CPUs.</span>
<span class="cm">		 	 */</span>
			<span class="n">value</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PMU_PMC_OI</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">reg_flags</span> <span class="o">&amp;</span> <span class="n">PFM_REGFL_OVFL_NOTIFY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flags</span> <span class="o">|=</span> <span class="n">PFM_REGFL_OVFL_NOTIFY</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">reg_flags</span> <span class="o">&amp;</span> <span class="n">PFM_REGFL_RANDOM</span><span class="p">)</span> <span class="n">flags</span> <span class="o">|=</span> <span class="n">PFM_REGFL_RANDOM</span><span class="p">;</span>

			<span class="cm">/* verify validity of smpl_pmds */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">smpl_pmds</span> <span class="o">&amp;</span> <span class="n">impl_pmds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">smpl_pmds</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid smpl_pmds 0x%lx for pmc%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smpl_pmds</span><span class="p">,</span> <span class="n">cnum</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* verify validity of reset_pmds */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">reset_pmds</span> <span class="o">&amp;</span> <span class="n">impl_pmds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reset_pmds</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid reset_pmds 0x%lx for pmc%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reset_pmds</span><span class="p">,</span> <span class="n">cnum</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PFM_REGFL_OVFL_NOTIFY</span><span class="o">|</span><span class="n">PFM_REGFL_RANDOM</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot set ovfl_notify or random on pmc%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* eventid on non-counting monitors are ignored */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * execute write checker, if any</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">expert_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wr_func</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">wr_func</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * no error on this register</span>
<span class="cm">		 */</span>
		<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now we commit the changes to the software state</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * update overflow information</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_counting</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * full flag update each time a register is programmed</span>
<span class="cm">		 	 */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">reset_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reset_pmds</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">smpl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">smpl_pmds</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">eventid</span>       <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_smpl_eventid</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Mark all PMDS to be accessed as used.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do not keep track of PMC because we have to</span>
<span class="cm">			 * systematically restore ALL of them.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do not update the used_monitors mask, because</span>
<span class="cm">			 * if we have not programmed them, then will be in</span>
<span class="cm">			 * a quiescent state, therefore we will not need to</span>
<span class="cm">			 * mask/restore then when context is MASKED.</span>
<span class="cm">			 */</span>
			<span class="n">CTX_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">reset_pmds</span><span class="p">);</span>
			<span class="n">CTX_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">smpl_pmds</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * make sure we do not try to reset on</span>
<span class="cm">		 	 * restart because we have established new values</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cnum</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Needed in case the user does not initialize the equivalent</span>
<span class="cm">		 * PMD. Clearing is done indirectly via pfm_reset_pmu_state() so there is no</span>
<span class="cm">		 * possible leak here.</span>
<span class="cm">		 */</span>
		<span class="n">CTX_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmc_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">dep_pmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * keep track of the monitor PMC that we are using.</span>
<span class="cm">		 * we save the value of the pmc in ctx_pmcs[] and if</span>
<span class="cm">		 * the monitoring is not stopped for the context we also</span>
<span class="cm">		 * place it in the saved state area so that it will be</span>
<span class="cm">		 * picked up later by the context switch code.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The value in ctx_pmcs[] can only be changed in pfm_write_pmcs().</span>
<span class="cm">		 *</span>
<span class="cm">		 * The value in th_pmcs[] may be modified on overflow, i.e.,  when</span>
<span class="cm">		 * monitoring needs to be stopped.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_monitor</span><span class="p">)</span> <span class="n">CTX_USED_MONITOR</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cnum</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * update context state</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmcs</span><span class="p">[</span><span class="n">cnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * write thread state</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">cnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * write hardware register if we can</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="n">cnum</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * per-task SMP only here</span>
<span class="cm">				 *</span>
<span class="cm">			 	 * we are guaranteed that the task is not running on the other CPU,</span>
<span class="cm">			 	 * we indicate that this PMD will need to be reloaded if the task</span>
<span class="cm">			 	 * is rescheduled on the CPU it ran last on.</span>
<span class="cm">			 	 */</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cnum</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc[%u]=0x%lx ld=%d apmu=%d flags=0x%x all_pmcs=0x%lx used_pmds=0x%lx eventid=%ld smpl_pmds=0x%lx reset_pmds=0x%lx reloads_pmcs=0x%lx used_monitors=0x%lx ovfl_regs=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">cnum</span><span class="p">,</span>
			  <span class="n">value</span><span class="p">,</span>
			  <span class="n">is_loaded</span><span class="p">,</span>
			  <span class="n">can_access_pmu</span><span class="p">,</span>
			  <span class="n">flags</span><span class="p">,</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">eventid</span><span class="p">,</span>
			  <span class="n">smpl_pmds</span><span class="p">,</span>
			  <span class="n">reset_pmds</span><span class="p">,</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_monitors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure the changes are visible</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="n">ia64_srlz_d</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="n">PFM_REG_RETFL_EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_write_pmds</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="n">hw_value</span><span class="p">,</span> <span class="n">ovfl_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">can_access_pmu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_counting</span><span class="p">,</span> <span class="n">is_loaded</span><span class="p">,</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">expert_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pfm_reg_check_t</span> <span class="n">wr_func</span><span class="p">;</span>


	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_loaded</span> <span class="o">=</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">ovfl_mask</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="n">task</span>      <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * on both UP and SMP, we can only write to the PMC when the task is</span>
<span class="cm">	 * the owner of the local PMU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">is_loaded</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm">		 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm">		 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">can_access_pmu</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span> <span class="o">||</span> <span class="n">is_system</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">expert_mode</span> <span class="o">=</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">expert_mode</span><span class="p">;</span> 

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">req</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cnum</span>  <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_value</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMD_IS_IMPL</span><span class="p">(</span><span class="n">cnum</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmd[%u] is unimplemented or invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">abort_mission</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">is_counting</span> <span class="o">=</span> <span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">cnum</span><span class="p">);</span>
		<span class="n">wr_func</span>     <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmd_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">write_check</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * execute write checker, if any</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">expert_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wr_func</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">wr_func</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">abort_mission</span><span class="p">;</span>

			<span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">ret</span>   <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * no error on this register</span>
<span class="cm">		 */</span>
		<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * now commit changes to software state</span>
<span class="cm">		 */</span>
		<span class="n">hw_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * update virtualized (64bits) counter</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_counting</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * write context state</span>
<span class="cm">			 */</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">lval</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * when context is load we use the split value</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span>  <span class="n">ovfl_mask</span><span class="p">;</span>
				<span class="n">value</span>    <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ovfl_mask</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * update reset values (not just for counters)</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">long_reset</span>  <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_long_reset</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">short_reset</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_short_reset</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * update randomization parameters (not just for counters)</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">seed</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_random_seed</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_random_mask</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * update context value</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">val</span>  <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Keep track of what we use</span>
<span class="cm">		 *</span>
<span class="cm">		 * We do not keep track of PMC because we have to</span>
<span class="cm">		 * systematically restore ALL of them.</span>
<span class="cm">		 */</span>
		<span class="n">CTX_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">PMD_PMD_DEP</span><span class="p">(</span><span class="n">cnum</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * mark this PMD register used as well</span>
<span class="cm">		 */</span>
		<span class="n">CTX_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">RDEP</span><span class="p">(</span><span class="n">cnum</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * make sure we do not try to reset on</span>
<span class="cm">		 * restart because we have established new values</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_counting</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cnum</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">		 	 * write thread state</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hw_value</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * write hardware register if we can</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_pmd</span><span class="p">(</span><span class="n">cnum</span><span class="p">,</span> <span class="n">hw_value</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
				<span class="cm">/*</span>
<span class="cm">			 	 * we are guaranteed that the task is not running on the other CPU,</span>
<span class="cm">			 	 * we indicate that this PMD will need to be reloaded if the task</span>
<span class="cm">			 	 * is rescheduled on the CPU it ran last on.</span>
<span class="cm">			 	 */</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cnum</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmd[%u]=0x%lx ld=%d apmu=%d, hw_value=0x%lx ctx_pmd=0x%lx  short_reset=0x%lx &quot;</span>
			  <span class="s">&quot;long_reset=0x%lx notify=%c seed=0x%lx mask=0x%lx used_pmds=0x%lx reset_pmds=0x%lx reload_pmds=0x%lx all_pmds=0x%lx ovfl_regs=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cnum</span><span class="p">,</span>
			<span class="n">value</span><span class="p">,</span>
			<span class="n">is_loaded</span><span class="p">,</span>
			<span class="n">can_access_pmu</span><span class="p">,</span>
			<span class="n">hw_value</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">val</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">short_reset</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">long_reset</span><span class="p">,</span>
			<span class="n">PMC_OVFL_NOTIFY</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cnum</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;Y&#39;</span><span class="o">:</span><span class="sc">&#39;N&#39;</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">seed</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">mask</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">reset_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * make changes visible</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="n">ia64_srlz_d</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_mission:</span>
	<span class="cm">/*</span>
<span class="cm">	 * for now, we have only one possibility for error</span>
<span class="cm">	 */</span>
	<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="n">PFM_REG_RETFL_EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By the way of PROTECT_CONTEXT(), interrupts are masked while we are in this function.</span>
<span class="cm"> * Therefore we know, we do not have to worry about the PMU overflow interrupt. If an</span>
<span class="cm"> * interrupt is delivered during the call, it will be kept pending until we leave, making</span>
<span class="cm"> * it appears as if it had been generated at the UNPROTECT_CONTEXT(). At least we are</span>
<span class="cm"> * guaranteed to return consistent data to the user, it may simply be old. It is not</span>
<span class="cm"> * trivial to treat the overflow while inside the call because you may end up in</span>
<span class="cm"> * some module sampling buffer code causing deadlocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_read_pmds</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span> <span class="n">lval</span><span class="p">,</span> <span class="n">ovfl_mask</span><span class="p">,</span> <span class="n">sval</span><span class="p">;</span>
	<span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">reg_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">can_access_pmu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_loaded</span><span class="p">,</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">is_counting</span><span class="p">,</span> <span class="n">expert_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pfm_reg_check_t</span> <span class="n">rd_func</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * access is possible when loaded only for</span>
<span class="cm">	 * self-monitoring tasks or in UP mode</span>
<span class="cm">	 */</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_loaded</span> <span class="o">=</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">ovfl_mask</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="n">task</span>      <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">is_loaded</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm">		 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm">		 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * this can be true when not self-monitoring only in UP</span>
<span class="cm">		 */</span>
		<span class="n">can_access_pmu</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span> <span class="o">||</span> <span class="n">is_system</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">expert_mode</span> <span class="o">=</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">expert_mode</span><span class="p">;</span> 

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ld=%d apmu=%d ctx_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">is_loaded</span><span class="p">,</span>
		<span class="n">can_access_pmu</span><span class="p">,</span>
		<span class="n">state</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * on both UP and SMP, we can only read the PMD from the hardware register when</span>
<span class="cm">	 * the task is the owner of the local PMU.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">req</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cnum</span>        <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">;</span>
		<span class="n">reg_flags</span>   <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PMD_IS_IMPL</span><span class="p">(</span><span class="n">cnum</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we can only read the register that we use. That includes</span>
<span class="cm">		 * the one we explicitly initialize AND the one we want included</span>
<span class="cm">		 * in the sampling buffer (smpl_regs).</span>
<span class="cm">		 *</span>
<span class="cm">		 * Having this restriction allows optimization in the ctxsw routine</span>
<span class="cm">		 * without compromising security (leaks)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">CTX_IS_USED_PMD</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cnum</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">sval</span>        <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
		<span class="n">lval</span>        <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">lval</span><span class="p">;</span>
		<span class="n">is_counting</span> <span class="o">=</span> <span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">cnum</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the task is not the current one, then we check if the</span>
<span class="cm">		 * PMU state is still in the local live register due to lazy ctxsw.</span>
<span class="cm">		 * If true, then we read directly from the registers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">){</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">cnum</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * context has been saved</span>
<span class="cm">			 * if context is zombie, then task does not exist anymore.</span>
<span class="cm">			 * In this case, we use the full value saved in the context (pfm_flush_regs()).</span>
<span class="cm">			 */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">is_loaded</span> <span class="o">?</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">cnum</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rd_func</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmd_desc</span><span class="p">[</span><span class="n">cnum</span><span class="p">].</span><span class="n">read_check</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_counting</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * XXX: need to check for overflow when loaded</span>
<span class="cm">			 */</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">ovfl_mask</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">sval</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * execute read checker, if any</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">expert_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rd_func</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">rd_func</span><span class="p">)(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">reg_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmd[%u]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * update register return value, abort all if problem during copy.</span>
<span class="cm">		 * we only modify the reg_flags field. no check mode is fine because</span>
<span class="cm">		 * access has been verified upfront in sys_perfmonctl().</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_value</span>            <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span>            <span class="o">=</span> <span class="n">reg_flags</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_last_reset_val</span>   <span class="o">=</span> <span class="n">lval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="n">PFM_REG_RETFL_EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pfm_mod_write_pmcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

 	<span class="n">ctx</span> <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now limit to current task, which is enough when calling</span>
<span class="cm">	 * from overflow handler</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pfm_write_pmcs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">nreq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_mod_write_pmcs</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">pfm_mod_read_pmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

 	<span class="n">ctx</span> <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now limit to current task, which is enough when calling</span>
<span class="cm">	 * from overflow handler</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pfm_read_pmds</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">nreq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_mod_read_pmds</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Only call this function when a process it trying to</span>
<span class="cm"> * write the debug registers (reading is always allowed)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pfm_use_debug_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">use_rr_dbregs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;called for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * do it only once</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even on SMP, we do not need to use an atomic here because</span>
<span class="cm">	 * the only way in is via ptrace() and this is possible only when the</span>
<span class="cm">	 * process is stopped. Even in the case where the ctxsw out is not totally</span>
<span class="cm">	 * completed by the time we come here, there is no way the &#39;stopped&#39; process</span>
<span class="cm">	 * could be in the middle of fiddling with the pfm_write_ibr_dbr() routine.</span>
<span class="cm">	 * So this is always safe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot allow setting breakpoints when system wide monitoring</span>
<span class="cm">	 * sessions are using the debug registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ptrace_use_dbregs=%u  sys_use_dbregs=%u by [%d] ret = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="p">,</span>
		  <span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
		  <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">ret</span><span class="p">));</span>

	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called for every task that exits with the</span>
<span class="cm"> * IA64_THREAD_DBG_VALID set. This indicates a task which was</span>
<span class="cm"> * able to use the debug registers for debugging purposes via</span>
<span class="cm"> * ptrace(). Therefore we know it was not using them for</span>
<span class="cm"> * performance monitoring, so we only decrement the number</span>
<span class="cm"> * of &quot;ptraced&quot; debug register users to keep the count up to date</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pfm_release_debug_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">use_rr_dbregs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: invalid release for [%d] ptrace_use_dbregs=0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_restart</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="n">pfm_ovfl_ctrl_t</span> <span class="n">rst_ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">fmt</span>       <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">task</span>      <span class="o">=</span> <span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PFM_CTX_MASKED</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PFM_CTX_LOADED</span>: 
			<span class="k">if</span> <span class="p">(</span><span class="n">CTX_HAS_SMPL</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt_restart_active</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">PFM_CTX_UNLOADED</span>:
		<span class="k">case</span> <span class="n">PFM_CTX_ZOMBIE</span>:
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;state=%d, cannot operate (no active_restart handler)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm"> 	 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm"> 	 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: [%d] pfm_restart no task</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span> <span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">fmt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;restarting self %d ovfl=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">CTX_HAS_SMPL</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">prefetch</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">);</span>

			<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_restart_active</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rst_ctrl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_restart</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rst_ctrl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span><span class="p">)</span>
				<span class="n">pfm_reset_regs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">,</span> <span class="n">PFM_PMD_LONG_RESET</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;resuming monitoring for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="n">pfm_restore_monitoring</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;keeping monitoring stopped for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>cannot use pfm<em>stop</em>monitoring(task, regs);</p></td><td class="code"><div class="highlight"><pre>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * clear overflowed PMD mask to remove any stale information</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * back to LOADED state</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_LOADED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX: not really useful for self monitoring</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_can_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* </span>
<span class="cm">	 * restart another task</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * When PFM_CTX_MASKED, we cannot issue a restart before the previous </span>
<span class="cm">	 * one is seen by the task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_can_restart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * will prevent subsequent restart before this one is</span>
<span class="cm">		 * seen by other task</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_can_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if blocking, then post the semaphore is PFM_CTX_MASKED, i.e.</span>
<span class="cm">	 * the task is blocked or on its way to block. That&#39;s the normal</span>
<span class="cm">	 * restart path. If the monitoring is not masked, then the task</span>
<span class="cm">	 * can be actively monitoring and we cannot directly intervene.</span>
<span class="cm">	 * Therefore we use the trap mechanism to catch the task and</span>
<span class="cm">	 * force it to reset the buffer/reset PMDs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if non-blocking, then we ensure that the task will go into</span>
<span class="cm">	 * pfm_handle_work() before returning to user mode.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We cannot explicitly reset another task, it MUST always</span>
<span class="cm">	 * be done by the task itself. This works for system wide because</span>
<span class="cm">	 * the tool that is controlling the session is logically doing </span>
<span class="cm">	 * &quot;self-monitoring&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;unblocking [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_restart_done</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] armed exit trap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span> <span class="o">=</span> <span class="n">PFM_TRAP_REASON_RESET</span><span class="p">;</span>

		<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">set_notify_resume</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX: send reschedule if task runs on another CPU</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_debug</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon debugging %s (timing reset)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">debug</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pfm_stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_stats</span><span class="p">));</span>
		<span class="k">for</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_min</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * arg can be NULL and count can be zero for this function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_write_ibr_dbr</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">pfarg_dbreg_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_dbreg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">dbreg_t</span> <span class="n">dbreg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">can_access_pmu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">is_loaded</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">use_rr_dbregs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_loaded</span> <span class="o">=</span> <span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="n">task</span>      <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * on both UP and SMP, we can only write to the PMC when the task is</span>
<span class="cm">	 * the owner of the local PMU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="kr">thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm">		 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm">		 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">can_access_pmu</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span> <span class="o">||</span> <span class="n">is_system</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we do not need to check for ipsr.db because we do clear ibr.x, dbr.r, and dbr.w</span>
<span class="cm">	 * ensuring that no real breakpoint can be installed via this call.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IMPORTANT: regs can be NULL in this function</span>
<span class="cm">	 */</span>

	<span class="n">first_time</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t bother if we are loaded and task is being debugged</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;debug registers already in use for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for debug registers in system wide mode</span>
<span class="cm">	 *</span>
<span class="cm">	 * If though a check is done in pfm_context_load(),</span>
<span class="cm">	 * we must repeat it here, in case the registers are</span>
<span class="cm">	 * written after the context is loaded</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span> <span class="o">&amp;&amp;</span> <span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark ourself as user of the debug registers for</span>
<span class="cm">	 * perfmon purposes.</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * clear hardware registers to make sure we don&#39;t</span>
<span class="cm"> 	 * pick up stale state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * for a system wide session, we do not use</span>
<span class="cm">	 * thread.dbr, thread.ibr because this process</span>
<span class="cm">	 * never leaves the current CPU and the state</span>
<span class="cm">	 * is shared by all processes running on it</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span> <span class="o">&amp;&amp;</span> <span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] clearing ibrs, dbrs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_set_ibr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
			<span class="n">ia64_dv_serialize_instruction</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_set_dbr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
			<span class="n">ia64_dv_serialize_data</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now install the values into the registers</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">req</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">rnum</span>      <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dbreg_num</span><span class="p">;</span>
		<span class="n">dbreg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dbreg_value</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="n">PFM_CODE_RR</span> <span class="o">&amp;&amp;</span> <span class="n">rnum</span> <span class="o">&gt;=</span> <span class="n">PFM_NUM_IBRS</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="n">PFM_DATA_RR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rnum</span> <span class="o">&gt;=</span> <span class="n">PFM_NUM_DBRS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid register %u val=0x%lx mode=%d i=%d count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">rnum</span><span class="p">,</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">));</span>

			<span class="k">goto</span> <span class="n">abort_mission</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * make sure we do not install enabled breakpoint</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rnum</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">PFM_CODE_RR</span><span class="p">)</span>
				<span class="n">dbreg</span><span class="p">.</span><span class="n">ibr</span><span class="p">.</span><span class="n">ibr_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dbreg</span><span class="p">.</span><span class="n">dbr</span><span class="p">.</span><span class="n">dbr_r</span> <span class="o">=</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">dbr</span><span class="p">.</span><span class="n">dbr_w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dbreg_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Debug registers, just like PMC, can only be modified</span>
<span class="cm">		 * by a kernel call. Moreover, perfmon() access to those</span>
<span class="cm">		 * registers are centralized in this routine. The hardware</span>
<span class="cm">		 * does not modify the value of these registers, therefore,</span>
<span class="cm">		 * if we save them as they are written, we can avoid having</span>
<span class="cm">		 * to save them on context switch out. This is made possible</span>
<span class="cm">		 * by the fact that when perfmon uses debug registers, ptrace()</span>
<span class="cm">		 * won&#39;t be able to modify them concurrently.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">PFM_CODE_RR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">CTX_USED_IBR</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">rnum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_ibr</span><span class="p">(</span><span class="n">rnum</span><span class="p">,</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
				<span class="n">ia64_dv_serialize_instruction</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ibrs</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>

			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;write ibr%u=0x%lx used_ibrs=0x%x ld=%d apmu=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rnum</span><span class="p">,</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_ibrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_loaded</span><span class="p">,</span> <span class="n">can_access_pmu</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">CTX_USED_DBR</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">rnum</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_dbr</span><span class="p">(</span><span class="n">rnum</span><span class="p">,</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
				<span class="n">ia64_dv_serialize_data</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_dbrs</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>

			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;write dbr%u=0x%lx used_dbrs=0x%x ld=%d apmu=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rnum</span><span class="p">,</span> <span class="n">dbreg</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_dbrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_loaded</span><span class="p">,</span> <span class="n">can_access_pmu</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_mission:</span>
	<span class="cm">/*</span>
<span class="cm">	 * in case it was our first attempt, we undo the global modifications</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * install error return flag</span>
<span class="cm">	 */</span>
	<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dbreg_flags</span><span class="p">,</span> <span class="n">PFM_REG_RETFL_EINVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_write_ibrs</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfm_write_ibr_dbr</span><span class="p">(</span><span class="n">PFM_CODE_RR</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_write_dbrs</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pfm_write_ibr_dbr</span><span class="p">(</span><span class="n">PFM_DATA_RR</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pfm_mod_write_ibrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

 	<span class="n">ctx</span> <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now limit to current task, which is enough when calling</span>
<span class="cm">	 * from overflow handler</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pfm_write_ibrs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">nreq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_mod_write_ibrs</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">pfm_mod_write_dbrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

 	<span class="n">ctx</span> <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for now limit to current task, which is enough when calling</span>
<span class="cm">	 * from overflow handler</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pfm_write_dbrs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">nreq</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pfm_mod_write_dbrs</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_get_features</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfarg_features_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_features_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ft_version</span> <span class="o">=</span> <span class="n">PFM_VERSION</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_stop</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">tregs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * context must be attached to issue the stop command (includes LOADED,MASKED,ZOMBIE)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm"> 	 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm"> 	 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;task [%d] ctx_state=%d is_system=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)),</span>
		<span class="n">state</span><span class="p">,</span>
		<span class="n">is_system</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * in system mode, we need to update the PMU directly</span>
<span class="cm">	 * and the user level state of the caller, which may not</span>
<span class="cm">	 * necessarily be the creator of the context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update local PMU first</span>
<span class="cm">		 *</span>
<span class="cm">		 * disable dcr pp</span>
<span class="cm">		 */</span>
		<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IA64_DCR_PP</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * update local cpuinfo</span>
<span class="cm">		 */</span>
		<span class="n">PFM_CPUINFO_CLEAR</span><span class="p">(</span><span class="n">PFM_CPUINFO_DCR_PP</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop monitoring, does srlz.i</span>
<span class="cm">		 */</span>
		<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop monitoring in the caller</span>
<span class="cm">		 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * per-task mode</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stop monitoring  at kernel level */</span>
		<span class="n">pfm_clear_psr_up</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">	 	 * stop monitoring at the user level</span>
<span class="cm">	 	 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tregs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">	 	 * stop monitoring at the user level</span>
<span class="cm">	 	 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">tregs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * monitoring disabled in kernel at next reschedule</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;task=[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_start</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">tregs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PFM_CTX_LOADED</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * In system wide and when the context is loaded, access can only happen</span>
<span class="cm"> 	 * when the caller is running on the CPU being monitored by the session.</span>
<span class="cm"> 	 * It does not have to be the owner (ctx_task) of the context per se.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;should be running on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * in system mode, we need to update the PMU directly</span>
<span class="cm">	 * and the user level state of the caller, which may not</span>
<span class="cm">	 * necessarily be the creator of the context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * set user level psr.pp for the caller</span>
<span class="cm">		 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * now update the local PMU and cpuinfo</span>
<span class="cm">		 */</span>
		<span class="n">PFM_CPUINFO_SET</span><span class="p">(</span><span class="n">PFM_CPUINFO_DCR_PP</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * start monitoring at kernel level</span>
<span class="cm">		 */</span>
		<span class="n">pfm_set_psr_pp</span><span class="p">();</span>

		<span class="cm">/* enable dcr pp */</span>
		<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">IA64_DCR_PP</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * per-process mode</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* start monitoring at kernel level */</span>
		<span class="n">pfm_set_psr_up</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * activate monitoring at user level</span>
<span class="cm">		 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tregs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * start monitoring at the kernel level the next</span>
<span class="cm">		 * time the task is scheduled</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span> <span class="o">=</span> <span class="n">IA64_PSR_UP</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * activate monitoring at user level</span>
<span class="cm">		 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">tregs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_get_pmc_reset</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_reg_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">req</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cnum</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMC_IS_IMPL</span><span class="p">(</span><span class="n">cnum</span><span class="p">))</span> <span class="k">goto</span> <span class="n">abort_mission</span><span class="p">;</span>

		<span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_value</span> <span class="o">=</span> <span class="n">PMC_DFL_VAL</span><span class="p">(</span><span class="n">cnum</span><span class="p">);</span>

		<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pmc_reset_val pmc[%u]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_value</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">abort_mission:</span>
	<span class="n">PFM_REG_RETFLAG_SET</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">reg_flags</span><span class="p">,</span> <span class="n">PFM_REG_RETFL_EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_check_task_exist</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">do_each_thread</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span> <span class="o">==</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;pfm_check_task_exist: ret=%d ctx=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_context_load</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pfarg_load_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfarg_load_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pmcs_source</span><span class="p">,</span> <span class="o">*</span><span class="n">pmds_source</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">the_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">set_dbregs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">state</span>     <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * can only load from unloaded or terminated state</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot load to [%d], invalid ctx_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;load_pid [%d] using_dbreg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot use blocking mode on self</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_get_task</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;load_pid [%d] get_task=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * system wide is self monitoring only</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">&amp;&amp;</span> <span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;system wide is self monitoring only load_pid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * cannot load a context which is using range restrictions,</span>
<span class="cm">	 * into a task that is being debugged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;load_pid [%d] task is debugged, cannot load range restrictions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot load [%d] dbregs in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">++</span><span class="p">;</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;load [%d] increased sys_use_dbreg=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">));</span>
				<span class="n">set_dbregs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * SMP system-wide monitoring implies self-monitoring.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The programming model expects the task to</span>
<span class="cm">	 * be pinned on a CPU throughout the session.</span>
<span class="cm">	 * Here we take note of the current CPU at the</span>
<span class="cm">	 * time the context is loaded. No call from</span>
<span class="cm">	 * another CPU will be allowed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The pinning via shed_setaffinity()</span>
<span class="cm">	 * must be done by the calling task prior</span>
<span class="cm">	 * to this call.</span>
<span class="cm">	 *</span>
<span class="cm">	 * systemwide: keep track of CPU this session is supposed to run on</span>
<span class="cm">	 */</span>
	<span class="n">the_cpu</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * now reserve the session</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_reserve_session</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">is_system</span><span class="p">,</span> <span class="n">the_cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * task is necessarily stopped at this point.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the previous context was zombie, then it got removed in</span>
<span class="cm">	 * pfm_save_regs(). Therefore we should not see it here.</span>
<span class="cm">	 * If we see a context, then this is an active context</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX: needs to be atomic</span>
<span class="cm">	 */</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;before cmpxchg() old_ctx=%p new_ctx=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pfm_context</span><span class="p">,</span> <span class="n">ctx</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">ia64_cmpxchg</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pfm_context</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;load_pid [%d] already has a context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">load_pid</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_unres</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pfm_reset_msgq</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_LOADED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * link context to task</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we load as stopped</span>
<span class="cm">		 */</span>
		<span class="n">PFM_CPUINFO_SET</span><span class="p">(</span><span class="n">PFM_CPUINFO_SYST_WIDE</span><span class="p">);</span>
		<span class="n">PFM_CPUINFO_CLEAR</span><span class="p">(</span><span class="n">PFM_CPUINFO_DCR_PP</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_excl_idle</span><span class="p">)</span> <span class="n">PFM_CPUINFO_SET</span><span class="p">(</span><span class="n">PFM_CPUINFO_EXCL_IDLE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IA64_THREAD_PM_VALID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * propagate into thread-state</span>
<span class="cm">	 */</span>
	<span class="n">pfm_copy_pmds</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">pfm_copy_pmcs</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">pmcs_source</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">;</span>
	<span class="n">pmds_source</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * always the case for system-wide</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* allow user level control */</span>
			<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;clearing psr.sp for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

			<span class="n">SET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
			<span class="n">INC_ACTIVATION</span><span class="p">();</span>
			<span class="n">SET_ACTIVATION</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_SMP</span>
			<span class="cm">/*</span>
<span class="cm">			 * push the other task out, if any</span>
<span class="cm">			 */</span>
			<span class="n">owner_task</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">owner_task</span><span class="p">)</span> <span class="n">pfm_lazy_save_regs</span><span class="p">(</span><span class="n">owner_task</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * load all PMD from ctx to PMU (as opposed to thread state)</span>
<span class="cm">		 * restore all PMC from ctx to PMU</span>
<span class="cm">		 */</span>
		<span class="n">pfm_restore_pmds</span><span class="p">(</span><span class="n">pmds_source</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">pfm_restore_pmcs</span><span class="p">(</span><span class="n">pmcs_source</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * guaranteed safe by earlier check against DBG_VALID</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pfm_restore_ibrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ibrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
			<span class="n">pfm_restore_dbrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_dbrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * set new ownership</span>
<span class="cm">		 */</span>
		<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context loaded on PMU for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * when not current, task MUST be stopped, so this is safe</span>
<span class="cm">		 */</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="cm">/* force a full reload */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_last_activation</span> <span class="o">=</span> <span class="n">PFM_INVALID_ACTIVATION</span><span class="p">;</span>
		<span class="n">SET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* initial saved psr (stopped) */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_unres:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">,</span> <span class="n">the_cpu</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="cm">/*</span>
<span class="cm">	 * we must undo the dbregs setting (for system-wide)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">set_dbregs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="o">--</span><span class="p">;</span>
		<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * release task, there is now a link with the context</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_put_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_check_task_exist</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">;</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * in this function, we do not need to increase the use count</span>
<span class="cm"> * for the task via get_task_struct(), because we hold the</span>
<span class="cm"> * context lock. If the task were to disappear while having</span>
<span class="cm"> * a context attached, it would go through pfm_exit_thread()</span>
<span class="cm"> * which also grabs the context lock  and would therefore be blocked</span>
<span class="cm"> * until we are here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pfm_flush_pmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_context_unload</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">PFM_CTX_TASK</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">tregs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prev_state</span><span class="p">,</span> <span class="n">is_system</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d task [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">,</span> <span class="n">task</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>

	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">is_system</span>  <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * unload only when necessary</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx_state=%d, nothing to do</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">prev_state</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear psr and dcr bits</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_stop</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_UNLOADED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * in system mode, we need to update the PMU directly</span>
<span class="cm">	 * and the user level state of the caller, which may not</span>
<span class="cm">	 * necessarily be the creator of the context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_system</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update cpuinfo</span>
<span class="cm">		 *</span>
<span class="cm">		 * local PMU is taken care of in pfm_stop()</span>
<span class="cm">		 */</span>
		<span class="n">PFM_CPUINFO_CLEAR</span><span class="p">(</span><span class="n">PFM_CPUINFO_SYST_WIDE</span><span class="p">);</span>
		<span class="n">PFM_CPUINFO_CLEAR</span><span class="p">(</span><span class="n">PFM_CPUINFO_EXCL_IDLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * save PMDs in context</span>
<span class="cm">		 * release ownership</span>
<span class="cm">		 */</span>
		<span class="n">pfm_flush_pmds</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * at this point we are done with the PMU</span>
<span class="cm">		 * so we can unreserve the resource.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">!=</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> 
			<span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * disconnect context from task</span>
<span class="cm">		 */</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * disconnect task from context</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * There is nothing more to cleanup here.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * per-task mode</span>
<span class="cm">	 */</span>
	<span class="n">tregs</span> <span class="o">=</span> <span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">?</span> <span class="n">regs</span> <span class="o">:</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * cancel user level control</span>
<span class="cm">		 */</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;setting psr.sp for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * save PMDs to context</span>
<span class="cm">	 * release ownership</span>
<span class="cm">	 */</span>
	<span class="n">pfm_flush_pmds</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * at this point we are done with the PMU</span>
<span class="cm">	 * so we can unreserve the resource.</span>
<span class="cm">	 *</span>
<span class="cm">	 * when state was ZOMBIE, we have already unreserved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev_state</span> <span class="o">!=</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> 
		<span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * reset activation counter and psr</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_last_activation</span> <span class="o">=</span> <span class="n">PFM_INVALID_ACTIVATION</span><span class="p">;</span>
	<span class="n">SET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PMU state will not be restored</span>
<span class="cm">	 */</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IA64_THREAD_PM_VALID</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * break links between context and task</span>
<span class="cm">	 */</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span>             <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span>  <span class="o">=</span> <span class="n">PFM_TRAP_REASON_NONE</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_can_restart</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_going_zombie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;disconnected [%d] from context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * called only from exit_thread(): task == current</span>
<span class="cm"> * we come here only if current has a context attached (loaded or masked)</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_exit_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;state=%d task [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PFM_CTX_UNLOADED</span>:
			<span class="cm">/*</span>
<span class="cm">	 		 * only comes to this function if pfm_context is not NULL, i.e., cannot</span>
<span class="cm">			 * be in unloaded state</span>
<span class="cm">	 		 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_exit_thread [%d] ctx unloaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PFM_CTX_LOADED</span>:
		<span class="k">case</span> <span class="n">PFM_CTX_MASKED</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_exit_thread [%d] state=%d unload failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">state</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx unloaded for current state was %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>

			<span class="n">pfm_end_notify_user</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PFM_CTX_ZOMBIE</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_exit_thread [%d] state=%d unload failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">state</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">free_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_exit_thread [%d] unexpected state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">state</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">{</span> <span class="n">u64</span> <span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>
	  <span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IA64_PSR_UP</span><span class="o">|</span><span class="n">IA64_PSR_PP</span><span class="p">));</span>
	  <span class="n">BUG_ON</span><span class="p">(</span><span class="n">GET_PMU_OWNER</span><span class="p">());</span>
	  <span class="n">BUG_ON</span><span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">);</span>
	  <span class="n">BUG_ON</span><span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All memory free operations (especially for vmalloc&#39;ed memory)</span>
<span class="cm">	 * MUST be done with interrupts ENABLED.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_ok</span><span class="p">)</span> <span class="n">pfm_context_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * functions MUST be listed in the increasing order of their index (see permfon.h)</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_CMD(name, flags, arg_count, arg_type, getsz) { name, #name, flags, arg_count, sizeof(arg_type), getsz }</span>
<span class="cp">#define PFM_CMD_S(name, flags) { name, #name, flags, 0, 0, NULL }</span>
<span class="cp">#define PFM_CMD_PCLRWS	(PFM_CMD_FD|PFM_CMD_ARG_RW|PFM_CMD_STOP)</span>
<span class="cp">#define PFM_CMD_PCLRW	(PFM_CMD_FD|PFM_CMD_ARG_RW)</span>
<span class="cp">#define PFM_CMD_NONE	{ NULL, &quot;no-cmd&quot;, 0, 0, 0, NULL}</span>

<span class="k">static</span> <span class="n">pfm_cmd_desc_t</span> <span class="n">pfm_cmd_tab</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
<span class="cm">/* 0  */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 1  */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_write_pmcs</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_reg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 2  */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_write_pmds</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_reg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 3  */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_read_pmds</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_reg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 4  */</span><span class="n">PFM_CMD_S</span><span class="p">(</span><span class="n">pfm_stop</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">),</span>
<span class="cm">/* 5  */</span><span class="n">PFM_CMD_S</span><span class="p">(</span><span class="n">pfm_start</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">),</span>
<span class="cm">/* 6  */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 7  */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 8  */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_context_create</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_RW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pfarg_context_t</span><span class="p">,</span> <span class="n">pfm_ctx_getsize</span><span class="p">),</span>
<span class="cm">/* 9  */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 10 */</span><span class="n">PFM_CMD_S</span><span class="p">(</span><span class="n">pfm_restart</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRW</span><span class="p">),</span>
<span class="cm">/* 11 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 12 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_get_features</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_RW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pfarg_features_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 13 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_debug</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 14 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 15 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_get_pmc_reset</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_RW</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_reg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 16 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_context_load</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pfarg_load_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 17 */</span><span class="n">PFM_CMD_S</span><span class="p">(</span><span class="n">pfm_context_unload</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">),</span>
<span class="cm">/* 18 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 19 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 20 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 21 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 22 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 23 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 24 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 25 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 26 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 27 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 28 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 29 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 30 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 31 */</span><span class="n">PFM_CMD_NONE</span><span class="p">,</span>
<span class="cm">/* 32 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_write_ibrs</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_dbreg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
<span class="cm">/* 33 */</span><span class="n">PFM_CMD</span><span class="p">(</span><span class="n">pfm_write_dbrs</span><span class="p">,</span> <span class="n">PFM_CMD_PCLRWS</span><span class="p">,</span> <span class="n">PFM_CMD_ARG_MANY</span><span class="p">,</span> <span class="n">pfarg_dbreg_t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#define PFM_CMD_COUNT	(sizeof(pfm_cmd_tab)/sizeof(pfm_cmd_desc_t))</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_check_task_state</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">old_state</span><span class="p">;</span>

<span class="nl">recheck:</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="n">task</span>  <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context %d no task, state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context %d state=%d [%d] task_state=%ld must_stop=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">,</span>
		<span class="n">state</span><span class="p">,</span>
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">PFM_CMD_STOPPED</span><span class="p">(</span><span class="n">cmd</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * self-monitoring always ok.</span>
<span class="cm">	 *</span>
<span class="cm">	 * for system-wide the caller can either be the creator of the</span>
<span class="cm">	 * context (to one to which the context is attached to) OR</span>
<span class="cm">	 * a task running on the same CPU as the session.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we are monitoring another thread</span>
<span class="cm">	 */</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PFM_CTX_UNLOADED</span>:
			<span class="cm">/*</span>
<span class="cm">			 * if context is UNLOADED we are safe to go</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PFM_CTX_ZOMBIE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * no command can operate on a zombie context</span>
<span class="cm">			 */</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cmd %d state zombie cannot operate on context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">PFM_CTX_MASKED</span>:
			<span class="cm">/*</span>
<span class="cm">			 * PMU state has been saved to software even though</span>
<span class="cm">			 * the thread may still be running.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">PFM_UNLOAD_CONTEXT</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * context is LOADED or MASKED. Some commands may need to have </span>
<span class="cm">	 * the task stopped.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We could lift this restriction for UP but it would mean that</span>
<span class="cm">	 * the user has no guarantee the task would not run between</span>
<span class="cm">	 * two successive calls to perfmonctl(). That&#39;s probably OK.</span>
<span class="cm">	 * If this user wants to ensure the task does not run, then</span>
<span class="cm">	 * the task must be stopped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PFM_CMD_STOPPED</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_is_stopped_or_traced</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] task not in stopped state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * task is now stopped, wait for ctxsw out</span>
<span class="cm">		 *</span>
<span class="cm">		 * This is an interesting point in the code.</span>
<span class="cm">		 * We need to unprotect the context because</span>
<span class="cm">		 * the pfm_save_regs() routines needs to grab</span>
<span class="cm">		 * the same lock. There are danger in doing</span>
<span class="cm">		 * this because it leaves a window open for</span>
<span class="cm">		 * another task to get access to the context</span>
<span class="cm">		 * and possibly change its state. The one thing</span>
<span class="cm">		 * that is not possible is for the context to disappear</span>
<span class="cm">		 * because we are protected by the VFS layer, i.e.,</span>
<span class="cm">		 * get_fd()/put_fd().</span>
<span class="cm">		 */</span>
		<span class="n">old_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

		<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">wait_task_inactive</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we must recheck to verify if state has changed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">!=</span> <span class="n">old_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;old_state=%d new_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old_state</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * system-call entry point (must return long)</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">long</span>
<span class="nf">sys_perfmonctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">args_k</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span> <span class="cm">/* will expand int return types */</span>
	<span class="kt">size_t</span> <span class="n">base_sz</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">xtra_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">narg</span><span class="p">,</span> <span class="n">completed_args</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">call_made</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getsize</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">sz</span><span class="p">);</span>
<span class="cp">#define PFM_MAX_ARGSIZE	4096</span>

	<span class="cm">/*</span>
<span class="cm">	 * reject any call if perfmon was disabled at initialization</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmu_conf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">PFM_CMD_COUNT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid cmd=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">func</span>      <span class="o">=</span> <span class="n">pfm_cmd_tab</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">cmd_func</span><span class="p">;</span>
	<span class="n">narg</span>      <span class="o">=</span> <span class="n">pfm_cmd_tab</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">cmd_narg</span><span class="p">;</span>
	<span class="n">base_sz</span>   <span class="o">=</span> <span class="n">pfm_cmd_tab</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">cmd_argsize</span><span class="p">;</span>
	<span class="n">getsize</span>   <span class="o">=</span> <span class="n">pfm_cmd_tab</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">cmd_getsize</span><span class="p">;</span>
	<span class="n">cmd_flags</span> <span class="o">=</span> <span class="n">pfm_cmd_tab</span><span class="p">[</span><span class="n">cmd</span><span class="p">].</span><span class="n">cmd_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid cmd=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cmd=%s idx=%d narg=0x%x argsz=%lu count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PFM_CMD_NAME</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
		<span class="n">cmd</span><span class="p">,</span>
		<span class="n">narg</span><span class="p">,</span>
		<span class="n">base_sz</span><span class="p">,</span>
		<span class="n">count</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if number of arguments matches what the command expects</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">narg</span> <span class="o">==</span> <span class="n">PFM_CMD_ARG_MANY</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">narg</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">narg</span> <span class="o">!=</span> <span class="n">count</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">restart_args:</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">xtra_sz</span> <span class="o">+</span> <span class="n">base_sz</span><span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * limit abuse to min page size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">PFM_MAX_ARGSIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: [%d] argument too big %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">sz</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate default-sized argument buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">args_k</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">args_k</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PFM_MAX_ARGSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args_k</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy arguments</span>
<span class="cm">	 *</span>
<span class="cm">	 * assume sz = 0 for command without parameters</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&amp;&amp;</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">args_k</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">sz</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cannot copy_from_user %lu bytes @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">arg</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_args</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if command supports extra parameters</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">completed_args</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">getsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * get extra parameters size (based on main argument)</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">getsize</span><span class="p">)(</span><span class="n">args_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xtra_sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">error_args</span><span class="p">;</span>

		<span class="n">completed_args</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;restart_args sz=%lu xtra_sz=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">xtra_sz</span><span class="p">));</span>

		<span class="cm">/* retry if necessary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">xtra_sz</span><span class="p">))</span> <span class="k">goto</span> <span class="n">restart_args</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">PFM_CMD_FD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">goto</span> <span class="n">skip_fd</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;invalid fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_args</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PFM_IS_FILE</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;fd %d not related to perfmon</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_args</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;no context for fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_args</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">);</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check task is stopped</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_check_task_state</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="k">goto</span> <span class="n">abort_locked</span><span class="p">;</span>

<span class="nl">skip_fd:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">args_k</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

	<span class="n">call_made</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">abort_locked:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context unlocked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copy argument back to user, if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">call_made</span> <span class="o">&amp;&amp;</span> <span class="n">PFM_CMD_RW_ARG</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">args_k</span><span class="p">,</span> <span class="n">base_sz</span><span class="o">*</span><span class="n">count</span><span class="p">))</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">error_args:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">args_k</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cmd=%s ret=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PFM_CMD_NAME</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">ret</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_resume_after_ovfl</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="p">;</span>
	<span class="n">pfm_ovfl_ctrl_t</span> <span class="n">rst_ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unlock sampling buffer and reset index atomically</span>
<span class="cm">	 * XXX: not really needed when blocking</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CTX_HAS_SMPL</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PFM_CTX_LOADED</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_restart_active</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rst_ctrl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_buf_fmt_restart</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rst_ctrl</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pfm_reset_regs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ovfl_regs</span><span class="p">,</span> <span class="n">PFM_PMD_LONG_RESET</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rst_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;resuming monitoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_MASKED</span><span class="p">)</span> <span class="n">pfm_restore_monitoring</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;stopping monitoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>pfm<em>stop</em>monitoring(current, regs);</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_LOADED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * context MUST BE LOCKED when calling</span>
<span class="cm"> * can only be called for current</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_context_force_terminate</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;entering for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">)));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_context_unload</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pfm_context_force_terminate: [%d] unloaded failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * and wakeup controlling task, indicating we are now disconnected</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_zombieq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * given that context is still locked, the controlling</span>
<span class="cm">	 * task will only get access when we return from</span>
<span class="cm">	 * pfm_handle_work().</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pfm_ovfl_notify_user</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_pmds</span><span class="p">);</span>

 <span class="cm">/*</span>
<span class="cm">  * pfm_handle_work() can be called with interrupts enabled</span>
<span class="cm">  * (TIF_NEED_RESCHED) or disabled. The down_interruptible</span>
<span class="cm">  * call may sleep, therefore we must re-enable interrupts</span>
<span class="cm">  * to avoid deadlocks. It is safe to do so because this function</span>
<span class="cm">  * is called ONLY when returning to user level (pUStk=1), in which case</span>
<span class="cm">  * there is no risk of kernel stack overflow due to deep</span>
<span class="cm">  * interrupt nesting.</span>
<span class="cm">  */</span>
<span class="kt">void</span>
<span class="nf">pfm_handle_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dummy_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: [%d] has no PFM context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * extract reason for being here and clear</span>
<span class="cm">	 */</span>
	<span class="n">reason</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span> <span class="o">=</span> <span class="n">PFM_TRAP_REASON_NONE</span><span class="p">;</span>
	<span class="n">ovfl_regs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;reason=%d state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * must be done before we check for simple-reset mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_going_zombie</span> <span class="o">||</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">do_zombie</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>if (CTX<em>OVFL</em>NOBLOCK(ctx)) goto skip_blocking;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="n">PFM_TRAP_REASON_RESET</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_blocking</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * restore interrupt mask to what it was on entry.</span>
<span class="cm">	 * Could be enabled/diasbled.</span>
<span class="cm">	 */</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * force interrupt enable because of down_interruptible()</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;before block sleeping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * may go through without blocking on SMP systems</span>
<span class="cm">	 * if restart has been received already by the time we call down()</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_completion_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_restart_done</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;after block sleeping ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * lock context and mask interrupts again</span>
<span class="cm">	 * We save flags into a dummy because we may have</span>
<span class="cm">	 * altered interrupts mask compared to entry in this</span>
<span class="cm">	 * function.</span>
<span class="cm">	 */</span>
	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dummy_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need to read the ovfl_regs only after wake-up</span>
<span class="cm">	 * because we may have had pfm_write_pmds() in between</span>
<span class="cm">	 * and that can changed PMD values and therefore </span>
<span class="cm">	 * ovfl_regs is reset for these new PMD values.</span>
<span class="cm">	 */</span>
	<span class="n">ovfl_regs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_going_zombie</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">do_zombie:</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;context is zombie, bailing out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">pfm_context_force_terminate</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">nothing_to_do</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * in case of interruption of down() we don&#39;t restart anything</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nothing_to_do</span><span class="p">;</span>

<span class="nl">skip_blocking:</span>
	<span class="n">pfm_resume_after_ovfl</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ovfl_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

<span class="nl">nothing_to_do:</span>
	<span class="cm">/*</span>
<span class="cm">	 * restore flags as they were upon entry</span>
<span class="cm">	 */</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_notify_user</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pfm_msg_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ignoring overflow notification, owner is zombie</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;waking up somebody</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * safe, we are not in intr handler, nor in ctxsw when</span>
<span class="cm">	 * we come here</span>
<span class="cm">	 */</span>
	<span class="n">kill_fasync</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_async_queue</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_ovfl_notify_user</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_pmds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_msg_t</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_no_msg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">pfm_get_new_msg</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_ovfl_notify_user no more notification msgs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_type</span>         <span class="o">=</span> <span class="n">PFM_MSG_OVFL</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_ctx_fd</span>       <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_active_set</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_ovfl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ovfl_pmds</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_ovfl_pmds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_ovfl_pmds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_ovfl_pmds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_tstamp</span>       <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ovfl msg: msg=%p no_msg=%d fd=%d ovfl_pmds=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_no_msg</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">,</span>
		<span class="n">ovfl_pmds</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">pfm_notify_user</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_end_notify_user</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_msg_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">pfm_get_new_msg</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: pfm_end_notify_user no more notification msgs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* no leak */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">));</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_end_msg</span><span class="p">.</span><span class="n">msg_type</span>    <span class="o">=</span> <span class="n">PFM_MSG_END</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_end_msg</span><span class="p">.</span><span class="n">msg_ctx_fd</span>  <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">pfm_ovfl_msg</span><span class="p">.</span><span class="n">msg_tstamp</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;end msg: msg=%p no_msg=%d ctx_fd=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_no_msg</span><span class="p">,</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fd</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">pfm_notify_user</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * main overflow processing routine.</span>
<span class="cm"> * it can be called from the interrupt path or explicitly during the context switch code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pfm_overflow_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc0</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_ovfl_arg_t</span> <span class="o">*</span><span class="n">ovfl_arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_val</span><span class="p">,</span> <span class="n">ovfl_val</span><span class="p">,</span> <span class="n">new_val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ovfl_notify</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span> <span class="n">ovfl_pmds</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span> <span class="n">smpl_pmds</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span> <span class="n">reset_pmds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="n">pfm_ovfl_ctrl_t</span>	<span class="n">ovfl_ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">has_smpl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">must_notify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">))</span> <span class="k">goto</span> <span class="n">stop_monitoring</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * sanity test. Should never happen</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">pmc0</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">goto</span> <span class="n">sanity_check</span><span class="p">;</span>

	<span class="n">tstamp</span>   <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
	<span class="n">mask</span>     <span class="o">=</span> <span class="n">pmc0</span> <span class="o">&gt;&gt;</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
	<span class="n">ovfl_val</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="n">has_smpl</span> <span class="o">=</span> <span class="n">CTX_HAS_SMPL</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;pmc0=0x%lx pid=%d iip=0x%lx, %s &quot;</span>
		     <span class="s">&quot;used_pmds=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pmc0</span><span class="p">,</span>
			<span class="n">task</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			<span class="p">(</span><span class="n">regs</span> <span class="o">?</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;nonblocking&quot;</span> <span class="o">:</span> <span class="s">&quot;blocking&quot;</span><span class="p">,</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>


	<span class="cm">/*</span>
<span class="cm">	 * first we update the virtual counters</span>
<span class="cm">	 * assume there was a prior ia64_srlz_d() issued</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* skip pmd which did not overflow */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note that the pmd is not necessarily 0 at this point as qualified events</span>
<span class="cm">		 * may have happened before the PMU was frozen. The residual count is not</span>
<span class="cm">		 * taken into consideration here but will be with any read of the pmd via</span>
<span class="cm">		 * pfm_read_pmds().</span>
<span class="cm">		 */</span>
		<span class="n">old_val</span>              <span class="o">=</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
		<span class="n">new_val</span>             <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ovfl_val</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * check for overflow condition</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">old_val</span> <span class="o">&gt;</span> <span class="n">new_val</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ovfl_pmds</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PMC_OVFL_NOTIFY</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="n">ovfl_notify</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;ctx_pmd[%d].val=0x%lx old_val=0x%lx pmd=0x%lx ovfl_pmds=0x%lx ovfl_notify=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">new_val</span><span class="p">,</span>
			<span class="n">old_val</span><span class="p">,</span>
			<span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ovfl_val</span><span class="p">,</span>
			<span class="n">ovfl_pmds</span><span class="p">,</span>
			<span class="n">ovfl_notify</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * there was no 64-bit overflow, nothing else to do</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ovfl_pmds</span> <span class="o">==</span> <span class="mi">0UL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * reset all control bits</span>
<span class="cm">	 */</span>
	<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reset_pmds</span>    <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if a sampling format module exists, then we &quot;cache&quot; the overflow by </span>
<span class="cm">	 * calling the module&#39;s handler() routine.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_smpl</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_cycles</span><span class="p">,</span> <span class="n">end_cycles</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd_mask</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

		<span class="n">pmd_mask</span> <span class="o">=</span> <span class="n">ovfl_pmds</span> <span class="o">&gt;&gt;</span> <span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span>
		<span class="n">ovfl_arg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_arg</span><span class="p">;</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">);</span>

		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">PMU_FIRST_COUNTER</span><span class="p">;</span> <span class="n">pmd_mask</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pmd_mask</span> <span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">pmd_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_pmd</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">)</span><span class="n">i</span><span class="p">;</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_notify</span>   <span class="o">=</span> <span class="n">ovfl_notify</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">active_set</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* module must fill in all fields */</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">smpl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">smpl_pmds</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">smpl_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">pmd_value</span>      <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">pmd_last_reset</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lval</span><span class="p">;</span>
			<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">pmd_eventid</span>    <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eventid</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">		 	 * copy values of pmds of interest. Sampling format may copy them</span>
<span class="cm">		 	 * into sampling buffer.</span>
<span class="cm">		 	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smpl_pmds</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">smpl_pmds</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">smpl_pmds</span> <span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">smpl_pmds</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
					<span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">smpl_pmds_values</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">?</span>  <span class="n">pfm_read_soft_counter</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">:</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
					<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;smpl_pmd[%d]=pmd%u=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">smpl_pmds_values</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_smpl_handler_calls</span><span class="o">++</span><span class="p">;</span>

			<span class="n">start_cycles</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">		 	 * call custom buffer format record (handler) routine</span>
<span class="cm">		 	 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_buf_fmt</span><span class="o">-&gt;</span><span class="n">fmt_handler</span><span class="p">)(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span> <span class="n">ovfl_arg</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">tstamp</span><span class="p">);</span>

			<span class="n">end_cycles</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">			 * For those controls, we take the union because they have</span>
<span class="cm">			 * an all or nothing behavior.</span>
<span class="cm">			 */</span>
			<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">notify_user</span>     <span class="o">|=</span> <span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">notify_user</span><span class="p">;</span>
			<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">block_task</span>      <span class="o">|=</span> <span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">block_task</span><span class="p">;</span>
			<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">|=</span> <span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * build the bitmask of pmds to reset now</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ovfl_arg</span><span class="o">-&gt;</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span><span class="p">)</span> <span class="n">reset_pmds</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>

			<span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_smpl_handler_cycles</span> <span class="o">+=</span> <span class="n">end_cycles</span> <span class="o">-</span> <span class="n">start_cycles</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * when the module cannot handle the rest of the overflows, we abort right here</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">pmd_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;handler aborts leftover ovfl_pmds=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmd_mask</span><span class="o">&lt;&lt;</span><span class="n">PMU_FIRST_COUNTER</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * remove the pmds we reset now from the set of pmds to reset in pfm_restart()</span>
<span class="cm">		 */</span>
		<span class="n">ovfl_pmds</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">reset_pmds</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * when no sampling module is used, then the default</span>
<span class="cm">		 * is to notify on overflow if requested by user</span>
<span class="cm">		 */</span>
		<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">notify_user</span>     <span class="o">=</span> <span class="n">ovfl_notify</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">block_task</span>      <span class="o">=</span> <span class="n">ovfl_notify</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">=</span> <span class="n">ovfl_notify</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* XXX: change for saturation */</span>
		<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">reset_ovfl_pmds</span> <span class="o">=</span> <span class="n">ovfl_notify</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * if needed, we reset all overflowed pmds</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ovfl_notify</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">reset_pmds</span> <span class="o">=</span> <span class="n">ovfl_pmds</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;ovfl_pmds=0x%lx reset_pmds=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ovfl_pmds</span><span class="p">,</span> <span class="n">reset_pmds</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * reset the requested PMD registers using the short reset values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_pmds</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm</span> <span class="o">=</span> <span class="n">reset_pmds</span><span class="p">;</span>
		<span class="n">pfm_reset_regs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm</span><span class="p">,</span> <span class="n">PFM_PMD_SHORT_RESET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ovfl_notify</span> <span class="o">&amp;&amp;</span> <span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">notify_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * keep track of what to reset when unblocking</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ovfl_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ovfl_pmds</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * check for blocking context </span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CTX_OVFL_NOBLOCK</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">block_task</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span> <span class="o">=</span> <span class="n">PFM_TRAP_REASON_BLOCK</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * set the perfmon specific checking pending work for the task</span>
<span class="cm">			 */</span>
			<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * when coming from ctxsw, current still points to the</span>
<span class="cm">			 * previous task, therefore we must work with task and not current.</span>
<span class="cm">			 */</span>
			<span class="n">set_notify_resume</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * defer until state is changed (shorten spin window). the context is locked</span>
<span class="cm">		 * anyway, so the signal receiver would come spin for nothing.</span>
<span class="cm">		 */</span>
		<span class="n">must_notify</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT_ovfl</span><span class="p">((</span><span class="s">&quot;owner [%d] pending=%ld reason=%u ovfl_pmds=0x%lx ovfl_notify=0x%lx masked=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">GET_PMU_OWNER</span><span class="p">())</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			<span class="n">PFM_GET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_trap_reason</span><span class="p">,</span>
			<span class="n">ovfl_pmds</span><span class="p">,</span>
			<span class="n">ovfl_notify</span><span class="p">,</span>
			<span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * in case monitoring must be stopped, we toggle the psr bits</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ovfl_ctrl</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">mask_monitoring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_mask_monitoring</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">=</span> <span class="n">PFM_CTX_MASKED</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_can_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * send notification now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">must_notify</span><span class="p">)</span> <span class="n">pfm_ovfl_notify_user</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ovfl_notify</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">sanity_check:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: CPU%d overflow handler [%d] pmc0=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span>
			<span class="n">task</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			<span class="n">pmc0</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">stop_monitoring:</span>
	<span class="cm">/*</span>
<span class="cm">	 * in SMP, zombie context is never restored but reclaimed in pfm_load_regs().</span>
<span class="cm">	 * Moreover, zombies are also reclaimed in pfm_save_regs(). Therefore we can</span>
<span class="cm">	 * come here as zombie only if the task is the current task. In which case, we</span>
<span class="cm">	 * can access the PMU  hardware directly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that zombies do have PM_VALID set. So here we do the minimal.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In case the context was zombified it could not be reclaimed at the time</span>
<span class="cm">	 * the monitoring program exited. At this point, the PMU reservation has been</span>
<span class="cm">	 * returned, the sampiing buffer has been freed. We must convert this call</span>
<span class="cm">	 * into a spurious interrupt. However, we must also avoid infinite overflows</span>
<span class="cm">	 * by stopping monitoring for this task. We can only come here for a per-task</span>
<span class="cm">	 * context. All we need to do is to stop monitoring using the psr bits which</span>
<span class="cm">	 * are always task private. By re-enabling secure montioring, we ensure that</span>
<span class="cm">	 * the monitored task will not be able to re-activate monitoring.</span>
<span class="cm">	 * The task will eventually be context switched out, at which point the context</span>
<span class="cm">	 * will be reclaimed (that includes releasing ownership of the PMU).</span>
<span class="cm">	 *</span>
<span class="cm">	 * So there might be a window of time where the number of per-task session is zero</span>
<span class="cm">	 * yet one PMU might have a owner and get at most one overflow interrupt for a zombie</span>
<span class="cm">	 * context. This is safe because if a per-task session comes in, it will push this one</span>
<span class="cm">	 * out and by the virtue on pfm_save_regs(), this one will disappear. If a system wide</span>
<span class="cm">	 * session is force on that CPU, given that we use task pinning, pfm_save_regs() will</span>
<span class="cm">	 * also push our zombie context out.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Overall pretty hairy stuff....</span>
<span class="cm">	 */</span>
	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;ctx is zombie for [%d], converted to spurious</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_do_interrupt_handler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pmc0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * srlz.d done before arriving here</span>
<span class="cm">	 */</span>
	<span class="n">pmc0</span> <span class="o">=</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">();</span>
	<span class="n">ctx</span>  <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we have some pending bits set</span>
<span class="cm">	 * assumes : if any PMC0.bit[63-1] is set, then PMC0.fr = 1</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PMC0_HAS_OVFL</span><span class="p">(</span><span class="n">pmc0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we assume that pmc0.fr is always set here</span>
<span class="cm">		 */</span>

		<span class="cm">/* sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="k">goto</span> <span class="n">report_spurious1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_PM_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
			<span class="k">goto</span> <span class="n">report_spurious2</span><span class="p">;</span>

		<span class="n">PROTECT_CTX_NOPRINT</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">pfm_overflow_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">pmc0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">UNPROTECT_CTX_NOPRINT</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_spurious_ovfl_intr_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * keep it unfrozen at all times</span>
<span class="cm">	 */</span>
	<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">report_spurious1:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: spurious overflow interrupt on CPU%d: process %d has no PFM context</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">this_cpu</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">report_spurious2:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: spurious overflow interrupt on CPU%d: process %d, invalid flag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">this_cpu</span><span class="p">,</span> 
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">pfm_interrupt_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_cycles</span><span class="p">,</span> <span class="n">total_cycles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">pfm_alt_intr_handler</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_min</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_max</span><span class="p">;</span>

		<span class="n">start_cycles</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_do_interrupt_handler</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">total_cycles</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * don&#39;t measure spurious interrupts</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">total_cycles</span> <span class="o">-=</span> <span class="n">start_cycles</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">total_cycles</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_min</span> <span class="o">=</span> <span class="n">total_cycles</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_cycles</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_max</span> <span class="o">=</span> <span class="n">total_cycles</span><span class="p">;</span>

			<span class="n">pfm_stats</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles</span> <span class="o">+=</span> <span class="n">total_cycles</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pfm_alt_intr_handler</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)(</span><span class="n">irq</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * /proc/perfmon interface, for debug only</span>
<span class="cm"> */</span>

<span class="cp">#define PFM_PROC_SHOW_HEADER	((void *)(long)nr_cpu_ids+1)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">pfm_proc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">PFM_PROC_SHOW_HEADER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">pfm_proc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pfm_proc_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_proc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_proc_show_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

 	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		<span class="s">&quot;perfmon version           : %u.%u</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;model                     : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;fastctxsw                 : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;expert mode               : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;ovfl_mask                 : 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;PMU flags                 : 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PFM_VERSION_MAJ</span><span class="p">,</span> <span class="n">PFM_VERSION_MIN</span><span class="p">,</span>
		<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmu_name</span><span class="p">,</span>
		<span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">fastctxsw</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Yes&quot;</span><span class="o">:</span> <span class="s">&quot;No&quot;</span><span class="p">,</span>
		<span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">expert_mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Yes&quot;</span><span class="o">:</span> <span class="s">&quot;No&quot;</span><span class="p">,</span>
		<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">,</span>
		<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

  	<span class="n">LOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

 	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
 		<span class="s">&quot;proc_sessions             : %u</span><span class="se">\n</span><span class="s">&quot;</span>
 		<span class="s">&quot;sys_sessions              : %u</span><span class="se">\n</span><span class="s">&quot;</span>
 		<span class="s">&quot;sys_use_dbregs            : %u</span><span class="se">\n</span><span class="s">&quot;</span>
 		<span class="s">&quot;ptrace_use_dbregs         : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
 		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_task_sessions</span><span class="p">,</span>
 		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_sessions</span><span class="p">,</span>
 		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_sys_use_dbregs</span><span class="p">,</span>
 		<span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_ptrace_use_dbregs</span><span class="p">);</span>

  	<span class="n">UNLOCK_PFS</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_buffer_fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pfm_buffer_fmt_t</span><span class="p">,</span> <span class="n">fmt_list</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;format                    : %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_uuid</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fmt_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">PFM_PROC_SHOW_HEADER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_proc_show_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* show info for CPU (v - 1) */</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		<span class="s">&quot;CPU%-2d overflow intrs      : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d overflow cycles     : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d overflow min        : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d overflow max        : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d smpl handler calls  : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d smpl handler cycles : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d spurious intrs      : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d replay   intrs      : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d syst_wide           : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d dcr_pp              : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d exclude idle        : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d owner               : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d context             : %p</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;CPU%-2d activations         : %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_count</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_min</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_max</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_smpl_handler_calls</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_smpl_handler_cycles</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_spurious_ovfl_intr_count</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">pfm_replay_ovfl_intr_count</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_SYST_WIDE</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_DCR_PP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_EXCL_IDLE</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pmu_owner</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">?</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pmu_owner</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pmu_ctx</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
		<span class="n">cpu</span><span class="p">,</span> <span class="n">pfm_get_cpu_data</span><span class="p">(</span><span class="n">pmu_activation_number</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

		<span class="n">ia64_srlz_d</span><span class="p">();</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> 
			<span class="s">&quot;CPU%-2d psr                 : 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;CPU%-2d pmc0                : 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">cpu</span><span class="p">,</span> <span class="n">psr</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">PMC_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PMC_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
   			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> 
				<span class="s">&quot;CPU%-2d pmc%u                : 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span>
   				<span class="s">&quot;CPU%-2d pmd%u                : 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
				<span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
				<span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
  		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">pfm_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span>	<span class="n">pfm_proc_start</span><span class="p">,</span>
 	<span class="p">.</span><span class="n">next</span> <span class="o">=</span>		<span class="n">pfm_proc_next</span><span class="p">,</span>
 	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span>		<span class="n">pfm_proc_stop</span><span class="p">,</span>
 	<span class="p">.</span><span class="n">show</span> <span class="o">=</span>		<span class="n">pfm_proc_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pfm_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_seq_ops</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * we come here as soon as local_cpu_data-&gt;pfm_syst_wide is set. this happens</span>
<span class="cm"> * during pfm_enable() hence before pfm_start(). We cannot assume monitoring</span>
<span class="cm"> * is active or inactive based on mode. We must rely on the value in</span>
<span class="cm"> * local_cpu_data-&gt;pfm_syst_info</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_syst_wide_update_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_ctxswin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dcr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dcr_pp</span><span class="p">;</span>

	<span class="n">dcr_pp</span> <span class="o">=</span> <span class="n">info</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_DCR_PP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pid 0 is guaranteed to be the idle task. There is one such task with pid 0</span>
<span class="cm">	 * on every CPU, so we can rely on the pid to identify the idle task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">info</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_EXCL_IDLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="n">is_ctxswin</span> <span class="o">?</span> <span class="n">dcr_pp</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if monitoring has started</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcr_pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dcr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * context switching in?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_ctxswin</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* mask monitoring for the idle task */</span>
			<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">dcr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IA64_DCR_PP</span><span class="p">);</span>
			<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>
			<span class="n">ia64_srlz_i</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * context switching out</span>
<span class="cm">		 * restore monitoring for next task</span>
<span class="cm">		 *</span>
<span class="cm">		 * Due to inlining this odd if-then-else construction generates</span>
<span class="cm">		 * better code.</span>
<span class="cm">		 */</span>
		<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span> <span class="n">dcr</span> <span class="o">|</span><span class="n">IA64_DCR_PP</span><span class="p">);</span>
		<span class="n">pfm_set_psr_pp</span><span class="p">();</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_force_cleanup</span><span class="p">(</span><span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">;</span>

	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;cleared ownership for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span><span class="p">)));</span>
		<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * disconnect the task from the context and vice-versa</span>
<span class="cm">	 */</span>
	<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span>       <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IA64_THREAD_PM_VALID</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;force cleanup for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * in 2.6, interrupts are masked when we come here and the runqueue lock is held</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_save_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">psr</span><span class="p">;</span>


	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * we always come here with interrupts ALREADY disabled by</span>
<span class="cm"> 	 * the scheduler. So we simply need to protect against concurrent</span>
<span class="cm">	 * access, not CPU concurrency.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">pfm_protect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="n">pfm_clear_psr_up</span><span class="p">();</span>

		<span class="n">pfm_force_cleanup</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">);</span>

		<span class="n">pfm_unprotect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">pfm_context_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * save current PSR: needed because we modify it</span>
<span class="cm">	 */</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IA64_PSR_I</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * stop monitoring:</span>
<span class="cm">	 * This is the last instruction which may generate an overflow</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not need to set psr.sp because, it is irrelevant in kernel.</span>
<span class="cm">	 * It will be restored from ipsr when going back to user level</span>
<span class="cm">	 */</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep a copy of psr.up (for reload)</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span> <span class="o">=</span> <span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_UP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * release ownership of this PMU.</span>
<span class="cm">	 * PM interrupts are masked, so nothing</span>
<span class="cm">	 * can happen.</span>
<span class="cm">	 */</span>
	<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we systematically save the PMD as we have no</span>
<span class="cm">	 * guarantee we will be schedule at that same</span>
<span class="cm">	 * CPU again.</span>
<span class="cm">	 */</span>
	<span class="n">pfm_save_pmds</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * save pmc0 ia64_srlz_d() done in pfm_save_pmds()</span>
<span class="cm">	 * we will need it on the restore path to check</span>
<span class="cm">	 * for pending overflow.</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * unfreeze PMU if had pending overflows</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1UL</span><span class="p">)</span> <span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * finally, allow context access.</span>
<span class="cm">	 * interrupts will still be masked after this call.</span>
<span class="cm">	 */</span>
	<span class="n">pfm_unprotect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>
<span class="kt">void</span>
<span class="nf">pfm_save_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">psr</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * save current PSR: needed because we modify it</span>
<span class="cm">	 */</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IA64_PSR_I</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * stop monitoring:</span>
<span class="cm">	 * This is the last instruction which may generate an overflow</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not need to set psr.sp because, it is irrelevant in kernel.</span>
<span class="cm">	 * It will be restored from ipsr when going back to user level</span>
<span class="cm">	 */</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * keep a copy of psr.up (for reload)</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span> <span class="o">=</span> <span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_UP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_lazy_save_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="p">{</span> <span class="n">u64</span> <span class="n">psr</span>  <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>
	  <span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_UP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need to mask PMU overflow here to</span>
<span class="cm">	 * make sure that we maintain pmc0 until</span>
<span class="cm">	 * we save it. overflow interrupts are</span>
<span class="cm">	 * treated as spurious if there is no</span>
<span class="cm">	 * owner.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX: I don&#39;t think this is necessary</span>
<span class="cm">	 */</span>
	<span class="n">PROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * release ownership of this PMU.</span>
<span class="cm">	 * must be done before we save the registers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * after this call any PMU interrupt is treated</span>
<span class="cm">	 * as spurious.</span>
<span class="cm">	 */</span>
	<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * save all the pmds we use</span>
<span class="cm">	 */</span>
	<span class="n">pfm_save_pmds</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * save pmc0 ia64_srlz_d() done in pfm_save_pmds()</span>
<span class="cm">	 * it is needed to check for pended overflow</span>
<span class="cm">	 * on the restore path</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * unfreeze PMU if had pending overflows</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1UL</span><span class="p">)</span> <span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * now get can unmask PMU interrupts, they will</span>
<span class="cm">	 * be treated as purely spurious and we will not</span>
<span class="cm">	 * lose any information</span>
<span class="cm">	 */</span>
	<span class="n">UNPROTECT_CTX</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * in 2.6, interrupts are masked when we come here and the runqueue lock is held</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_load_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmc_mask</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span> <span class="n">pmd_mask</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">psr</span><span class="p">,</span> <span class="n">psr_up</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_irq_resend</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">GET_PMU_OWNER</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * possible on unload</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_PM_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * we always come here with interrupts ALREADY disabled by</span>
<span class="cm"> 	 * the scheduler. So we simply need to protect against concurrent</span>
<span class="cm">	 * access, not CPU concurrency.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">pfm_protect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">psr</span>   <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

	<span class="n">need_irq_resend</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PFM_PMU_IRQ_RESEND</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IA64_PSR_UP</span><span class="o">|</span><span class="n">IA64_PSR_PP</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_I</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span> <span class="o">==</span> <span class="n">PFM_CTX_ZOMBIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">);</span>

		<span class="n">pfm_force_cleanup</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">pfm_unprotect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * this one (kmalloc&#39;ed) is fine with interrupts disabled</span>
<span class="cm">		 */</span>
		<span class="n">pfm_context_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we restore ALL the debug registers to avoid picking up</span>
<span class="cm">	 * stale state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_restore_ibrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ibrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
		<span class="n">pfm_restore_dbrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_dbrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * retrieve saved psr.up</span>
<span class="cm">	 */</span>
	<span class="n">psr_up</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we were the last user of the PMU on that CPU,</span>
<span class="cm">	 * then nothing to do except restore psr</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_last_activation</span> <span class="o">==</span> <span class="n">GET_ACTIVATION</span><span class="p">())</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * retrieve partial reload masks (due to user modifications)</span>
<span class="cm">		 */</span>
		<span class="n">pmc_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">pmd_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">	 	 * To avoid leaking information to the user level when psr.sp=0,</span>
<span class="cm">	 	 * we must reload ALL implemented pmds (even the ones we don&#39;t use).</span>
<span class="cm">	 	 * In the kernel we only allow PFM_READ_PMDS on registers which</span>
<span class="cm">	 	 * we initialized or requested (sampling) so there is no risk there.</span>
<span class="cm">	 	 */</span>
		<span class="n">pmd_mask</span> <span class="o">=</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">fastctxsw</span> <span class="o">?</span>  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">	 	 * ALL accessible PMCs are systematically reloaded, unused registers</span>
<span class="cm">	 	 * get their default (from pfm_reset_pmu_state()) values to avoid picking</span>
<span class="cm">	 	 * up stale configuration.</span>
<span class="cm">	 	 *</span>
<span class="cm">	 	 * PMC0 is never in the mask. It is always restored separately.</span>
<span class="cm">	 	 */</span>
		<span class="n">pmc_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * when context is MASKED, we will restore PMC with plm=0</span>
<span class="cm">	 * and PMD with stale information, but that&#39;s ok, nothing</span>
<span class="cm">	 * will be captured.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX: optimize here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_mask</span><span class="p">)</span> <span class="n">pfm_restore_pmds</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">,</span> <span class="n">pmd_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmc_mask</span><span class="p">)</span> <span class="n">pfm_restore_pmcs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">,</span> <span class="n">pmc_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for pending overflow at the time the state</span>
<span class="cm">	 * was saved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PMC0_HAS_OVFL</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reload pmc0 with the overflow information</span>
<span class="cm">		 * On McKinley PMU, this will trigger a PMU interrupt</span>
<span class="cm">		 */</span>
		<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * will replay the PMU interrupt</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_irq_resend</span><span class="p">)</span> <span class="n">ia64_resend_irq</span><span class="p">(</span><span class="n">IA64_PERFMON_VECTOR</span><span class="p">);</span>

		<span class="n">pfm_stats</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">pfm_replay_ovfl_intr_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we just did a reload, so we reset the partial reload fields</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_reload_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="n">SET_LAST_CPU</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * dump activation value for this PMU</span>
<span class="cm">	 */</span>
	<span class="n">INC_ACTIVATION</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * record current activation for this context</span>
<span class="cm">	 */</span>
	<span class="n">SET_ACTIVATION</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * establish new ownership. </span>
<span class="cm">	 */</span>
	<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * restore the psr.up bit. measurement</span>
<span class="cm">	 * is active again.</span>
<span class="cm">	 * no PMU interrupt can happen at this point</span>
<span class="cm">	 * because we still have interrupts disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">psr_up</span><span class="p">))</span> <span class="n">pfm_set_psr_up</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * allow concurrent access to context</span>
<span class="cm">	 */</span>
	<span class="n">pfm_unprotect_ctx_ctxsw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/*  !CONFIG_SMP */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * reload PMU state for UP kernels</span>
<span class="cm"> * in 2.5 we come here with interrupts disabled</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_load_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd_mask</span><span class="p">,</span> <span class="n">pmc_mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">psr</span><span class="p">,</span> <span class="n">psr_up</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_irq_resend</span><span class="p">;</span>

	<span class="n">owner</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">();</span>
	<span class="n">ctx</span>   <span class="o">=</span> <span class="n">PFM_GET_CTX</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">psr</span>   <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IA64_PSR_UP</span><span class="o">|</span><span class="n">IA64_PSR_PP</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_I</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we restore ALL the debug registers to avoid picking up</span>
<span class="cm">	 * stale state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This must be done even when the task is still the owner</span>
<span class="cm">	 * as the registers may have been modified via ptrace()</span>
<span class="cm">	 * (not perfmon) by the previous task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_using_dbreg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_restore_ibrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_ibrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
		<span class="n">pfm_restore_dbrs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_dbrs</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * retrieved saved psr.up</span>
<span class="cm">	 */</span>
	<span class="n">psr_up</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span><span class="p">;</span>
	<span class="n">need_irq_resend</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PFM_PMU_IRQ_RESEND</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * short path, our state is still there, just</span>
<span class="cm">	 * need to restore psr and we go</span>
<span class="cm">	 *</span>
<span class="cm">	 * we do not touch either PMC nor PMD. the psr is not touched</span>
<span class="cm">	 * by the overflow_handler. So we are safe w.r.t. to interrupt</span>
<span class="cm">	 * concurrency even without interrupt masking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">psr_up</span><span class="p">))</span> <span class="n">pfm_set_psr_up</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * someone else is still using the PMU, first push it out and</span>
<span class="cm">	 * then we&#39;ll be able to install our stuff !</span>
<span class="cm">	 *</span>
<span class="cm">	 * Upon return, there will be no owner for the current PMU</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="p">)</span> <span class="n">pfm_lazy_save_regs</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To avoid leaking information to the user level when psr.sp=0,</span>
<span class="cm">	 * we must reload ALL implemented pmds (even the ones we don&#39;t use).</span>
<span class="cm">	 * In the kernel we only allow PFM_READ_PMDS on registers which</span>
<span class="cm">	 * we initialized or requested (sampling) so there is no risk there.</span>
<span class="cm">	 */</span>
	<span class="n">pmd_mask</span> <span class="o">=</span> <span class="n">pfm_sysctl</span><span class="p">.</span><span class="n">fastctxsw</span> <span class="o">?</span>  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * ALL accessible PMCs are systematically reloaded, unused registers</span>
<span class="cm">	 * get their default (from pfm_reset_pmu_state()) values to avoid picking</span>
<span class="cm">	 * up stale configuration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * PMC0 is never in the mask. It is always restored separately</span>
<span class="cm">	 */</span>
	<span class="n">pmc_mask</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_all_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">pfm_restore_pmds</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">,</span> <span class="n">pmd_mask</span><span class="p">);</span>
	<span class="n">pfm_restore_pmcs</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">,</span> <span class="n">pmc_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for pending overflow at the time the state</span>
<span class="cm">	 * was saved.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PMC0_HAS_OVFL</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reload pmc0 with the overflow information</span>
<span class="cm">		 * On McKinley PMU, this will trigger a PMU interrupt</span>
<span class="cm">		 */</span>
		<span class="n">ia64_set_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * will replay the PMU interrupt</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_irq_resend</span><span class="p">)</span> <span class="n">ia64_resend_irq</span><span class="p">(</span><span class="n">IA64_PERFMON_VECTOR</span><span class="p">);</span>

		<span class="n">pfm_stats</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">pfm_replay_ovfl_intr_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * establish new ownership. </span>
<span class="cm">	 */</span>
	<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * restore the psr.up bit. measurement</span>
<span class="cm">	 * is active again.</span>
<span class="cm">	 * no PMU interrupt can happen at this point</span>
<span class="cm">	 * because we still have interrupts disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">psr_up</span><span class="p">))</span> <span class="n">pfm_set_psr_up</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * this function assumes monitoring is stopped</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_flush_pmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">pmc0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">pmd_val</span><span class="p">,</span> <span class="n">ovfl_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">can_access_pmu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_self</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * is the caller the task being monitored (or which initiated the</span>
<span class="cm">	 * session for system wide measurements)</span>
<span class="cm">	 */</span>
	<span class="n">is_self</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_task</span> <span class="o">==</span> <span class="n">task</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * can access PMU is task is the owner of the PMU state on the current CPU</span>
<span class="cm">	 * or if we are running on the CPU bound to the context in system-wide mode</span>
<span class="cm">	 * (that is not necessarily the task the context is attached to in this mode).</span>
<span class="cm">	 * In system-wide we always have can_access_pmu true because a task running on an</span>
<span class="cm">	 * invalid processor is flagged earlier in the call stack (see pfm_stop).</span>
<span class="cm">	 */</span>
	<span class="n">can_access_pmu</span> <span class="o">=</span> <span class="p">(</span><span class="n">GET_PMU_OWNER</span><span class="p">()</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_fl_system</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_access_pmu</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark the PMU as not owned</span>
<span class="cm">		 * This will cause the interrupt handler to do nothing in case an overflow</span>
<span class="cm">		 * interrupt was in-flight</span>
<span class="cm">		 * This also guarantees that pmc0 will contain the final state</span>
<span class="cm">		 * It virtually gives us full control on overflow processing from that point</span>
<span class="cm">		 * on.</span>
<span class="cm">		 */</span>
		<span class="n">SET_PMU_OWNER</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;releasing ownership</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * read current overflow status:</span>
<span class="cm">		 *</span>
<span class="cm">		 * we are guaranteed to read the final stable state</span>
<span class="cm">		 */</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>
		<span class="n">pmc0</span> <span class="o">=</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* slow */</span>

		<span class="cm">/*</span>
<span class="cm">		 * reset freeze bit, overflow status information destroyed</span>
<span class="cm">		 */</span>
		<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmc0</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * clear whatever overflow status bits there were</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ovfl_val</span> <span class="o">=</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * we save all the used pmds</span>
<span class="cm">	 * we take care of overflows for counting PMDs</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX: sampling situation is not taken into account here</span>
<span class="cm">	 */</span>
	<span class="n">mask2</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_used_pmds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;is_self=%d ovfl_val=0x%lx mask2=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_self</span><span class="p">,</span> <span class="n">ovfl_val</span><span class="p">,</span> <span class="n">mask2</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask2</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* skip non used pmds */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask2</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * can access PMU always true in system wide mode</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">pmd_val</span> <span class="o">=</span> <span class="n">can_access_pmu</span> <span class="o">?</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] pmd[%d] ctx_pmd=0x%lx hw_pmd=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
				<span class="n">i</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">,</span>
				<span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_val</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * we rebuild the full 64 bit value of the counter</span>
<span class="cm">			 */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ovfl_val</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * now everything is in ctx_pmds[] and we need</span>
<span class="cm">			 * to clear the saved context from save_regs() such that</span>
<span class="cm">			 * pfm_read_pmds() gets the correct value</span>
<span class="cm">			 */</span>
			<span class="n">pmd_val</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * take care of overflow inline</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmc0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ovfl_val</span><span class="p">;</span>
				<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] pmd[%d] overflowed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;[%d] ctx_pmd[%d]=0x%lx  pmd_val=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">pmd_val</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_self</span><span class="p">)</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmd_val</span><span class="p">;</span>

		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">perfmon_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">pfm_interrupt_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&quot;perfmon&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pfm_alt_save_pmu_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * should not be necessary but</span>
<span class="cm">	 * let&#39;s take not risk</span>
<span class="cm">	 */</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>
	<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This call is required</span>
<span class="cm">	 * May cause a spurious interrupt on some processors</span>
<span class="cm">	 */</span>
	<span class="n">pfm_freeze_pmu</span><span class="p">();</span>

	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">pfm_alt_restore_pmu_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * put PMU back in state expected</span>
<span class="cm">	 * by perfmon</span>
<span class="cm">	 */</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>
	<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * perfmon runs with PMU unfrozen at all times</span>
<span class="cm">	 */</span>
	<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>

	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pfm_install_alt_pmu_interrupt</span><span class="p">(</span><span class="n">pfm_intr_handler_desc_t</span> <span class="o">*</span><span class="n">hdl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserve_cpu</span><span class="p">;</span>

	<span class="cm">/* some sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdl</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">hdl</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* do the easy test first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_alt_intr_handler</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* one at a time in the install or remove, just fail the others */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_alt_install_check</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reserve our session */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">reserve_cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pfm_reserve_session</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reserve_cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">goto</span> <span class="n">cleanup_reserve</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save the current system wide pmu states */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">on_each_cpu</span><span class="p">(</span><span class="n">pfm_alt_save_pmu_state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;on_each_cpu() failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">cleanup_reserve</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* officially change to the alternate interrupt handler */</span>
	<span class="n">pfm_alt_intr_handler</span> <span class="o">=</span> <span class="n">hdl</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_alt_install_check</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup_reserve:</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t unreserve more than we reserved */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">reserve_cpu</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_alt_install_check</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pfm_install_alt_pmu_interrupt</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">pfm_remove_alt_pmu_interrupt</span><span class="p">(</span><span class="n">pfm_intr_handler_desc_t</span> <span class="o">*</span><span class="n">hdl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* cannot remove someone else&#39;s handler! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_alt_intr_handler</span> <span class="o">!=</span> <span class="n">hdl</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* one at a time in the install or remove, just fail the others */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_alt_install_check</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pfm_alt_intr_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">on_each_cpu</span><span class="p">(</span><span class="n">pfm_alt_restore_pmu_state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;on_each_cpu() failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfm_unreserve_session</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_alt_install_check</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pfm_remove_alt_pmu_interrupt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * perfmon initialization routine, called from the initcall() table</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">init_pfm_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">pfm_probe_pmu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmu_config_t</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">family</span><span class="p">;</span>

	<span class="n">family</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">;</span>
	<span class="n">p</span>      <span class="o">=</span> <span class="n">pmu_confs</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmu_family</span> <span class="o">==</span> <span class="n">family</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmu_family</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">pmu_conf</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pfm_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">pfm_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">pfm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_counters</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;perfmon: version %u.%u IRQ %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PFM_VERSION_MAJ</span><span class="p">,</span>
		<span class="n">PFM_VERSION_MIN</span><span class="p">,</span>
		<span class="n">IA64_PERFMON_VECTOR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pfm_probe_pmu</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: disabled, there is no support for processor family %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
				<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * compute the number of implemented PMD/PMC from the</span>
<span class="cm">	 * description tables</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">PMC_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMC_IS_IMPL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">impl_pmcs</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">63</span><span class="p">);</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmcs</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n_counters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">PMD_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_IMPL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">impl_pmds</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">6</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">63</span><span class="p">);</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_COUNTING</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="n">n_counters</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmds</span>      <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_counters</span>  <span class="o">=</span> <span class="n">n_counters</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * sanity checks on the number of debug registers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">use_rr_dbregs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span> <span class="o">&gt;</span> <span class="n">IA64_NUM_DBG_REGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: unsupported number of code debug registers (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
			<span class="n">pmu_conf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_dbrs</span> <span class="o">&gt;</span> <span class="n">IA64_NUM_DBG_REGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;perfmon: unsupported number of data debug registers (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_ibrs</span><span class="p">);</span>
			<span class="n">pmu_conf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;perfmon: %s PMU detected, %u PMCs, %u PMDs, %u counters (%lu bits)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">pmu_name</span><span class="p">,</span>
	       <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmcs</span><span class="p">,</span>
	       <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmds</span><span class="p">,</span>
	       <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_counters</span><span class="p">,</span>
	       <span class="n">ffz</span><span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">ovfl_val</span><span class="p">));</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmds</span> <span class="o">&gt;=</span> <span class="n">PFM_NUM_PMD_REGS</span> <span class="o">||</span> <span class="n">pmu_conf</span><span class="o">-&gt;</span><span class="n">num_pmcs</span> <span class="o">&gt;=</span> <span class="n">PFM_NUM_PMC_REGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: not enough pmc/pmd, perfmon disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmu_conf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * create /proc/perfmon (mostly for debugging purposes)</span>
<span class="cm">	 */</span>
	<span class="n">perfmon_dir</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;perfmon&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfm_proc_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">perfmon_dir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;perfmon: cannot create /proc entry, perfmon disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pmu_conf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * create /proc/sys/kernel/perfmon (for debugging purposes)</span>
<span class="cm">	 */</span>
	<span class="n">pfm_sysctl_header</span> <span class="o">=</span> <span class="n">register_sysctl_table</span><span class="p">(</span><span class="n">pfm_sysctl_root</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize all our spinlocks</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_sessions</span><span class="p">.</span><span class="n">pfs_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfm_buffer_fmt_lock</span><span class="p">);</span>

	<span class="n">init_pfm_fs</span><span class="p">();</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">pfm_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pfm_ovfl_intr_cycles_min</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">pfm_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * this function is called before pfm_init()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_init_percpu</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first_time</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * make sure no measurement is active</span>
<span class="cm">	 * (may inherit programmed PMCs from EFI).</span>
<span class="cm">	 */</span>
	<span class="n">pfm_clear_psr_pp</span><span class="p">();</span>
	<span class="n">pfm_clear_psr_up</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * we run with the PMU not frozen at all times</span>
<span class="cm">	 */</span>
	<span class="n">pfm_unfreeze_pmu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_PERFMON_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">perfmon_irqaction</span><span class="p">);</span>
		<span class="n">first_time</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_PMV</span><span class="p">,</span> <span class="n">IA64_PERFMON_VECTOR</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * used for debug purposes only</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">dump_pmu_state</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">pfm_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">,</span> <span class="n">dcr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">regs</span>     <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">info</span>     <span class="o">=</span> <span class="n">PFM_CPUINFO_GET</span><span class="p">();</span>
	<span class="n">dcr</span>      <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">IA64_DCR_PP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d from %s() current [%d] iip=0x%lx %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">this_cpu</span><span class="p">,</span> 
		<span class="n">from</span><span class="p">,</span> 
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">GET_PMU_OWNER</span><span class="p">();</span>
	<span class="n">ctx</span>  <span class="o">=</span> <span class="n">GET_PMU_CTX</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt;CPU%d owner [%d] ctx=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">task</span> <span class="o">?</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">psr</span> <span class="o">=</span> <span class="n">pfm_get_psr</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt;CPU%d pmc0=0x%lx psr.pp=%d psr.up=%d dcr.pp=%d syst_info=0x%lx user_psr.up=%d user_psr.pp=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">this_cpu</span><span class="p">,</span>
		<span class="n">ia64_get_pmc</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_PP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">psr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_UP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">IA64_DCR_PP</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">info</span><span class="p">,</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">,</span>
		<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span><span class="p">);</span>

	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">PMC_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMC_IS_IMPL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt;CPU%d pmc[%d]=0x%lx thread_pmc[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ia64_get_pmc</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmcs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">PMD_IS_LAST</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PMD_IS_IMPL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt;CPU%d pmd[%d]=0x%lx thread_pmd[%d]=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ia64_get_pmd</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">th_pmds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt;CPU%d ctx_state=%d vaddr=%p addr=%p fd=%d ctx_task=[%d] saved_psr_up=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">this_cpu</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_state</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_vaddr</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_smpl_hdr</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_head</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_msgq_tail</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_saved_psr_up</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called from process.c:copy_thread(). task is new child.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pfm_inherit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">((</span><span class="s">&quot;perfmon: pfm_inherit clearing state for [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">)));</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cut links inherited from parent (current)</span>
<span class="cm">	 */</span>
	<span class="kr">thread</span><span class="o">-&gt;</span><span class="n">pfm_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">PFM_SET_WORK_PENDING</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * the psr bits are already set properly in copy_threads()</span>
<span class="cm">	 */</span>
<span class="p">}</span>
<span class="cp">#else  </span><span class="cm">/* !CONFIG_PERFMON */</span><span class="cp"></span>
<span class="n">asmlinkage</span> <span class="kt">long</span>
<span class="nf">sys_perfmonctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PERFMON */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
