<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › mca.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mca.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File:	mca.c</span>
<span class="cm"> * Purpose:	Generic MCA handling layer</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002 Dell Inc.</span>
<span class="cm"> * Copyright (C) Matt Domsch &lt;Matt_Domsch@dell.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002 Intel</span>
<span class="cm"> * Copyright (C) Jenna Hall &lt;jenna.s.hall@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 Intel</span>
<span class="cm"> * Copyright (C) Fred Lewis &lt;frederick.v.lewis@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000 Intel</span>
<span class="cm"> * Copyright (C) Chuck Fleckenstein &lt;cfleck@co.intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999, 2004-2008 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (C) Vijay Chander &lt;vijay@engr.sgi.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 FUJITSU LIMITED</span>
<span class="cm"> * Copyright (C) Hidetoshi Seto &lt;seto.hidetoshi@jp.fujitsu.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2000-03-29 Chuck Fleckenstein &lt;cfleck@co.intel.com&gt;</span>
<span class="cm"> *	      Fixed PAL/SAL update issues, began MCA bug fixes, logging issues,</span>
<span class="cm"> *	      added min save state dump, added INIT handler.</span>
<span class="cm"> *</span>
<span class="cm"> * 2001-01-03 Fred Lewis &lt;frederick.v.lewis@intel.com&gt;</span>
<span class="cm"> *	      Added setup of CMCI and CPEI IRQs, logging of corrected platform</span>
<span class="cm"> *	      errors, completed code for logging of corrected &amp; uncorrected</span>
<span class="cm"> *	      machine check errors, and updated for conformance with Nov. 2000</span>
<span class="cm"> *	      revision of the SAL 3.0 spec.</span>
<span class="cm"> *</span>
<span class="cm"> * 2002-01-04 Jenna Hall &lt;jenna.s.hall@intel.com&gt;</span>
<span class="cm"> *	      Aligned MCA stack to 16 bytes, added platform vs. CPU error flag,</span>
<span class="cm"> *	      set SAL default return values, changed error record structure to</span>
<span class="cm"> *	      linked list, added init call to sal_get_state_info_size().</span>
<span class="cm"> *</span>
<span class="cm"> * 2002-03-25 Matt Domsch &lt;Matt_Domsch@dell.com&gt;</span>
<span class="cm"> *	      GUID cleanups.</span>
<span class="cm"> *</span>
<span class="cm"> * 2003-04-15 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *	      Added INIT backtrace support.</span>
<span class="cm"> *</span>
<span class="cm"> * 2003-12-08 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> *	      smp_call_function() must not be called from interrupt context</span>
<span class="cm"> *	      (can deadlock on tasklist_lock).</span>
<span class="cm"> *	      Use keventd to call smp_call_function().</span>
<span class="cm"> *</span>
<span class="cm"> * 2004-02-01 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> *	      Avoid deadlock when using printk() for MCA and INIT records.</span>
<span class="cm"> *	      Delete all record printing code, moved to salinfo_decode in user</span>
<span class="cm"> *	      space.  Mark variables and functions static where possible.</span>
<span class="cm"> *	      Delete dead variables and functions.  Reorder to remove the need</span>
<span class="cm"> *	      for forward declarations and to consolidate related code.</span>
<span class="cm"> *</span>
<span class="cm"> * 2005-08-12 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> *	      Convert MCA/INIT handlers to use per event stacks and SAL/OS</span>
<span class="cm"> *	      state.</span>
<span class="cm"> *</span>
<span class="cm"> * 2005-10-07 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> *	      Add notify_die() hooks.</span>
<span class="cm"> *</span>
<span class="cm"> * 2006-09-15 Hidetoshi Seto &lt;seto.hidetoshi@jp.fujitsu.com&gt;</span>
<span class="cm"> *	      Add printing support for MCA/INIT.</span>
<span class="cm"> *</span>
<span class="cm"> * 2007-04-27 Russ Anderson &lt;rja@sgi.com&gt;</span>
<span class="cm"> *	      Support multiple cpus going through OS_MCA in the same event.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/meminit.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/mca.h&gt;</span>
<span class="cp">#include &lt;asm/kexec.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>

<span class="cp">#include &quot;mca_drv.h&quot;</span>
<span class="cp">#include &quot;entry.h&quot;</span>

<span class="cp">#if defined(IA64_MCA_DEBUG_INFO)</span>
<span class="cp"># define IA64_MCA_DEBUG(fmt...)	printk(fmt)</span>
<span class="cp">#else</span>
<span class="cp"># define IA64_MCA_DEBUG(fmt...)</span>
<span class="cp">#endif</span>

<span class="cp">#define NOTIFY_INIT(event, regs, arg, spin)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((notify_die((event), &quot;INIT&quot;, (regs), (arg), 0, 0)		\</span>
<span class="cp">			== NOTIFY_STOP) &amp;&amp; ((spin) == 1))		\</span>
<span class="cp">		ia64_mca_spin(__func__);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define NOTIFY_MCA(event, regs, arg, spin)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	if ((notify_die((event), &quot;MCA&quot;, (regs), (arg), 0, 0)		\</span>
<span class="cp">			== NOTIFY_STOP) &amp;&amp; ((spin) == 1))		\</span>
<span class="cp">		ia64_mca_spin(__func__);				\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Used by mca_asm.S */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">ia64_mca_data</span><span class="p">);</span> <span class="cm">/* == __per_cpu_mca[smp_processor_id()] */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">ia64_mca_per_cpu_pte</span><span class="p">);</span> <span class="cm">/* PTE to map per-CPU area */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">ia64_mca_pal_pte</span><span class="p">);</span>	    <span class="cm">/* PTE to map PAL code */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">ia64_mca_pal_base</span><span class="p">);</span>    <span class="cm">/* vaddr PAL code granule */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">ia64_mca_tr_reload</span><span class="p">);</span>   <span class="cm">/* Flag for TR reload */</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__per_cpu_mca</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cm">/* In mca_asm.S */</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">ia64_os_init_dispatch_monarch</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>			<span class="n">ia64_os_init_dispatch_slave</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ia64_mc_info_t</span>		<span class="n">ia64_mc_info</span><span class="p">;</span>

<span class="cp">#define MAX_CPE_POLL_INTERVAL (15*60*HZ) </span><span class="cm">/* 15 minutes */</span><span class="cp"></span>
<span class="cp">#define MIN_CPE_POLL_INTERVAL (2*60*HZ)  </span><span class="cm">/* 2 minutes */</span><span class="cp"></span>
<span class="cp">#define CMC_POLL_INTERVAL     (1*60*HZ)  </span><span class="cm">/* 1 minute */</span><span class="cp"></span>
<span class="cp">#define CPE_HISTORY_LENGTH    5</span>
<span class="cp">#define CMC_HISTORY_LENGTH    5</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">cpe_poll_timer</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">cmc_poll_timer</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * This variable tells whether we are currently in polling mode.</span>
<span class="cm"> * Start with this in the wrong state so we won&#39;t play w/ timers</span>
<span class="cm"> * before the system is ready.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cmc_polling_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Clearing this variable prevents CPE polling from getting activated</span>
<span class="cm"> * in mca_late_init.  Use it if your system doesn&#39;t provide a CPEI,</span>
<span class="cm"> * but encounters problems retrieving CPE logs.  This should only be</span>
<span class="cm"> * necessary for debugging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cpe_poll_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">salinfo_log_wakeup</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irqsafe</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mca_init</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * limited &amp; delayed printing support for MCA/INIT handler</span>
<span class="cm"> */</span>

<span class="cp">#define mprintk(fmt...) ia64_mca_printk(fmt)</span>

<span class="cp">#define MLOGBUF_SIZE (512+256*NR_CPUS)</span>
<span class="cp">#define MLOGBUF_MSGMAX 256</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">mlogbuf</span><span class="p">[</span><span class="n">MLOGBUF_SIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mlogbuf_wlock</span><span class="p">);</span>	<span class="cm">/* mca context only */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mlogbuf_rlock</span><span class="p">);</span>	<span class="cm">/* normal context only */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mlogbuf_start</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mlogbuf_end</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mlogbuf_finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mlogbuf_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">loglevel_save</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#define BREAK_LOGLEVEL(__console_loglevel)		\</span>
<span class="cp">	oops_in_progress = 1;				\</span>
<span class="cp">	if (loglevel_save &lt; 0)				\</span>
<span class="cp">		loglevel_save = __console_loglevel;	\</span>
<span class="cp">	__console_loglevel = 15;</span>

<span class="cp">#define RESTORE_LOGLEVEL(__console_loglevel)		\</span>
<span class="cp">	if (loglevel_save &gt;= 0) {			\</span>
<span class="cp">		__console_loglevel = loglevel_save;	\</span>
<span class="cp">		loglevel_save = -1;			\</span>
<span class="cp">	}						\</span>
<span class="cp">	mlogbuf_finished = 0;				\</span>
<span class="cp">	oops_in_progress = 0;</span>

<span class="cm">/*</span>
<span class="cm"> * Push messages into buffer, print them later if not urgent.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ia64_mca_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">printed_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">temp_buf</span><span class="p">[</span><span class="n">MLOGBUF_MSGMAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">printed_len</span> <span class="o">=</span> <span class="n">vscnprintf</span><span class="p">(</span><span class="n">temp_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/* Copy the output into mlogbuf */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oops_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mlogbuf was abandoned, use printk directly instead. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">temp_buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_wlock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">temp_buf</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">mlogbuf_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MLOGBUF_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">mlogbuf_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlogbuf</span><span class="p">[</span><span class="n">mlogbuf_end</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
				<span class="n">mlogbuf_end</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* buffer full */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mlogbuf</span><span class="p">[</span><span class="n">mlogbuf_end</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_wlock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_mca_printk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Print buffered messages.</span>
<span class="cm"> *  NOTE: call this after returning normal context. (ex. from salinfod)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ia64_mlogbuf_dump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">temp_buf</span><span class="p">[</span><span class="n">MLOGBUF_MSGMAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">printed_len</span><span class="p">;</span>

	<span class="cm">/* Get output from mlogbuf */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mlogbuf_start</span> <span class="o">!=</span> <span class="n">mlogbuf_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">temp_buf</span><span class="p">;</span>
		<span class="n">printed_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_rlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">mlogbuf_start</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">mlogbuf_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">mlogbuf</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MLOGBUF_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">printed_len</span> <span class="o">&gt;=</span> <span class="n">MLOGBUF_MSGMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">temp_buf</span><span class="p">);</span>
		<span class="n">mlogbuf_start</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

		<span class="n">mlogbuf_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_rlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_mlogbuf_dump</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Call this if system is going to down or if immediate flushing messages to</span>
<span class="cm"> * console is required. (ex. recovery was failed, crash dump is going to be</span>
<span class="cm"> * invoked, long-wait rendezvous etc.)</span>
<span class="cm"> *  NOTE: this should be called from monarch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ia64_mlogbuf_finish</span><span class="p">(</span><span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BREAK_LOGLEVEL</span><span class="p">(</span><span class="n">console_loglevel</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_rlock</span><span class="p">);</span>
	<span class="n">ia64_mlogbuf_dump</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;mlogbuf_finish: printing switched to urgent mode, &quot;</span>
		<span class="s">&quot;MCA/INIT might be dodgy or fail.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* wait for console */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Delaying for 5 seconds...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">1000000</span><span class="p">);</span>

	<span class="n">mlogbuf_finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print buffered messages from INIT context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ia64_mlogbuf_dump_from_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mlogbuf_finished</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mlogbuf_timestamp</span> <span class="o">&amp;&amp;</span>
			<span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">mlogbuf_timestamp</span> <span class="o">+</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INIT: mlogbuf_dump is interrupted by INIT &quot;</span>
			<span class="s">&quot; and the system seems to be messed up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ia64_mlogbuf_finish</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_rlock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INIT: mlogbuf_dump is interrupted by INIT. &quot;</span>
			<span class="s">&quot;Generated messages other than stack dump will be &quot;</span>
			<span class="s">&quot;buffered to mlogbuf and will be printed later.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INIT: If messages would not printed after &quot;</span>
			<span class="s">&quot;this INIT, wait 30sec and assert INIT again.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mlogbuf_timestamp</span><span class="p">)</span>
			<span class="n">mlogbuf_timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlogbuf_rlock</span><span class="p">);</span>
	<span class="n">ia64_mlogbuf_dump</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="kr">inline</span>
<span class="nf">ia64_mca_spin</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">ia64_mlogbuf_finish</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%s: spinning here, not returning to SAL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * IA64_MCA log support</span>
<span class="cm"> */</span>
<span class="cp">#define IA64_MAX_LOGS		2	</span><span class="cm">/* Double-buffering for nested MCAs */</span><span class="cp"></span>
<span class="cp">#define IA64_MAX_LOG_TYPES      4   </span><span class="cm">/* MCA, INIT, CMC, CPE */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ia64_state_log_s</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span>	<span class="n">isl_lock</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">isl_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">isl_count</span><span class="p">;</span>
	<span class="n">ia64_err_rec_t</span>  <span class="o">*</span><span class="n">isl_log</span><span class="p">[</span><span class="n">IA64_MAX_LOGS</span><span class="p">];</span> <span class="cm">/* need space to store header + error log */</span>
<span class="p">}</span> <span class="n">ia64_state_log_t</span><span class="p">;</span>

<span class="k">static</span> <span class="n">ia64_state_log_t</span> <span class="n">ia64_state_log</span><span class="p">[</span><span class="n">IA64_MAX_LOG_TYPES</span><span class="p">];</span>

<span class="cp">#define IA64_LOG_ALLOCATE(it, size) \</span>
<span class="cp">	{ia64_state_log[it].isl_log[IA64_LOG_CURR_INDEX(it)] = \</span>
<span class="cp">		(ia64_err_rec_t *)alloc_bootmem(size); \</span>
<span class="cp">	ia64_state_log[it].isl_log[IA64_LOG_NEXT_INDEX(it)] = \</span>
<span class="cp">		(ia64_err_rec_t *)alloc_bootmem(size);}</span>
<span class="cp">#define IA64_LOG_LOCK_INIT(it) spin_lock_init(&amp;ia64_state_log[it].isl_lock)</span>
<span class="cp">#define IA64_LOG_LOCK(it)      spin_lock_irqsave(&amp;ia64_state_log[it].isl_lock, s)</span>
<span class="cp">#define IA64_LOG_UNLOCK(it)    spin_unlock_irqrestore(&amp;ia64_state_log[it].isl_lock,s)</span>
<span class="cp">#define IA64_LOG_NEXT_INDEX(it)    ia64_state_log[it].isl_index</span>
<span class="cp">#define IA64_LOG_CURR_INDEX(it)    1 - ia64_state_log[it].isl_index</span>
<span class="cp">#define IA64_LOG_INDEX_INC(it) \</span>
<span class="cp">    {ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index; \</span>
<span class="cp">    ia64_state_log[it].isl_count++;}</span>
<span class="cp">#define IA64_LOG_INDEX_DEC(it) \</span>
<span class="cp">    ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index</span>
<span class="cp">#define IA64_LOG_NEXT_BUFFER(it)   (void *)((ia64_state_log[it].isl_log[IA64_LOG_NEXT_INDEX(it)]))</span>
<span class="cp">#define IA64_LOG_CURR_BUFFER(it)   (void *)((ia64_state_log[it].isl_log[IA64_LOG_CURR_INDEX(it)]))</span>
<span class="cp">#define IA64_LOG_COUNT(it)         ia64_state_log[it].isl_count</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_log_init</span>
<span class="cm"> *	Reset the OS ia64 log buffer</span>
<span class="cm"> * Inputs   :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})</span>
<span class="cm"> * Outputs	:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ia64_log_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">sal_info_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span>	<span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IA64_LOG_NEXT_INDEX</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">IA64_LOG_LOCK_INIT</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>SAL will tell us the maximum size of any error record of this type</p></td><td class="code"><div class="highlight"><pre>	<span class="n">max_size</span> <span class="o">=</span> <span class="n">ia64_sal_get_state_info_size</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_size</span><span class="p">)</span>
		<span class="cm">/* alloc_bootmem() doesn&#39;t like zero-sized allocations! */</span>
		<span class="k">return</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>set up OS data structures to hold error info</p></td><td class="code"><div class="highlight"><pre>	<span class="n">IA64_LOG_ALLOCATE</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">IA64_LOG_CURR_BUFFER</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">IA64_LOG_NEXT_BUFFER</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_log_get</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the current MCA log from SAL and copy it into the OS log buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})</span>
<span class="cm"> *              irq_safe    whether you can use printk at this point</span>
<span class="cm"> *  Outputs :   size        (total record length)</span>
<span class="cm"> *              *buffer     (ptr to error record)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">ia64_log_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">sal_info_type</span><span class="p">,</span> <span class="n">u8</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_safe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sal_log_record_header_t</span>     <span class="o">*</span><span class="n">log_buffer</span><span class="p">;</span>
	<span class="n">u64</span>                         <span class="n">total_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>               <span class="n">s</span><span class="p">;</span>

	<span class="n">IA64_LOG_LOCK</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>

	<span class="cm">/* Get the process state information */</span>
	<span class="n">log_buffer</span> <span class="o">=</span> <span class="n">IA64_LOG_NEXT_BUFFER</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>

	<span class="n">total_len</span> <span class="o">=</span> <span class="n">ia64_sal_get_state_info</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">log_buffer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IA64_LOG_INDEX_INC</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>
		<span class="n">IA64_LOG_UNLOCK</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_safe</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: SAL error record type %d retrieved. Record length = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">sal_info_type</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">log_buffer</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">total_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IA64_LOG_UNLOCK</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ia64_mca_log_sal_error_record</span>
<span class="cm"> *</span>
<span class="cm"> *  This function retrieves a specified error record type from SAL</span>
<span class="cm"> *  and wakes up any processes waiting for error records.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   sal_info_type   (Type of error record MCA/CMC/CPE)</span>
<span class="cm"> *              FIXME: remove MCA and irq_safe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_log_sal_error_record</span><span class="p">(</span><span class="kt">int</span> <span class="n">sal_info_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">sal_log_record_header_t</span> <span class="o">*</span><span class="n">rh</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_safe</span> <span class="o">=</span> <span class="n">sal_info_type</span> <span class="o">!=</span> <span class="n">SAL_INFO_TYPE_MCA</span><span class="p">;</span>
<span class="cp">#ifdef IA64_MCA_DEBUG_INFO</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">rec_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;MCA&quot;</span><span class="p">,</span> <span class="s">&quot;INIT&quot;</span><span class="p">,</span> <span class="s">&quot;CMC&quot;</span><span class="p">,</span> <span class="s">&quot;CPE&quot;</span> <span class="p">};</span>
<span class="cp">#endif</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ia64_log_get</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">irq_safe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">salinfo_log_wakeup</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">irq_safe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_safe</span><span class="p">)</span>
		<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;CPU %d: SAL log contains %s error record</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span>
			<span class="n">sal_info_type</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rec_name</span><span class="p">)</span> <span class="o">?</span> <span class="n">rec_name</span><span class="p">[</span><span class="n">sal_info_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear logs from corrected errors in case there&#39;s no user-level logger */</span>
	<span class="n">rh</span> <span class="o">=</span> <span class="p">(</span><span class="n">sal_log_record_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rh</span><span class="o">-&gt;</span><span class="n">severity</span> <span class="o">==</span> <span class="n">sal_log_severity_corrected</span><span class="p">)</span>
		<span class="n">ia64_sal_clear_state_info</span><span class="p">(</span><span class="n">sal_info_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search_mca_table</span>
<span class="cm"> *  See if the MCA surfaced in an instruction range</span>
<span class="cm"> *  that has been tagged as recoverable.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs</span>
<span class="cm"> *	first	First address range to check</span>
<span class="cm"> *	last	Last address range to check</span>
<span class="cm"> *	ip	Instruction pointer, address we are looking for</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *      1 on Success (in the table)/ 0 on Failure (not in the  table)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">search_mca_table</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
                <span class="k">const</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
        <span class="n">u64</span> <span class="n">curr_start</span><span class="p">,</span> <span class="n">curr_end</span><span class="p">;</span>

        <span class="n">curr</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">start_addr</span> <span class="o">+</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">start_addr</span><span class="p">;</span>
                <span class="n">curr_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">end_addr</span> <span class="o">+</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">end_addr</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">((</span><span class="n">ip</span> <span class="o">&gt;=</span> <span class="n">curr_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&lt;=</span> <span class="n">curr_end</span><span class="p">))</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">curr</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Given an address, look for it in the mca tables. */</span>
<span class="kt">int</span> <span class="nf">mca_recover_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="n">__start___mca_table</span><span class="p">[];</span>
	<span class="k">extern</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="n">__stop___mca_table</span><span class="p">[];</span>

	<span class="k">return</span> <span class="n">search_mca_table</span><span class="p">(</span><span class="n">__start___mca_table</span><span class="p">,</span> <span class="n">__stop___mca_table</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mca_recover_range</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ACPI</span>

<span class="kt">int</span> <span class="n">cpe_vector</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ia64_cpe_irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_cpe_int_handler</span> <span class="p">(</span><span class="kt">int</span> <span class="n">cpe_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">cpe_history</span><span class="p">[</span><span class="n">CPE_HISTORY_LENGTH</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">int</span>		<span class="n">index</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cpe_history_lock</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: received interrupt vector = %#x on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">cpe_irq</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/* SAL spec states this should run w/ interrupts enabled */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_history_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpe_poll_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">cpe_vector</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we know 1 happened now */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPE_HISTORY_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">cpe_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">HZ</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPE threshold %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">CPE_HISTORY_LENGTH</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CPE_HISTORY_LENGTH</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">cpe_poll_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_history_lock</span><span class="p">);</span>
			<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">local_vector_to_irq</span><span class="p">(</span><span class="n">IA64_CPE_VECTOR</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * Corrected errors will still be corrected, but</span>
<span class="cm">			 * make sure there&#39;s a log somewhere that indicates</span>
<span class="cm">			 * something is generating more than we can handle.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;WARNING: Switching to polling CPE handler; error records may be lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_poll_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">MIN_CPE_POLL_INTERVAL</span><span class="p">);</span>

			<span class="cm">/* lock already released, get out now */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cpe_history</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">CPE_HISTORY_LENGTH</span><span class="p">)</span>
				<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_history_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="cm">/* Get the CPE error record and log it */</span>
	<span class="n">ia64_mca_log_sal_error_record</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CPE</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_ACPI */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="cm">/*</span>
<span class="cm"> * ia64_mca_register_cpev</span>
<span class="cm"> *</span>
<span class="cm"> *  Register the corrected platform error vector with SAL.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs</span>
<span class="cm"> *      cpev        Corrected Platform Error Vector number</span>
<span class="cm"> *</span>
<span class="cm"> *  Outputs</span>
<span class="cm"> *      None</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ia64_mca_register_cpev</span> <span class="p">(</span><span class="kt">int</span> <span class="n">cpev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Register the CPE interrupt vector with SAL */</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">isrv</span><span class="p">;</span>

	<span class="n">isrv</span> <span class="o">=</span> <span class="n">ia64_sal_mc_set_params</span><span class="p">(</span><span class="n">SAL_MC_PARAM_CPE_INT</span><span class="p">,</span> <span class="n">SAL_MC_PARAM_MECHANISM_INT</span><span class="p">,</span> <span class="n">cpev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register Corrected Platform &quot;</span>
		       <span class="s">&quot;Error interrupt vector with SAL (status %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: corrected platform error &quot;</span>
		       <span class="s">&quot;vector %#x registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cpev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ACPI */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_vector_setup</span>
<span class="cm"> *</span>
<span class="cm"> *  Setup the corrected machine check vector register in the processor.</span>
<span class="cm"> *  (The interrupt is masked on boot. ia64_mca_late_init unmask this.)</span>
<span class="cm"> *  This function is invoked on a per-processor basis.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *      None</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">ia64_mca_cmc_vector_setup</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmcv_reg_t</span>	<span class="n">cmcv</span><span class="p">;</span>

	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_mask</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="cm">/* Mask/disable interrupt at first */</span>
	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_vector</span>	<span class="o">=</span> <span class="n">IA64_CMC_VECTOR</span><span class="p">;</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">,</span> <span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPU %d corrected machine check vector %#x registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">IA64_CMC_VECTOR</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPU %d CMCV = %#016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_vector_disable</span>
<span class="cm"> *</span>
<span class="cm"> *  Mask the corrected machine check vector register in the processor.</span>
<span class="cm"> *  This function is invoked on a per-processor basis.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *      dummy(unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cmc_vector_disable</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmcv_reg_t</span>	<span class="n">cmcv</span><span class="p">;</span>

	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">);</span>

	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Mask/disable interrupt */</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">,</span> <span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPU %d corrected machine check vector %#x disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_vector_enable</span>
<span class="cm"> *</span>
<span class="cm"> *  Unmask the corrected machine check vector register in the processor.</span>
<span class="cm"> *  This function is invoked on a per-processor basis.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *      dummy(unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cmc_vector_enable</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmcv_reg_t</span>	<span class="n">cmcv</span><span class="p">;</span>

	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">);</span>

	<span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Unmask/enable interrupt */</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">,</span> <span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_regval</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPU %d corrected machine check vector %#x enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cmcv</span><span class="p">.</span><span class="n">cmcv_vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_vector_disable_keventd</span>
<span class="cm"> *</span>
<span class="cm"> * Called via keventd (smp_call_function() is not safe in interrupt context) to</span>
<span class="cm"> * disable the cmc interrupt vector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cmc_vector_disable_keventd</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">ia64_mca_cmc_vector_disable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_vector_enable_keventd</span>
<span class="cm"> *</span>
<span class="cm"> * Called via keventd (smp_call_function() is not safe in interrupt context) to</span>
<span class="cm"> * enable the cmc interrupt vector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cmc_vector_enable_keventd</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">ia64_mca_cmc_vector_enable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_wakeup</span>
<span class="cm"> *</span>
<span class="cm"> *	Send an inter-cpu interrupt to wake-up a particular cpu.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   cpuid</span>
<span class="cm"> *  Outputs :   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_wakeup</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">IA64_MCA_WAKEUP_VECTOR</span><span class="p">,</span> <span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_wakeup_all</span>
<span class="cm"> *</span>
<span class="cm"> *	Wakeup all the slave cpus which have rendez&#39;ed previously.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   None</span>
<span class="cm"> *  Outputs :   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_wakeup_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Clear the Rendez checkin flag for all cpus */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">==</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_DONE</span><span class="p">)</span>
			<span class="n">ia64_mca_wakeup</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_rendez_interrupt_handler</span>
<span class="cm"> *</span>
<span class="cm"> *	This is handler used to put slave processors into spinloop</span>
<span class="cm"> *	while the monarch processor does the mca handling and later</span>
<span class="cm"> *	wake each slave up once the monarch is done.  The state</span>
<span class="cm"> *	IA64_MCA_RENDEZ_CHECKIN_DONE indicates the cpu is rendez&#39;ed</span>
<span class="cm"> *	in SAL.  The state IA64_MCA_RENDEZ_CHECKIN_NOTDONE indicates</span>
<span class="cm"> *	the cpu has come out of OS rendezvous.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   None</span>
<span class="cm"> *  Outputs :   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_rendez_int_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">rendez_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">ia64_mca_notify_die</span> <span class="n">nd</span> <span class="o">=</span>
		<span class="p">{</span> <span class="p">.</span><span class="n">sos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">.</span><span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">monarch_cpu</span> <span class="p">};</span>

	<span class="cm">/* Mask all interrupts */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_RENDZVOUS_ENTER</span><span class="p">,</span> <span class="n">get_irq_regs</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_DONE</span><span class="p">;</span>
	<span class="cm">/* Register with the SAL monarch that the slave has</span>
<span class="cm">	 * reached SAL</span>
<span class="cm">	 */</span>
	<span class="n">ia64_sal_mc_rendez</span><span class="p">();</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_RENDZVOUS_PROCESS</span><span class="p">,</span> <span class="n">get_irq_regs</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Wait for the monarch cpu to exit. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	       <span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* spin until monarch leaves */</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_RENDZVOUS_LEAVE</span><span class="p">,</span> <span class="n">get_irq_regs</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">;</span>
	<span class="cm">/* Enable all interrupts */</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_wakeup_int_handler</span>
<span class="cm"> *</span>
<span class="cm"> *	The interrupt handler for processing the inter-cpu interrupt to the</span>
<span class="cm"> *	slave cpu which was spinning in the rendez loop.</span>
<span class="cm"> *	Since this spinning is done by turning off the interrupts and</span>
<span class="cm"> *	polling on the wakeup-interrupt bit in the IRR, there is</span>
<span class="cm"> *	nothing useful to be done in the handler.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   wakeup_irq  (Wakeup-interrupt bit)</span>
<span class="cm"> *	arg		(Interrupt handler specific argument)</span>
<span class="cm"> *  Outputs :   None</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_wakeup_int_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">wakeup_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function pointer for extra MCA recovery */</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ia64_mca_ucmc_extension</span><span class="p">)</span>
	<span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">ia64_sal_os_state</span><span class="o">*</span><span class="p">)</span>
	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">ia64_reg_MCA_extension</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_mca_ucmc_extension</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ia64_mca_ucmc_extension</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ia64_unreg_MCA_extension</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_mca_ucmc_extension</span><span class="p">)</span>
		<span class="n">ia64_mca_ucmc_extension</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_reg_MCA_extension</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_unreg_MCA_extension</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">copy_reg</span><span class="p">(</span><span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">fr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">fnat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tnat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">fslot</span><span class="p">,</span> <span class="n">tslot</span><span class="p">,</span> <span class="n">nat</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>
	<span class="n">fslot</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">;</span>
	<span class="n">tslot</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tnat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">tslot</span><span class="p">);</span>
	<span class="n">nat</span> <span class="o">=</span> <span class="p">(</span><span class="n">fnat</span> <span class="o">&gt;&gt;</span> <span class="n">fslot</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tnat</span> <span class="o">|=</span> <span class="p">(</span><span class="n">nat</span> <span class="o">&lt;&lt;</span> <span class="n">tslot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Change the comm field on the MCA/INT task to include the pid that</span>
<span class="cm"> * was interrupted, it makes for easier debugging.  If that pid was 0</span>
<span class="cm"> * (swapper or nested MCA/INIT) then use the start of the previous comm</span>
<span class="cm"> * field suffixed with its cpu.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_modify_comm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">previous_current</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">comm</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">)];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm</span><span class="p">),</span> <span class="s">&quot;%s %d&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)))</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm</span><span class="p">),</span> <span class="s">&quot;%s %*s %d&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">previous_current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
			<span class="n">task_thread_info</span><span class="p">(</span><span class="n">previous_current</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">finish_pt_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">pal_min_state_area_t</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">pal_min_state</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">bank</span><span class="p">;</span>

	<span class="cm">/* If ipsr.ic then use pmsa_{iip,ipsr,ifs}, else use</span>
<span class="cm">	 * pmsa_{xip,xpsr,xfs}</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_ifs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_xip</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_xpsr</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_xfs</span><span class="p">;</span>

		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">;</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">ipsr</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">;</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">ifs</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_ifs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pr</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_pr</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">b0</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_br0</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_rsc</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_rsc</span><span class="p">;</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r1</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r2</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r3</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">10</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">11</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r11</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">12</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r12</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">13</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r13</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">14</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r14</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">15</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bn</span><span class="p">)</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_bank1_gr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_bank0_gr</span><span class="p">;</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">16</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r16</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">17</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r17</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">18</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r18</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r19</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">20</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r20</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">21</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r21</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">22</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r22</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">23</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r23</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">24</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r24</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">25</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r25</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">26</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r26</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">27</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r27</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">28</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r28</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">29</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r29</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">30</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r30</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank</span><span class="p">[</span><span class="mi">31</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r31</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* On entry to this routine, we are running on the per cpu stack, see</span>
<span class="cm"> * mca_asm.h.  The original stack has not been touched by this event.  Some of</span>
<span class="cm"> * the original stack&#39;s registers will be in the RBS on this stack.  This stack</span>
<span class="cm"> * also contains a partial pt_regs and switch_stack, the rest of the data is in</span>
<span class="cm"> * PAL minstate.</span>
<span class="cm"> *</span>
<span class="cm"> * The first thing to do is modify the original stack to look like a blocked</span>
<span class="cm"> * task so we can run backtrace on the original task.  Also mark the per cpu</span>
<span class="cm"> * stack as current to ensure that we use the correct task state, it also means</span>
<span class="cm"> * that we can do backtrace on the MCA/INIT handler code itself.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">ia64_mca_modify_original_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">ia64_va</span> <span class="n">va</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">ia64_leave_kernel</span><span class="p">[];</span>	<span class="cm">/* Need asm address, not function descriptor */</span>
	<span class="k">const</span> <span class="n">pal_min_state_area_t</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">pal_min_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">previous_current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">old_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">old_sw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">old_bspstore</span><span class="p">,</span> <span class="o">*</span><span class="n">old_bsp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">new_bspstore</span><span class="p">,</span> <span class="o">*</span><span class="n">new_bsp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_unat</span><span class="p">,</span> <span class="n">old_rnat</span><span class="p">,</span> <span class="n">new_rnat</span><span class="p">,</span> <span class="n">nat</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">slots</span><span class="p">,</span> <span class="n">loadrs</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">loadrs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">r12</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">12</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">r13</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">13</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">ar_bspstore</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ar_bsp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span> <span class="o">+</span> <span class="p">(</span><span class="n">loadrs</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">previous_current</span> <span class="o">=</span> <span class="n">curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="cm">/* Best effort attempt to cope with MCA/INIT delivered while in</span>
<span class="cm">	 * physical mode.</span>
<span class="cm">	 */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">va</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">r12</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">r12</span> <span class="o">=</span> <span class="n">va</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">va</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">r13</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">r13</span> <span class="o">=</span> <span class="n">va</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">va</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">ar_bspstore</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">ar_bspstore</span> <span class="o">=</span> <span class="n">va</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">va</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">ar_bsp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">ar_bsp</span> <span class="o">=</span> <span class="n">va</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* mca_asm.S ia64_old_stack() cannot assume that the dirty registers</span>
<span class="cm">	 * have been copied to the old stack, the old stack may fail the</span>
<span class="cm">	 * validation tests below.  So ia64_old_stack() must restore the dirty</span>
<span class="cm">	 * registers from the new stack.  The old and new bspstore probably</span>
<span class="cm">	 * have different alignments, so loadrs calculated on the old bsp</span>
<span class="cm">	 * cannot be used to restore from the new bsp.  Calculate a suitable</span>
<span class="cm">	 * loadrs for the new stack and save it in the new pt_regs, where</span>
<span class="cm">	 * ia64_old_stack() can get it.</span>
<span class="cm">	 */</span>
	<span class="n">old_bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ar_bspstore</span><span class="p">;</span>
	<span class="n">old_bsp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ar_bsp</span><span class="p">;</span>
	<span class="n">slots</span> <span class="o">=</span> <span class="n">ia64_rse_num_regs</span><span class="p">(</span><span class="n">old_bspstore</span><span class="p">,</span> <span class="n">old_bsp</span><span class="p">);</span>
	<span class="n">new_bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="n">u64</span><span class="p">)</span><span class="n">current</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">);</span>
	<span class="n">new_bsp</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">new_bspstore</span><span class="p">,</span> <span class="n">slots</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">loadrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_bsp</span> <span class="o">-</span> <span class="n">new_bspstore</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Verify the previous stack state before we change it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;occurred in user space&quot;</span><span class="p">;</span>
		<span class="cm">/* previous_current is guaranteed to be valid when the task was</span>
<span class="cm">		 * in user space, so ...</span>
<span class="cm">		 */</span>
		<span class="n">ia64_mca_modify_comm</span><span class="p">(</span><span class="n">previous_current</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r13</span> <span class="o">!=</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">prev_IA64_KR_CURRENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;inconsistent previous current and r13&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mca_recover_range</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">r12</span> <span class="o">-</span> <span class="n">r13</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;inconsistent r12 and r13&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ar_bspstore</span> <span class="o">-</span> <span class="n">r13</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;inconsistent ar.bspstore and r13&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">va</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">old_bspstore</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">va</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">reg</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;old_bspstore is in the wrong region&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ar_bsp</span> <span class="o">-</span> <span class="n">r13</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;inconsistent ar.bsp and r13&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">old_bspstore</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span> <span class="o">-</span> <span class="n">old_bspstore</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ar_bspstore</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">r12</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;no room for blocked state&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_mod</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ia64_mca_modify_comm</span><span class="p">(</span><span class="n">previous_current</span><span class="p">);</span>

	<span class="cm">/* Make the original task look blocked.  First stack a struct pt_regs,</span>
<span class="cm">	 * describing the state at the time of interrupt.  mca_asm.S built a</span>
<span class="cm">	 * partial pt_regs, copy it and fill in the blanks using minstate.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">r12</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">old_regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">old_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">old_regs</span><span class="o">-&gt;</span><span class="n">loadrs</span> <span class="o">=</span> <span class="n">loadrs</span><span class="p">;</span>
	<span class="n">old_unat</span> <span class="o">=</span> <span class="n">old_regs</span><span class="o">-&gt;</span><span class="n">ar_unat</span><span class="p">;</span>
	<span class="n">finish_pt_regs</span><span class="p">(</span><span class="n">old_regs</span><span class="p">,</span> <span class="n">sos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>

	<span class="cm">/* Next stack a struct switch_stack.  mca_asm.S built a partial</span>
<span class="cm">	 * switch_stack, copy it and fill in the blanks using pt_regs and</span>
<span class="cm">	 * minstate.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the synthesized switch_stack, b0 points to ia64_leave_kernel,</span>
<span class="cm">	 * ar.pfs is set to 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * unwind.c::unw_unwind() does special processing for interrupt frames.</span>
<span class="cm">	 * It checks if the PRED_NON_SYSCALL predicate is set, if the predicate</span>
<span class="cm">	 * is clear then unw_unwind() does _not_ adjust bsp over pt_regs.  Not</span>
<span class="cm">	 * that this is documented, of course.  Set PRED_NON_SYSCALL in the</span>
<span class="cm">	 * switch_stack on the original stack so it will unwind correctly when</span>
<span class="cm">	 * unwind.c reads pt_regs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * thread.ksp is updated to point to the synthesized switch_stack.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span><span class="p">);</span>
	<span class="n">old_sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">old_sw</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sw</span><span class="p">));</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">caller_unat</span> <span class="o">=</span> <span class="n">old_unat</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">ar_fpsr</span> <span class="o">=</span> <span class="n">old_regs</span><span class="o">-&gt;</span><span class="n">ar_fpsr</span><span class="p">;</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">r4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">r5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">6</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">r6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>
	<span class="n">copy_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">7</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_nat_bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">r7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">b0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ia64_leave_kernel</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">b1</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">pmsa_br1</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">ar_pfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">ar_unat</span> <span class="o">=</span> <span class="n">old_unat</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">pr</span> <span class="o">=</span> <span class="n">old_regs</span><span class="o">-&gt;</span><span class="n">pr</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PRED_NON_SYSCALL</span><span class="p">);</span>
	<span class="n">previous_current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">p</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Finally copy the original stack&#39;s registers back to its RBS.</span>
<span class="cm">	 * Registers from ar.bspstore through ar.bsp at the time of the event</span>
<span class="cm">	 * are in the current RBS, copy them back to the original stack.  The</span>
<span class="cm">	 * copy must be done register by register because the original bspstore</span>
<span class="cm">	 * and the current one have different alignments, so the saved RNAT</span>
<span class="cm">	 * data occurs at different places.</span>
<span class="cm">	 *</span>
<span class="cm">	 * mca_asm does cover, so the old_bsp already includes all registers at</span>
<span class="cm">	 * the time of MCA/INIT.  It also does flushrs, so all registers before</span>
<span class="cm">	 * this function have been written to backing store on the MCA/INIT</span>
<span class="cm">	 * stack.</span>
<span class="cm">	 */</span>
	<span class="n">new_rnat</span> <span class="o">=</span> <span class="n">ia64_get_rnat</span><span class="p">(</span><span class="n">ia64_rse_rnat_addr</span><span class="p">(</span><span class="n">new_bspstore</span><span class="p">));</span>
	<span class="n">old_rnat</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_rnat</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">slots</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_rse_is_rnat_slot</span><span class="p">(</span><span class="n">new_bspstore</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_rnat</span> <span class="o">=</span> <span class="n">ia64_get_rnat</span><span class="p">(</span><span class="n">new_bspstore</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_rse_is_rnat_slot</span><span class="p">(</span><span class="n">old_bspstore</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">old_bspstore</span><span class="o">++</span> <span class="o">=</span> <span class="n">old_rnat</span><span class="p">;</span>
			<span class="n">old_rnat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nat</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_rnat</span> <span class="o">&gt;&gt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">new_bspstore</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1UL</span><span class="p">;</span>
		<span class="n">old_rnat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">old_bspstore</span><span class="p">));</span>
		<span class="n">old_rnat</span> <span class="o">|=</span> <span class="p">(</span><span class="n">nat</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">old_bspstore</span><span class="p">));</span>
		<span class="o">*</span><span class="n">old_bspstore</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">new_bspstore</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_bspstore</span><span class="p">;</span>
	<span class="n">old_sw</span><span class="o">-&gt;</span><span class="n">ar_rnat</span> <span class="o">=</span> <span class="n">old_rnat</span><span class="p">;</span>

	<span class="n">sos</span><span class="o">-&gt;</span><span class="n">prev_task</span> <span class="o">=</span> <span class="n">previous_current</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">previous_current</span><span class="p">;</span>

<span class="nl">no_mod:</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;cpu %d, %s %s, original stack not modified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">type</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">old_unat</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_unat</span><span class="p">;</span>
	<span class="n">finish_pt_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">sos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_unat</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">previous_current</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The monarch/slave interaction is based on monarch_cpu and requires that all</span>
<span class="cm"> * slaves have entered rendezvous before the monarch leaves.  If any cpu has</span>
<span class="cm"> * not entered rendezvous yet then wait a bit.  The assumption is that any</span>
<span class="cm"> * slave that has not rendezvoused after a reasonable time is never going to do</span>
<span class="cm"> * so.  In this context, slave includes cpus that respond to the MCA rendezvous</span>
<span class="cm"> * interrupt, as well as cpus that receive the INIT slave event.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_wait_for_slaves</span><span class="p">(</span><span class="kt">int</span> <span class="n">monarch</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="n">wait</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait 5 seconds total for slaves (arbitrary)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">monarch</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
					<span class="o">==</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>		<span class="cm">/* short wait */</span>
				<span class="n">wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">all_in</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maybe slave(s) dead. Print buffered messages immediately.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_mlogbuf_finish</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;OS %s slave did not rendezvous on cpu&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">monarch</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">)</span>
			<span class="n">mprintk</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">all_in:</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;All OS %s slaves have reached rendezvous</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  mca_insert_tr</span>
<span class="cm"> *</span>
<span class="cm"> *  Switch rid when TR reload and needed!</span>
<span class="cm"> *  iord: 1: itr, 2: itr;</span>
<span class="cm"> *</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mca_insert_tr</span><span class="p">(</span><span class="n">u64</span> <span class="n">iord</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_rr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_tr_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">psr</span> <span class="o">=</span> <span class="n">ia64_clear_ic</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IA64_TR_ALLOC_BASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IA64_TR_ALLOC_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">iord</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IA64_TR_ALLOC_MAX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old_rr</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_rr</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">);</span>
				<span class="n">ia64_srlz_d</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">ia64_ptr</span><span class="p">(</span><span class="n">iord</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">ia64_srlz_i</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iord</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_itr</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">ia64_srlz_i</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iord</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_itr</span><span class="p">(</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">ia64_srlz_i</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_rr</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">old_rr</span><span class="p">);</span>
				<span class="n">ia64_srlz_d</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ia64_set_psr</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_handler</span>
<span class="cm"> *</span>
<span class="cm"> *	This is uncorrectable machine check handler called from OS_MCA</span>
<span class="cm"> *	dispatch code which is in turn called from SAL_CHECK().</span>
<span class="cm"> *	This is the place where the core of OS MCA handling is done.</span>
<span class="cm"> *	Right now the logs are extracted and displayed in a well-defined</span>
<span class="cm"> *	format. This handler code is supposed to be run only on the</span>
<span class="cm"> *	monarch processor. Once the monarch is done with MCA handling</span>
<span class="cm"> *	further MCA logging is enabled by clearing logs.</span>
<span class="cm"> *	Monarch also has the duty of sending wakeup-IPIs to pull the</span>
<span class="cm"> *	slave processors out of rendezvous spinloop.</span>
<span class="cm"> *</span>
<span class="cm"> *	If multiple processors call into OS_MCA, the first will become</span>
<span class="cm"> *	the monarch.  Subsequent cpus will be recorded in the mca_cpu</span>
<span class="cm"> *	bitmask.  After the first monarch has processed its MCA, it</span>
<span class="cm"> *	will wake up the next cpu in the mca_cpu bitmask and then go</span>
<span class="cm"> *	into the rendezvous loop.  When all processors have serviced</span>
<span class="cm"> *	their MCA, the last monarch frees up the rest of the processors.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ia64_mca_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">recover</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">previous_current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_mca_notify_die</span> <span class="n">nd</span> <span class="o">=</span>
		<span class="p">{</span> <span class="p">.</span><span class="n">sos</span> <span class="o">=</span> <span class="n">sos</span><span class="p">,</span> <span class="p">.</span><span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">monarch_cpu</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">recover</span> <span class="p">};</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">mca_count</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">mca_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mca_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">monarch_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mca_cpu</span><span class="p">);</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Entered OS MCA handler. PSP=%lx cpu=%d &quot;</span>
		<span class="s">&quot;monarch=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">proc_state_param</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span><span class="p">);</span>

	<span class="n">previous_current</span> <span class="o">=</span> <span class="n">ia64_mca_modify_original_stack</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sos</span><span class="p">,</span> <span class="s">&quot;MCA&quot;</span><span class="p">);</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_MONARCH_ENTER</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_CONCURRENT_MCA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_wait_for_slaves</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;MCA&quot;</span><span class="p">);</span>

		<span class="cm">/* Wakeup all the processors which are spinning in the</span>
<span class="cm">		 * rendezvous loop.  They will leave SAL, then spin in the OS</span>
<span class="cm">		 * with interrupts disabled until this monarch cpu leaves the</span>
<span class="cm">		 * MCA handler.  That gets control back to the OS so we can</span>
<span class="cm">		 * backtrace the other cpus, backtrace when spinning in SAL</span>
<span class="cm">		 * does not work.</span>
<span class="cm">		 */</span>
		<span class="n">ia64_mca_wakeup_all</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mca_cpu</span><span class="p">))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* spin until monarch wakes us */</span>
	<span class="p">}</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_MONARCH_PROCESS</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Get the MCA error record and log it */</span>
	<span class="n">ia64_mca_log_sal_error_record</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_MCA</span><span class="p">);</span>

	<span class="cm">/* MCA error recovery */</span>
	<span class="n">recover</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_mca_ucmc_extension</span>
		<span class="o">&amp;&amp;</span> <span class="n">ia64_mca_ucmc_extension</span><span class="p">(</span>
			<span class="n">IA64_LOG_CURR_BUFFER</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_MCA</span><span class="p">),</span>
			<span class="n">sos</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recover</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sal_log_record_header_t</span> <span class="o">*</span><span class="n">rh</span> <span class="o">=</span> <span class="n">IA64_LOG_CURR_BUFFER</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_MCA</span><span class="p">);</span>
		<span class="n">rh</span><span class="o">-&gt;</span><span class="n">severity</span> <span class="o">=</span> <span class="n">sal_log_severity_corrected</span><span class="p">;</span>
		<span class="n">ia64_sal_clear_state_info</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_MCA</span><span class="p">);</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">os_status</span> <span class="o">=</span> <span class="n">IA64_MCA_CORRECTED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Dump buffered message to console */</span>
		<span class="n">ia64_mlogbuf_finish</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ia64_mca_tr_reload</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mca_insert_tr</span><span class="p">(</span><span class="mh">0x1</span><span class="p">);</span> <span class="cm">/*Reload dynamic itrs*/</span>
		<span class="n">mca_insert_tr</span><span class="p">(</span><span class="mh">0x2</span><span class="p">);</span> <span class="cm">/*Reload dynamic itrs*/</span>
	<span class="p">}</span>

	<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_MONARCH_LEAVE</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mca_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* wake up the next monarch cpu,</span>
<span class="cm">		 * and put this cpu in the rendez loop.</span>
<span class="cm">		 */</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mca_cpu</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">monarch_cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">cpu_clear</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mca_cpu</span><span class="p">);</span>	<span class="cm">/* wake next cpu */</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* spin until last cpu leaves */</span>
				<span class="n">set_curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">previous_current</span><span class="p">);</span>
				<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span>
						<span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">set_curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">previous_current</span><span class="p">);</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">;</span>
	<span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* This frees the slaves and previous monarchs */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">cmc_disable_work</span><span class="p">,</span> <span class="n">ia64_mca_cmc_vector_disable_keventd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">cmc_enable_work</span><span class="p">,</span> <span class="n">ia64_mca_cmc_vector_enable_keventd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_cmc_int_handler</span>
<span class="cm"> *</span>
<span class="cm"> *  This is corrected machine check interrupt handler.</span>
<span class="cm"> *	Right now the logs are extracted and displayed in a well-defined</span>
<span class="cm"> *	format.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *      interrupt number</span>
<span class="cm"> *      client data arg ptr</span>
<span class="cm"> *</span>
<span class="cm"> * Outputs</span>
<span class="cm"> *	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_cmc_int_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmc_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">cmc_history</span><span class="p">[</span><span class="n">CMC_HISTORY_LENGTH</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">int</span>		<span class="n">index</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cmc_history_lock</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: received interrupt vector = %#x on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">cmc_irq</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/* SAL spec states this should run w/ interrupts enabled */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_history_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmc_polling_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we know 1 happened now */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CMC_HISTORY_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">cmc_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">HZ</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CMC threshold %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">CMC_HISTORY_LENGTH</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">CMC_HISTORY_LENGTH</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">cmc_polling_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_history_lock</span><span class="p">);</span>
			<span class="cm">/* If we&#39;re being hit with CMC interrupts, we won&#39;t</span>
<span class="cm">			 * ever execute the schedule_work() below.  Need to</span>
<span class="cm">			 * disable CMC interrupts on this processor now.</span>
<span class="cm">			 */</span>
			<span class="n">ia64_mca_cmc_vector_disable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_disable_work</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Corrected errors will still be corrected, but</span>
<span class="cm">			 * make sure there&#39;s a log somewhere that indicates</span>
<span class="cm">			 * something is generating more than we can handle.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;WARNING: Switching to polling CMC handler; error records may be lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_poll_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CMC_POLL_INTERVAL</span><span class="p">);</span>

			<span class="cm">/* lock already released, get out now */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cmc_history</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">CMC_HISTORY_LENGTH</span><span class="p">)</span>
				<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_history_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="cm">/* Get the CMC error record and log it */</span>
	<span class="n">ia64_mca_log_sal_error_record</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CMC</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ia64_mca_cmc_int_caller</span>
<span class="cm"> *</span>
<span class="cm"> * 	Triggered by sw interrupt from CMC polling routine.  Calls</span>
<span class="cm"> * 	real interrupt handler and either triggers a sw interrupt</span>
<span class="cm"> * 	on the next cpu or does cleanup at the end.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *	interrupt number</span>
<span class="cm"> *	client data arg ptr</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * 	handled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_cmc_int_caller</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmc_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">start_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuid</span><span class="p">;</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* If first cpu, update count */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">start_count</span> <span class="o">=</span> <span class="n">IA64_LOG_COUNT</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CMC</span><span class="p">);</span>

	<span class="n">ia64_mca_cmc_int_handler</span><span class="p">(</span><span class="n">cmc_irq</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">cpuid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">IA64_CMCP_VECTOR</span><span class="p">,</span> <span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If no log record, switch out of polling mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_count</span> <span class="o">==</span> <span class="n">IA64_LOG_COUNT</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CMC</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Returning to interrupt driven CMC handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_enable_work</span><span class="p">);</span>
			<span class="n">cmc_polling_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_poll_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CMC_POLL_INTERVAL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">start_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ia64_mca_cmc_poll</span>
<span class="cm"> *</span>
<span class="cm"> *	Poll for Corrected Machine Checks (CMCs)</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs   :   dummy(unused)</span>
<span class="cm"> * Outputs  :   None</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cmc_poll</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Trigger a CMC interrupt cascade  */</span>
	<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">),</span> <span class="n">IA64_CMCP_VECTOR</span><span class="p">,</span>
							<span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ia64_mca_cpe_int_caller</span>
<span class="cm"> *</span>
<span class="cm"> * 	Triggered by sw interrupt from CPE polling routine.  Calls</span>
<span class="cm"> * 	real interrupt handler and either triggers a sw interrupt</span>
<span class="cm"> * 	on the next cpu or does cleanup at the end.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs</span>
<span class="cm"> *	interrupt number</span>
<span class="cm"> *	client data arg ptr</span>
<span class="cm"> * Outputs</span>
<span class="cm"> * 	handled</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ACPI</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">ia64_mca_cpe_int_caller</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpe_irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">start_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">poll_time</span> <span class="o">=</span> <span class="n">MIN_CPE_POLL_INTERVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuid</span><span class="p">;</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* If first cpu, update count */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">start_count</span> <span class="o">=</span> <span class="n">IA64_LOG_COUNT</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CPE</span><span class="p">);</span>

	<span class="n">ia64_mca_cpe_int_handler</span><span class="p">(</span><span class="n">cpe_irq</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">cpuid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">IA64_CPEP_VECTOR</span><span class="p">,</span> <span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a log was recorded, increase our polling frequency,</span>
<span class="cm">		 * otherwise, backoff or return to interrupt mode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_count</span> <span class="o">!=</span> <span class="n">IA64_LOG_COUNT</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CPE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">poll_time</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">MIN_CPE_POLL_INTERVAL</span><span class="p">,</span> <span class="n">poll_time</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpe_vector</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">poll_time</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">MAX_CPE_POLL_INTERVAL</span><span class="p">,</span> <span class="n">poll_time</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">poll_time</span> <span class="o">=</span> <span class="n">MIN_CPE_POLL_INTERVAL</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Returning to interrupt driven CPE handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">enable_irq</span><span class="p">(</span><span class="n">local_vector_to_irq</span><span class="p">(</span><span class="n">IA64_CPE_VECTOR</span><span class="p">));</span>
			<span class="n">cpe_poll_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpe_poll_enabled</span><span class="p">)</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_poll_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">poll_time</span><span class="p">);</span>
		<span class="n">start_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ia64_mca_cpe_poll</span>
<span class="cm"> *</span>
<span class="cm"> *	Poll for Corrected Platform Errors (CPEs), trigger interrupt</span>
<span class="cm"> *	on first cpu, from there it will trickle through all the cpus.</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs   :   dummy(unused)</span>
<span class="cm"> * Outputs  :   None</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ia64_mca_cpe_poll</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Trigger a CPE interrupt cascade  */</span>
	<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">),</span> <span class="n">IA64_CPEP_VECTOR</span><span class="p">,</span>
							<span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_ACPI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">default_monarch_init_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">DIE_INIT_MONARCH_PROCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdump_in_progress</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: mlogbuf will brim over with INIT stack dumps.</span>
<span class="cm">	 * To enable show_stack from INIT, we use oops_in_progress which should</span>
<span class="cm">	 * be used in real oops. This would cause something wrong after INIT.</span>
<span class="cm">	 */</span>
	<span class="n">BREAK_LOGLEVEL</span><span class="p">(</span><span class="n">console_loglevel</span><span class="p">);</span>
	<span class="n">ia64_mlogbuf_dump_from_init</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Processes interrupted by INIT -&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">__per_cpu_mca</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_MCA_CPU_INIT_STACK_OFFSET</span><span class="p">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span> <span class="o">+</span> <span class="n">MCA_SOS_OFFSET</span><span class="p">);</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %d (cpu %d task 0x%p)&quot;</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">g</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_each_thread</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Backtrace of pid %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">show_stack</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_thread</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* FIXME: This will not restore zapped printk locks. */</span>
	<span class="n">RESTORE_LOGLEVEL</span><span class="p">(</span><span class="n">console_loglevel</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * C portion of the OS INIT handler</span>
<span class="cm"> *</span>
<span class="cm"> * Called from ia64_os_init_dispatch</span>
<span class="cm"> *</span>
<span class="cm"> * Inputs: pointer to pt_regs where processor info was saved.  SAL/OS state for</span>
<span class="cm"> * this event.  This code is used for both monarch and slave INIT events, see</span>
<span class="cm"> * sos-&gt;monarch.</span>
<span class="cm"> *</span>
<span class="cm"> * All INIT events switch to the INIT stack and change the previous process to</span>
<span class="cm"> * blocked status.  If one of the INIT events is the monarch then we are</span>
<span class="cm"> * probably processing the nmi button/command.  Use the monarch cpu to dump all</span>
<span class="cm"> * the processes.  The slave INIT events all spin until the monarch cpu</span>
<span class="cm"> * returns.  We can also get INIT slave events for MCA, in which case the MCA</span>
<span class="cm"> * process is the monarch.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">ia64_init_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">slaves</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">monarchs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">previous_current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">ia64_mca_notify_die</span> <span class="n">nd</span> <span class="o">=</span>
		<span class="p">{</span> <span class="p">.</span><span class="n">sos</span> <span class="o">=</span> <span class="n">sos</span><span class="p">,</span> <span class="p">.</span><span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">monarch_cpu</span> <span class="p">};</span>

	<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_ENTER</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Entered OS INIT handler. PSP=%lx cpu=%d monarch=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">proc_state_param</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span><span class="p">);</span>
	<span class="n">salinfo_log_wakeup</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_INIT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">previous_current</span> <span class="o">=</span> <span class="n">ia64_mca_modify_original_stack</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sos</span><span class="p">,</span> <span class="s">&quot;INIT&quot;</span><span class="p">);</span>
	<span class="n">sos</span><span class="o">-&gt;</span><span class="n">os_status</span> <span class="o">=</span> <span class="n">IA64_INIT_RESUME</span><span class="p">;</span>

	<span class="cm">/* FIXME: Workaround for broken proms that drive all INIT events as</span>
<span class="cm">	 * slaves.  The last slave that enters is promoted to be a monarch.</span>
<span class="cm">	 * Remove this code in September 2006, that gives platforms a year to</span>
<span class="cm">	 * fix their proms and get their customers updated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_online_cpus</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Promoting cpu %d to monarch.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">__func__</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slaves</span><span class="p">);</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: Workaround for broken proms that drive all INIT events as</span>
<span class="cm">	 * monarchs.  Second and subsequent monarchs are demoted to slaves.</span>
<span class="cm">	 * Remove this code in September 2006, that gives platforms a year to</span>
<span class="cm">	 * fix their proms and get their customers updated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monarchs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mprintk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Demoting cpu %d to slave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monarchs</span><span class="p">);</span>
		<span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sos</span><span class="o">-&gt;</span><span class="n">monarch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_INIT</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdump_in_progress</span><span class="p">))</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* spin until monarch enters */</span>
<span class="cp">#endif</span>

		<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_SLAVE_ENTER</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_SLAVE_PROCESS</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kdump_in_progress</span><span class="p">))</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">monarch_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* spin until monarch leaves */</span>
<span class="cp">#endif</span>

		<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_SLAVE_LEAVE</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">mprintk</span><span class="p">(</span><span class="s">&quot;Slave on cpu %d returning to normal service.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">previous_current</span><span class="p">);</span>
		<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slaves</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">monarch_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_MONARCH_ENTER</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for a bit.  On some machines (e.g., HP&#39;s zx2000 and zx6000, INIT can be</span>
<span class="cm">	 * generated via the BMC&#39;s command-line interface, but since the console is on the</span>
<span class="cm">	 * same serial line, the user will need some time to switch out of the BMC before</span>
<span class="cm">	 * the dump begins.</span>
<span class="cm">	 */</span>
	<span class="n">mprintk</span><span class="p">(</span><span class="s">&quot;Delaying for 5 seconds...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">1000000</span><span class="p">);</span>
	<span class="n">ia64_wait_for_slaves</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="s">&quot;INIT&quot;</span><span class="p">);</span>
	<span class="cm">/* If nobody intercepts DIE_INIT_MONARCH_PROCESS then we drop through</span>
<span class="cm">	 * to default_monarch_init_process() above and just print all the</span>
<span class="cm">	 * tasks.</span>
<span class="cm">	 */</span>
	<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_MONARCH_PROCESS</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">NOTIFY_INIT</span><span class="p">(</span><span class="n">DIE_INIT_MONARCH_LEAVE</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">mprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">INIT dump complete.  Monarch on cpu %d returning to normal service.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monarchs</span><span class="p">);</span>
	<span class="n">set_curr_task</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">previous_current</span><span class="p">);</span>
	<span class="n">monarch_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">ia64_mca_disable_cpe_polling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpe_poll_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;disable_cpe_poll&quot;</span><span class="p">,</span> <span class="n">ia64_mca_disable_cpe_polling</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">cmci_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_cmc_int_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;cmc_hndlr&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">cmcp_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_cmc_int_caller</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;cmc_poll&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">mca_rdzv_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_rendez_int_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;mca_rdzv&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">mca_wkup_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_wakeup_int_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;mca_wkup&quot;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">mca_cpe_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_cpe_int_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;cpe_hndlr&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">mca_cpep_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span> <span class="o">=</span>	<span class="n">ia64_mca_cpe_int_caller</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span>	<span class="n">IRQF_DISABLED</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;cpe_poll&quot;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ACPI */</span><span class="cp"></span>

<span class="cm">/* Minimal format of the MCA/INIT stacks.  The pseudo processes that run on</span>
<span class="cm"> * these stacks can never sleep, they cannot return from the kernel to user</span>
<span class="cm"> * space, they do not appear in a normal ps listing.  So there is no need to</span>
<span class="cm"> * format most of the fields.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">format_mca_init_stack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mca_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mca_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">);</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">_TIF_MCA_INIT</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">preempt_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">stack</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">;</span>
	<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller prevents this from being called after init */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init_refok</span> <span class="nf">mca_bootmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_mca_cpu</span><span class="p">),</span>
	                    <span class="n">KERNEL_STACK_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do per-CPU MCA-related initialization.  */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">ia64_mca_cpu_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cpu_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pal_vaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_mca_cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Structure will already be allocated if cpu has been online,</span>
<span class="cm">	 * then offlined.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__per_cpu_mca</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">__per_cpu_mca</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">mca_bootmem</span><span class="p">();</span>
			<span class="n">first_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
							<span class="n">get_order</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not allocate MCA memory for cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">format_mca_init_stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_mca_cpu</span><span class="p">,</span> <span class="n">mca_stack</span><span class="p">),</span>
		<span class="s">&quot;MCA&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">format_mca_init_stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_mca_cpu</span><span class="p">,</span> <span class="n">init_stack</span><span class="p">),</span>
		<span class="s">&quot;INIT&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ia64_mca_data</span><span class="p">)</span> <span class="o">=</span> <span class="n">__per_cpu_mca</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stash away a copy of the PTE needed to map the per-CPU page.</span>
<span class="cm">	 * We may need it during MCA recovery.</span>
<span class="cm">	 */</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ia64_mca_per_cpu_pte</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">),</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also, stash away a copy of the PAL address and the PTE</span>
<span class="cm">	 * needed to map it.</span>
<span class="cm">	 */</span>
	<span class="n">pal_vaddr</span> <span class="o">=</span> <span class="n">efi_get_pal_addr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pal_vaddr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ia64_mca_pal_base</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">GRANULEROUNDDOWN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pal_vaddr</span><span class="p">);</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ia64_mca_pal_pte</span><span class="p">)</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pal_vaddr</span><span class="p">),</span>
							      <span class="n">PAGE_KERNEL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">ia64_mca_cmc_vector_adjust</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmc_polling_enabled</span><span class="p">)</span>
		<span class="n">ia64_mca_cmc_vector_enable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">mca_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hotcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">hotcpu</span><span class="p">,</span> <span class="n">ia64_mca_cmc_vector_adjust</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">mca_cpu_notifier</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">mca_cpu_callback</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_init</span>
<span class="cm"> *</span>
<span class="cm"> *  Do all the system level mca specific initialization.</span>
<span class="cm"> *</span>
<span class="cm"> *	1. Register spinloop and wakeup request interrupt vectors</span>
<span class="cm"> *</span>
<span class="cm"> *	2. Register OS_MCA handler entry point</span>
<span class="cm"> *</span>
<span class="cm"> *	3. Register OS_INIT handler entry point</span>
<span class="cm"> *</span>
<span class="cm"> *  4. Initialize MCA/CMC/INIT related log buffers maintained by the OS.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note that this initialization is done very early before some kernel</span>
<span class="cm"> *  services are available.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   None</span>
<span class="cm"> *</span>
<span class="cm"> *  Outputs :   None</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ia64_mca_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="n">init_hldlr_ptr_monarch</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ia64_os_init_dispatch_monarch</span><span class="p">;</span>
	<span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="n">init_hldlr_ptr_slave</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ia64_os_init_dispatch_slave</span><span class="p">;</span>
	<span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="n">mca_hldlr_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ia64_os_mca_dispatch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">isrv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_TIMEOUT</span><span class="p">;</span> <span class="cm">/* platform specific */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">default_init_monarch_nb</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">default_monarch_init_process</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="cm">/* we need to notified last */</span>
	<span class="p">};</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Clear the Rendez checkin flag for all cpus */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_rendez_checkin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_MCA_RENDEZ_CHECKIN_NOTDONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the rendezvous spinloop and wakeup mechanism with SAL</span>
<span class="cm">	 */</span>

	<span class="cm">/* Register the rendezvous interrupt vector with SAL */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isrv</span> <span class="o">=</span> <span class="n">ia64_sal_mc_set_params</span><span class="p">(</span><span class="n">SAL_MC_PARAM_RENDEZ_INT</span><span class="p">,</span>
					      <span class="n">SAL_MC_PARAM_MECHANISM_INT</span><span class="p">,</span>
					      <span class="n">IA64_MCA_RENDEZ_VECTOR</span><span class="p">,</span>
					      <span class="n">timeout</span><span class="p">,</span>
					      <span class="n">SAL_MC_PARAM_RZ_ALWAYS</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Increasing MCA rendezvous timeout from &quot;</span>
				<span class="s">&quot;%ld to %ld milliseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">isrv</span><span class="p">.</span><span class="n">v0</span><span class="p">);</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">isrv</span><span class="p">.</span><span class="n">v0</span><span class="p">;</span>
			<span class="n">NOTIFY_MCA</span><span class="p">(</span><span class="n">DIE_MCA_NEW_TIMEOUT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register rendezvous interrupt &quot;</span>
		       <span class="s">&quot;with SAL (status %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register the wakeup interrupt vector with SAL */</span>
	<span class="n">isrv</span> <span class="o">=</span> <span class="n">ia64_sal_mc_set_params</span><span class="p">(</span><span class="n">SAL_MC_PARAM_RENDEZ_WAKEUP</span><span class="p">,</span>
				      <span class="n">SAL_MC_PARAM_MECHANISM_INT</span><span class="p">,</span>
				      <span class="n">IA64_MCA_WAKEUP_VECTOR</span><span class="p">,</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register wakeup interrupt with SAL &quot;</span>
		       <span class="s">&quot;(status %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: registered MCA rendezvous spinloop and wakeup mech.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_mca_handler</span>        <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">mca_hldlr_ptr</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX - disable SAL checksum by setting size to 0; should be</span>
<span class="cm">	 *	ia64_tpa(ia64_os_mca_dispatch_end) - ia64_tpa(ia64_os_mca_dispatch);</span>
<span class="cm">	 */</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_mca_handler_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Register the os mca handler with SAL */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ia64_sal_set_vectors</span><span class="p">(</span><span class="n">SAL_VECTOR_OS_MCA</span><span class="p">,</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_mca_handler</span><span class="p">,</span>
				       <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">mca_hldlr_ptr</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">),</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_mca_handler_size</span><span class="p">,</span>
				       <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register OS MCA handler with SAL &quot;</span>
		       <span class="s">&quot;(status %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: registered OS MCA handler with SAL at 0x%lx, gp = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_mca_handler</span><span class="p">,</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">mca_hldlr_ptr</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX - disable SAL checksum by setting size to 0, should be</span>
<span class="cm">	 * size of the actual init handler in mca_asm.S.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_monarch_init_handler</span>		<span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">init_hldlr_ptr_monarch</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_monarch_init_handler_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_slave_init_handler</span>		<span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">init_hldlr_ptr_slave</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_slave_init_handler_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: OS INIT handler at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_monarch_init_handler</span><span class="p">);</span>

	<span class="cm">/* Register the os init handler with SAL */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ia64_sal_set_vectors</span><span class="p">(</span><span class="n">SAL_VECTOR_OS_INIT</span><span class="p">,</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_monarch_init_handler</span><span class="p">,</span>
				       <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_GP</span><span class="p">)),</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_monarch_init_handler_size</span><span class="p">,</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_slave_init_handler</span><span class="p">,</span>
				       <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_GP</span><span class="p">)),</span>
				       <span class="n">ia64_mc_info</span><span class="p">.</span><span class="n">imi_slave_init_handler_size</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register m/s INIT handlers with SAL &quot;</span>
		       <span class="s">&quot;(status %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_init_monarch_nb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to register default monarch INIT process</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: registered OS INIT handler with SAL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Initialize the areas set aside by the OS to buffer the</span>
<span class="cm">	 * platform/processor error states for MCA/INIT/CMC</span>
<span class="cm">	 * handling.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_log_init</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_MCA</span><span class="p">);</span>
	<span class="n">ia64_log_init</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_INIT</span><span class="p">);</span>
	<span class="n">ia64_log_init</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CMC</span><span class="p">);</span>
	<span class="n">ia64_log_init</span><span class="p">(</span><span class="n">SAL_INFO_TYPE_CPE</span><span class="p">);</span>

	<span class="n">mca_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;MCA related initialization done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_mca_late_init</span>
<span class="cm"> *</span>
<span class="cm"> *	Opportunity to setup things that require initialization later</span>
<span class="cm"> *	than ia64_mca_init.  Setup a timer to poll for CPEs if the</span>
<span class="cm"> *	platform doesn&#39;t support an interrupt driven mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> *  Inputs  :   None</span>
<span class="cm"> *  Outputs :   Status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">ia64_mca_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mca_init</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Configure the CMCI/P vector and handler. Interrupts for CMC are</span>
<span class="cm">	 *  per-processor, so AP CMC interrupts are setup in smp_callin() (smpboot.c).</span>
<span class="cm">	 */</span>
	<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_CMC_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmci_irqaction</span><span class="p">);</span>
	<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_CMCP_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmcp_irqaction</span><span class="p">);</span>
	<span class="n">ia64_mca_cmc_vector_setup</span><span class="p">();</span>       <span class="cm">/* Setup vector on BSP */</span>

	<span class="cm">/* Setup the MCA rendezvous interrupt vector */</span>
	<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_MCA_RENDEZ_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mca_rdzv_irqaction</span><span class="p">);</span>

	<span class="cm">/* Setup the MCA wakeup interrupt vector */</span>
	<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_MCA_WAKEUP_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mca_wkup_irqaction</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="cm">/* Setup the CPEI/P handler */</span>
	<span class="n">register_percpu_irq</span><span class="p">(</span><span class="n">IA64_CPEP_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mca_cpep_irqaction</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mca_cpu_notifier</span><span class="p">);</span>

	<span class="cm">/* Setup the CMCI/P vector and handler */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_poll_timer</span><span class="p">);</span>
	<span class="n">cmc_poll_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ia64_mca_cmc_poll</span><span class="p">;</span>

	<span class="cm">/* Unmask/enable the vector */</span>
	<span class="n">cmc_polling_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmc_enable_work</span><span class="p">);</span>

	<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CMCI/P setup and enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="cm">/* Setup the CPEI/P vector and handler */</span>
	<span class="n">cpe_vector</span> <span class="o">=</span> <span class="n">acpi_request_vector</span><span class="p">(</span><span class="n">ACPI_INTERRUPT_CPEI</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpe_poll_timer</span><span class="p">);</span>
	<span class="n">cpe_poll_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ia64_mca_cpe_poll</span><span class="p">;</span>

	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpe_vector</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If platform supports CPEI, enable the irq. */</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">local_vector_to_irq</span><span class="p">(</span><span class="n">cpe_vector</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpe_poll_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_PER_CPU</span><span class="p">);</span>
				<span class="n">setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mca_cpe_irqaction</span><span class="p">);</span>
				<span class="n">ia64_cpe_irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
				<span class="n">ia64_mca_register_cpev</span><span class="p">(</span><span class="n">cpe_vector</span><span class="p">);</span>
				<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPEI/P setup and enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Failed to find irq for CPE &quot;</span>
					<span class="s">&quot;interrupt handler, vector %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">cpe_vector</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* If platform doesn&#39;t support CPEI, get the timer going. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpe_poll_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_mca_cpe_poll</span><span class="p">(</span><span class="mi">0UL</span><span class="p">);</span>
			<span class="n">IA64_MCA_DEBUG</span><span class="p">(</span><span class="s">&quot;%s: CPEP setup and enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">ia64_mca_late_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
