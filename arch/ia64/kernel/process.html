<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › process.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>process.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Architecture-specific setup.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> * 04/11/17 Ashok Raj	&lt;ashok.raj@intel.com&gt; Added CPU Hotplug Support</span>
<span class="cm"> *</span>
<span class="cm"> * 2005-10-07 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> *	      Add notify_die() hooks.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>

<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/elf.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/kexec.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/switch_to.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unwind.h&gt;</span>
<span class="cp">#include &lt;asm/user.h&gt;</span>

<span class="cp">#include &quot;entry.h&quot;</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
<span class="cp"># include &lt;asm/perfmon.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;sigframe.h&quot;</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ia64_mark_idle</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_NO_OVERRIDE</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">boot_option_idle_override</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_idle</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pm_idle</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_power_off</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pm_power_off</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">ia64_do_show_stack</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">bsp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>			<span class="cm">/* don&#39;t make it so big that it overflows the stack! */</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Call Trace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">unw_get_ip</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">unw_get_sp</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
		<span class="n">unw_get_bsp</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bsp</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
			 <span class="s">&quot; [&lt;%016lx&gt;] %%s</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;                                sp=%016lx bsp=%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">bsp</span><span class="p">);</span>
		<span class="n">print_symbol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unw_unwind</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">show_stack</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="n">unw_init_running</span><span class="p">(</span><span class="n">ia64_do_show_stack</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="n">info</span><span class="p">;</span>

		<span class="n">unw_init_from_blocked_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="n">ia64_do_show_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">dump_stack</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">show_stack</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_stack</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">show_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">;</span>

	<span class="n">print_modules</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Pid: %d, CPU %d, comm: %20s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
			<span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;psr : %016lx ifs : %016lx ip  : [&lt;%016lx&gt;]    %s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">print_tainted</span><span class="p">(),</span>
	       <span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">);</span>
	<span class="n">print_symbol</span><span class="p">(</span><span class="s">&quot;ip is at %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;unat: %016lx pfs : %016lx rsc : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_unat</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_pfs</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_rsc</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rnat: %016lx bsps: %016lx pr  : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_rnat</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ldrs: %016lx ccv : %016lx fpsr: %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">loadrs</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_ccv</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_fpsr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;csd : %016lx ssd : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_csd</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_ssd</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;b0  : %016lx b6  : %016lx b7  : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">b0</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">b6</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">b7</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;f6  : %05lx%016lx f7  : %05lx%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f6</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f6</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f7</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f7</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;f8  : %05lx%016lx f9  : %05lx%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f8</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f8</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f9</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f9</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;f10 : %05lx%016lx f11 : %05lx%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f10</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f10</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f11</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">f11</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r1  : %016lx r2  : %016lx r3  : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r1</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r2</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r3</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r8  : %016lx r9  : %016lx r10 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r11 : %016lx r12 : %016lx r13 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r11</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r12</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r13</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r14 : %016lx r15 : %016lx r16 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r14</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r15</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r16</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r17 : %016lx r18 : %016lx r19 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r17</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r18</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r19</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r20 : %016lx r21 : %016lx r22 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r20</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r21</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r22</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r23 : %016lx r24 : %016lx r25 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r23</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r24</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r25</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r26 : %016lx r27 : %016lx r28 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r26</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r27</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r28</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r29 : %016lx r30 : %016lx r31 : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r29</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r30</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r31</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* print the stacked registers */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">bsp</span><span class="p">,</span> <span class="n">ndirty</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sof</span><span class="p">,</span> <span class="n">is_nat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">sof</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>	<span class="cm">/* size of frame */</span>
		<span class="n">ndirty</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">loadrs</span> <span class="o">&gt;&gt;</span> <span class="mi">19</span><span class="p">);</span>
		<span class="n">bsp</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">ndirty</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sof</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">bsp</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;r%-3u:%c%016lx%s&quot;</span><span class="p">,</span> <span class="mi">32</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_nat</span> <span class="o">?</span> <span class="sc">&#39;*&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
			       <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">sof</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">show_stack</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* local support for deprecated console_print */</span>
<span class="kt">void</span>
<span class="nf">console_print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">do_notify_resume_user</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigscratch</span> <span class="o">*</span><span class="n">scr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">in_syscall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsys_mode</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * defer signal-handling etc. until we return to</span>
<span class="cm">		 * privilege-level 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_psr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">)</span>
			<span class="n">ia64_psr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_needs_checking</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: pfm_handle_work() allow us to call it with interrupts</span>
<span class="cm">		 * disabled, and may enable interrupts within the function.</span>
<span class="cm">		 */</span>
		<span class="n">pfm_handle_work</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* deal with pending signal delivery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>	<span class="cm">/* force interrupt enable */</span>
		<span class="n">ia64_do_signal</span><span class="p">(</span><span class="n">scr</span><span class="p">,</span> <span class="n">in_syscall</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTIFY_RESUME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTIFY_RESUME</span><span class="p">);</span>
		<span class="n">tracehook_notify_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scr</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copy user rbs to kernel rbs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_RESTORE_RSE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>	<span class="cm">/* force interrupt enable */</span>
		<span class="n">ia64_sync_krbs</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>	<span class="cm">/* force interrupt disable */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pal_halt</span>        <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">can_do_pal_halt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nohalt_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pal_halt</span> <span class="o">=</span> <span class="n">can_do_pal_halt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nohalt&quot;</span><span class="p">,</span> <span class="n">nohalt_setup</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">update_pal_halt_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">can_do_pal_halt</span> <span class="o">=</span> <span class="n">pal_halt</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use this if we don&#39;t have any better idle routine..</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">default_idle</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_do_pal_halt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">safe_halt</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cm">/* We don&#39;t actually take CPU down, just spin without interrupts. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* Ack it */</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_DEAD</span><span class="p">;</span>

	<span class="n">max_xtp</span><span class="p">();</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">ia64_jump_to_sal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_boot_rendez_state</span><span class="p">[</span><span class="n">this_cpu</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The above is a point of no-return, the processor is</span>
<span class="cm">	 * expected to be in SAL loop now.</span>
<span class="cm">	 */</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span>
<span class="n">cpu_idle</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">mark_idle</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">ia64_mark_idle</span><span class="p">;</span>
  	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* endless idle loop with no priority at all */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_do_pal_halt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * TS_POLLING-cleared state must be visible before we</span>
<span class="cm">			 * test NEED_RESCHED:</span>
<span class="cm">			 */</span>
			<span class="n">smp_mb</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="n">min_xtp</span><span class="p">();</span>
<span class="cp">#endif</span>
			<span class="n">rmb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mark_idle</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">mark_idle</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">idle</span> <span class="o">=</span> <span class="n">pm_idle</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle</span><span class="p">)</span>
				<span class="n">idle</span> <span class="o">=</span> <span class="n">default_idle</span><span class="p">;</span>
			<span class="p">(</span><span class="o">*</span><span class="n">idle</span><span class="p">)();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mark_idle</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">mark_idle</span><span class="p">)(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
			<span class="n">normal_xtp</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="n">schedule_preempt_disabled</span><span class="p">();</span>
		<span class="n">check_pgt_cache</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="n">play_dead</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ia64_save_extra</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">info</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ia64_save_debug_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_PM_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pfm_save_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_SYST_WIDE</span><span class="p">)</span>
		<span class="n">pfm_syst_wide_update_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ia64_load_extra</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">info</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ia64_load_debug_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">dbr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_PM_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pfm_load_regs</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">pfm_syst_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;</span> <span class="n">PFM_CPUINFO_SYST_WIDE</span><span class="p">)</span> 
		<span class="n">pfm_syst_wide_update_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the state of an ia-64 thread.</span>
<span class="cm"> *</span>
<span class="cm"> * We get here through the following  call chain:</span>
<span class="cm"> *</span>
<span class="cm"> *	from user-level:	from kernel:</span>
<span class="cm"> *</span>
<span class="cm"> *	&lt;clone syscall&gt;	        &lt;some kernel call frames&gt;</span>
<span class="cm"> *	sys_clone		   :</span>
<span class="cm"> *	do_fork			do_fork</span>
<span class="cm"> *	copy_thread		copy_thread</span>
<span class="cm"> *</span>
<span class="cm"> * This means that the stack layout is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *	+---------------------+ (highest addr)</span>
<span class="cm"> *	|   struct pt_regs    |</span>
<span class="cm"> *	+---------------------+</span>
<span class="cm"> *	| struct switch_stack |</span>
<span class="cm"> *	+---------------------+</span>
<span class="cm"> *	|                     |</span>
<span class="cm"> *	|    memory stack     |</span>
<span class="cm"> *	|                     | &lt;-- sp (lowest addr)</span>
<span class="cm"> *	+---------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Observe that we copy the unat values that are in pt_regs and switch_stack.  Spilling an</span>
<span class="cm"> * integer to address X causes bit N in ar.unat to be set to the NaT bit of the register,</span>
<span class="cm"> * with N=(X &amp; 0x1ff)/8.  Thus, copying the unat value preserves the NaT bits ONLY if the</span>
<span class="cm"> * pt_regs structure in the parent is congruent to that of the child, modulo 512.  Since</span>
<span class="cm"> * the stack is page aligned and the page size is at least 4KB, this is always the case,</span>
<span class="cm"> * so there is nothing to worry about.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">copy_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_stack_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_stack_size</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">ia64_ret_from_clone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">child_stack</span><span class="p">,</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rbs</span><span class="p">,</span> <span class="n">child_rbs</span><span class="p">,</span> <span class="n">rbs_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">child_ptregs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * For SMP idle threads, fork_by_hand() calls do_fork with</span>
<span class="cm">	 * NULL regs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">stack</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">child_ptregs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span> <span class="o">+</span> <span class="n">IA64_STK_OFFSET</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">child_stack</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">child_ptregs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* copy parent&#39;s switch_stack &amp; pt_regs to child: */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">child_stack</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">child_ptregs</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">child_stack</span><span class="p">));</span>

	<span class="n">rbs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">current</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">;</span>
	<span class="n">child_rbs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">;</span>
	<span class="n">rbs_size</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span> <span class="o">-</span> <span class="n">rbs</span><span class="p">;</span>

	<span class="cm">/* copy the parent&#39;s register backing store to the child: */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">child_rbs</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">rbs</span><span class="p">,</span> <span class="n">rbs_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">child_ptregs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SETTLS</span><span class="p">)</span>
			<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">r13</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">r16</span><span class="p">;</span>	<span class="cm">/* see sys_clone2() in entry.S */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_stack_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">r12</span> <span class="o">=</span> <span class="n">user_stack_base</span> <span class="o">+</span> <span class="n">user_stack_size</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span> <span class="o">=</span> <span class="n">user_stack_base</span><span class="p">;</span>
			<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">ar_rnat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">loadrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: we simply preserve the relative position of</span>
<span class="cm">		 * the stack pointer here.  There is no need to</span>
<span class="cm">		 * allocate a scratch area here, since that will have</span>
<span class="cm">		 * been taken care of by the caller of sys_clone()</span>
<span class="cm">		 * already.</span>
<span class="cm">		 */</span>
		<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">r12</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">child_ptregs</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* kernel sp */</span>
		<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">r13</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>		<span class="cm">/* set `current&#39; pointer */</span>
	<span class="p">}</span>
	<span class="n">child_stack</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span> <span class="o">=</span> <span class="n">child_rbs</span> <span class="o">+</span> <span class="n">rbs_size</span><span class="p">;</span>
	<span class="n">child_stack</span><span class="o">-&gt;</span><span class="n">b0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ia64_ret_from_clone</span><span class="p">;</span>

	<span class="cm">/* copy parts of thread_struct: */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">ksp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">child_stack</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* stop some PSR bits from being inherited.</span>
<span class="cm">	 * the psr.up/psr.pp bits must be cleared on fork but inherited on execve()</span>
<span class="cm">	 * therefore we must specify them explicitly here and not include them in</span>
<span class="cm">	 * IA64_PSR_BITS_TO_CLEAR.</span>
<span class="cm">	 */</span>
	<span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">=</span> <span class="p">((</span><span class="n">child_ptregs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">|</span> <span class="n">IA64_PSR_BITS_TO_SET</span><span class="p">)</span>
				 <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">IA64_PSR_BITS_TO_CLEAR</span> <span class="o">|</span> <span class="n">IA64_PSR_PP</span> <span class="o">|</span> <span class="n">IA64_PSR_UP</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: The calling convention considers all floating point</span>
<span class="cm">	 * registers in the high partition (fph) to be scratch.  Since</span>
<span class="cm">	 * the only way to get to this point is through a system call,</span>
<span class="cm">	 * we know that the values in fph are all dead.  Hence, there</span>
<span class="cm">	 * is no need to inherit the fph state from the parent to the</span>
<span class="cm">	 * child and all we have to do is to make sure that</span>
<span class="cm">	 * IA64_THREAD_FPH_VALID is cleared in the child.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX We could push this optimization a bit further by</span>
<span class="cm">	 * clearing IA64_THREAD_FPH_VALID on ANY system call.</span>
<span class="cm">	 * However, it&#39;s not clear this is worth doing.  Also, it</span>
<span class="cm">	 * would be a slight deviation from the normal Linux system</span>
<span class="cm">	 * call behavior where scratch registers are preserved across</span>
<span class="cm">	 * system calls (unless used by the system call itself).</span>
<span class="cm">	 */</span>
<span class="cp">#	define THREAD_FLAGS_TO_CLEAR	(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID \</span>
<span class="cp">					 | IA64_THREAD_PM_VALID)</span>
<span class="cp">#	define THREAD_FLAGS_TO_SET	0</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">THREAD_FLAGS_TO_CLEAR</span><span class="p">)</span>
			   <span class="o">|</span> <span class="n">THREAD_FLAGS_TO_SET</span><span class="p">);</span>
	<span class="n">ia64_drop_fpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	<span class="cm">/* don&#39;t pick up stale state from a CPU&#39;s fph */</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span><span class="p">)</span>
		<span class="n">pfm_inherit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child_ptregs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_copy_task_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">nat_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ar_rnat</span><span class="p">,</span> <span class="n">urbs_end</span><span class="p">,</span> <span class="n">cfm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>	<span class="cm">/* GCC be quiet */</span>
	<span class="n">elf_greg_t</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">nat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_gregset_t</span><span class="p">));</span>	<span class="cm">/* don&#39;t leak any kernel bits to user-level */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unw_unwind_to_user</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">unw_get_sp</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">sp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">urbs_end</span> <span class="o">=</span> <span class="n">ia64_get_user_rbs_end</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sync_user_rbs</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">urbs_end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ia64_peek</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sw</span><span class="p">,</span> <span class="n">urbs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ia64_rse_rnat_addr</span><span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">urbs_end</span><span class="p">),</span>
		  <span class="o">&amp;</span><span class="n">ar_rnat</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * coredump format:</span>
<span class="cm">	 *	r0-r31</span>
<span class="cm">	 *	NaT bits (for r0-r31; bit N == 1 iff rN is a NaT)</span>
<span class="cm">	 *	predicate registers (p0-p63)</span>
<span class="cm">	 *	b0-b7</span>
<span class="cm">	 *	ip cfm user-mask</span>
<span class="cm">	 *	ar.rsc ar.bsp ar.bspstore ar.rnat</span>
<span class="cm">	 *	ar.ccv ar.unat ar.fpsr ar.pfs ar.lc ar.ec</span>
<span class="cm">	 */</span>

	<span class="cm">/* r0 is zero */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unw_get_gr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">nat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
			<span class="n">nat_bits</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">nat_bits</span><span class="p">;</span>
	<span class="n">unw_get_pr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">33</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">unw_get_br</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">34</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>

	<span class="n">unw_get_rp</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span> <span class="o">+</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">;</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">43</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfm</span><span class="p">;</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">44</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">&amp;</span> <span class="n">IA64_PSR_UM</span><span class="p">;</span>

	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_RSC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">45</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * For bsp and bspstore, unw_get_ar() would return the kernel</span>
<span class="cm">	 * addresses, but we need the user-level addresses instead:</span>
<span class="cm">	 */</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">46</span><span class="p">]</span> <span class="o">=</span> <span class="n">urbs_end</span><span class="p">;</span>	<span class="cm">/* note: by convention PT_AR_BSP points to the end of the urbs! */</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">47</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">;</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">=</span> <span class="n">ar_rnat</span><span class="p">;</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_CCV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">49</span><span class="p">]);</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_UNAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">50</span><span class="p">]);</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_FPSR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">51</span><span class="p">]);</span>
	<span class="n">dst</span><span class="p">[</span><span class="mi">52</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">ar_pfs</span><span class="p">;</span>	<span class="cm">/* UNW_AR_PFS is == to pt-&gt;cr_ifs for interrupt frames */</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_LC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">53</span><span class="p">]);</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_EC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">54</span><span class="p">]);</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_CSD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">55</span><span class="p">]);</span>
	<span class="n">unw_get_ar</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">UNW_AR_SSD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">56</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">do_dump_task_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elf_fpreg_t</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_fpregset_t</span><span class="p">));</span>	<span class="cm">/* don&#39;t leak any &quot;random&quot; bits */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unw_unwind_to_user</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* f0 is 0.0, f1 is 1.0 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">unw_get_fr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">ia64_flush_fph</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_FPH_VALID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">32</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fph</span><span class="p">,</span> <span class="mi">96</span><span class="o">*</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">do_copy_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_copy_task_regs</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">do_dump_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_dump_task_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ia64_elf_core_copy_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">elf_gregset_t</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unw_init_running</span><span class="p">(</span><span class="n">do_copy_regs</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">dump_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">elf_fpregset_t</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unw_init_running</span><span class="p">(</span><span class="n">do_dump_fpu</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* f0-f31 are always valid so we always return 1 */</span>
<span class="p">}</span>

<span class="kt">long</span>
<span class="nf">sys_execve</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
	    <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span>
	    <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">envp</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">do_execve</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pid_t</span>
<span class="nf">kernel_thread</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_kernel_thread</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">helper_fptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">start_kernel_thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">switch_stack</span> <span class="n">sw</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">pt</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">cr_iip</span> <span class="o">=</span> <span class="n">helper_fptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* set entry point (IP) */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">r1</span> <span class="o">=</span> <span class="n">helper_fptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* set GP */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">r9</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fn</span><span class="p">;</span>	<span class="cm">/* 1st argument */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">r11</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>	<span class="cm">/* 2nd argument */</span>
	<span class="cm">/* Preserve PSR bits, except for bits 32-34 and 37-45, which we can&#39;t read.  */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">cr_ipsr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_PSR</span><span class="p">)</span> <span class="o">|</span> <span class="n">IA64_PSR_BN</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">cr_ifs</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">;</span>		<span class="cm">/* mark as valid, empty frame */</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">sw</span><span class="p">.</span><span class="n">ar_fpsr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">ar_fpsr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_AR_FPSR</span><span class="p">);</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">sw</span><span class="p">.</span><span class="n">ar_bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">current</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">sw</span><span class="p">.</span><span class="n">pr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PRED_KERNEL_STACK</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">CLONE_UNTRACED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_thread</span><span class="p">);</span>

<span class="cm">/* This gets called from kernel_thread() via ia64_invoke_thread_helper().  */</span>
<span class="kt">int</span>
<span class="nf">kernel_thread_helper</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush thread state.  This is called when a thread does an execve().</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">flush_thread</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* drop floating-point and debug-register state if it exists: */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IA64_THREAD_FPH_VALID</span> <span class="o">|</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">);</span>
	<span class="n">ia64_drop_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up state associated with current thread.  This is called when</span>
<span class="cm"> * the thread calls exit().</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">exit_thread</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ia64_drop_fpu</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PERFMON</span>
       <span class="cm">/* if needed, stop monitoring and flush state to perfmon context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">pfm_context</span><span class="p">)</span>
		<span class="n">pfm_exit_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* free debug register resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_DBG_VALID</span><span class="p">)</span>
		<span class="n">pfm_release_debug_registers</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">get_wchan</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: p may not be a blocked task (it could be current or</span>
<span class="cm">	 * another process running on some other CPU.  Rather than</span>
<span class="cm">	 * trying to determine if p is really blocked, we just assume</span>
<span class="cm">	 * it&#39;s blocked and rely on the unwind routines to fail</span>
<span class="cm">	 * gracefully if the process wasn&#39;t really blocked after all.</span>
<span class="cm">	 * --davidm 99/12/15</span>
<span class="cm">	 */</span>
	<span class="n">unw_init_from_blocked_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unw_unwind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">unw_get_ip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sched_functions</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">cpu_halt</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pal_power_mgmt_info_u_t</span> <span class="n">power_info</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_power</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_power_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_pal_halt_info</span><span class="p">(</span><span class="n">power_info</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">min_power_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">min_power</span> <span class="o">=</span> <span class="n">power_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pal_power_mgmt_info_s</span><span class="p">.</span><span class="n">power_consumption</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">power_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pal_power_mgmt_info_s</span><span class="p">.</span><span class="n">im</span>
		    <span class="o">&amp;&amp;</span> <span class="n">power_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pal_power_mgmt_info_s</span><span class="p">.</span><span class="n">power_consumption</span> <span class="o">&lt;</span> <span class="n">min_power</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_power</span> <span class="o">=</span> <span class="n">power_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pal_power_mgmt_info_s</span><span class="p">.</span><span class="n">power_consumption</span><span class="p">;</span>
			<span class="n">min_power_state</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ia64_pal_halt</span><span class="p">(</span><span class="n">min_power_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">machine_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
			<span class="n">cpu_down</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="n">kexec_disable_iosapic</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">machine_restart</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">restart_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_MACHINE_RESTART</span><span class="p">,</span> <span class="n">restart_cmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">(</span><span class="o">*</span><span class="n">efi</span><span class="p">.</span><span class="n">reset_system</span><span class="p">)(</span><span class="n">EFI_RESET_WARM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">machine_halt</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_MACHINE_HALT</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cpu_halt</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">machine_power_off</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_power_off</span><span class="p">)</span>
		<span class="n">pm_power_off</span><span class="p">();</span>
	<span class="n">machine_halt</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
