<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › module.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>module.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IA-64-specific support for kernel module loader.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Loosely based on patch by Rusty Russell.</span>
<span class="cm"> */</span>

<span class="cm">/* relocs tested so far:</span>

<span class="cm">   DIR64LSB</span>
<span class="cm">   FPTR64LSB</span>
<span class="cm">   GPREL22</span>
<span class="cm">   LDXMOV</span>
<span class="cm">   LDXMOV</span>
<span class="cm">   LTOFF22</span>
<span class="cm">   LTOFF22X</span>
<span class="cm">   LTOFF22X</span>
<span class="cm">   LTOFF_FPTR22</span>
<span class="cm">   PCREL21B	(for br.call only; br.cond is not supported out of modules!)</span>
<span class="cm">   PCREL60B	(for brl.cond only; brl.call is not supported for modules!)</span>
<span class="cm">   PCREL64LSB</span>
<span class="cm">   SECREL32LSB</span>
<span class="cm">   SEGREL64LSB</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>

<span class="cp">#include &lt;asm/patch.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#define ARCH_MODULE_DEBUG 0</span>

<span class="cp">#if ARCH_MODULE_DEBUG</span>
<span class="cp"># define DEBUGP printk</span>
<span class="cp"># define inline</span>
<span class="cp">#else</span>
<span class="cp"># define DEBUGP(fmt , a...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ITANIUM</span>
<span class="cp"># define USE_BRL	0</span>
<span class="cp">#else</span>
<span class="cp"># define USE_BRL	1</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_LTOFF	((uint64_t) (1 &lt;&lt; 22))	</span><span class="cm">/* max. allowable linkage-table offset */</span><span class="cp"></span>

<span class="cm">/* Define some relocation helper macros/types: */</span>

<span class="cp">#define FORMAT_SHIFT	0</span>
<span class="cp">#define FORMAT_BITS	3</span>
<span class="cp">#define FORMAT_MASK	((1 &lt;&lt; FORMAT_BITS) - 1)</span>
<span class="cp">#define VALUE_SHIFT	3</span>
<span class="cp">#define VALUE_BITS	5</span>
<span class="cp">#define VALUE_MASK	((1 &lt;&lt; VALUE_BITS) - 1)</span>

<span class="k">enum</span> <span class="n">reloc_target_format</span> <span class="p">{</span>
	<span class="cm">/* direct encoded formats: */</span>
	<span class="n">RF_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RF_INSN14</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RF_INSN22</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RF_INSN64</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RF_32MSB</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">RF_32LSB</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">RF_64MSB</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">RF_64LSB</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

	<span class="cm">/* formats that cannot be directly decoded: */</span>
	<span class="n">RF_INSN60</span><span class="p">,</span>
	<span class="n">RF_INSN21B</span><span class="p">,</span>	<span class="cm">/* imm21 form 1 */</span>
	<span class="n">RF_INSN21M</span><span class="p">,</span>	<span class="cm">/* imm21 form 2 */</span>
	<span class="n">RF_INSN21F</span>	<span class="cm">/* imm21 form 3 */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">reloc_value_formula</span> <span class="p">{</span>
	<span class="n">RV_DIRECT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>		<span class="cm">/* S + A */</span>
	<span class="n">RV_GPREL</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>		<span class="cm">/* @gprel(S + A) */</span>
	<span class="n">RV_LTREL</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>		<span class="cm">/* @ltoff(S + A) */</span>
	<span class="n">RV_PLTREL</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>		<span class="cm">/* @pltoff(S + A) */</span>
	<span class="n">RV_FPTR</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>		<span class="cm">/* @fptr(S + A) */</span>
	<span class="n">RV_PCREL</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>		<span class="cm">/* S + A - P */</span>
	<span class="n">RV_LTREL_FPTR</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* @ltoff(@fptr(S + A)) */</span>
	<span class="n">RV_SEGREL</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>		<span class="cm">/* @segrel(S + A) */</span>
	<span class="n">RV_SECREL</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>		<span class="cm">/* @secrel(S + A) */</span>
	<span class="n">RV_BDREL</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>		<span class="cm">/* BD + A */</span>
	<span class="n">RV_LTV</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>		<span class="cm">/* S + A (like RV_DIRECT, except frozen at static link-time) */</span>
	<span class="n">RV_PCREL2</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>		<span class="cm">/* S + A - P */</span>
	<span class="n">RV_SPECIAL</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>	<span class="cm">/* various (see below) */</span>
	<span class="n">RV_RSVD17</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">RV_TPREL</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>		<span class="cm">/* @tprel(S + A) */</span>
	<span class="n">RV_LTREL_TPREL</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>	<span class="cm">/* @ltoff(@tprel(S + A)) */</span>
	<span class="n">RV_DTPMOD</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>		<span class="cm">/* @dtpmod(S + A) */</span>
	<span class="n">RV_LTREL_DTPMOD</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>	<span class="cm">/* @ltoff(@dtpmod(S + A)) */</span>
	<span class="n">RV_DTPREL</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>		<span class="cm">/* @dtprel(S + A) */</span>
	<span class="n">RV_LTREL_DTPREL</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>	<span class="cm">/* @ltoff(@dtprel(S + A)) */</span>
	<span class="n">RV_RSVD24</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	<span class="n">RV_RSVD25</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
	<span class="n">RV_RSVD26</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
	<span class="n">RV_RSVD27</span> <span class="o">=</span> <span class="mi">27</span>
	<span class="cm">/* 28-31 reserved for implementation-specific purposes.  */</span>
<span class="p">};</span>

<span class="cp">#define N(reloc)	[R_IA64_##reloc] = #reloc</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reloc_name</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">N</span><span class="p">(</span><span class="n">NONE</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">IMM14</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">IMM22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">IMM64</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">DIR32MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DIR32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DIR64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DIR64LSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">GPREL22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">GPREL64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">GPREL32MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">GPREL32LSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">GPREL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">GPREL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF64I</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">PLTOFF22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PLTOFF64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PLTOFF64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PLTOFF64LSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">FPTR64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">FPTR32MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">FPTR32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">FPTR64MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">FPTR64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL60B</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL21B</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL21M</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">PCREL21F</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL32MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL64MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">PCREL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR22</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR64I</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR32LSB</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR64MSB</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_FPTR64LSB</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">SEGREL32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">SEGREL32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">SEGREL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">SEGREL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">SECREL32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">SECREL32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">SECREL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">SECREL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">REL32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">REL32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">REL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">REL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTV32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">LTV32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTV64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTV64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL21BI</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">PCREL22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">PCREL64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">IPLTMSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">IPLTLSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">COPY</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF22X</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LDXMOV</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">TPREL14</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">TPREL22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">TPREL64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">TPREL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">TPREL64LSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_TPREL22</span><span class="p">),</span>	<span class="n">N</span><span class="p">(</span><span class="n">DTPMOD64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPMOD64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_DTPMOD22</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">DTPREL14</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPREL22</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPREL64I</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPREL32MSB</span><span class="p">),</span>
	<span class="n">N</span><span class="p">(</span><span class="n">DTPREL32LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPREL64MSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">DTPREL64LSB</span><span class="p">),</span>		<span class="n">N</span><span class="p">(</span><span class="n">LTOFF_DTPREL22</span><span class="p">)</span>
<span class="p">};</span>

<span class="cp">#undef N</span>

<span class="cm">/* Opaque struct for insns, to protect against derefs. */</span>
<span class="k">struct</span> <span class="n">insn</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">bundle</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">slot</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">apply_imm64</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: invalid slot number %d for IMM64</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slot</span><span class="p">(</span><span class="n">insn</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ia64_patch_imm64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">insn</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">apply_imm60</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: invalid slot number %d for IMM60</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slot</span><span class="p">(</span><span class="n">insn</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">59</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">60</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: value %ld out of IMM60 range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ia64_patch_imm60</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">insn</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">apply_imm22</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: value %li out of IMM22 range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ia64_patch</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">insn</span><span class="p">,</span> <span class="mh">0x01fffcfe000UL</span><span class="p">,</span> <span class="p">(</span>  <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x200000UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="cm">/* bit 21 -&gt; 36 */</span>
					         <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x1f0000UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span>  <span class="mi">6</span><span class="p">)</span> <span class="cm">/* bit 16 -&gt; 22 */</span>
					         <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x00ff80UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="cm">/* bit  7 -&gt; 27 */</span>
					         <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x00007fUL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="cm">/* bit  0 -&gt; 13 */</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">apply_imm21b</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: value %li out of IMM21b range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ia64_patch</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">insn</span><span class="p">,</span> <span class="mh">0x11ffffe000UL</span><span class="p">,</span> <span class="p">(</span>  <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x100000UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="cm">/* bit 20 -&gt; 36 */</span>
					        <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x0fffffUL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="cm">/* bit  0 -&gt; 13 */</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if USE_BRL</span>

<span class="k">struct</span> <span class="n">plt_entry</span> <span class="p">{</span>
	<span class="cm">/* Three instruction bundles in PLT. */</span>
 	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bundle</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">plt_entry</span> <span class="n">ia64_plt_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">{</span>
			<span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* [MLX] nop.m 0 */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="cm">/*	     movl gp=TARGET_GP */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x60</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* [MLX] nop.m 0 */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*	     brl.many gp=TARGET_GP */</span>
			<span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xc0</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">patch_plt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">plt_entry</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="kt">long</span> <span class="n">target_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_gp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apply_imm64</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">target_gp</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">apply_imm60</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
			   <span class="p">(</span><span class="n">target_ip</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">plt_target</span> <span class="p">(</span><span class="k">struct</span> <span class="n">plt_entry</span> <span class="o">*</span><span class="n">plt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">long</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">off</span> <span class="o">=</span> <span class="p">(</span>  <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x00fffff000000000UL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">36</span><span class="p">)</span>		<span class="cm">/* imm20b -&gt; bit 0 */</span>
	       <span class="o">|</span> <span class="p">((</span><span class="n">b0</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x7fffffUL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">36</span><span class="p">)</span>	<span class="cm">/* imm39 -&gt; bit 20 */</span>
	       <span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x0800000000000000UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">));</span>		<span class="cm">/* i -&gt; bit 59 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="n">off</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !USE_BRL */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">plt_entry</span> <span class="p">{</span>
	<span class="cm">/* Three instruction bundles in PLT. */</span>
 	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bundle</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">plt_entry</span> <span class="n">ia64_plt_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">{</span>
			<span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* [MLX] nop.m 0 */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*	     movl r16=TARGET_IP */</span>
			<span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x60</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* [MLX] nop.m 0 */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="cm">/*	     movl gp=TARGET_GP */</span>
			<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x60</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* [MIB] nop.m 0 */</span>
			<span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/*	     mov b6=r16 */</span>
			<span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span>		    <span class="cm">/*	     br.few b6 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">patch_plt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">plt_entry</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="kt">long</span> <span class="n">target_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target_gp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apply_imm64</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">target_ip</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">apply_imm64</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">target_gp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">plt_target</span> <span class="p">(</span><span class="k">struct</span> <span class="n">plt_entry</span> <span class="o">*</span><span class="n">plt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span>  <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x000007f000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">36</span><span class="p">)</span>		<span class="cm">/* imm7b -&gt; bit 0 */</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x07fc000000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">43</span><span class="p">)</span>		<span class="cm">/* imm9d -&gt; bit 7 */</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x0003e00000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">29</span><span class="p">)</span>		<span class="cm">/* imm5c -&gt; bit 16 */</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x0000100000000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">)</span>		<span class="cm">/* ic -&gt; bit 21 */</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">b0</span> <span class="o">&gt;&gt;</span> <span class="mi">46</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x7fffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">)</span>	<span class="cm">/* imm41 -&gt; bit 22 */</span>
		<span class="o">|</span> <span class="p">((</span><span class="n">b1</span> <span class="o">&amp;</span> <span class="mh">0x0800000000000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">));</span>		<span class="cm">/* i -&gt; bit 63 */</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !USE_BRL */</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">module_free</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">module_region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span> <span class="o">&amp;&amp;</span>
	    <span class="n">module_region</span> <span class="o">==</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unw_remove_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span><span class="p">);</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">module_region</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Have we already seen one of these relocations? */</span>
<span class="cm">/* FIXME: we could look in other sections, too --RR */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">duplicate_reloc</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span> <span class="o">==</span> <span class="n">rela</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">r_info</span> <span class="o">&amp;&amp;</span> <span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span> <span class="o">==</span> <span class="n">rela</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">r_addend</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Count how many GOT entries we may need */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">count_gots</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Sure, this is order(n^2), but it&#39;s usually short, and not</span>
<span class="cm">           time critical */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF22</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF22X</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF64I</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR22</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64I</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR32MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR32LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64LSB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">duplicate_reloc</span><span class="p">(</span><span class="n">rela</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Count how many PLT entries we may need */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">count_plts</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Sure, this is order(n^2), but it&#39;s usually short, and not</span>
<span class="cm">           time critical */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21B</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PLTOFF22</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PLTOFF64I</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PLTOFF64MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PLTOFF64LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_IPLTMSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_IPLTLSB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">duplicate_reloc</span><span class="p">(</span><span class="n">rela</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We need to create an function-descriptors for any internal function</span>
<span class="cm">   which is referenced. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">count_fdescs</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Sure, this is order(n^2), but it&#39;s usually short, and not time critical.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_FPTR64I</span>:
		      <span class="k">case</span> <span class="n">R_IA64_FPTR32LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_FPTR32MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_FPTR64LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_FPTR64MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR22</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR32LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR32MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64I</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_LTOFF_FPTR64MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_IPLTMSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_IPLTLSB</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Jumps to static functions sometimes go straight to their</span>
<span class="cm">			 * offset.  Of course, that may not be possible if the jump is</span>
<span class="cm">			 * from init -&gt; core or vice. versa, so we need to generate an</span>
<span class="cm">			 * FDESC (and PLT etc) for that.</span>
<span class="cm">			 */</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21B</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">duplicate_reloc</span><span class="p">(</span><span class="n">rela</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">module_frob_arch_sections</span> <span class="p">(</span><span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">ehdr</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">core_plts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">init_plts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fdescs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Elf64_Shdr</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">sechdrs_end</span> <span class="o">=</span> <span class="n">sechdrs</span> <span class="o">+</span> <span class="n">ehdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To store the PLTs and function-descriptors, we expand the .text section for</span>
<span class="cm">	 * core module-code and the .init.text section for initialization code.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">sechdrs_end</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.core.plt&quot;</span><span class="p">,</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.init.plt&quot;</span><span class="p">,</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.got&quot;</span><span class="p">,</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.opd&quot;</span><span class="p">,</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.IA_64.unwind&quot;</span><span class="p">,</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.paravirt_bundles&quot;</span><span class="p">,</span>
				<span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_bundles</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;.paravirt_insts&quot;</span><span class="p">,</span>
				<span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_insts</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span> <span class="o">||</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span> <span class="o">||</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span> <span class="o">||</span> <span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: sections missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* GOT and PLTs can occur in any relocated section... */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">sechdrs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">sechdrs_end</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ehdr</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">numrels</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Elf64_Rela</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_RELA</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">gots</span> <span class="o">+=</span> <span class="n">count_gots</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">numrels</span><span class="p">);</span>
		<span class="n">fdescs</span> <span class="o">+=</span> <span class="n">count_fdescs</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">numrels</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">,</span> <span class="s">&quot;.init&quot;</span><span class="p">))</span>
			<span class="n">init_plts</span> <span class="o">+=</span> <span class="n">count_plts</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">numrels</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">core_plts</span> <span class="o">+=</span> <span class="n">count_plts</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">numrels</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">=</span> <span class="n">SHT_NOBITS</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">=</span> <span class="n">SHF_EXECINSTR</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">core_plts</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">plt_entry</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">=</span> <span class="n">SHT_NOBITS</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">=</span> <span class="n">SHF_EXECINSTR</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">init_plts</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">plt_entry</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">=</span> <span class="n">SHT_NOBITS</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">=</span> <span class="n">ARCH_SHF_SMALL</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">gots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">got_entry</span><span class="p">);</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">=</span> <span class="n">SHT_NOBITS</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">=</span> <span class="n">SHF_ALLOC</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">fdescs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fdesc</span><span class="p">);</span>
	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: core.plt=%lx, init.plt=%lx, got=%lx, fdesc=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">,</span>
	       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">in_init</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">in_core</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">&lt;</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">is_internal</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">||</span> <span class="n">in_core</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get gp-relative offset for the linkage-table entry of VALUE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint64_t</span>
<span class="nf">get_ltoff</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">okp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">got_entry</span> <span class="o">*</span><span class="n">got</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">okp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">got</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">got</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">got</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">next_got_entry</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="cm">/* Not enough GOT entries? */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">got_entry</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">got</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">));</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="o">++</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">next_got_entry</span><span class="p">;</span>
  <span class="nl">found:</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">e</span> <span class="o">-</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">gp_addressable</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">value</span> <span class="o">-</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span> <span class="o">+</span> <span class="n">MAX_LTOFF</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">MAX_LTOFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get PC-relative PLT entry for this value.  Returns 0 on failure. */</span>
<span class="k">static</span> <span class="kt">uint64_t</span>
<span class="nf">get_plt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">okp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">plt_entry</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="o">*</span><span class="n">plt_end</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">target_gp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">okp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">insn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">plt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="n">plt_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">plt</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">plt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
		<span class="n">plt_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">plt</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_plt</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* &quot;value&quot; is a pointer to a function-descriptor; fetch the target ip/gp from it: */</span>
	<span class="n">target_ip</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">target_gp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">value</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Look for existing PLT entry. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">plt</span><span class="o">-&gt;</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">plt_target</span><span class="p">(</span><span class="n">plt</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_ip</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">plt</span> <span class="o">&gt;=</span> <span class="n">plt_end</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">plt</span> <span class="o">=</span> <span class="n">ia64_plt_template</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">patch_plt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">plt</span><span class="p">,</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">target_gp</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">okp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if ARCH_MODULE_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plt_target</span><span class="p">(</span><span class="n">plt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">target_ip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: mistargeted PLT: wanted %lx, got %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">plt_target</span><span class="p">(</span><span class="n">plt</span><span class="p">));</span>
		<span class="o">*</span><span class="n">okp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
  <span class="nl">found:</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">plt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get function descriptor for VALUE. */</span>
<span class="k">static</span> <span class="kt">uint64_t</span>
<span class="nf">get_fdesc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">okp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fdesc</span> <span class="o">*</span><span class="n">fdesc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">okp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: fdesc for zero requested!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_internal</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s not a module-local entry-point, &quot;value&quot; already points to a</span>
<span class="cm">		 * function-descriptor.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Look for existing function descriptor. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">fdesc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">++</span><span class="n">fdesc</span> <span class="o">&gt;=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">opd</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Create new one */</span>
	<span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">fdesc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">do_reloc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">r_type</span><span class="p">,</span> <span class="n">Elf64_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addend</span><span class="p">,</span>
	  <span class="n">Elf64_Shdr</span> <span class="o">*</span><span class="n">sec</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">reloc_target_format</span> <span class="n">format</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_type</span> <span class="o">&gt;&gt;</span> <span class="n">FORMAT_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FORMAT_MASK</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">reloc_value_formula</span> <span class="n">formula</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_type</span> <span class="o">&gt;&gt;</span> <span class="n">VALUE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VALUE_MASK</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">formula</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">RV_SEGREL</span>:	<span class="cm">/* segment base is arbitrarily chosen to be 0 for kernel modules */</span>
	      <span class="k">case</span> <span class="n">RV_DIRECT</span>:
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_GPREL</span>:	  <span class="n">val</span> <span class="o">-=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RV_LTREL</span>:	  <span class="n">val</span> <span class="o">=</span> <span class="n">get_ltoff</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RV_PLTREL</span>:	  <span class="n">val</span> <span class="o">=</span> <span class="n">get_plt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RV_FPTR</span>:	  <span class="n">val</span> <span class="o">=</span> <span class="n">get_fdesc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RV_SECREL</span>:	  <span class="n">val</span> <span class="o">-=</span> <span class="n">sec</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RV_LTREL_FPTR</span>: <span class="n">val</span> <span class="o">=</span> <span class="n">get_ltoff</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">get_fdesc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_PCREL</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">r_type</span><span class="p">)</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21B</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">in_core</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">location</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">in_core</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">location</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Init section may have been allocated far away from core,</span>
<span class="cm">				 * if the branch won&#39;t reach, then allocate a plt for it.</span>
<span class="cm">				 */</span>
				<span class="kt">uint64_t</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">val</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">location</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">get_fdesc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">get_plt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_internal</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">get_plt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
			<span class="cm">/* FALL THROUGH */</span>
		      <span class="nl">default:</span>
			<span class="n">val</span> <span class="o">-=</span> <span class="n">bundle</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		      <span class="k">case</span> <span class="n">R_IA64_PCREL32MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PCREL32LSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PCREL64MSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_PCREL64LSB</span>:
			<span class="n">val</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">location</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">r_type</span><span class="p">)</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL60B</span>: <span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN60</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21B</span>: <span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN21B</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21M</span>: <span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN21M</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		      <span class="k">case</span> <span class="n">R_IA64_PCREL21F</span>: <span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN21F</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		      <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_BDREL</span>:
		<span class="n">val</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="p">(</span><span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">?</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_init</span> <span class="o">:</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_LTV</span>:
		<span class="cm">/* can link-time value relocs happen here?  */</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_PCREL2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">r_type</span> <span class="o">==</span> <span class="n">R_IA64_PCREL21BI</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_internal</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: %s reloc against &quot;</span>
					<span class="s">&quot;non-local symbol (%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN21B</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">val</span> <span class="o">-=</span> <span class="n">bundle</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_SPECIAL</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">r_type</span><span class="p">)</span> <span class="p">{</span>
		      <span class="k">case</span> <span class="n">R_IA64_IPLTMSB</span>:
		      <span class="k">case</span> <span class="n">R_IA64_IPLTLSB</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">get_fdesc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">get_plt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
			<span class="n">format</span> <span class="o">=</span> <span class="n">RF_64LSB</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_type</span> <span class="o">==</span> <span class="n">R_IA64_IPLTMSB</span><span class="p">)</span>
				<span class="n">format</span> <span class="o">=</span> <span class="n">RF_64MSB</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		      <span class="k">case</span> <span class="n">R_IA64_SUB</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">addend</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
			<span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN64</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		      <span class="k">case</span> <span class="n">R_IA64_LTOFF22X</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">gp_addressable</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">-=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">get_ltoff</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
			<span class="n">format</span> <span class="o">=</span> <span class="n">RF_INSN22</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		      <span class="k">case</span> <span class="n">R_IA64_LDXMOV</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">gp_addressable</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* turn &quot;ld8&quot; into &quot;mov&quot;: */</span>
				<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: patching ld8 at %p to mov</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
				<span class="n">ia64_patch</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">location</span><span class="p">,</span> <span class="mh">0x1fff80fe000UL</span><span class="p">,</span> <span class="mh">0x10000000000UL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		      <span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">])</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: special reloc %s not supported&quot;</span><span class="p">,</span>
				       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unknown special reloc %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r_type</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">RV_TPREL</span>:
	      <span class="k">case</span> <span class="n">RV_LTREL_TPREL</span>:
	      <span class="k">case</span> <span class="n">RV_DTPMOD</span>:
	      <span class="k">case</span> <span class="n">RV_LTREL_DTPMOD</span>:
	      <span class="k">case</span> <span class="n">RV_DTPREL</span>:
	      <span class="k">case</span> <span class="n">RV_LTREL_DTPREL</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: %s reloc not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">?</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	      <span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unknown reloc %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">r_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: [%p]&lt;-%016lx = %s(%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
	       <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">?</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">+</span> <span class="n">addend</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">RF_INSN21B</span>:	<span class="n">ok</span> <span class="o">=</span> <span class="n">apply_imm21b</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">val</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_INSN22</span>:	<span class="n">ok</span> <span class="o">=</span> <span class="n">apply_imm22</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_INSN64</span>:	<span class="n">ok</span> <span class="o">=</span> <span class="n">apply_imm64</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_INSN60</span>:	<span class="n">ok</span> <span class="o">=</span> <span class="n">apply_imm60</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">val</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_32LSB</span>:	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">location</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_64LSB</span>:	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">location</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">RF_32MSB</span>:	<span class="cm">/* ia64 Linux is little-endian... */</span>
	      <span class="k">case</span> <span class="n">RF_64MSB</span>:	<span class="cm">/* ia64 Linux is little-endian... */</span>
	      <span class="k">case</span> <span class="n">RF_INSN14</span>:	<span class="cm">/* must be within-module, i.e., resolved by &quot;ld -r&quot; */</span>
	      <span class="k">case</span> <span class="n">RF_INSN21M</span>:	<span class="cm">/* must be within-module, i.e., resolved by &quot;ld -r&quot; */</span>
	      <span class="k">case</span> <span class="n">RF_INSN21F</span>:	<span class="cm">/* must be within-module, i.e., resolved by &quot;ld -r&quot; */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: format %u needed by %s reloc is not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">?</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	      <span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: relocation %s resulted in unknown format %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">?</span> <span class="n">reloc_name</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ok</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">apply_relocate_add</span> <span class="p">(</span><span class="n">Elf64_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf64_Rela</span><span class="p">);</span>
	<span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rela</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">Elf64_Shdr</span> <span class="o">*</span><span class="n">target_sec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: applying section %u (%u relocs) to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
	       <span class="n">relsec</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">);</span>

	<span class="n">target_sec</span> <span class="o">=</span> <span class="n">sechdrs</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_sec</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If target section wasn&#39;t allocated, we don&#39;t need to relocate it.</span>
<span class="cm">		 * Happens, e.g., for debug sections.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX Should have an arch-hook for running this after final section</span>
<span class="cm">		 *     addresses have been selected...</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">gp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">&gt;</span> <span class="n">MAX_LTOFF</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * This takes advantage of fact that SHF_ARCH_SMALL gets allocated</span>
<span class="cm">			 * at the end of the module.</span>
<span class="cm">			 */</span>
			<span class="n">gp</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">-</span> <span class="n">MAX_LTOFF</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">gp</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">gp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">module_core</span> <span class="o">+</span> <span class="p">((</span><span class="n">gp</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span> <span class="o">=</span> <span class="n">gp</span><span class="p">;</span>
		<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: placing gp at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_reloc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">),</span>
			       <span class="p">((</span><span class="n">Elf64_Sym</span> <span class="o">*</span><span class="p">)</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span>
				<span class="o">+</span> <span class="n">ELF64_R_SYM</span><span class="p">(</span><span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">)),</span>
			       <span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span><span class="p">,</span> <span class="n">target_sec</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">target_sec</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">+</span> <span class="n">rela</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Modules contain a single unwind table which covers both the core and the init text</span>
<span class="cm"> * sections but since the two are not contiguous, we need to split this table up such that</span>
<span class="cm"> * we can register (and unregister) each &quot;segment&quot; separately.  Fortunately, this sounds</span>
<span class="cm"> * more complicated than it really is.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">register_unwind_table</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_table_entry</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unw_table_entry</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unw_table_entry</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">e1</span><span class="p">,</span> <span class="o">*</span><span class="n">e2</span><span class="p">,</span> <span class="o">*</span><span class="n">core</span><span class="p">,</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_core</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First, count how many init and core unwind-table entries there are.  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">e1</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">e1</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">e1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">start_offset</span><span class="p">))</span>
			<span class="o">++</span><span class="n">num_init</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">++</span><span class="n">num_core</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Second, sort the table such that all unwind-table entries for the init and core</span>
<span class="cm">	 * text sections are nicely separated.  We do this with a stupid bubble sort</span>
<span class="cm">	 * (unwind tables don&#39;t get ridiculously huge).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">e1</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">e1</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">e1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">e2</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">start_offset</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">start_offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>
				<span class="o">*</span><span class="n">e1</span> <span class="o">=</span> <span class="o">*</span><span class="n">e2</span><span class="p">;</span>
				<span class="o">*</span><span class="n">e2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Third, locate the init and core segments in the unwind table:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_init</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">start_offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">core</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num_init</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">core</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">init</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num_core</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: name=%s, gp=%lx, num_init=%lu, num_core=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
	       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">,</span> <span class="n">num_init</span><span class="p">,</span> <span class="n">num_core</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fourth, register both tables (if not empty).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_core</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_unw_table</span> <span class="o">=</span> <span class="n">unw_add_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">,</span>
								<span class="n">core</span><span class="p">,</span> <span class="n">core</span> <span class="o">+</span> <span class="n">num_core</span><span class="p">);</span>
		<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s:  core: handle=%p [%p-%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_unw_table</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">core</span> <span class="o">+</span> <span class="n">num_core</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_init</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span> <span class="o">=</span> <span class="n">unw_add_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">gp</span><span class="p">,</span>
								<span class="n">init</span><span class="p">,</span> <span class="n">init</span> <span class="o">+</span> <span class="n">num_init</span><span class="p">);</span>
		<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s:  init: handle=%p [%p-%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">init</span> <span class="o">+</span> <span class="n">num_init</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">module_finalize</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">&quot;%s: init: entry=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">unwind</span><span class="p">)</span>
		<span class="n">register_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_bundles</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">paravirt_patch_site_bundle</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span>
                        <span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site_bundle</span> <span class="o">*</span><span class="p">)</span>
                        <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_bundles</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">paravirt_patch_site_bundle</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span>
                        <span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site_bundle</span> <span class="o">*</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_bundles</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">+</span>
                         <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_bundles</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">);</span>

                <span class="n">paravirt_patch_apply_bundle</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_insts</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">paravirt_patch_site_inst</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span>
                        <span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site_inst</span> <span class="o">*</span><span class="p">)</span>
                        <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_insts</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">;</span>
                <span class="k">struct</span> <span class="n">paravirt_patch_site_inst</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span>
                        <span class="p">(</span><span class="k">struct</span> <span class="n">paravirt_patch_site_inst</span> <span class="o">*</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_insts</span><span class="o">-&gt;</span><span class="n">sh_addr</span> <span class="o">+</span>
                         <span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">paravirt_insts</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">);</span>

                <span class="n">paravirt_patch_apply_inst</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">module_arch_cleanup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span><span class="p">)</span>
		<span class="n">unw_remove_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">init_unw_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_unw_table</span><span class="p">)</span>
		<span class="n">unw_remove_unwind_table</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">core_unw_table</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
