<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › efi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>efi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Extensible Firmware Interface</span>
<span class="cm"> *</span>
<span class="cm"> * Based on Extensible Firmware Interface Specification version 0.9</span>
<span class="cm"> * April 30, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999 VA Linux Systems</span>
<span class="cm"> * Copyright (C) 1999 Walt Drummond &lt;drummond@valinux.com&gt;</span>
<span class="cm"> * Copyright (C) 1999-2003 Hewlett-Packard Co.</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *	Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> * (c) Copyright 2006 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> *	Bjorn Helgaas &lt;bjorn.helgaas@hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * All EFI Runtime Services are not implemented yet as EFI only</span>
<span class="cm"> * supports physical mode addressing on SoftSDV. This is to be fixed</span>
<span class="cm"> * in a future version.  --drummond 1999-07-20</span>
<span class="cm"> *</span>
<span class="cm"> * Implemented EFI runtime services and virtual mode calls.  --davidm</span>
<span class="cm"> *</span>
<span class="cm"> * Goutham Rao: &lt;goutham.rao@intel.com&gt;</span>
<span class="cm"> *	Skip non-WB memory and ignore empty memory ranges.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/kregs.h&gt;</span>
<span class="cp">#include &lt;asm/meminit.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/mca.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#define EFI_DEBUG	0</span>

<span class="k">extern</span> <span class="n">efi_status_t</span> <span class="n">efi_call_phys</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">struct</span> <span class="n">efi</span> <span class="n">efi</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">efi</span><span class="p">);</span>
<span class="k">static</span> <span class="n">efi_runtime_services_t</span> <span class="o">*</span><span class="n">runtime</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">mem_limit</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">max_addr</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">min_addr</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

<span class="cp">#define efi_call_virt(f, args...)	(*(f))(args)</span>

<span class="cp">#define STUB_GET_TIME(prefix, adjust_arg)				       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_get_time (efi_time_t *tm, efi_time_cap_t *tc)			       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_time_cap_t *atc = NULL;					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	if (tc)								       \</span>
<span class="cp">		atc = adjust_arg(tc);					       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix((efi_get_time_t *) __va(runtime-&gt;get_time),    \</span>
<span class="cp">				adjust_arg(tm), atc);			       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_SET_TIME(prefix, adjust_arg)				       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_set_time (efi_time_t *tm)					       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix((efi_set_time_t *) __va(runtime-&gt;set_time),    \</span>
<span class="cp">				adjust_arg(tm));			       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_GET_WAKEUP_TIME(prefix, adjust_arg)			       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_get_wakeup_time (efi_bool_t *enabled, efi_bool_t *pending,	       \</span>
<span class="cp">			  efi_time_t *tm)				       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix(					       \</span>
<span class="cp">		(efi_get_wakeup_time_t *) __va(runtime-&gt;get_wakeup_time),      \</span>
<span class="cp">		adjust_arg(enabled), adjust_arg(pending), adjust_arg(tm));     \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_SET_WAKEUP_TIME(prefix, adjust_arg)			       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_set_wakeup_time (efi_bool_t enabled, efi_time_t *tm)		       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_time_t *atm = NULL;						       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	if (tm)								       \</span>
<span class="cp">		atm = adjust_arg(tm);					       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix(					       \</span>
<span class="cp">		(efi_set_wakeup_time_t *) __va(runtime-&gt;set_wakeup_time),      \</span>
<span class="cp">		enabled, atm);						       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_GET_VARIABLE(prefix, adjust_arg)				       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_get_variable (efi_char16_t *name, efi_guid_t *vendor, u32 *attr,      \</span>
<span class="cp">		       unsigned long *data_size, void *data)		       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	u32 *aattr = NULL;						       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	if (attr)							       \</span>
<span class="cp">		aattr = adjust_arg(attr);				       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix(					       \</span>
<span class="cp">		(efi_get_variable_t *) __va(runtime-&gt;get_variable),	       \</span>
<span class="cp">		adjust_arg(name), adjust_arg(vendor), aattr,		       \</span>
<span class="cp">		adjust_arg(data_size), adjust_arg(data));		       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_GET_NEXT_VARIABLE(prefix, adjust_arg)			       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_get_next_variable (unsigned long *name_size, efi_char16_t *name,      \</span>
<span class="cp">			    efi_guid_t *vendor)				       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix(					       \</span>
<span class="cp">		(efi_get_next_variable_t *) __va(runtime-&gt;get_next_variable),  \</span>
<span class="cp">		adjust_arg(name_size), adjust_arg(name), adjust_arg(vendor));  \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_SET_VARIABLE(prefix, adjust_arg)				       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_set_variable (efi_char16_t *name, efi_guid_t *vendor,		       \</span>
<span class="cp">		       u32 attr, unsigned long data_size,		       \</span>
<span class="cp">		       void *data)					       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix(					       \</span>
<span class="cp">		(efi_set_variable_t *) __va(runtime-&gt;set_variable),	       \</span>
<span class="cp">		adjust_arg(name), adjust_arg(vendor), attr, data_size,	       \</span>
<span class="cp">		adjust_arg(data));					       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_GET_NEXT_HIGH_MONO_COUNT(prefix, adjust_arg)		       \</span>
<span class="cp">static efi_status_t							       \</span>
<span class="cp">prefix##_get_next_high_mono_count (u32 *count)				       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_status_t ret;						       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	ret = efi_call_##prefix((efi_get_next_high_mono_count_t *)	       \</span>
<span class="cp">				__va(runtime-&gt;get_next_high_mono_count),       \</span>
<span class="cp">				adjust_arg(count));			       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">	return ret;							       \</span>
<span class="cp">}</span>

<span class="cp">#define STUB_RESET_SYSTEM(prefix, adjust_arg)				       \</span>
<span class="cp">static void								       \</span>
<span class="cp">prefix##_reset_system (int reset_type, efi_status_t status,		       \</span>
<span class="cp">		       unsigned long data_size, efi_char16_t *data)	       \</span>
<span class="cp">{									       \</span>
<span class="cp">	struct ia64_fpreg fr[6];					       \</span>
<span class="cp">	efi_char16_t *adata = NULL;					       \</span>
<span class="cp">									       \</span>
<span class="cp">	if (data)							       \</span>
<span class="cp">		adata = adjust_arg(data);				       \</span>
<span class="cp">									       \</span>
<span class="cp">	ia64_save_scratch_fpregs(fr);					       \</span>
<span class="cp">	efi_call_##prefix(						       \</span>
<span class="cp">		(efi_reset_system_t *) __va(runtime-&gt;reset_system),	       \</span>
<span class="cp">		reset_type, status, data_size, adata);			       \</span>
<span class="cp">	</span><span class="cm">/* should not return, but just in case... */</span><span class="cp">			       \</span>
<span class="cp">	ia64_load_scratch_fpregs(fr);					       \</span>
<span class="cp">}</span>

<span class="cp">#define phys_ptr(arg)	((__typeof__(arg)) ia64_tpa(arg))</span>

<span class="n">STUB_GET_TIME</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_SET_TIME</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_GET_WAKEUP_TIME</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_SET_WAKEUP_TIME</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_GET_VARIABLE</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_GET_NEXT_VARIABLE</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_SET_VARIABLE</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_GET_NEXT_HIGH_MONO_COUNT</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>
<span class="n">STUB_RESET_SYSTEM</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">phys_ptr</span><span class="p">)</span>

<span class="cp">#define id(arg)	arg</span>

<span class="n">STUB_GET_TIME</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_SET_TIME</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_GET_WAKEUP_TIME</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_SET_WAKEUP_TIME</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_GET_VARIABLE</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_GET_NEXT_VARIABLE</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_SET_VARIABLE</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_GET_NEXT_HIGH_MONO_COUNT</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="n">STUB_RESET_SYSTEM</span><span class="p">(</span><span class="n">virt</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>

<span class="kt">void</span>
<span class="n">efi_gettimeofday</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efi_time_t</span> <span class="n">tm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">efi</span><span class="p">.</span><span class="n">get_time</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EFI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
			    <span class="n">tm</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">tm</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">tm</span><span class="p">.</span><span class="n">nanosecond</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">is_memory_available</span> <span class="p">(</span><span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">EFI_LOADER_CODE</span>:
	      <span class="k">case</span> <span class="n">EFI_LOADER_DATA</span>:
	      <span class="k">case</span> <span class="n">EFI_BOOT_SERVICES_CODE</span>:
	      <span class="k">case</span> <span class="n">EFI_BOOT_SERVICES_DATA</span>:
	      <span class="k">case</span> <span class="n">EFI_CONVENTIONAL_MEMORY</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">attribute</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_pages</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kern_memdesc_t</span><span class="p">;</span>

<span class="k">static</span> <span class="n">kern_memdesc_t</span> <span class="o">*</span><span class="n">kern_memmap</span><span class="p">;</span>

<span class="cp">#define efi_md_size(md)	(md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span>
<span class="nf">kmd_end</span><span class="p">(</span><span class="n">kern_memdesc_t</span> <span class="o">*</span><span class="n">kmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">kmd</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">kmd</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span>
<span class="nf">efi_md_end</span><span class="p">(</span><span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">efi_wb</span><span class="p">(</span><span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">efi_uc</span><span class="p">(</span><span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">walk</span> <span class="p">(</span><span class="n">efi_freemem_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kern_memdesc_t</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">voff</span><span class="p">;</span>

	<span class="n">voff</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="n">EFI_MEMORY_WB</span><span class="p">)</span> <span class="o">?</span> <span class="n">PAGE_OFFSET</span> <span class="o">:</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">kern_memmap</span><span class="p">;</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">!=</span> <span class="n">attr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">start</span> <span class="o">+</span> <span class="n">voff</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">voff</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the EFI memory map and call CALLBACK once for each EFI memory</span>
<span class="cm"> * descriptor that has memory that is available for OS use.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">efi_memmap_walk</span> <span class="p">(</span><span class="n">efi_freemem_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">walk</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">EFI_MEMORY_WB</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the EFI memory map and call CALLBACK once for each EFI memory</span>
<span class="cm"> * descriptor that has memory that is available for uncached allocator.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">efi_memmap_walk_uc</span> <span class="p">(</span><span class="n">efi_freemem_callback_t</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">walk</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">EFI_MEMORY_UC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look for the PAL_CODE region reported by EFI and map it using an</span>
<span class="cm"> * ITR to enable safe PAL calls in virtual mode.  See IA-64 Processor</span>
<span class="cm"> * Abstraction Layer chapter 11 in ADAG</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">efi_get_pal_addr</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pal_code_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">EFI_PAL_CODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pal_code_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Too many EFI Pal Code memory ranges, &quot;</span>
			       <span class="s">&quot;dropped @ %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The only ITLB entry in region 7 that is used is the one</span>
<span class="cm">		 * installed by __start().  That entry covers a 64MB range.</span>
<span class="cm">		 */</span>
		<span class="n">mask</span>  <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KERNEL_TR_PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We must check that the PAL mapping won&#39;t overlap with the</span>
<span class="cm">		 * kernel mapping.</span>
<span class="cm">		 *</span>
<span class="cm">		 * PAL code is guaranteed to be aligned on a power of 2 between</span>
<span class="cm">		 * 4k and 256KB and that only one ITR is needed to map it. This</span>
<span class="cm">		 * implies that the PAL code is always aligned on its size,</span>
<span class="cm">		 * i.e., the closest matching page size supported by the TLB.</span>
<span class="cm">		 * Therefore PAL code is guaranteed never to cross a 64MB unless</span>
<span class="cm">		 * it is bigger than 64MB (very unlikely!).  So for now the</span>
<span class="cm">		 * following test is enough to determine whether or not we need</span>
<span class="cm">		 * a dedicated ITR for the PAL code.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">KERNEL_START</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: no need to install ITR for PAL code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">IA64_GRANULE_SIZE</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Whoa!  PAL code size bigger than a granule!&quot;</span><span class="p">);</span>

<span class="cp">#if EFI_DEBUG</span>
		<span class="n">mask</span>  <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IA64_GRANULE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU %d: mapping PAL code &quot;</span>
                       <span class="s">&quot;[0x%lx-0x%lx) into [0x%lx-0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span>
                       <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">),</span>
                       <span class="n">vaddr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="n">IA64_GRANULE_SIZE</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: no PAL-code memory-descriptor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u8</span> <span class="n">__init</span> <span class="nf">palo_checksum</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">buffer</span><span class="o">++</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse and handle PALO table which is published at:</span>
<span class="cm"> * http://www.dig64.org/home/DIG64_PALO_R1_0.pdf</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">handle_palo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">palo_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">palo_table</span> <span class="o">*</span><span class="n">palo</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">palo_phys</span><span class="p">);</span>
	<span class="n">u8</span>  <span class="n">checksum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">palo</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">PALO_SIG</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PALO_SIG</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PALO signature incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">checksum</span> <span class="o">=</span> <span class="n">palo_checksum</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">palo</span><span class="p">,</span> <span class="n">palo</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;PALO checksum incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_ptcg_sem</span><span class="p">(</span><span class="n">palo</span><span class="o">-&gt;</span><span class="n">max_tlb_purges</span><span class="p">,</span> <span class="n">NPTCG_FROM_PALO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">efi_map_pal_code</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pal_vaddr</span> <span class="o">=</span> <span class="n">efi_get_pal_addr</span> <span class="p">();</span>
	<span class="n">u64</span> <span class="n">psr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pal_vaddr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cannot write to CRx with PSR.ic=1</span>
<span class="cm">	 */</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="n">ia64_clear_ic</span><span class="p">();</span>
	<span class="n">ia64_itr</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">IA64_TR_PALCODE</span><span class="p">,</span>
		 <span class="n">GRANULEROUNDDOWN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pal_vaddr</span><span class="p">),</span>
		 <span class="n">pte_val</span><span class="p">(</span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pal_vaddr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">)),</span>
		 <span class="n">IA64_GRANULE_SHIFT</span><span class="p">);</span>
	<span class="n">paravirt_dv_serialize_data</span><span class="p">();</span>
	<span class="n">ia64_set_psr</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>		<span class="cm">/* restore psr */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">efi_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">;</span>
	<span class="n">efi_config_table_t</span> <span class="o">*</span><span class="n">config_tables</span><span class="p">;</span>
	<span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">c16</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">vendor</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">palo_phys</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s too early to be able to use the standard kernel command line</span>
<span class="cm">	 * support...</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cp</span> <span class="o">=</span> <span class="n">boot_command_line</span><span class="p">;</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;mem=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_limit</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;max_addr=&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_addr</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">memparse</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;min_addr=&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">min_addr</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">memparse</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="mi">9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
				<span class="o">++</span><span class="n">cp</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
				<span class="o">++</span><span class="n">cp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_addr</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Ignoring memory below %lluMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">min_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_addr</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Ignoring memory above %lluMB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">max_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="n">efi</span><span class="p">.</span><span class="n">systab</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_systab</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify the EFI Table</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Whoa! Can&#39;t find EFI system table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">signature</span> <span class="o">!=</span> <span class="n">EFI_SYSTEM_TABLE_SIGNATURE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Whoa! EFI system table signature incorrect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">revision</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning: EFI system table version &quot;</span>
		       <span class="s">&quot;%d.%02d, expected 1.00 or greater</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">revision</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span>
		       <span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">revision</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="n">config_tables</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">tables</span><span class="p">);</span>

	<span class="cm">/* Show what we know for posterity */</span>
	<span class="n">c16</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">fw_vendor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c16</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vendor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">c16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">c16</span><span class="o">++</span><span class="p">;</span>
		<span class="n">vendor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EFI v%u.%.02u by %s:&quot;</span><span class="p">,</span>
	       <span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">revision</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span>
	       <span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">revision</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">vendor</span><span class="p">);</span>

	<span class="n">efi</span><span class="p">.</span><span class="n">mps</span>        <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">acpi</span>       <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">acpi20</span>     <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">smbios</span>     <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">sal_systab</span> <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">boot_info</span>  <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">hcdp</span>       <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">uga</span>        <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>

	<span class="n">palo_phys</span>      <span class="o">=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">nr_tables</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">MPS_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">mps</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; MPS=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">ACPI_20_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">acpi20</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ACPI 2.0=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">ACPI_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">acpi</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ACPI=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">SMBIOS_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">smbios</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; SMBIOS=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">SAL_SYSTEM_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">sal_systab</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; SALsystab=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">HCDP_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efi</span><span class="p">.</span><span class="n">hcdp</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; HCDP=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span>
			 <span class="n">PROCESSOR_ABSTRACTION_LAYER_OVERWRITE_GUID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">palo_phys</span> <span class="o">=</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; PALO=0x%lx&quot;</span><span class="p">,</span> <span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">palo_phys</span> <span class="o">!=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">)</span>
		<span class="n">handle_palo</span><span class="p">(</span><span class="n">palo_phys</span><span class="p">);</span>

	<span class="n">runtime</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">systab</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">);</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_time</span> <span class="o">=</span> <span class="n">phys_get_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_time</span> <span class="o">=</span> <span class="n">phys_set_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_wakeup_time</span> <span class="o">=</span> <span class="n">phys_get_wakeup_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_wakeup_time</span> <span class="o">=</span> <span class="n">phys_set_wakeup_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_variable</span> <span class="o">=</span> <span class="n">phys_get_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_next_variable</span> <span class="o">=</span> <span class="n">phys_get_next_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_variable</span> <span class="o">=</span> <span class="n">phys_set_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_next_high_mono_count</span> <span class="o">=</span> <span class="n">phys_get_next_high_mono_count</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">reset_system</span> <span class="o">=</span> <span class="n">phys_reset_system</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

<span class="cp">#if EFI_DEBUG</span>
	<span class="cm">/* print EFI memory map: */</span>
	<span class="p">{</span>
		<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span>
		     <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unit</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

			<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">40</span><span class="p">;</span>
				<span class="n">unit</span> <span class="o">=</span> <span class="s">&quot;TB&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">30</span><span class="p">;</span>
				<span class="n">unit</span> <span class="o">=</span> <span class="s">&quot;GB&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">20</span><span class="p">;</span>
				<span class="n">unit</span> <span class="o">=</span> <span class="s">&quot;MB&quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>
				<span class="n">unit</span> <span class="o">=</span> <span class="s">&quot;KB&quot;</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;mem%02d: type=%2u, attr=0x%016lx, &quot;</span>
			       <span class="s">&quot;range=[0x%016lx-0x%016lx) (%4lu%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span>
			       <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">efi_map_pal_code</span><span class="p">();</span>
	<span class="n">efi_enter_virtual_mode</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">efi_enter_virtual_mode</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">efi_status_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_RUNTIME</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some descriptors have multiple bits set, so the</span>
<span class="cm">			 * order of the tests is relevant.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">md</span><span class="o">-&gt;</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">md</span><span class="o">-&gt;</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WC</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				md-&gt;virt_addr = ia64_remap(md-&gt;phys_addr,</span>
<span class="c">							   (_PAGE_A |</span>
<span class="c">							    _PAGE_P |</span>
<span class="c">							    _PAGE_D |</span>
<span class="c">							    _PAGE_MA_WC |</span>
<span class="c">							    _PAGE_PL_0 |</span>
<span class="c">							    _PAGE_AR_RW));</span>
<span class="cp">#else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EFI_MEMORY_WC mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">md</span><span class="o">-&gt;</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WT</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				md-&gt;virt_addr = ia64_remap(md-&gt;phys_addr,</span>
<span class="c">							   (_PAGE_A |</span>
<span class="c">							    _PAGE_P |</span>
<span class="c">							    _PAGE_D |</span>
<span class="c">							    _PAGE_MA_WT |</span>
<span class="c">							    _PAGE_PL_0 |</span>
<span class="c">							    _PAGE_AR_RW));</span>
<span class="cp">#else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EFI_MEMORY_WT mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">md</span><span class="o">-&gt;</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">efi_call_phys</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">set_virtual_address_map</span><span class="p">),</span>
			       <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">,</span>
			       <span class="n">efi_desc_size</span><span class="p">,</span>
			       <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_version</span><span class="p">,</span>
			       <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">EFI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;warning: unable to switch EFI into &quot;</span>
		       <span class="s">&quot;virtual mode (status=%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that EFI is in virtual mode, we call the EFI functions more</span>
<span class="cm">	 * efficiently:</span>
<span class="cm">	 */</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_time</span> <span class="o">=</span> <span class="n">virt_get_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_time</span> <span class="o">=</span> <span class="n">virt_set_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_wakeup_time</span> <span class="o">=</span> <span class="n">virt_get_wakeup_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_wakeup_time</span> <span class="o">=</span> <span class="n">virt_set_wakeup_time</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_variable</span> <span class="o">=</span> <span class="n">virt_get_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_next_variable</span> <span class="o">=</span> <span class="n">virt_get_next_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">set_variable</span> <span class="o">=</span> <span class="n">virt_set_variable</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">get_next_high_mono_count</span> <span class="o">=</span> <span class="n">virt_get_next_high_mono_count</span><span class="p">;</span>
	<span class="n">efi</span><span class="p">.</span><span class="n">reset_system</span> <span class="o">=</span> <span class="n">virt_reset_system</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the EFI memory map looking for the I/O port range.  There can only be</span>
<span class="cm"> * one entry of this type, other I/O port ranges should be described via ACPI.</span>
<span class="cm"> */</span>
<span class="n">u64</span>
<span class="nf">efi_get_iobase</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_MEMORY_MAPPED_IO_PORT_SPACE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="o">*</span>
<span class="nf">kern_memory_descriptor</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">md</span> <span class="o">=</span> <span class="n">kern_memmap</span><span class="p">;</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span> <span class="n">md</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phys_addr</span> <span class="o">-</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">))</span>
			 <span class="k">return</span> <span class="n">md</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">efi_memory_desc_t</span> <span class="o">*</span>
<span class="nf">efi_memory_descriptor</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phys_addr</span> <span class="o">-</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">))</span>
			 <span class="k">return</span> <span class="n">md</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">efi_memmap_intersects</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">phys_addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">phys_addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u32</span>
<span class="nf">efi_mem_type</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span> <span class="o">=</span> <span class="n">efi_memory_descriptor</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span>
<span class="nf">efi_mem_attributes</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span> <span class="o">=</span> <span class="n">efi_memory_descriptor</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">efi_mem_attributes</span><span class="p">);</span>

<span class="n">u64</span>
<span class="nf">efi_mem_attribute</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">phys_addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span> <span class="o">=</span> <span class="n">efi_memory_descriptor</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">md</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * EFI_MEMORY_RUNTIME is not a memory attribute; it just tells</span>
<span class="cm">	 * the kernel that firmware needs this region mapped.</span>
<span class="cm">	 */</span>
	<span class="n">attr</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EFI_MEMORY_RUNTIME</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">md_end</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">md_end</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">attr</span><span class="p">;</span>

		<span class="n">md</span> <span class="o">=</span> <span class="n">efi_memory_descriptor</span><span class="p">(</span><span class="n">md_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">md</span> <span class="o">||</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EFI_MEMORY_RUNTIME</span><span class="p">)</span> <span class="o">!=</span> <span class="n">attr</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">md</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* never reached */</span>
<span class="p">}</span>

<span class="n">u64</span>
<span class="nf">kern_mem_attribute</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">phys_addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">attr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a hack for ioremap calls before we set up kern_memmap.</span>
<span class="cm">	 * Maybe we should do efi_memmap_init() earlier instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kern_memmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr</span> <span class="o">=</span> <span class="n">efi_mem_attribute</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">EFI_MEMORY_WB</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">md</span> <span class="o">=</span> <span class="n">kern_memory_descriptor</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">md</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">md_end</span> <span class="o">=</span> <span class="n">kmd_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">md_end</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">attr</span><span class="p">;</span>

		<span class="n">md</span> <span class="o">=</span> <span class="n">kern_memory_descriptor</span><span class="p">(</span><span class="n">md_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">md</span> <span class="o">||</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">!=</span> <span class="n">attr</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">md</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* never reached */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kern_mem_attribute</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">valid_phys_addr_range</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">attr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * /dev/mem reads and writes use copy_to_user(), which implicitly</span>
<span class="cm">	 * uses a granule-sized kernel identity mapping.  It&#39;s really</span>
<span class="cm">	 * only safe to do this for regions in kern_memmap.  For more</span>
<span class="cm">	 * details, see Documentation/ia64/aliasing.txt.</span>
<span class="cm">	 */</span>
	<span class="n">attr</span> <span class="o">=</span> <span class="n">kern_mem_attribute</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span> <span class="o">||</span> <span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">valid_mmap_phys_addr_range</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">attr</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">efi_mem_attribute</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * /dev/mem mmap uses normal user pages, so we don&#39;t need the entire</span>
<span class="cm">	 * granule, but the entire region we&#39;re mapping must support the same</span>
<span class="cm">	 * attribute.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span> <span class="o">||</span> <span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Intel firmware doesn&#39;t tell us about all the MMIO regions, so</span>
<span class="cm">	 * in general we have to allow mmap requests.  But if EFI *does*</span>
<span class="cm">	 * tell us about anything inside this region, we should deny it.</span>
<span class="cm">	 * The user can always map a smaller region to avoid the overlap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efi_memmap_intersects</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pgprot_t</span>
<span class="nf">phys_mem_access_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		     <span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">attr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For /dev/mem mmap, we use user mappings, but if the region is</span>
<span class="cm">	 * in kern_memmap (and hence may be covered by a kernel mapping),</span>
<span class="cm">	 * we must use the same attribute as the kernel mapping.</span>
<span class="cm">	 */</span>
	<span class="n">attr</span> <span class="o">=</span> <span class="n">kern_mem_attribute</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pgprot_cacheable</span><span class="p">(</span><span class="n">vma_prot</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma_prot</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some chipsets don&#39;t support UC access to memory.  If</span>
<span class="cm">	 * WB is supported, we prefer that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efi_mem_attribute</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WB</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pgprot_cacheable</span><span class="p">(</span><span class="n">vma_prot</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pgprot_noncached</span><span class="p">(</span><span class="n">vma_prot</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">efi_uart_console_only</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efi_status_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ConOut&quot;</span><span class="p">;</span>
	<span class="n">efi_guid_t</span> <span class="n">guid</span> <span class="o">=</span> <span class="n">EFI_GLOBAL_VARIABLE_GUID</span><span class="p">;</span>
	<span class="n">efi_char16_t</span> <span class="o">*</span><span class="n">utf16</span><span class="p">,</span> <span class="n">name_utf16</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">efi_generic_dev_path</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">end_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Convert to UTF-16 */</span>
	<span class="n">utf16</span> <span class="o">=</span> <span class="n">name_utf16</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
		<span class="o">*</span><span class="n">utf16</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="o">*</span><span class="n">utf16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">efi</span><span class="p">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">name_utf16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">guid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">EFI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;No EFI %s variable?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efi_generic_dev_path</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">end_addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efi_generic_dev_path</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hdr</span> <span class="o">&lt;</span> <span class="n">end_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_DEV_MSG</span> <span class="o">&amp;&amp;</span>
		    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sub_type</span> <span class="o">==</span> <span class="n">EFI_DEV_MSG_UART</span><span class="p">)</span>
			<span class="n">uart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_DEV_END_PATH</span> <span class="o">||</span>
			  <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_DEV_END_PATH2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sub_type</span> <span class="o">==</span> <span class="n">EFI_DEV_END_ENTIRE</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">uart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">efi_generic_dev_path</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">hdr</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Malformed %s value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look for the first granule aligned memory descriptor memory</span>
<span class="cm"> * that is big enough to hold EFI memory map. Make sure this</span>
<span class="cm"> * descriptor is atleast granule sized so it does not get trimmed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="o">*</span>
<span class="nf">find_memmap_space</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span>	<span class="n">contig_low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">contig_high</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">as</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ae</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">check_md</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">space_needed</span><span class="p">,</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Worst case: we need 3 kernel descriptors for each efi descriptor</span>
<span class="cm">	 * (if every entry has a WB part in the middle, and UC head and tail),</span>
<span class="cm">	 * plus one for the end marker.</span>
<span class="cm">	 */</span>
	<span class="n">space_needed</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kern_memdesc_t</span><span class="p">)</span> <span class="o">*</span>
		<span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="o">/</span><span class="n">efi_desc_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">pmd</span> <span class="o">=</span> <span class="n">md</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">md</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">efi_md_end</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">contig_low</span> <span class="o">=</span> <span class="n">GRANULEROUNDUP</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="n">contig_high</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">efi_desc_size</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span>
			     <span class="n">q</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">check_md</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">check_md</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">contig_high</span> <span class="o">!=</span> <span class="n">check_md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">contig_high</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">check_md</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">contig_high</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">contig_high</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_memory_available</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">||</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_LOADER_DATA</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Round ends inward to granule boundaries */</span>
		<span class="n">as</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">contig_low</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
		<span class="n">ae</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">contig_high</span><span class="p">,</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">));</span>

		<span class="cm">/* keep within max_addr= and min_addr= command line arg */</span>
		<span class="n">as</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">min_addr</span><span class="p">);</span>
		<span class="n">ae</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ae</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ae</span> <span class="o">&lt;=</span> <span class="n">as</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* avoid going over mem= command line arg */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mem_limit</span><span class="p">)</span>
			<span class="n">ae</span> <span class="o">-=</span> <span class="n">total_mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">-</span> <span class="n">mem_limit</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ae</span> <span class="o">&lt;=</span> <span class="n">as</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span> <span class="o">&gt;</span> <span class="n">space_needed</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">efi_map_end</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t allocate space for kernel memory descriptors&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the EFI memory map and gather all memory available for kernel</span>
<span class="cm"> * to use.  We can allocate partial granules only if the unavailable</span>
<span class="cm"> * parts exist, and are WB.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">efi_memmap_init</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kern_memdesc</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">contig_low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">contig_high</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">as</span><span class="p">,</span> <span class="n">ae</span><span class="p">,</span> <span class="n">lim</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">check_md</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">k</span> <span class="o">=</span> <span class="n">kern_memmap</span> <span class="o">=</span> <span class="n">find_memmap_space</span><span class="p">();</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">pmd</span> <span class="o">=</span> <span class="n">md</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">md</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efi_uc</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_CONVENTIONAL_MEMORY</span> <span class="o">||</span>
			     <span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_BOOT_SERVICES_DATA</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">k</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">EFI_MEMORY_UC</span><span class="p">;</span>
				<span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
				<span class="n">k</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">;</span>
				<span class="n">k</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">efi_md_end</span><span class="p">(</span><span class="n">pmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">contig_low</span> <span class="o">=</span> <span class="n">GRANULEROUNDUP</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">);</span>
			<span class="n">contig_high</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">efi_desc_size</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span>
			     <span class="n">q</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">check_md</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">check_md</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">contig_high</span> <span class="o">!=</span> <span class="n">check_md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">contig_high</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">check_md</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">contig_high</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">contig_high</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_memory_available</span><span class="p">(</span><span class="n">md</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CRASH_DUMP</span>
		<span class="cm">/* saved_max_pfn should ignore max_addr= command line arg */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">saved_max_pfn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
			<span class="n">saved_max_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Round ends inward to granule boundaries</span>
<span class="cm">		 * Give trimmings to uncached allocator</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&lt;</span> <span class="n">contig_low</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">),</span> <span class="n">contig_low</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efi_uc</span><span class="p">(</span><span class="n">md</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">kern_memmap</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">EFI_MEMORY_UC</span> <span class="o">&amp;&amp;</span>
				    <span class="n">kmd_end</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">+=</span>
						<span class="p">(</span><span class="n">lim</span> <span class="o">-</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
						<span class="o">&gt;&gt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">EFI_MEMORY_UC</span><span class="p">;</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">lim</span> <span class="o">-</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span>
						<span class="o">&gt;&gt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
					<span class="n">k</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">as</span> <span class="o">=</span> <span class="n">contig_low</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">as</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">contig_high</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lim</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">contig_high</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efi_uc</span><span class="p">(</span><span class="n">md</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lim</span> <span class="o">==</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">kern_memmap</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">EFI_MEMORY_UC</span> <span class="o">&amp;&amp;</span>
				    <span class="n">kmd_end</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">+=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">EFI_MEMORY_UC</span><span class="p">;</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">lim</span><span class="p">;</span>
					<span class="n">k</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">-</span> <span class="n">lim</span><span class="p">)</span>
						<span class="o">&gt;&gt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
					<span class="n">k</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">ae</span> <span class="o">=</span> <span class="n">contig_high</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ae</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>

		<span class="cm">/* keep within max_addr= and min_addr= command line arg */</span>
		<span class="n">as</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">min_addr</span><span class="p">);</span>
		<span class="n">ae</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ae</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ae</span> <span class="o">&lt;=</span> <span class="n">as</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* avoid going over mem= command line arg */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mem_limit</span><span class="p">)</span>
			<span class="n">ae</span> <span class="o">-=</span> <span class="n">total_mem</span> <span class="o">+</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">-</span> <span class="n">mem_limit</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ae</span> <span class="o">&lt;=</span> <span class="n">as</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">kmd_end</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="o">==</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">total_mem</span> <span class="o">+=</span> <span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">EFI_MEMORY_WB</span><span class="p">;</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">as</span><span class="p">;</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EFI_PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">total_mem</span> <span class="o">+=</span> <span class="n">ae</span> <span class="o">-</span> <span class="n">as</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0L</span><span class="p">;</span> <span class="cm">/* end-marker */</span>

	<span class="cm">/* reserve the memory we are using for kern_memmap */</span>
	<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">kern_memmap</span><span class="p">;</span>
	<span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">++</span><span class="n">k</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">total_mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">efi_initialize_iomem_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">code_resource</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">data_resource</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">bss_resource</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* should not happen */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_BUSY</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">EFI_MEMORY_MAPPED_IO</span>:
			<span class="k">case</span> <span class="n">EFI_MEMORY_MAPPED_IO_PORT_SPACE</span>:
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">EFI_LOADER_CODE</span>:
			<span class="k">case</span> <span class="n">EFI_LOADER_DATA</span>:
			<span class="k">case</span> <span class="n">EFI_BOOT_SERVICES_DATA</span>:
			<span class="k">case</span> <span class="n">EFI_BOOT_SERVICES_CODE</span>:
			<span class="k">case</span> <span class="n">EFI_CONVENTIONAL_MEMORY</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">&amp;</span> <span class="n">EFI_MEMORY_WP</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;System ROM&quot;</span><span class="p">;</span>
					<span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_READONLY</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">EFI_MEMORY_UC</span><span class="p">)</span>
					<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Uncached RAM&quot;</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;System RAM&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">EFI_ACPI_MEMORY_NVS</span>:
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ACPI Non-volatile Storage&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">EFI_UNUSABLE_MEMORY</span>:
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;reserved&quot;</span><span class="p">;</span>
				<span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_DISABLED</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">EFI_RESERVED_TYPE</span>:
			<span class="k">case</span> <span class="n">EFI_RUNTIME_SERVICES_CODE</span>:
			<span class="k">case</span> <span class="n">EFI_RUNTIME_SERVICES_DATA</span>:
			<span class="k">case</span> <span class="n">EFI_ACPI_RECLAIM_MEMORY</span>:
			<span class="nl">default:</span>
				<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;reserved&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">),</span>
				   <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;failed to allocate resource for iomem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">+</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t know which region contains</span>
<span class="cm">			 * kernel data so we try it repeatedly and</span>
<span class="cm">			 * let the resource manager test it.</span>
<span class="cm">			 */</span>
			<span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">code_resource</span><span class="p">);</span>
			<span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">data_resource</span><span class="p">);</span>
			<span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">bss_resource</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KEXEC</span>
                        <span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efi_memmap_res</span><span class="p">);</span>
                        <span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot_param_res</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">)</span>
				<span class="n">insert_resource</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">crashk_res</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
<span class="cm">/* find a block of memory aligned to 64M exclude reserved regions</span>
<span class="cm">   rsvd_regions are sorted</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span>
<span class="nf">kdump_find_rsvd_region</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rsvd_region</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alignment</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">_PAGE_SIZE_64M</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">md</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">efi_md_end</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">__pa</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">start</span><span class="p">;</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">),</span> <span class="n">alignment</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
				    <span class="n">__pa</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	       <span class="s">&quot;Cannot reserve 0x%lx byte of memory for crashdump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CRASH_DUMP</span>
<span class="cm">/* locate the size find a the descriptor at a certain address */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span>
<span class="nf">vmcore_find_descriptor_size</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">efi_map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">efi_map_end</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">efi_memory_desc_t</span> <span class="o">*</span><span class="n">md</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">efi_desc_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">efi_map_start</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">efi_map_end</span>   <span class="o">=</span> <span class="n">efi_map_start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">efi_desc_size</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memdesc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">efi_map_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">efi_map_end</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">efi_desc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efi_wb</span><span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">EFI_LOADER_DATA</span>
		    <span class="o">&amp;&amp;</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">==</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">efi_md_size</span><span class="p">(</span><span class="n">md</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Cannot locate EFI vmcore descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
