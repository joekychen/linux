<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › iosapic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iosapic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * I/O SAPIC support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999 Intel Corp.</span>
<span class="cm"> * Copyright (C) 1999 Asit Mallick &lt;asit.k.mallick@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 2000-2002 J.I. Lee &lt;jung-ik.lee@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 1999-2000, 2002-2003 Hewlett-Packard Co.</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 VA Linux Systems</span>
<span class="cm"> * Copyright (C) 1999,2000 Walt Drummond &lt;drummond@valinux.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 00/04/19	D. Mosberger	Rewritten to mirror more closely the x86 I/O</span>
<span class="cm"> *				APIC code.  In particular, we now have separate</span>
<span class="cm"> *				handlers for edge and level triggered</span>
<span class="cm"> *				interrupts.</span>
<span class="cm"> * 00/10/27	Asit Mallick, Goutham Rao &lt;goutham.rao@intel.com&gt; IRQ vector</span>
<span class="cm"> *				allocation PCI to vector mapping, shared PCI</span>
<span class="cm"> *				interrupts.</span>
<span class="cm"> * 00/10/27	D. Mosberger	Document things a bit more to make them more</span>
<span class="cm"> *				understandable.  Clean up much of the old</span>
<span class="cm"> *				IOSAPIC cruft.</span>
<span class="cm"> * 01/07/27	J.I. Lee	PCI irq routing, Platform/Legacy interrupts</span>
<span class="cm"> *				and fixes for ACPI S5(SoftOff) support.</span>
<span class="cm"> * 02/01/23	J.I. Lee	iosapic pgm fixes for PCI irq routing from _PRT</span>
<span class="cm"> * 02/01/07     E. Focht        &lt;efocht@ess.nec.de&gt; Redirectable interrupt</span>
<span class="cm"> *				vectors in iosapic_set_affinity(),</span>
<span class="cm"> *				initializations for /proc/irq/#/smp_affinity</span>
<span class="cm"> * 02/04/02	P. Diefenbaugh	Cleaned up ACPI PCI IRQ routing.</span>
<span class="cm"> * 02/04/18	J.I. Lee	bug fix in iosapic_init_pci_irq</span>
<span class="cm"> * 02/04/30	J.I. Lee	bug fix in find_iosapic to fix ACPI PCI IRQ to</span>
<span class="cm"> *				IOSAPIC mapping error</span>
<span class="cm"> * 02/07/29	T. Kochi	Allocate interrupt vectors dynamically</span>
<span class="cm"> * 02/08/04	T. Kochi	Cleaned up terminology (irq, global system</span>
<span class="cm"> *				interrupt, vector, etc.)</span>
<span class="cm"> * 02/09/20	D. Mosberger	Simplified by taking advantage of ACPI&#39;s</span>
<span class="cm"> *				pci_irq code.</span>
<span class="cm"> * 03/02/19	B. Helgaas	Make pcat_compat system-wide, not per-IOSAPIC.</span>
<span class="cm"> *				Remove iosapic_address &amp; gsi_base from</span>
<span class="cm"> *				external interfaces.  Rationalize</span>
<span class="cm"> *				__init/__devinit attributes.</span>
<span class="cm"> * 04/12/04 Ashok Raj	&lt;ashok.raj@intel.com&gt; Intel Corporation 2004</span>
<span class="cm"> *				Updated to work with irq migration necessary</span>
<span class="cm"> *				for CPU Hotplug</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Here is what the interrupt logic between a PCI device and the kernel looks</span>
<span class="cm"> * like:</span>
<span class="cm"> *</span>
<span class="cm"> * (1) A PCI device raises one of the four interrupt pins (INTA, INTB, INTC,</span>
<span class="cm"> *     INTD).  The device is uniquely identified by its bus-, and slot-number</span>
<span class="cm"> *     (the function number does not matter here because all functions share</span>
<span class="cm"> *     the same interrupt lines).</span>
<span class="cm"> *</span>
<span class="cm"> * (2) The motherboard routes the interrupt line to a pin on a IOSAPIC</span>
<span class="cm"> *     controller.  Multiple interrupt lines may have to share the same</span>
<span class="cm"> *     IOSAPIC pin (if they&#39;re level triggered and use the same polarity).</span>
<span class="cm"> *     Each interrupt line has a unique Global System Interrupt (GSI) number</span>
<span class="cm"> *     which can be calculated as the sum of the controller&#39;s base GSI number</span>
<span class="cm"> *     and the IOSAPIC pin number to which the line connects.</span>
<span class="cm"> *</span>
<span class="cm"> * (3) The IOSAPIC uses an internal routing table entries (RTEs) to map the</span>
<span class="cm"> * IOSAPIC pin into the IA-64 interrupt vector.  This interrupt vector is then</span>
<span class="cm"> * sent to the CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * (4) The kernel recognizes an interrupt as an IRQ.  The IRQ interface is</span>
<span class="cm"> *     used as architecture-independent interrupt handling mechanism in Linux.</span>
<span class="cm"> *     As an IRQ is a number, we have to have</span>
<span class="cm"> *     IA-64 interrupt vector number &lt;-&gt; IRQ number mapping.  On smaller</span>
<span class="cm"> *     systems, we use one-to-one mapping between IA-64 vector and IRQ.  A</span>
<span class="cm"> *     platform can implement platform_irq_to_vector(irq) and</span>
<span class="cm"> *     platform_local_vector_to_irq(vector) APIs to differentiate the mapping.</span>
<span class="cm"> *     Please see also arch/ia64/include/asm/hw_irq.h for those APIs.</span>
<span class="cm"> *</span>
<span class="cm"> * To sum up, there are three levels of mappings involved:</span>
<span class="cm"> *</span>
<span class="cm"> *	PCI pin -&gt; global system interrupt (GSI) -&gt; IA-64 vector &lt;-&gt; IRQ</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The term &quot;IRQ&quot; is loosely used everywhere in Linux kernel to</span>
<span class="cm"> * describeinterrupts.  Now we use &quot;IRQ&quot; only for Linux IRQ&#39;s.  ISA IRQ</span>
<span class="cm"> * (isa_irq) is the only exception in this source code.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>

<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/iosapic.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cp">#undef DEBUG_INTERRUPT_ROUTING</span>

<span class="cp">#ifdef DEBUG_INTERRUPT_ROUTING</span>
<span class="cp">#define DBG(fmt...)	printk(fmt)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG(fmt...)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">iosapic_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * These tables map IA-64 vectors to the IOSAPIC pin that generates this</span>
<span class="cm"> * vector.</span>
<span class="cm"> */</span>

<span class="cp">#define NO_REF_RTE	0</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iosapic</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">addr</span><span class="p">;</span>		<span class="cm">/* base address of IOSAPIC */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">gsi_base</span><span class="p">;</span>	<span class="cm">/* GSI base */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">num_rte</span><span class="p">;</span>	<span class="cm">/* # of RTEs on this IOSAPIC */</span>
	<span class="kt">int</span>		<span class="n">rtes_inuse</span><span class="p">;</span>	<span class="cm">/* # of RTEs in use on this IOSAPIC */</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">node</span><span class="p">;</span>		<span class="cm">/* numa node association via pxm */</span>
<span class="cp">#endif</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* lock for indirect reg access */</span>
<span class="p">}</span> <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">NR_IOSAPICS</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rte_list</span><span class="p">;</span>	<span class="cm">/* RTEs sharing the same vector */</span>
	<span class="kt">char</span>		<span class="n">rte_index</span><span class="p">;</span>	<span class="cm">/* IOSAPIC RTE index */</span>
	<span class="kt">int</span>		<span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>
	<span class="k">struct</span> <span class="n">iosapic</span>	<span class="o">*</span><span class="n">iosapic</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iosapic_intr_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rtes</span><span class="p">;</span>		<span class="cm">/* RTEs using this vector (empty =&gt;</span>
<span class="cm">					 * not an IOSAPIC interrupt) */</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">;</span>		<span class="cm">/* # of registered RTEs */</span>
	<span class="n">u32</span>		<span class="n">low32</span><span class="p">;</span>		<span class="cm">/* current value of low word of</span>
<span class="cm">					 * Redirection table entry */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">dest</span><span class="p">;</span>		<span class="cm">/* destination CPU physical ID */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">dmode</span>	<span class="o">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* delivery mode (see iosapic.h) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> 	<span class="n">polarity</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* interrupt polarity</span>
<span class="cm">					 * (see iosapic.h) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">trigger</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* trigger mode (see iosapic.h) */</span>
<span class="p">}</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">NR_IRQS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pcat_compat</span> <span class="n">__devinitdata</span><span class="p">;</span>	<span class="cm">/* 8259 compatibility flag */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">iosapic_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__iosapic_write</span><span class="p">(</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find an IOSAPIC associated with a GSI</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">find_iosapic</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_IOSAPICS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">(</span><span class="n">gsi</span> <span class="o">-</span> <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gsi_base</span><span class="p">)</span> <span class="o">&lt;</span>
		    <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num_rte</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__gsi_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_intr_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">irq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">];</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">gsi_base</span> <span class="o">+</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span> <span class="o">==</span> <span class="n">gsi</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">gsi_to_irq</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">__gsi_to_irq</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="nf">find_rte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">gsi_base</span> <span class="o">+</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span> <span class="o">==</span> <span class="n">gsi</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rte</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_rte</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pol</span><span class="p">,</span> <span class="n">trigger</span><span class="p">,</span> <span class="n">dmode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">,</span> <span class="n">high32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rte_index</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">redir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>
	<span class="n">ia64_vector</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;IOSAPIC: routing vector %d to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

	<span class="n">rte</span> <span class="o">=</span> <span class="n">find_rte</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rte</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* not an IOSAPIC interrupt */</span>

	<span class="n">rte_index</span> <span class="o">=</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">;</span>
	<span class="n">pol</span>     <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">polarity</span><span class="p">;</span>
	<span class="n">trigger</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">trigger</span><span class="p">;</span>
	<span class="n">dmode</span>   <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dmode</span><span class="p">;</span>

	<span class="n">redir</span> <span class="o">=</span> <span class="p">(</span><span class="n">dmode</span> <span class="o">==</span> <span class="n">IOSAPIC_LOWEST_PRIORITY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">set_irq_affinity_info</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">dest</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">),</span> <span class="n">redir</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">low32</span> <span class="o">=</span> <span class="p">((</span><span class="n">pol</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_POLARITY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">trigger</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_TRIGGER_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">(</span><span class="n">dmode</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DELIVERY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		 <span class="p">((</span><span class="n">mask</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_MASK_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		 <span class="n">vector</span><span class="p">);</span>

	<span class="cm">/* dest contains both id and eid */</span>
	<span class="n">high32</span> <span class="o">=</span> <span class="p">(</span><span class="n">dest</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DEST_SHIFT</span><span class="p">);</span>

	<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_HIGH</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">high32</span><span class="p">);</span>
	<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">low32</span><span class="p">);</span>
	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">=</span> <span class="n">low32</span><span class="p">;</span>
	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">nop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do nothing... */</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_KEXEC</span>
<span class="kt">void</span>
<span class="nf">kexec_disable_iosapic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iosapic_intr_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>
	<span class="n">ia64_vector</span> <span class="n">vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">irq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">];</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rtes</span><span class="p">,</span>
				<span class="n">rte_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span>
					<span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">),</span>
					<span class="n">IOSAPIC_MASK</span><span class="o">|</span><span class="n">vec</span><span class="p">);</span>
			<span class="n">iosapic_eoi</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mask_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rte_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>			<span class="cm">/* not an IOSAPIC interrupt! */</span>

	<span class="cm">/* set only the mask bit */</span>
	<span class="n">low32</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">|=</span> <span class="n">IOSAPIC_MASK</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rte_index</span> <span class="o">=</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">;</span>
		<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">low32</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">unmask_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rte_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>			<span class="cm">/* not an IOSAPIC interrupt! */</span>

	<span class="n">low32</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOSAPIC_MASK</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rte_index</span> <span class="o">=</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">;</span>
		<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">low32</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">iosapic_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		     <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">high32</span><span class="p">,</span> <span class="n">low32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">rte_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">redir</span> <span class="o">=</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&amp;</span> <span class="n">IA64_IRQ_REDIRECTED</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">IA64_IRQ_REDIRECTED</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first_and</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_prepare_move</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* not an IOSAPIC interrupt */</span>

	<span class="n">set_irq_affinity_info</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">redir</span><span class="p">);</span>

	<span class="cm">/* dest contains both id and eid */</span>
	<span class="n">high32</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DEST_SHIFT</span><span class="p">;</span>

	<span class="n">low32</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DELIVERY_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">redir</span><span class="p">)</span>
		<span class="cm">/* change delivery mode to lowest priority */</span>
		<span class="n">low32</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IOSAPIC_LOWEST_PRIORITY</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DELIVERY_SHIFT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* change delivery mode to fixed */</span>
		<span class="n">low32</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IOSAPIC_FIXED</span> <span class="o">&lt;&lt;</span> <span class="n">IOSAPIC_DELIVERY_SHIFT</span><span class="p">);</span>
	<span class="n">low32</span> <span class="o">&amp;=</span> <span class="n">IOSAPIC_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">low32</span> <span class="o">|=</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">=</span> <span class="n">low32</span><span class="p">;</span>
	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iosapic</span> <span class="o">=</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">;</span>
		<span class="n">rte_index</span> <span class="o">=</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">;</span>
		<span class="n">iosapic_write</span><span class="p">(</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_HIGH</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">high32</span><span class="p">);</span>
		<span class="n">iosapic_write</span><span class="p">(</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">low32</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handlers for level-triggered interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">iosapic_startup_level_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unmask_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_unmask_level_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">ia64_vector</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_unmask_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irq_complete_move</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irqd_is_setaffinity_pending</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">do_unmask_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mask_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">unmask_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">,</span> <span class="n">rte_list</span><span class="p">)</span>
		<span class="n">iosapic_eoi</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_unmask_irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_move_masked_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">unmask_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define iosapic_shutdown_level_irq	mask_irq</span>
<span class="cp">#define iosapic_enable_level_irq	unmask_irq</span>
<span class="cp">#define iosapic_disable_level_irq	mask_irq</span>
<span class="cp">#define iosapic_ack_level_irq		nop</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">irq_type_iosapic_level</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>			<span class="s">&quot;IO-SAPIC-level&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_startup</span> <span class="o">=</span>		<span class="n">iosapic_startup_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_shutdown</span> <span class="o">=</span>		<span class="n">iosapic_shutdown_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span> <span class="o">=</span>		<span class="n">iosapic_enable_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span> <span class="o">=</span>		<span class="n">iosapic_disable_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span> <span class="o">=</span>		<span class="n">iosapic_ack_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span> <span class="o">=</span>		<span class="n">mask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span> <span class="o">=</span>		<span class="n">iosapic_unmask_level_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span> <span class="o">=</span>	<span class="n">iosapic_set_affinity</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Handlers for edge-triggered interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">iosapic_startup_edge_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unmask_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * IOSAPIC simply drops interrupts pended while the</span>
<span class="cm">	 * corresponding pin was masked, so we can&#39;t know if an</span>
<span class="cm">	 * interrupt is pending already.  Let&#39;s hope not...</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">iosapic_ack_edge_irq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_complete_move</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">irq_move_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define iosapic_enable_edge_irq		unmask_irq</span>
<span class="cp">#define iosapic_disable_edge_irq	nop</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">irq_type_iosapic_edge</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>			<span class="s">&quot;IO-SAPIC-edge&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_startup</span> <span class="o">=</span>		<span class="n">iosapic_startup_edge_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_shutdown</span> <span class="o">=</span>		<span class="n">iosapic_disable_edge_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span> <span class="o">=</span>		<span class="n">iosapic_enable_edge_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span> <span class="o">=</span>		<span class="n">iosapic_disable_edge_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span> <span class="o">=</span>		<span class="n">iosapic_ack_edge_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span> <span class="o">=</span>		<span class="n">mask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span> <span class="o">=</span>		<span class="n">unmask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span> <span class="o">=</span>	<span class="n">iosapic_set_affinity</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">iosapic_version</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * IOSAPIC Version Register return 32 bit structure like:</span>
<span class="cm">	 * {</span>
<span class="cm">	 *	unsigned int version   : 8;</span>
<span class="cm">	 *	unsigned int reserved1 : 8;</span>
<span class="cm">	 *	unsigned int max_redir : 8;</span>
<span class="cm">	 *	unsigned int reserved2 : 8;</span>
<span class="cm">	 * }</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__iosapic_read</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">IOSAPIC_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iosapic_find_sharable_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_intr_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * shared vectors for edge-triggered interrupts are not</span>
<span class="cm">	 * supported yet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">trigger</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">polarity</span> <span class="o">==</span> <span class="n">pol</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dmode</span> <span class="o">==</span> <span class="n">IOSAPIC_FIXED</span> <span class="o">||</span>
		     <span class="n">info</span><span class="o">-&gt;</span><span class="n">dmode</span> <span class="o">==</span> <span class="n">IOSAPIC_LOWEST_PRIORITY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">can_request_irq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">irq</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">min_count</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if the given vector is already owned by other,</span>
<span class="cm"> *  assign a new vector for the other and make the vector available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">iosapic_reassign_vector</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_irq</span> <span class="o">=</span> <span class="n">create_irq</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: out of interrupt vectors!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Reassigning vector %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">new_irq</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">new_irq</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">],</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_intr_info</span><span class="p">));</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">new_irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">);</span>
		<span class="n">list_move</span><span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">new_irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iosapic_intr_info</span><span class="p">));</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">=</span> <span class="n">IOSAPIC_MASK</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_is_shared</span> <span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">irq_chip</span><span class="o">*</span>
<span class="nf">ia64_native_iosapic_get_irq_chip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">irq_type_iosapic_edge</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">irq_type_iosapic_level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">register_intr</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">delivery</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">polarity</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="o">*</span><span class="n">irq_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: No IOSAPIC for GSI %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rte</span> <span class="o">=</span> <span class="n">find_rte</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rte</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">rte</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: cannot allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span>	<span class="o">=</span> <span class="n">gsi</span> <span class="o">-</span> <span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">gsi_base</span><span class="p">;</span>
		<span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">);</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rtes_inuse</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="n">NO_REF_RTE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iosapic_intr_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">trigger</span> <span class="o">!=</span> <span class="n">trigger</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">polarity</span> <span class="o">!=</span> <span class="n">polarity</span><span class="p">)){</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;%s: cannot override the interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rtes_inuse</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">polarity</span> <span class="o">=</span> <span class="n">polarity</span><span class="p">;</span>
	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dmode</span>    <span class="o">=</span> <span class="n">delivery</span><span class="p">;</span>
	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">trigger</span>  <span class="o">=</span> <span class="n">trigger</span><span class="p">;</span>

	<span class="n">irq_type</span> <span class="o">=</span> <span class="n">iosapic_get_irq_chip</span><span class="p">(</span><span class="n">trigger</span><span class="p">);</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">irq_get_chip</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_type</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span> <span class="o">!=</span> <span class="n">irq_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">no_irq_chip</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s: changing vector %d from %s to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span>
			       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">irq_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="n">irq_type</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__irq_set_chip_handler_name_locked</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">?</span>
					   <span class="n">handle_edge_irq</span> <span class="o">:</span> <span class="n">handle_level_irq</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">get_target_cpu</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">cpe_vector</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">irq_to_domain</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of vector shared by multiple RTEs, all RTEs that</span>
<span class="cm">	 * share the vector need to use the same destination CPU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dest</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the platform supports redirection via XTP, let it</span>
<span class="cm">	 * distribute interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_int_redirect</span> <span class="o">&amp;</span> <span class="n">SMP_IRQ_REDIRECTION</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some interrupts (ACPI SCI, for instance) are registered</span>
<span class="cm">	 * before the BSP is marked as online.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpe_vector</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">==</span> <span class="n">IA64_CPEP_VECTOR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">get_cpei_target_cpu</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_cpus</span><span class="p">,</span> <span class="n">cpu_index</span><span class="p">,</span> <span class="n">iosapic_index</span><span class="p">,</span> <span class="n">numa_cpu</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_mask</span><span class="p">;</span>

		<span class="n">iosapic_index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iosapic_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">iosapic_index</span><span class="p">].</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_numa_setup</span><span class="p">;</span>

		<span class="n">cpu_mask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">iosapic_index</span><span class="p">].</span><span class="n">node</span><span class="p">);</span>
		<span class="n">num_cpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">numa_cpu</span><span class="p">,</span> <span class="n">cpu_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">numa_cpu</span><span class="p">))</span>
				<span class="n">num_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_cpus</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_numa_setup</span><span class="p">;</span>

		<span class="cm">/* Use irq assignment to distribute across cpus in node */</span>
		<span class="n">cpu_index</span> <span class="o">=</span> <span class="n">irq</span> <span class="o">%</span> <span class="n">num_cpus</span><span class="p">;</span>

		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">numa_cpu</span><span class="p">,</span> <span class="n">cpu_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domain</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">numa_cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">cpu_index</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">numa_cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">numa_cpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">skip_numa_setup:</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, round-robin interrupt vectors across all the</span>
<span class="cm">	 * processors.  (It&#39;d be nice if we could be smarter in the</span>
<span class="cm">	 * case of NUMA.)</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">domain</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else  </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
	<span class="k">return</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">choose_dmode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_int_redirect</span> <span class="o">&amp;</span> <span class="n">SMP_IRQ_REDIRECTION</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IOSAPIC_LOWEST_PRIORITY</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">IOSAPIC_FIXED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ACPI can describe IOSAPIC interrupts via static tables and namespace</span>
<span class="cm"> * methods.  This provides an interface to register those interrupts and</span>
<span class="cm"> * program the IOSAPIC RTE.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">iosapic_register_intr</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">polarity</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this GSI has already been registered (i.e., it&#39;s a</span>
<span class="cm">	 * shared interrupt, or we lost a race to register it),</span>
<span class="cm">	 * don&#39;t touch the RTE.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">__gsi_to_irq</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rte</span> <span class="o">=</span> <span class="n">find_rte</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
			<span class="n">dynamic_irq_init</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">!=</span> <span class="n">NO_REF_RTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock_iosapic_lock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">create_irq</span><span class="p">();</span>

	<span class="cm">/* If vector is running out, we try to find a sharable vector */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">iosapic_find_sharable_irq</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="n">polarity</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_iosapic_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">dest</span> <span class="o">=</span> <span class="n">get_target_cpu</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">dmode</span> <span class="o">=</span> <span class="n">choose_dmode</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_intr</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dmode</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span> <span class="n">trigger</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock_iosapic_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the vector is shared and already unmasked for other</span>
<span class="cm">	 * interrupt sources, don&#39;t mask it.</span>
<span class="cm">	 */</span>
	<span class="n">low32</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_is_shared</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">low32</span> <span class="o">&amp;</span> <span class="n">IOSAPIC_MASK</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_rte</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;GSI %u (%s, %s) -&gt; CPU %d (0x%04x) vector %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">gsi</span><span class="p">,</span> <span class="p">(</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">?</span> <span class="s">&quot;edge&quot;</span> <span class="o">:</span> <span class="s">&quot;level&quot;</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">polarity</span> <span class="o">==</span> <span class="n">IOSAPIC_POL_HIGH</span> <span class="o">?</span> <span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;low&quot;</span><span class="p">),</span>
	       <span class="n">cpu_logical_id</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">dest</span><span class="p">,</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 <span class="nl">unlock_iosapic_lock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">iosapic_unregister_intr</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low32</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">,</span> <span class="n">polarity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iosapic_rte_info</span> <span class="o">*</span><span class="n">rte</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the irq associated with the gsi is not found,</span>
<span class="cm">	 * iosapic_unregister_intr() is unbalanced. We need to check</span>
<span class="cm">	 * this again after getting locks.</span>
<span class="cm">	 */</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">gsi_to_irq</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iosapic_unregister_intr(%u) unbalanced</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">gsi</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rte</span> <span class="o">=</span> <span class="n">find_rte</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;iosapic_unregister_intr(%u) unbalanced</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">gsi</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rte</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="n">NO_REF_RTE</span><span class="p">;</span>

	<span class="cm">/* Mask the interrupt */</span>
	<span class="n">low32</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">|</span> <span class="n">IOSAPIC_MASK</span><span class="p">;</span>
	<span class="n">iosapic_write</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">IOSAPIC_RTE_LOW</span><span class="p">(</span><span class="n">rte</span><span class="o">-&gt;</span><span class="n">rte_index</span><span class="p">),</span> <span class="n">low32</span><span class="p">);</span>

	<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rtes_inuse</span><span class="o">--</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rtes_inuse</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">trigger</span>  <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">trigger</span><span class="p">;</span>
	<span class="n">polarity</span> <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">polarity</span><span class="p">;</span>
	<span class="n">dest</span>     <span class="o">=</span> <span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dest</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;GSI %u (%s, %s) -&gt; CPU %d (0x%04x) vector %d unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">gsi</span><span class="p">,</span> <span class="p">(</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">?</span> <span class="s">&quot;edge&quot;</span> <span class="o">:</span> <span class="s">&quot;level&quot;</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">polarity</span> <span class="o">==</span> <span class="n">IOSAPIC_POL_HIGH</span> <span class="o">?</span> <span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;low&quot;</span><span class="p">),</span>
	       <span class="n">cpu_logical_id</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">dest</span><span class="p">,</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="cm">/* Clear affinity */</span>
		<span class="n">cpumask_setall</span><span class="p">(</span><span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/* Clear the interrupt information */</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">dmode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">polarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">trigger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">|=</span> <span class="n">IOSAPIC_MASK</span><span class="p">;</span>

		<span class="cm">/* Destroy and reserve IRQ */</span>
		<span class="n">destroy_and_reserve_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ACPI calls this when it finds an entry for a platform interrupt.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">iosapic_register_platform_intr</span> <span class="p">(</span><span class="n">u32</span> <span class="n">int_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">iosapic_vector</span><span class="p">,</span> <span class="n">u16</span> <span class="n">eid</span><span class="p">,</span> <span class="n">u16</span> <span class="n">id</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">polarity</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;unknown&quot;</span><span class="p">,</span> <span class="s">&quot;PMI&quot;</span><span class="p">,</span> <span class="s">&quot;INIT&quot;</span><span class="p">,</span> <span class="s">&quot;CPEI&quot;</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">delivery</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">((</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">eid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">int_type</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">ACPI_INTERRUPT_PMI</span>:
		<span class="n">irq</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">iosapic_vector</span><span class="p">;</span>
		<span class="n">bind_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">CPU_MASK_ALL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * since PMI vector is alloc&#39;d by FW(ACPI) not by kernel,</span>
<span class="cm">		 * we need to make sure the vector is available</span>
<span class="cm">		 */</span>
		<span class="n">iosapic_reassign_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">delivery</span> <span class="o">=</span> <span class="n">IOSAPIC_PMI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">ACPI_INTERRUPT_INIT</span>:
		<span class="n">irq</span> <span class="o">=</span> <span class="n">create_irq</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: out of interrupt vectors!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">delivery</span> <span class="o">=</span> <span class="n">IOSAPIC_INIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">ACPI_INTERRUPT_CPEI</span>:
		<span class="n">irq</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">IA64_CPE_VECTOR</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bind_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">CPU_MASK_ALL</span><span class="p">));</span>
		<span class="n">delivery</span> <span class="o">=</span> <span class="n">IOSAPIC_FIXED</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	      <span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: invalid int type 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">int_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_intr</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">delivery</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span> <span class="n">trigger</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;PLATFORM int %s (0x%x): GSI %u (%s, %s) -&gt; CPU %d (0x%04x)&quot;</span>
	       <span class="s">&quot; vector %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">int_type</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">?</span> <span class="n">name</span><span class="p">[</span><span class="n">int_type</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">,</span>
	       <span class="n">int_type</span><span class="p">,</span> <span class="n">gsi</span><span class="p">,</span> <span class="p">(</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">?</span> <span class="s">&quot;edge&quot;</span> <span class="o">:</span> <span class="s">&quot;level&quot;</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">polarity</span> <span class="o">==</span> <span class="n">IOSAPIC_POL_HIGH</span> <span class="o">?</span> <span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;low&quot;</span><span class="p">),</span>
	       <span class="n">cpu_logical_id</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">dest</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>

	<span class="n">set_rte</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vector</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ACPI calls this when it finds an entry for a legacy ISA IRQ override.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">iosapic_override_isa_irq</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isa_irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">polarity</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dmode</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">isa_irq_to_vector</span><span class="p">(</span><span class="n">isa_irq</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bind_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">CPU_MASK_ALL</span><span class="p">));</span>
	<span class="n">dmode</span> <span class="o">=</span> <span class="n">choose_dmode</span><span class="p">();</span>
	<span class="n">register_intr</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dmode</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span> <span class="n">trigger</span><span class="p">);</span>

	<span class="n">DBG</span><span class="p">(</span><span class="s">&quot;ISA: IRQ %u -&gt; GSI %u (%s,%s) -&gt; CPU %d (0x%04x) vector %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">isa_irq</span><span class="p">,</span> <span class="n">gsi</span><span class="p">,</span> <span class="n">trigger</span> <span class="o">==</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">?</span> <span class="s">&quot;edge&quot;</span> <span class="o">:</span> <span class="s">&quot;level&quot;</span><span class="p">,</span>
	    <span class="n">polarity</span> <span class="o">==</span> <span class="n">IOSAPIC_POL_HIGH</span> <span class="o">?</span> <span class="s">&quot;high&quot;</span> <span class="o">:</span> <span class="s">&quot;low&quot;</span><span class="p">,</span>
	    <span class="n">cpu_logical_id</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">dest</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>

	<span class="n">set_rte</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ia64_native_iosapic_pcat_compat_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcat_compat</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Disable the compatibility mode interrupts (8259 style),</span>
<span class="cm">		 * needs IN/OUT support enabled.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;%s: Disabling PC-AT compatible 8259 interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xA1</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">iosapic_system_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">system_pcat_compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="o">++</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">low32</span> <span class="o">=</span> <span class="n">IOSAPIC_MASK</span><span class="p">;</span>
		<span class="cm">/* mark as unused */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">rtes</span><span class="p">);</span>

		<span class="n">iosapic_intr_info</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcat_compat</span> <span class="o">=</span> <span class="n">system_pcat_compat</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcat_compat</span><span class="p">)</span>
		<span class="n">iosapic_pcat_compat_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">iosapic_alloc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">NR_IOSAPICS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: failed to allocate iosapic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">iosapic_free</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">iosapic_check_gsi_range</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_end</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/* check gsi range */</span>
	<span class="n">gsi_end</span> <span class="o">=</span> <span class="n">gsi_base</span> <span class="o">+</span> <span class="p">((</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">NR_IOSAPICS</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gsi_base</span><span class="p">;</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">num_rte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gsi_end</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">gsi_base</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* OK */</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">iosapic_init</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_rte</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isa_irq</span><span class="p">,</span> <span class="n">ver</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ver</span> <span class="o">=</span> <span class="n">iosapic_version</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">iosapic_check_gsi_range</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">,</span> <span class="n">ver</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The MAX_REDIR register holds the highest input pin number</span>
<span class="cm">	 * (starting from 0).  We add 1 so that we can use it for</span>
<span class="cm">	 * number of pins (= RTEs)</span>
<span class="cm">	 */</span>
	<span class="n">num_rte</span> <span class="o">=</span> <span class="p">((</span><span class="n">ver</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">iosapic_alloc</span><span class="p">();</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gsi_base</span> <span class="o">=</span> <span class="n">gsi_base</span><span class="p">;</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">num_rte</span> <span class="o">=</span> <span class="n">num_rte</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">node</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">gsi_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pcat_compat</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Map the legacy ISA devices into the IOSAPIC data.  Some of</span>
<span class="cm">		 * these may get reprogrammed later on with data from the ACPI</span>
<span class="cm">		 * Interrupt Source Override table.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">isa_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">isa_irq</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">isa_irq</span><span class="p">)</span>
			<span class="n">iosapic_override_isa_irq</span><span class="p">(</span><span class="n">isa_irq</span><span class="p">,</span> <span class="n">isa_irq</span><span class="p">,</span>
						 <span class="n">IOSAPIC_POL_HIGH</span><span class="p">,</span>
						 <span class="n">IOSAPIC_EDGE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="kt">int</span>
<span class="nf">iosapic_remove</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: No IOSAPIC for GSI base %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">gsi_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rtes_inuse</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: IOSAPIC for GSI base %u is busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">gsi_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">iosapic_free</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iosapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">map_iosapic_to_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">find_iosapic</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: No IOSAPIC for GSI %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">gsi_base</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iosapic_lists</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
