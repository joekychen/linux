<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › smpboot.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smpboot.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SMP boot-related support</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2003, 2005 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 2001, 2004-2005 Intel Corp</span>
<span class="cm"> * 	Rohit Seth &lt;rohit.seth@intel.com&gt;</span>
<span class="cm"> * 	Suresh Siddha &lt;suresh.b.siddha@intel.com&gt;</span>
<span class="cm"> * 	Gordon Jin &lt;gordon.jin@intel.com&gt;</span>
<span class="cm"> *	Ashok Raj  &lt;ashok.raj@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 01/05/16 Rohit Seth &lt;rohit.seth@intel.com&gt;	Moved SMP booting functions from smp.c to here.</span>
<span class="cm"> * 01/04/27 David Mosberger &lt;davidm@hpl.hp.com&gt;	Added ITC synching code.</span>
<span class="cm"> * 02/07/31 David Mosberger &lt;davidm@hpl.hp.com&gt;	Switch over to hotplug-CPU boot-sequence.</span>
<span class="cm"> *						smp_boot_cpus()/smp_commence() is replaced by</span>
<span class="cm"> *						smp_prepare_cpus()/__cpu_up()/smp_cpus_done().</span>
<span class="cm"> * 04/06/21 Ashok Raj		&lt;ashok.raj@intel.com&gt; Added CPU Hotplug Support</span>
<span class="cm"> * 04/12/26 Jin Gordon &lt;gordon.jin@intel.com&gt;</span>
<span class="cm"> * 04/12/26 Rohit Seth &lt;rohit.seth@intel.com&gt;</span>
<span class="cm"> *						Add multi-threading and multi-core detection</span>
<span class="cm"> * 05/01/30 Suresh Siddha &lt;suresh.b.siddha@intel.com&gt;</span>
<span class="cm"> *						Setup cpu_sibling_map and cpu_core_map</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/cache.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/mca.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;</span>

<span class="cp">#define SMP_DEBUG 0</span>

<span class="cp">#if SMP_DEBUG</span>
<span class="cp">#define Dprintk(x...)  printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define Dprintk(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cp">#ifdef CONFIG_PERMIT_BSP_REMOVE</span>
<span class="cp">#define bsp_remove_ok	1</span>
<span class="cp">#else</span>
<span class="cp">#define bsp_remove_ok	0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Global array allocated for NR_CPUS at boot time</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sal_to_os_boot</span> <span class="n">sal_boot_rendez_state</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * start_ap in head.S uses this to store current booting cpu</span>
<span class="cm"> * info.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sal_to_os_boot</span> <span class="o">*</span><span class="n">sal_state_for_booting_cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sal_boot_rendez_state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="cp">#define set_brendez_area(x) (sal_state_for_booting_cpu = &amp;sal_boot_rendez_state[(x)]);</span>

<span class="cp">#else</span>
<span class="cp">#define set_brendez_area(x)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * ITC synchronization related stuff:</span>
<span class="cm"> */</span>
<span class="cp">#define MASTER	(0)</span>
<span class="cp">#define SLAVE	(SMP_CACHE_BYTES/8)</span>

<span class="cp">#define NUM_ROUNDS	64	</span><span class="cm">/* magic value */</span><span class="cp"></span>
<span class="cp">#define NUM_ITERS	5	</span><span class="cm">/* likewise */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">itc_sync_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="cp">#define DEBUG_ITC_SYNC	0</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_ap</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_iobase</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task_for_booting_cpu</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * State for each CPU</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cpu_state</span><span class="p">);</span>

<span class="n">cpumask_t</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="n">cpumask_t</span><span class="p">,</span> <span class="n">cpu_sibling_map</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">smp_num_siblings</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* which logical CPU number maps to which CPU (physical APIC ID) */</span>
<span class="k">volatile</span> <span class="kt">int</span> <span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_cpu_to_sapicid</span><span class="p">);</span>

<span class="k">static</span> <span class="k">volatile</span> <span class="n">cpumask_t</span> <span class="n">cpu_callin_map</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">smp_boot_data</span> <span class="n">smp_boot_data</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ap_wakeup_vector</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* External Int use to wakeup APs */</span>

<span class="kt">char</span> <span class="n">__initdata</span> <span class="n">no_int_routing</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">smp_int_redirect</span><span class="p">;</span> <span class="cm">/* are INT and IPI redirectable by the chipset? */</span>

<span class="cp">#ifdef CONFIG_FORCE_CPEI_RETARGET</span>
<span class="cp">#define CPEI_OVERRIDE_DEFAULT	(1)</span>
<span class="cp">#else</span>
<span class="cp">#define CPEI_OVERRIDE_DEFAULT	(0)</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">force_cpei_retarget</span> <span class="o">=</span> <span class="n">CPEI_OVERRIDE_DEFAULT</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">cmdl_force_cpei</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">get_option</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">force_cpei_retarget</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;force_cpei=&quot;</span><span class="p">,</span> <span class="n">cmdl_force_cpei</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">nointroute</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">no_int_routing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;no_int_routing on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nointroute&quot;</span><span class="p">,</span> <span class="n">nointroute</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fix_b0_for_bsp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="kt">int</span> <span class="n">cpuid</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">fix_bsp_b0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cache the b0 value on the first AP that comes up</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fix_bsp_b0</span> <span class="o">&amp;&amp;</span> <span class="n">cpuid</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sal_boot_rendez_state</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sal_boot_rendez_state</span><span class="p">[</span><span class="n">cpuid</span><span class="p">].</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Fixed BSP b0 value from CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>

	<span class="n">fix_bsp_b0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">sync_master</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="o">*</span><span class="n">NUM_ITERS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">])</span>
				<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the number of cycles by which our itc differs from the itc on the master</span>
<span class="cm"> * (time-keeper) CPU.  A positive number indicates our itc is ahead of the master,</span>
<span class="cm"> * negative that it is behind.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">get_delta</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">best_t0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">best_t1</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">best_tm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcenter</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">tm</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ITERS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t0</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
		<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tm</span> <span class="o">=</span> <span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">go</span><span class="p">[</span><span class="n">SLAVE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">t1</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span> <span class="o">&lt;</span> <span class="n">best_t1</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">)</span>
			<span class="n">best_t0</span> <span class="o">=</span> <span class="n">t0</span><span class="p">,</span> <span class="n">best_t1</span> <span class="o">=</span> <span class="n">t1</span><span class="p">,</span> <span class="n">best_tm</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">rt</span> <span class="o">=</span> <span class="n">best_t1</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">best_tm</span> <span class="o">-</span> <span class="n">best_t0</span><span class="p">;</span>

	<span class="cm">/* average best_t0 and best_t1 without overflow: */</span>
	<span class="n">tcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_t0</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">best_t1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">best_t0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">best_t1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">++</span><span class="n">tcenter</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tcenter</span> <span class="o">-</span> <span class="n">best_tm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronize ar.itc of the current (slave) CPU with the ar.itc of the MASTER CPU</span>
<span class="cm"> * (normally the time-keeper CPU).  We use a closed loop to eliminate the possibility of</span>
<span class="cm"> * unaccounted-for errors (such as getting a machine check in the middle of a calibration</span>
<span class="cm"> * step).  The basic idea is for the slave to ask the master what itc value it has and to</span>
<span class="cm"> * read its own itc before and after the master responds.  Each iteration gives us three</span>
<span class="cm"> * timestamps:</span>
<span class="cm"> *</span>
<span class="cm"> *	slave		master</span>
<span class="cm"> *</span>
<span class="cm"> *	t0 ---\</span>
<span class="cm"> *             ---\</span>
<span class="cm"> *		   ---&gt;</span>
<span class="cm"> *			tm</span>
<span class="cm"> *		   /---</span>
<span class="cm"> *	       /---</span>
<span class="cm"> *	t1 &lt;---</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is to adjust the slave&#39;s ar.itc such that tm falls exactly half-way between t0</span>
<span class="cm"> * and t1.  If we achieve this, the clocks are synchronized provided the interconnect</span>
<span class="cm"> * between the slave and the master is symmetric.  Even if the interconnect were</span>
<span class="cm"> * asymmetric, we would still know that the synchronization error is smaller than the</span>
<span class="cm"> * roundtrip latency (t0 - t1).</span>
<span class="cm"> *</span>
<span class="cm"> * When the interconnect is quiet and symmetric, this lets us synchronize the itc to</span>
<span class="cm"> * within one or two cycles.  However, we can only *guarantee* that the synchronization is</span>
<span class="cm"> * accurate to within a round-trip time, which is typically in the range of several</span>
<span class="cm"> * hundred cycles (e.g., ~500 cycles).  In practice, this means that the itc&#39;s are usually</span>
<span class="cm"> * almost perfectly synchronized, but we shouldn&#39;t assume that the accuracy is much better</span>
<span class="cm"> * than half a micro second or so.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ia64_sync_itc</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adjust_latency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">master_time_stamp</span><span class="p">,</span> <span class="n">bound</span><span class="p">;</span>
<span class="cp">#if DEBUG_ITC_SYNC</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">rt</span><span class="p">;</span>	<span class="cm">/* roundtrip time */</span>
		<span class="kt">long</span> <span class="n">master</span><span class="p">;</span>	<span class="cm">/* master&#39;s timestamp */</span>
		<span class="kt">long</span> <span class="n">diff</span><span class="p">;</span>	<span class="cm">/* difference between midpoint and master&#39;s timestamp */</span>
		<span class="kt">long</span> <span class="n">lat</span><span class="p">;</span>	<span class="cm">/* estimate of itc adjustment latency */</span>
	<span class="p">}</span> <span class="n">t</span><span class="p">[</span><span class="n">NUM_ROUNDS</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure local timer ticks are disabled while we sync.  If</span>
<span class="cm">	 * they were enabled, we&#39;d have to worry about nasty issues</span>
<span class="cm">	 * like setting the ITC ahead of (or a long time before) the</span>
<span class="cm">	 * next scheduled tick.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">ia64_get_itv</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">sync_master</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sync_itc: failed to get attention of CPU %u!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">go</span><span class="p">[</span><span class="n">MASTER</span><span class="p">])</span>
		<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* wait for master to be ready */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itc_sync_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">get_delta</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master_time_stamp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* let&#39;s lock on to this... */</span>
				<span class="n">bound</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adjust_latency</span> <span class="o">+=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
					<span class="n">adj</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span> <span class="o">+</span> <span class="n">adjust_latency</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">adj</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>

				<span class="n">ia64_set_itc</span><span class="p">(</span><span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">+</span> <span class="n">adj</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#if DEBUG_ITC_SYNC</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">master</span> <span class="o">=</span> <span class="n">master_time_stamp</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diff</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lat</span> <span class="o">=</span> <span class="n">adjust_latency</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">itc_sync_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#if DEBUG_ITC_SYNC</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ROUNDS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rt=%5ld master=%5ld diff=%5ld adjlat=%5ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rt</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">master</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diff</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lat</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU %d: synchronized ITC with CPU %u (last diff %ld cycles, &quot;</span>
	       <span class="s">&quot;maxerr %lu cycles)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">master</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ideally sets up per-cpu profiling hooks.  Doesn&#39;t do much now...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">smp_setup_percpu_timer</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">smp_callin</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpuid</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">,</span> <span class="n">itc_master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">last_cpuinfo</span><span class="p">,</span> <span class="o">*</span><span class="n">this_cpuinfo</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_init_itm</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">extern</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">time_keeper_id</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_init_percpu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">phys_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
	<span class="n">itc_master</span> <span class="o">=</span> <span class="n">time_keeper_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;huh, phys CPU#0x%x, CPU#0x%x already present??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">phys_id</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">fix_b0_for_bsp</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * numa_node_id() works after this.</span>
<span class="cm">	 */</span>
	<span class="n">set_numa_node</span><span class="p">(</span><span class="n">cpu_to_node_map</span><span class="p">[</span><span class="n">cpuid</span><span class="p">]);</span>
	<span class="n">set_numa_mem</span><span class="p">(</span><span class="n">local_memory_node</span><span class="p">(</span><span class="n">cpu_to_node_map</span><span class="p">[</span><span class="n">cpuid</span><span class="p">]));</span>

	<span class="n">ipi_call_lock_irq</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
	<span class="cm">/* Setup the per cpu irq handling data structures */</span>
	<span class="n">__setup_vector_irq</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>
	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_ONLINE</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
	<span class="n">ipi_call_unlock_irq</span><span class="p">();</span>

	<span class="n">smp_setup_percpu_timer</span><span class="p">();</span>

	<span class="n">ia64_mca_cmc_vector_setup</span><span class="p">();</span>	<span class="cm">/* Setup vector on AP */</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="n">pfm_init_percpu</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sal_platform_features</span> <span class="o">&amp;</span> <span class="n">IA64_SAL_PLATFORM_FEATURE_ITC_DRIFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Synchronize the ITC with the BP.  Need to do this after irqs are</span>
<span class="cm">		 * enabled because ia64_sync_itc() calls smp_call_function_single(), which</span>
<span class="cm">		 * calls spin_unlock_bh(), which calls spin_unlock_bh(), which calls</span>
<span class="cm">		 * local_bh_enable(), which bugs out if irqs are not enabled...</span>
<span class="cm">		 */</span>
		<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Going to syncup ITC with ITC Master.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ia64_sync_itc</span><span class="p">(</span><span class="n">itc_master</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get our bogomips.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_init_itm</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delay calibration can be skipped if new processor is identical to the</span>
<span class="cm">	 * previous processor.</span>
<span class="cm">	 */</span>
	<span class="n">last_cpuinfo</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpuid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">this_cpuinfo</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">itc_freq</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">itc_freq</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">proc_freq</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">proc_freq</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">archrev</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">archrev</span> <span class="o">||</span>
	    <span class="n">last_cpuinfo</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">!=</span> <span class="n">this_cpuinfo</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">)</span>
		<span class="n">calibrate_delay</span><span class="p">();</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the master to continue.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Stack on CPU %d at about %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">cpuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Activate a secondary processor.  head.S calls this.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">start_secondary</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Early console may use I/O ports */</span>
	<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_IO_BASE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ia64_iobase</span><span class="p">));</span>
<span class="cp">#ifndef CONFIG_PRINTK_TIME</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;start_secondary: starting CPU 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hard_smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>
	<span class="n">efi_map_pal_code</span><span class="p">();</span>
	<span class="n">cpu_init</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_callin</span><span class="p">();</span>

	<span class="n">cpu_idle</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">__cpuinit</span> <span class="nf">idle_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">do_boot_cpu</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sapicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">task_for_booting_cpu</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Sending wakeup vector %lu to AP 0x%x/0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap_wakeup_vector</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sapicid</span><span class="p">);</span>

	<span class="n">set_brendez_area</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">platform_send_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ap_wakeup_vector</span><span class="p">,</span> <span class="n">IA64_IPI_DM_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait 10s total for the AP to start</span>
<span class="cm">	 */</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;Waiting on callin_map ...&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>  <span class="cm">/* It has booted */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">Dprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Processor 0x%x/0x%x is stuck.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sapicid</span><span class="p">);</span>
		<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>  <span class="cm">/* was set in smp_callin() */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">decay</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ticks</span><span class="p">;</span>
	<span class="n">get_option</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ticks</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;decay=&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the logical CPU number to SAPICID mapping</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">smp_build_cpu_map</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sapicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boot_cpu_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_cpu_id</span><span class="p">;</span>
	<span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">set_cpu_possible</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sapicid</span> <span class="o">=</span> <span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_phys_id</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sapicid</span> <span class="o">==</span> <span class="n">boot_cpu_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">sapicid</span><span class="p">;</span>
		<span class="n">cpu</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cycle through the APs sending Wakeup IPIs to boot each.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">smp_prepare_cpus</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">boot_cpu_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the per-CPU profiling counter/multiplier</span>
<span class="cm">	 */</span>

	<span class="n">smp_setup_percpu_timer</span><span class="p">();</span>

	<span class="n">cpu_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">);</span>

	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">boot_cpu_id</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Boot processor id 0x%x/0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boot_cpu_id</span><span class="p">);</span>

	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If SMP should be disabled, then really disable it!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP mode deactivated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">init_cpu_online</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">init_cpu_possible</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">cpu_set</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="n">set_numa_node</span><span class="p">(</span><span class="n">cpu_to_node_map</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">=</span> <span class="n">CPU_ONLINE</span><span class="p">;</span>
	<span class="n">paravirt_post_smp_prepare_boot_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">clear_cpu_sibling_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">for_each_cpu_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
		<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">remove_siblinginfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cores_per_socket</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpus_weight</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* remove it from all sibling map&#39;s */</span>
	<span class="n">clear_cpu_sibling_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fixup_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">migrate_platform_irqs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_cpei_cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> 		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * dont permit CPEI target to removed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpe_vector</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">is_cpu_cpei_target</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CPU (%d) is CPEI Target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_cpei_retarget</span><span class="p">())</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now re-target the CPEI to a different processor</span>
<span class="cm">			 */</span>
			<span class="n">new_cpei_cpu</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">new_cpei_cpu</span><span class="p">);</span>
			<span class="n">set_cpei_target_cpu</span><span class="p">(</span><span class="n">new_cpei_cpu</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">ia64_cpe_irq</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Switch for now, immediately, we need to do fake intr</span>
<span class="cm">			 * as other interrupts, but need to study CPEI behaviour with</span>
<span class="cm">			 * polling before making changes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_disable</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_enable</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
				<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Re-targeting CPEI to cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_cpei_cpu</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Unable to retarget CPEI, offline cpu [%d] failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* must be called with cpucontrol mutex held */</span>
<span class="kt">int</span> <span class="nf">__cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * dont permit boot processor for now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bsp_remove_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;Your platform does not support removal of BSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_cpu_disable_allowed</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">migrate_platform_irqs</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">remove_siblinginfo</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">fixup_irqs</span><span class="p">();</span>
	<span class="n">local_flush_tlb_all</span><span class="p">();</span>
	<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* They ack this in play_dead by setting CPU_DEAD */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_DEAD</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;CPU %d is now offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
 	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU %u didn&#39;t die...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="kt">void</span>
<span class="nf">smp_cpus_done</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bogosum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the user to impress friends.</span>
<span class="cm">	 */</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bogosum</span> <span class="o">+=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num_online_cpus</span><span class="p">(),</span> <span class="n">bogosum</span><span class="o">/</span><span class="p">(</span><span class="mi">500000</span><span class="o">/</span><span class="n">HZ</span><span class="p">),</span> <span class="p">(</span><span class="n">bogosum</span><span class="o">/</span><span class="p">(</span><span class="mi">5000</span><span class="o">/</span><span class="n">HZ</span><span class="p">))</span><span class="o">%</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">set_cpu_sibling_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">socket_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">socket_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpu_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
			<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpu_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
				<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">__cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sapicid</span><span class="p">;</span>

	<span class="n">sapicid</span> <span class="o">=</span> <span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sapicid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Already booted cpu? not valid anymore since we dont</span>
<span class="cm">	 * do idle loop tightspin anymore.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_isset</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_UP_PREPARE</span><span class="p">;</span>
	<span class="cm">/* Processor goes to start_secondary(), sets online flag */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_boot_cpu</span><span class="p">(</span><span class="n">sapicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">tidle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cores_per_socket</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_cpu_sibling_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assume that CPUs have been discovered by some platform-dependent interface.  For</span>
<span class="cm"> * SoftSDV/Lion, that would be ACPI.</span>
<span class="cm"> *</span>
<span class="cm"> * Setup of the IPI irq handler is done in irq.c:init_IRQ_SMP().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">init_smp_config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fptr</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gp</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">ap_startup</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sal_ret</span><span class="p">;</span>

	<span class="cm">/* Tell SAL where to drop the APs.  */</span>
	<span class="n">ap_startup</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fptr</span> <span class="o">*</span><span class="p">)</span> <span class="n">start_ap</span><span class="p">;</span>
	<span class="n">sal_ret</span> <span class="o">=</span> <span class="n">ia64_sal_set_vectors</span><span class="p">(</span><span class="n">SAL_VECTOR_OS_BOOT_RENDEZ</span><span class="p">,</span>
				       <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">ap_startup</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">),</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">ap_startup</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sal_ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SMP: Can&#39;t set SAL AP Boot Rendezvous: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ia64_sal_strerror</span><span class="p">(</span><span class="n">sal_ret</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * identify_siblings(cpu) gets called from identify_cpu. This populates the </span>
<span class="cm"> * information related to logical execution units in per_cpu_data structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">identify_siblings</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pltid</span><span class="p">;</span>
	<span class="n">pal_logical_to_physical_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_logical_to_phys</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PAL_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PAL_STATUS_UNIMPLEMENTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;ia64_pal_logical_to_phys failed with %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="p">.</span><span class="n">overview_ppid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">overview_cpp</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">overview_tpc</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_sal_physical_id_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pltid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PAL_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PAL_STATUS_UNIMPLEMENTED</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;ia64_sal_pltid failed with %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">socket_id</span> <span class="o">=</span>  <span class="p">(</span><span class="n">pltid</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">info</span><span class="p">.</span><span class="n">overview_ppid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">overview_cpp</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="p">.</span><span class="n">overview_tpc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cores_per_socket</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">overview_cpp</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">overview_tpc</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">num_log</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">overview_num_log</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">core_id</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">log1_cid</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">thread_id</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">log1_tid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns non zero, if multi-threading is enabled</span>
<span class="cm"> * on at least one physical package. Due to hotplug cpu</span>
<span class="cm"> * and (maxcpus=), all threads may not necessarily be enabled</span>
<span class="cm"> * even though the processor supports multi-threading.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">is_multithreading_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">socket_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">socket_id</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core_id</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">is_multithreading_enabled</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
