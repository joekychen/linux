<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › unwind_i.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>unwind_i.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000, 2002-2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel unwind support.</span>
<span class="cm"> */</span>

<span class="cp">#define UNW_VER(x)		((x) &gt;&gt; 48)</span>
<span class="cp">#define UNW_FLAG_MASK		0x0000ffff00000000</span>
<span class="cp">#define UNW_FLAG_OSMASK		0x0000f00000000000</span>
<span class="cp">#define UNW_FLAG_EHANDLER(x)	((x) &amp; 0x0000000100000000L)</span>
<span class="cp">#define UNW_FLAG_UHANDLER(x)	((x) &amp; 0x0000000200000000L)</span>
<span class="cp">#define UNW_LENGTH(x)		((x) &amp; 0x00000000ffffffffL)</span>

<span class="k">enum</span> <span class="n">unw_register_index</span> <span class="p">{</span>
	<span class="cm">/* primary unat: */</span>
	<span class="n">UNW_REG_PRI_UNAT_GR</span><span class="p">,</span>
	<span class="n">UNW_REG_PRI_UNAT_MEM</span><span class="p">,</span>

	<span class="cm">/* register stack */</span>
	<span class="n">UNW_REG_BSP</span><span class="p">,</span>					<span class="cm">/* register stack pointer */</span>
	<span class="n">UNW_REG_BSPSTORE</span><span class="p">,</span>
	<span class="n">UNW_REG_PFS</span><span class="p">,</span>					<span class="cm">/* previous function state */</span>
	<span class="n">UNW_REG_RNAT</span><span class="p">,</span>
	<span class="cm">/* memory stack */</span>
	<span class="n">UNW_REG_PSP</span><span class="p">,</span>					<span class="cm">/* previous memory stack pointer */</span>
	<span class="cm">/* return pointer: */</span>
	<span class="n">UNW_REG_RP</span><span class="p">,</span>

	<span class="cm">/* preserved registers: */</span>
	<span class="n">UNW_REG_R4</span><span class="p">,</span> <span class="n">UNW_REG_R5</span><span class="p">,</span> <span class="n">UNW_REG_R6</span><span class="p">,</span> <span class="n">UNW_REG_R7</span><span class="p">,</span>
	<span class="n">UNW_REG_UNAT</span><span class="p">,</span> <span class="n">UNW_REG_PR</span><span class="p">,</span> <span class="n">UNW_REG_LC</span><span class="p">,</span> <span class="n">UNW_REG_FPSR</span><span class="p">,</span>
	<span class="n">UNW_REG_B1</span><span class="p">,</span> <span class="n">UNW_REG_B2</span><span class="p">,</span> <span class="n">UNW_REG_B3</span><span class="p">,</span> <span class="n">UNW_REG_B4</span><span class="p">,</span> <span class="n">UNW_REG_B5</span><span class="p">,</span>
	<span class="n">UNW_REG_F2</span><span class="p">,</span> <span class="n">UNW_REG_F3</span><span class="p">,</span> <span class="n">UNW_REG_F4</span><span class="p">,</span> <span class="n">UNW_REG_F5</span><span class="p">,</span>
	<span class="n">UNW_REG_F16</span><span class="p">,</span> <span class="n">UNW_REG_F17</span><span class="p">,</span> <span class="n">UNW_REG_F18</span><span class="p">,</span> <span class="n">UNW_REG_F19</span><span class="p">,</span>
	<span class="n">UNW_REG_F20</span><span class="p">,</span> <span class="n">UNW_REG_F21</span><span class="p">,</span> <span class="n">UNW_REG_F22</span><span class="p">,</span> <span class="n">UNW_REG_F23</span><span class="p">,</span>
	<span class="n">UNW_REG_F24</span><span class="p">,</span> <span class="n">UNW_REG_F25</span><span class="p">,</span> <span class="n">UNW_REG_F26</span><span class="p">,</span> <span class="n">UNW_REG_F27</span><span class="p">,</span>
	<span class="n">UNW_REG_F28</span><span class="p">,</span> <span class="n">UNW_REG_F29</span><span class="p">,</span> <span class="n">UNW_REG_F30</span><span class="p">,</span> <span class="n">UNW_REG_F31</span><span class="p">,</span>
	<span class="n">UNW_NUM_REGS</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_info_block</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* unwind descriptors */</span>
	<span class="cm">/* personality routine and language-specific data follow behind descriptors */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_table</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* must be first member! */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gp</span><span class="p">;</span>		<span class="cm">/* global pointer for this load-module */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segment_base</span><span class="p">;</span>	<span class="cm">/* base for offsets in the unwind table entries */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">unw_table_entry</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">unw_where</span> <span class="p">{</span>
	<span class="n">UNW_WHERE_NONE</span><span class="p">,</span>			<span class="cm">/* register isn&#39;t saved at all */</span>
	<span class="n">UNW_WHERE_GR</span><span class="p">,</span>			<span class="cm">/* register is saved in a general register */</span>
	<span class="n">UNW_WHERE_FR</span><span class="p">,</span>			<span class="cm">/* register is saved in a floating-point register */</span>
	<span class="n">UNW_WHERE_BR</span><span class="p">,</span>			<span class="cm">/* register is saved in a branch register */</span>
	<span class="n">UNW_WHERE_SPREL</span><span class="p">,</span>		<span class="cm">/* register is saved on memstack (sp-relative) */</span>
	<span class="n">UNW_WHERE_PSPREL</span><span class="p">,</span>		<span class="cm">/* register is saved on memstack (psp-relative) */</span>
	<span class="cm">/*</span>
<span class="cm">	 * At the end of each prologue these locations get resolved to</span>
<span class="cm">	 * UNW_WHERE_PSPREL and UNW_WHERE_GR, respectively:</span>
<span class="cm">	 */</span>
	<span class="n">UNW_WHERE_SPILL_HOME</span><span class="p">,</span>		<span class="cm">/* register is saved in its spill home */</span>
	<span class="n">UNW_WHERE_GR_SAVE</span>		<span class="cm">/* register is saved in next general register */</span>
<span class="p">};</span>

<span class="cp">#define UNW_WHEN_NEVER	0x7fffffff</span>

<span class="k">struct</span> <span class="n">unw_reg_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>		<span class="cm">/* save location: register number or offset */</span>
	<span class="k">enum</span> <span class="n">unw_where</span> <span class="n">where</span><span class="p">;</span>		<span class="cm">/* where the register gets saved */</span>
	<span class="kt">int</span> <span class="n">when</span><span class="p">;</span>			<span class="cm">/* when the register gets saved */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_reg_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_reg_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* next (outer) element on state stack */</span>
	<span class="k">struct</span> <span class="n">unw_reg_info</span> <span class="n">reg</span><span class="p">[</span><span class="n">UNW_NUM_REGS</span><span class="p">];</span>	<span class="cm">/* register save locations */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_labeled_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_labeled_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* next labeled state (or NULL) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">label</span><span class="p">;</span>			<span class="cm">/* label for this state */</span>
	<span class="k">struct</span> <span class="n">unw_reg_state</span> <span class="n">saved_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_state_record</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_region</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* is this the first region? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* are we done scanning descriptors? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">any_spills</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* got any register spills? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_body</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* are we inside a body (as opposed to a prologue)? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* see UNW_FLAG_* in unwind.h */</span>

	<span class="n">u8</span> <span class="o">*</span><span class="n">imask</span><span class="p">;</span>			<span class="cm">/* imask of spill_mask record or NULL */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pr_val</span><span class="p">;</span>		<span class="cm">/* predicate values */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pr_mask</span><span class="p">;</span>		<span class="cm">/* predicate mask */</span>
	<span class="kt">long</span> <span class="n">spill_offset</span><span class="p">;</span>		<span class="cm">/* psp-relative offset for spill base */</span>
	<span class="kt">int</span> <span class="n">region_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">region_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">epilogue_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">epilogue_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">when_target</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">gr_save_loc</span><span class="p">;</span>			<span class="cm">/* next general register to use for saving a register */</span>
	<span class="n">u8</span> <span class="n">return_link_reg</span><span class="p">;</span>		<span class="cm">/* branch register in which the return link is passed */</span>

	<span class="k">struct</span> <span class="n">unw_labeled_state</span> <span class="o">*</span><span class="n">labeled_states</span><span class="p">;</span>	<span class="cm">/* list of all labeled states */</span>
	<span class="k">struct</span> <span class="n">unw_reg_state</span> <span class="n">curr</span><span class="p">;</span>	<span class="cm">/* current state */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">unw_nat_type</span> <span class="p">{</span>
	<span class="n">UNW_NAT_NONE</span><span class="p">,</span>		<span class="cm">/* NaT not represented */</span>
	<span class="n">UNW_NAT_VAL</span><span class="p">,</span>		<span class="cm">/* NaT represented by NaT value (fp reg) */</span>
	<span class="n">UNW_NAT_MEMSTK</span><span class="p">,</span>		<span class="cm">/* NaT value is in unat word at offset OFF  */</span>
	<span class="n">UNW_NAT_REGSTK</span>		<span class="cm">/* NaT is in rnat */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">unw_insn_opcode</span> <span class="p">{</span>
	<span class="n">UNW_INSN_ADD</span><span class="p">,</span>			<span class="cm">/* s[dst] += val */</span>
	<span class="n">UNW_INSN_ADD_PSP</span><span class="p">,</span>		<span class="cm">/* s[dst] = (s.psp + val) */</span>
	<span class="n">UNW_INSN_ADD_SP</span><span class="p">,</span>		<span class="cm">/* s[dst] = (s.sp + val) */</span>
	<span class="n">UNW_INSN_MOVE</span><span class="p">,</span>			<span class="cm">/* s[dst] = s[val] */</span>
	<span class="n">UNW_INSN_MOVE2</span><span class="p">,</span>			<span class="cm">/* s[dst] = s[val]; s[dst+1] = s[val+1] */</span>
	<span class="n">UNW_INSN_MOVE_STACKED</span><span class="p">,</span>		<span class="cm">/* s[dst] = ia64_rse_skip(*s.bsp, val) */</span>
	<span class="n">UNW_INSN_SETNAT_MEMSTK</span><span class="p">,</span>		<span class="cm">/* s[dst+1].nat.type = MEMSTK;</span>
<span class="cm">					   s[dst+1].nat.off = *s.pri_unat - s[dst] */</span>
	<span class="n">UNW_INSN_SETNAT_TYPE</span><span class="p">,</span>		<span class="cm">/* s[dst+1].nat.type = val */</span>
	<span class="n">UNW_INSN_LOAD</span><span class="p">,</span>			<span class="cm">/* s[dst] = *s[val] */</span>
	<span class="n">UNW_INSN_MOVE_SCRATCH</span><span class="p">,</span>		<span class="cm">/* s[dst] = scratch reg &quot;val&quot; */</span>
	<span class="n">UNW_INSN_MOVE_CONST</span><span class="p">,</span>            <span class="cm">/* s[dst] = constant reg &quot;val&quot; */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unw_insn</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opc</span>	<span class="o">:</span>  <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst</span>	<span class="o">:</span>  <span class="mi">9</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">int</span> <span class="n">val</span>		<span class="o">:</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Preserved general static registers (r4-r7) give rise to two script</span>
<span class="cm"> * instructions; everything else yields at most one instruction; at</span>
<span class="cm"> * the end of the script, the psp gets popped, accounting for one more</span>
<span class="cm"> * instruction.</span>
<span class="cm"> */</span>
<span class="cp">#define UNW_MAX_SCRIPT_LEN	(UNW_NUM_REGS + 5)</span>

<span class="k">struct</span> <span class="n">unw_script</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>		<span class="cm">/* ip this script is for */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pr_mask</span><span class="p">;</span>		<span class="cm">/* mask of predicates script depends on */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pr_val</span><span class="p">;</span>		<span class="cm">/* predicate values this script is for */</span>
	<span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* see UNW_FLAG_* in unwind.h */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">lru_chain</span><span class="p">;</span>	<span class="cm">/* used for least-recently-used chain */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">coll_chain</span><span class="p">;</span>	<span class="cm">/* used for hash collisions */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">hint</span><span class="p">;</span>		<span class="cm">/* hint for next script to try (or -1) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* number of instructions in script */</span>
	<span class="k">struct</span> <span class="n">unw_insn</span> <span class="n">insn</span><span class="p">[</span><span class="n">UNW_MAX_SCRIPT_LEN</span><span class="p">];</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
