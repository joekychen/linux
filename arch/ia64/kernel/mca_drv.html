<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › mca_drv.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mca_drv.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File:	mca_drv.h</span>
<span class="cm"> * Purpose:	Define helpers for Generic MCA handling</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 FUJITSU LIMITED</span>
<span class="cm"> * Copyright (C) 2004 Hidetoshi Seto &lt;seto.hidetoshi@jp.fujitsu.com&gt;</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Processor error section:</span>
<span class="cm"> *</span>
<span class="cm"> *  +-sal_log_processor_info_t *info-------------+</span>
<span class="cm"> *  | sal_log_section_hdr_t header;              |</span>
<span class="cm"> *  | ...                                        |</span>
<span class="cm"> *  | sal_log_mod_error_info_t info[0];          |</span>
<span class="cm"> *  +-+----------------+-------------------------+</span>
<span class="cm"> *    | CACHE_CHECK    |  ^ num_cache_check v</span>
<span class="cm"> *    +----------------+</span>
<span class="cm"> *    | TLB_CHECK      |  ^ num_tlb_check v</span>
<span class="cm"> *    +----------------+</span>
<span class="cm"> *    | BUS_CHECK      |  ^ num_bus_check v</span>
<span class="cm"> *    +----------------+</span>
<span class="cm"> *    | REG_FILE_CHECK |  ^ num_reg_file_check v</span>
<span class="cm"> *    +----------------+</span>
<span class="cm"> *    | MS_CHECK       |  ^ num_ms_check v</span>
<span class="cm"> *  +-struct cpuid_info *id----------------------+</span>
<span class="cm"> *  | regs[5];                                   |</span>
<span class="cm"> *  | reserved;                                  |</span>
<span class="cm"> *  +-sal_processor_static_info_t *regs----------+</span>
<span class="cm"> *  | valid;                                     |</span>
<span class="cm"> *  | ...                                        |</span>
<span class="cm"> *  | fr[128];                                   |</span>
<span class="cm"> *  +--------------------------------------------+</span>
<span class="cm"> */</span>

<span class="cm">/* peidx: index of processor error section */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">peidx_table</span> <span class="p">{</span>
	<span class="n">sal_log_processor_info_t</span>        <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sal_cpuid_info</span>           <span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="n">sal_processor_static_info_t</span>     <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
<span class="p">}</span> <span class="n">peidx_table_t</span><span class="p">;</span>

<span class="cp">#define peidx_head(p)   (((p)-&gt;info))</span>
<span class="cp">#define peidx_mid(p)    (((p)-&gt;id))</span>
<span class="cp">#define peidx_bottom(p) (((p)-&gt;regs))</span>

<span class="cp">#define peidx_psp(p)           (&amp;(peidx_head(p)-&gt;proc_state_parameter))</span>
<span class="cp">#define peidx_field_valid(p)   (&amp;(peidx_head(p)-&gt;valid))</span>
<span class="cp">#define peidx_minstate_area(p) (&amp;(peidx_bottom(p)-&gt;min_state_area))</span>

<span class="cp">#define peidx_cache_check_num(p)    (peidx_head(p)-&gt;valid.num_cache_check)</span>
<span class="cp">#define peidx_tlb_check_num(p)      (peidx_head(p)-&gt;valid.num_tlb_check)</span>
<span class="cp">#define peidx_bus_check_num(p)      (peidx_head(p)-&gt;valid.num_bus_check)</span>
<span class="cp">#define peidx_reg_file_check_num(p) (peidx_head(p)-&gt;valid.num_reg_file_check)</span>
<span class="cp">#define peidx_ms_check_num(p)       (peidx_head(p)-&gt;valid.num_ms_check)</span>

<span class="cp">#define peidx_cache_check_idx(p, n)    (n)</span>
<span class="cp">#define peidx_tlb_check_idx(p, n)      (peidx_cache_check_idx(p, peidx_cache_check_num(p)) + n)</span>
<span class="cp">#define peidx_bus_check_idx(p, n)      (peidx_tlb_check_idx(p, peidx_tlb_check_num(p)) + n)</span>
<span class="cp">#define peidx_reg_file_check_idx(p, n) (peidx_bus_check_idx(p, peidx_bus_check_num(p)) + n)</span>
<span class="cp">#define peidx_ms_check_idx(p, n)       (peidx_reg_file_check_idx(p, peidx_reg_file_check_num(p)) + n)</span>

<span class="cp">#define peidx_mod_error_info(p, name, n) \</span>
<span class="cp">({	int __idx = peidx_##name##_idx(p, n); \</span>
<span class="cp">	sal_log_mod_error_info_t *__ret = NULL; \</span>
<span class="cp">	if (peidx_##name##_num(p) &gt; n) </span><span class="cm">/*BUG*/</span><span class="cp"> \</span>
<span class="cp">		__ret = &amp;(peidx_head(p)-&gt;info[__idx]); \</span>
<span class="cp">	__ret; })</span>

<span class="cp">#define peidx_cache_check(p, n)    peidx_mod_error_info(p, cache_check, n)</span>
<span class="cp">#define peidx_tlb_check(p, n)      peidx_mod_error_info(p, tlb_check, n)</span>
<span class="cp">#define peidx_bus_check(p, n)      peidx_mod_error_info(p, bus_check, n)</span>
<span class="cp">#define peidx_reg_file_check(p, n) peidx_mod_error_info(p, reg_file_check, n)</span>
<span class="cp">#define peidx_ms_check(p, n)       peidx_mod_error_info(p, ms_check, n)</span>

<span class="cp">#define peidx_check_info(proc, name, n) \</span>
<span class="cp">({ \</span>
<span class="cp">	sal_log_mod_error_info_t *__info = peidx_mod_error_info(proc, name, n);\</span>
<span class="cp">	u64 __temp = __info &amp;&amp; __info-&gt;valid.check_info \</span>
<span class="cp">		? __info-&gt;check_info : 0; \</span>
<span class="cp">	__temp; })</span>

<span class="cm">/* slidx: index of SAL log error record */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">slidx_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">sal_log_section_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">slidx_list_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">slidx_table</span> <span class="p">{</span>
	<span class="n">sal_log_record_header_t</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_sections</span><span class="p">;</span>			<span class="cm">/* # of section headers */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">proc_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mem_dev_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sel_dev_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pci_bus_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">smbios_dev_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pci_comp_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">plat_specific_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">host_ctlr_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">plat_bus_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">unsupported</span><span class="p">;</span>	<span class="cm">/* list of unsupported sections */</span>
<span class="p">}</span> <span class="n">slidx_table_t</span><span class="p">;</span>

<span class="cp">#define slidx_foreach_entry(pos, head) \</span>
<span class="cp">	list_for_each_entry(pos, head, list)</span>
<span class="cp">#define slidx_first_entry(head) \</span>
<span class="cp">	(((head)-&gt;next != (head)) ? list_entry((head)-&gt;next, typeof(slidx_list_t), list) : NULL)</span>
<span class="cp">#define slidx_count(slidx, sec) \</span>
<span class="cp">({	int __count = 0; \</span>
<span class="cp">	slidx_list_t *__pos; \</span>
<span class="cp">	slidx_foreach_entry(__pos, &amp;((slidx)-&gt;sec)) { __count++; }\</span>
<span class="cp">	__count; })</span>

<span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_addr</span><span class="p">;</span>	<span class="cm">/* location-relative starting address of MCA recoverable range */</span>
	<span class="kt">int</span> <span class="n">end_addr</span><span class="p">;</span>	<span class="cm">/* location-relative ending address of MCA recoverable range */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mca_table_entry</span> <span class="o">*</span><span class="n">search_mca_tables</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mca_recover_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_mlogbuf_dump</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
ss="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_isolate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ISOLATE_OK</span><span class="p">;</span> <span class="cm">/* already listed */</span>

	<span class="cm">/* limitation check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_page_isolate</span> <span class="o">==</span> <span class="n">MAX_PAGE_ISOLATE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ISOLATE_NG</span><span class="p">;</span>

	<span class="cm">/* kick pages having attribute &#39;SLAB&#39; or &#39;Reserved&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageReserved</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ISOLATE_NG</span><span class="p">;</span>

	<span class="cm">/* add attribute &#39;Reserved&#39; and register the page */</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">page_isolate</span><span class="p">[</span><span class="n">num_page_isolate</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ISOLATE_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mca_hanlder_bh - Kill the process which occurred memory read error</span>
<span class="cm"> * @paddr:	poisoned address received from MCA Handler</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">mca_handler_bh</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">iip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_mlogbuf_dump</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;OS_MCA: process [cpu %d, pid: %d, uid: %d, &quot;</span>
		<span class="s">&quot;iip: %p, psr: 0x%lx,paddr: 0x%lx](%s) encounters MCA.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current_uid</span><span class="p">(),</span>
		<span class="n">iip</span><span class="p">,</span> <span class="n">ipsr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mca_bh_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mca_page_isolate</span><span class="p">(</span><span class="n">paddr</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ISOLATE_OK</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Page isolation: ( %lx ) success.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ISOLATE_NG</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Page isolation: ( %lx ) failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mca_bh_lock</span><span class="p">);</span>

	<span class="cm">/* This process is about to be killed itself */</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mca_make_peidx - Make index of processor error section</span>
<span class="cm"> * @slpi:	pointer to record of processor error section</span>
<span class="cm"> * @peidx:	pointer to index of processor error section</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mca_make_peidx</span><span class="p">(</span><span class="n">sal_log_processor_info_t</span> <span class="o">*</span><span class="n">slpi</span><span class="p">,</span> <span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * calculate the start address of</span>
<span class="cm">	 *   &quot;struct cpuid_info&quot; and &quot;sal_processor_static_info_t&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">total_check_num</span> <span class="o">=</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">num_cache_check</span>
				<span class="o">+</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">num_tlb_check</span>
				<span class="o">+</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">num_bus_check</span>
				<span class="o">+</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">num_reg_file_check</span>
				<span class="o">+</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">num_ms_check</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">head_size</span> <span class="o">=</span>	<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_mod_error_info_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_check_num</span>
			<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_processor_info_t</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">mid_size</span>  <span class="o">=</span> <span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">cpuid_info</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sal_cpuid_info</span><span class="p">);</span>

	<span class="n">peidx_head</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span>   <span class="o">=</span> <span class="n">slpi</span><span class="p">;</span>
	<span class="n">peidx_mid</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span>    <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sal_cpuid_info</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">cpuid_info</span> <span class="o">?</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">slpi</span> <span class="o">+</span> <span class="n">head_size</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">peidx_bottom</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sal_processor_static_info_t</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">slpi</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">psi_static_struct</span> <span class="o">?</span>
			<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">slpi</span> <span class="o">+</span> <span class="n">head_size</span> <span class="o">+</span> <span class="n">mid_size</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mca_make_slidx -  Make index of SAL error record</span>
<span class="cm"> * @buffer:	pointer to SAL error record</span>
<span class="cm"> * @slidx:	pointer to index of SAL error record</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 if record has platform error / 0 if not</span>
<span class="cm"> */</span>
<span class="cp">#define LOG_INDEX_ADD_SECT_PTR(sect, ptr) \</span>
<span class="cp">	{slidx_list_t *hl = &amp;slidx_pool.buffer[slidx_pool.cur_idx]; \</span>
<span class="cp">	hl-&gt;hdr = ptr; \</span>
<span class="cp">	list_add(&amp;hl-&gt;list, &amp;(sect)); \</span>
<span class="cp">	slidx_pool.cur_idx = (slidx_pool.cur_idx + 1)%slidx_pool.max_idx; }</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mca_make_slidx</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">slidx_table_t</span> <span class="o">*</span><span class="n">slidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">platform_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">record_len</span> <span class="o">=</span> <span class="p">((</span><span class="n">sal_log_record_header_t</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ercd_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sects</span><span class="p">;</span>
	<span class="n">sal_log_section_hdr_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize index referring current record</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">proc_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">mem_dev_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">sel_dev_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">pci_bus_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">smbios_dev_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">pci_comp_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">plat_specific_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">host_ctlr_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">plat_bus_err</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">unsupported</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extract a Record Header</span>
<span class="cm">	 */</span>
	<span class="n">slidx</span><span class="o">-&gt;</span><span class="n">header</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extract each section records</span>
<span class="cm">	 * (arranged from &quot;int ia64_log_platform_info_print()&quot;)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ercd_pos</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_record_header_t</span><span class="p">),</span> <span class="n">sects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ercd_pos</span> <span class="o">&lt;</span> <span class="n">record_len</span><span class="p">;</span> <span class="n">ercd_pos</span> <span class="o">+=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">sects</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sal_log_section_hdr_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">ercd_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span> <span class="n">SAL_PROC_DEV_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">proc_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_MEM_DEV_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">mem_dev_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_SEL_DEV_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">sel_dev_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_PCI_BUS_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">pci_bus_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">smbios_dev_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_PCI_COMP_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">pci_comp_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_SPECIFIC_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">plat_specific_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_HOST_CTLR_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">host_ctlr_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">guid</span><span class="p">,</span>
				<span class="n">SAL_PLAT_BUS_ERR_SECT_GUID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">plat_bus_err</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">LOG_INDEX_ADD_SECT_PTR</span><span class="p">(</span><span class="n">slidx</span><span class="o">-&gt;</span><span class="n">unsupported</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">slidx</span><span class="o">-&gt;</span><span class="n">n_sections</span> <span class="o">=</span> <span class="n">sects</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">platform_err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_record_index_pools - Initialize pool of lists for SAL record index</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	0 on Success / -ENOMEM on Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">init_record_index_pools</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rec_max_size</span><span class="p">;</span>  <span class="cm">/* Maximum size of SAL error records */</span>
	<span class="kt">int</span> <span class="n">sect_min_size</span><span class="p">;</span> <span class="cm">/* Minimum size of SAL error sections */</span>
	<span class="cm">/* minimum size table of each section */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">sal_log_sect_min_sizes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_processor_info_t</span><span class="p">)</span>
		<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sal_processor_static_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_mem_dev_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_sel_dev_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_pci_bus_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_smbios_dev_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_pci_comp_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_plat_specific_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_host_ctlr_err_info_t</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">sal_log_plat_bus_err_info_t</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * MCA handler cannot allocate new memory on flight,</span>
<span class="cm">	 * so we preallocate enough memory to handle a SAL record.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Initialize a handling set of slidx_pool:</span>
<span class="cm">	 *   1. Pick up the max size of SAL error records</span>
<span class="cm">	 *   2. Pick up the min size of SAL error sections</span>
<span class="cm">	 *   3. Allocate the pool as enough to 2 SAL records</span>
<span class="cm">	 *     (now we can estimate the maxinum of section in a record.)</span>
<span class="cm">	 */</span>

	<span class="cm">/* - 1 - */</span>
	<span class="n">rec_max_size</span> <span class="o">=</span> <span class="n">sal_rec_max</span><span class="p">;</span>

	<span class="cm">/* - 2 - */</span>
	<span class="n">sect_min_size</span> <span class="o">=</span> <span class="n">sal_log_sect_min_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">sal_log_sect_min_sizes</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sect_min_size</span> <span class="o">&gt;</span> <span class="n">sal_log_sect_min_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">sect_min_size</span> <span class="o">=</span> <span class="n">sal_log_sect_min_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* - 3 - */</span>
	<span class="n">slidx_pool</span><span class="p">.</span><span class="n">max_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">rec_max_size</span><span class="o">/</span><span class="n">sect_min_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">slidx_pool</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">slidx_list_t</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="n">slidx_pool</span><span class="p">.</span><span class="n">max_idx</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">slidx_list_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">slidx_pool</span><span class="p">.</span><span class="n">buffer</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*****************************************************************************</span>
<span class="cm"> * Recovery functions                                                        *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * is_mca_global - Check whether this MCA is global or not</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> * @pbci:	pointer to pal_bus_check_info_t</span>
<span class="cm"> * @sos:	pointer to hand off struct between SAL and OS</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	MCA_IS_LOCAL / MCA_IS_GLOBAL</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">mca_type_t</span>
<span class="nf">is_mca_global</span><span class="p">(</span><span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">,</span> <span class="n">pal_bus_check_info_t</span> <span class="o">*</span><span class="n">pbci</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pal_processor_state_info_t</span> <span class="o">*</span><span class="n">psp</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">pal_processor_state_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">peidx_psp</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PAL can request a rendezvous, if the MCA has a global scope.</span>
<span class="cm">	 * If &quot;rz_always&quot; flag is set, SAL requests MCA rendezvous</span>
<span class="cm">	 * in spite of global MCA.</span>
<span class="cm">	 * Therefore it is local MCA when rendezvous has not been requested.</span>
<span class="cm">	 * Failed to rendezvous, the system must be down.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sos</span><span class="o">-&gt;</span><span class="n">rv_rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="mi">1</span>: <span class="cm">/* SAL rendezvous unsuccessful */</span>
			<span class="k">return</span> <span class="n">MCA_IS_GLOBAL</span><span class="p">;</span>
		<span class="k">case</span>  <span class="mi">0</span>: <span class="cm">/* SAL rendezvous not required */</span>
			<span class="k">return</span> <span class="n">MCA_IS_LOCAL</span><span class="p">;</span>
		<span class="k">case</span>  <span class="mi">1</span>: <span class="cm">/* SAL rendezvous successful int */</span>
		<span class="k">case</span>  <span class="mi">2</span>: <span class="cm">/* SAL rendezvous successful int with init */</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If One or more Cache/TLB/Reg_File/Uarch_Check is here,</span>
<span class="cm">	 * it would be a local MCA. (i.e. processor internal error)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">cc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MCA_IS_LOCAL</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Bus_Check structure with Bus_Check.ib (internal bus error) flag set</span>
<span class="cm">	 * would be a global MCA. (e.g. a system bus address parity error)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbci</span> <span class="o">||</span> <span class="n">pbci</span><span class="o">-&gt;</span><span class="n">ib</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MCA_IS_GLOBAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus_Check structure with Bus_Check.eb (external bus error) flag set</span>
<span class="cm">	 * could be either a local MCA or a global MCA.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Referring Bus_Check.bsi:</span>
<span class="cm">	 *   0: Unknown/unclassified</span>
<span class="cm">	 *   1: BERR#</span>
<span class="cm">	 *   2: BINIT#</span>
<span class="cm">	 *   3: Hard Fail</span>
<span class="cm">	 * (FIXME: Are these SGI specific or generic bsi values?)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pbci</span><span class="o">-&gt;</span><span class="n">eb</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pbci</span><span class="o">-&gt;</span><span class="n">bsi</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="cm">/* e.g. a load from poisoned memory */</span>
				<span class="k">return</span> <span class="n">MCA_IS_LOCAL</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="k">return</span> <span class="n">MCA_IS_GLOBAL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="n">MCA_IS_GLOBAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_target_identifier - Get the valid Cache or Bus check target identifier.</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	target address on Success / 0 on Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">get_target_identifier</span><span class="p">(</span><span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">target_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sal_log_mod_error_info_t</span> <span class="o">*</span><span class="n">smei</span><span class="p">;</span>
	<span class="n">pal_cache_check_info_t</span> <span class="o">*</span><span class="n">pcci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look through the cache checks for a valid target identifier</span>
<span class="cm">	 * If more than one valid target identifier, return the one</span>
<span class="cm">	 * with the lowest cache level.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">peidx_cache_check_num</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smei</span> <span class="o">=</span> <span class="p">(</span><span class="n">sal_log_mod_error_info_t</span> <span class="o">*</span><span class="p">)</span><span class="n">peidx_cache_check</span><span class="p">(</span><span class="n">peidx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smei</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">target_identifier</span> <span class="o">&amp;&amp;</span> <span class="n">smei</span><span class="o">-&gt;</span><span class="n">target_identifier</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pcci</span> <span class="o">=</span> <span class="p">(</span><span class="n">pal_cache_check_info_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smei</span><span class="o">-&gt;</span><span class="n">check_info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_address</span> <span class="o">||</span> <span class="p">(</span><span class="n">pcci</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">target_address</span> <span class="o">=</span> <span class="n">smei</span><span class="o">-&gt;</span><span class="n">target_identifier</span><span class="p">;</span>
				<span class="n">level</span> <span class="o">=</span> <span class="n">pcci</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_address</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">target_address</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look at the bus check for a valid target identifier</span>
<span class="cm">	 */</span>
	<span class="n">smei</span> <span class="o">=</span> <span class="n">peidx_bus_check</span><span class="p">(</span><span class="n">peidx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smei</span> <span class="o">&amp;&amp;</span> <span class="n">smei</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">target_identifier</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">smei</span><span class="o">-&gt;</span><span class="n">target_identifier</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recover_from_read_error - Try to recover the errors which type are &quot;read&quot;s.</span>
<span class="cm"> * @slidx:	pointer of index of SAL error record</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> * @pbci:	pointer of pal_bus_check_info</span>
<span class="cm"> * @sos:	pointer to hand off struct between SAL and OS</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on Success / 0 on Failure</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">recover_from_read_error</span><span class="p">(</span><span class="n">slidx_table_t</span> <span class="o">*</span><span class="n">slidx</span><span class="p">,</span>
			<span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">,</span> <span class="n">pal_bus_check_info_t</span> <span class="o">*</span><span class="n">pbci</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">target_identifier</span><span class="p">;</span>
	<span class="n">pal_min_state_area_t</span> <span class="o">*</span><span class="n">pmsa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_psr</span> <span class="o">*</span><span class="n">psr1</span><span class="p">,</span> <span class="o">*</span><span class="n">psr2</span><span class="p">;</span>
	<span class="n">ia64_fptr_t</span> <span class="o">*</span><span class="n">mca_hdlr_bh</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_fptr_t</span><span class="o">*</span><span class="p">)</span><span class="n">mca_handler_bhhook</span><span class="p">;</span>

	<span class="cm">/* Is target address valid? */</span>
	<span class="n">target_identifier</span> <span class="o">=</span> <span class="n">get_target_identifier</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_identifier</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;target address not valid&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * cpu read or memory-mapped io read</span>
<span class="cm">	 *</span>
<span class="cm">	 *    offending process  affected process  OS MCA do</span>
<span class="cm">	 *     kernel mode        kernel mode       down system</span>
<span class="cm">	 *     kernel mode        user   mode       kill the process</span>
<span class="cm">	 *     user   mode        kernel mode       down system (*)</span>
<span class="cm">	 *     user   mode        user   mode       kill the process</span>
<span class="cm">	 *</span>
<span class="cm">	 * (*) You could terminate offending user-mode process</span>
<span class="cm">	 *    if (pbci-&gt;pv &amp;&amp; pbci-&gt;pl != 0) *and* if you sure</span>
<span class="cm">	 *    the process not have any locks of kernel.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Is minstate valid? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">peidx_bottom</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">peidx_bottom</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">.</span><span class="n">minstate</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;minstate not valid&quot;</span><span class="p">);</span>
	<span class="n">psr1</span> <span class="o">=</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_psr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">peidx_minstate_area</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">);</span>
	<span class="n">psr2</span> <span class="o">=</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_psr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">peidx_minstate_area</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pmsa_xpsr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check the privilege level of interrupted context.</span>
<span class="cm">	 *   If it is user-mode, then terminate affected process.</span>
<span class="cm">	 */</span>

	<span class="n">pmsa</span> <span class="o">=</span> <span class="n">sos</span><span class="o">-&gt;</span><span class="n">pal_min_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psr1</span><span class="o">-&gt;</span><span class="n">cpl</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	   <span class="p">((</span><span class="n">psr2</span><span class="o">-&gt;</span><span class="n">cpl</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mca_recover_range</span><span class="p">(</span><span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  setup for resume to bottom half of MCA,</span>
<span class="cm">		 * &quot;mca_handler_bhhook&quot;</span>
<span class="cm">		 */</span>
		<span class="cm">/* pass to bhhook as argument (gr8, ...) */</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_identifier</span><span class="p">;</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">;</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">10</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">;</span>
		<span class="cm">/* set interrupted return address (but no use) */</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_br0</span> <span class="o">=</span> <span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">;</span>
		<span class="cm">/* change resume address to bottom half */</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span> <span class="o">=</span> <span class="n">mca_hdlr_bh</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_gr</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mca_hdlr_bh</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>
		<span class="cm">/* set cpl with kernel mode */</span>
		<span class="n">psr2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_psr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_ipsr</span><span class="p">;</span>
		<span class="n">psr2</span><span class="o">-&gt;</span><span class="n">cpl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">psr2</span><span class="o">-&gt;</span><span class="n">ri</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">psr2</span><span class="o">-&gt;</span><span class="n">bn</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">psr2</span><span class="o">-&gt;</span><span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">mca_recovered</span><span class="p">(</span><span class="s">&quot;user memory corruption. &quot;</span>
				<span class="s">&quot;kill affected process - recovered.&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;kernel context not recovered, iip 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pmsa</span><span class="o">-&gt;</span><span class="n">pmsa_iip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recover_from_platform_error - Recover from platform error.</span>
<span class="cm"> * @slidx:	pointer of index of SAL error record</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> * @pbci:	pointer of pal_bus_check_info</span>
<span class="cm"> * @sos:	pointer to hand off struct between SAL and OS</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on Success / 0 on Failure</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">recover_from_platform_error</span><span class="p">(</span><span class="n">slidx_table_t</span> <span class="o">*</span><span class="n">slidx</span><span class="p">,</span> <span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">,</span>
			    <span class="n">pal_bus_check_info_t</span> <span class="o">*</span><span class="n">pbci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pal_processor_state_info_t</span> <span class="o">*</span><span class="n">psp</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">pal_processor_state_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">peidx_psp</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">bc</span> <span class="o">&amp;&amp;</span> <span class="n">pbci</span><span class="o">-&gt;</span><span class="n">eb</span> <span class="o">&amp;&amp;</span> <span class="n">pbci</span><span class="o">-&gt;</span><span class="n">bsi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">pbci</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* partial read */</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* full line(cpu) read */</span>
		<span class="k">case</span> <span class="mi">9</span>: <span class="cm">/* I/O space read */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">recover_from_read_error</span><span class="p">(</span><span class="n">slidx</span><span class="p">,</span> <span class="n">peidx</span><span class="p">,</span> <span class="n">pbci</span><span class="p">,</span>
							 <span class="n">sos</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* unknown */</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* partial write */</span>
		<span class="k">case</span> <span class="mi">4</span>: <span class="cm">/* full line write */</span>
		<span class="k">case</span> <span class="mi">5</span>: <span class="cm">/* implicit or explicit write-back operation */</span>
		<span class="k">case</span> <span class="mi">6</span>: <span class="cm">/* snoop probe */</span>
		<span class="k">case</span> <span class="mi">7</span>: <span class="cm">/* incoming or outgoing ptc.g */</span>
		<span class="k">case</span> <span class="mi">8</span>: <span class="cm">/* write coalescing transactions */</span>
		<span class="k">case</span> <span class="mi">10</span>: <span class="cm">/* I/O space write */</span>
		<span class="k">case</span> <span class="mi">11</span>: <span class="cm">/* inter-processor interrupt message(IPI) */</span>
		<span class="k">case</span> <span class="mi">12</span>: <span class="cm">/* interrupt acknowledge or</span>
<span class="cm">				external task priority cycle */</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">cc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">bc</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Cache error */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">recover_from_read_error</span><span class="p">(</span><span class="n">slidx</span><span class="p">,</span> <span class="n">peidx</span><span class="p">,</span> <span class="n">pbci</span><span class="p">,</span> <span class="n">sos</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * recover_from_tlb_check</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on Success / 0 on Failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">recover_from_tlb_check</span><span class="p">(</span><span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sal_log_mod_error_info_t</span> <span class="o">*</span><span class="n">smei</span><span class="p">;</span>
	<span class="n">pal_tlb_check_info_t</span> <span class="o">*</span><span class="n">ptci</span><span class="p">;</span>

	<span class="n">smei</span> <span class="o">=</span> <span class="p">(</span><span class="n">sal_log_mod_error_info_t</span> <span class="o">*</span><span class="p">)</span><span class="n">peidx_tlb_check</span><span class="p">(</span><span class="n">peidx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ptci</span> <span class="o">=</span> <span class="p">(</span><span class="n">pal_tlb_check_info_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">smei</span><span class="o">-&gt;</span><span class="n">check_info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for signature of a duplicate TLB DTC entry, which is</span>
<span class="cm">	 * a SW bug and always fatal.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptci</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">PAL_TLB_CHECK_OP_PURGE</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ptci</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">||</span> <span class="n">ptci</span><span class="o">-&gt;</span><span class="n">dtc</span> <span class="o">||</span> <span class="n">ptci</span><span class="o">-&gt;</span><span class="n">itc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Duplicate TLB entry&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mca_recovered</span><span class="p">(</span><span class="s">&quot;TLB check recovered&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recover_from_processor_error</span>
<span class="cm"> * @platform:	whether there are some platform error section or not</span>
<span class="cm"> * @slidx:	pointer of index of SAL error record</span>
<span class="cm"> * @peidx:	pointer of index of processor error section</span>
<span class="cm"> * @pbci:	pointer of pal_bus_check_info</span>
<span class="cm"> * @sos:	pointer to hand off struct between SAL and OS</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on Success / 0 on Failure</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">recover_from_processor_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">platform</span><span class="p">,</span> <span class="n">slidx_table_t</span> <span class="o">*</span><span class="n">slidx</span><span class="p">,</span>
			     <span class="n">peidx_table_t</span> <span class="o">*</span><span class="n">peidx</span><span class="p">,</span> <span class="n">pal_bus_check_info_t</span> <span class="o">*</span><span class="n">pbci</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pal_processor_state_info_t</span> <span class="o">*</span><span class="n">psp</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">pal_processor_state_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">peidx_psp</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Processor recovery status must key off of the PAL recovery</span>
<span class="cm">	 * status in the Processor State Parameter.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The machine check is corrected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">cm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mca_recovered</span><span class="p">(</span><span class="s">&quot;machine check is already corrected.&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The error was not contained.  Software must be reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">us</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">ci</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;error not contained&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for recoverable TLB check</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">cc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">bc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">||</span> <span class="n">psp</span><span class="o">-&gt;</span><span class="n">uc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">recover_from_tlb_check</span><span class="p">(</span><span class="n">peidx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cache check and bus check bits have four possible states</span>
<span class="cm">	 *   cc bc</span>
<span class="cm">	 *    1  1	Memory error, attempt recovery</span>
<span class="cm">	 *    1  0	Cache error, attempt recovery</span>
<span class="cm">	 *    0  1	I/O error, attempt recovery</span>
<span class="cm">	 *    0  0	Other error type, not recovered</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">cc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">psp</span><span class="o">-&gt;</span><span class="n">bc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pbci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;No cache or bus check&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cannot handle more than one bus check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peidx_bus_check_num</span><span class="p">(</span><span class="n">peidx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Too many bus checks&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pbci</span><span class="o">-&gt;</span><span class="n">ib</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Internal Bus error&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pbci</span><span class="o">-&gt;</span><span class="n">eb</span> <span class="o">&amp;&amp;</span> <span class="n">pbci</span><span class="o">-&gt;</span><span class="n">bsi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;External bus check fatal status&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a local MCA and estimated as a recoverable error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">recover_from_platform_error</span><span class="p">(</span><span class="n">slidx</span><span class="p">,</span> <span class="n">peidx</span><span class="p">,</span> <span class="n">pbci</span><span class="p">,</span> <span class="n">sos</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * On account of strange SAL error record, we cannot recover.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Strange SAL record&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mca_try_to_recover - Try to recover from MCA</span>
<span class="cm"> * @rec:	pointer to a SAL error record</span>
<span class="cm"> * @sos:	pointer to hand off struct between SAL and OS</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *	1 on Success / 0 on Failure</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mca_try_to_recover</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_sal_os_state</span> <span class="o">*</span><span class="n">sos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">platform_err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_proc_err</span><span class="p">;</span>
	<span class="n">slidx_table_t</span> <span class="n">slidx</span><span class="p">;</span>
	<span class="n">peidx_table_t</span> <span class="n">peidx</span><span class="p">;</span>
	<span class="n">pal_bus_check_info_t</span> <span class="n">pbci</span><span class="p">;</span>

	<span class="cm">/* Make index of SAL error record */</span>
	<span class="n">platform_err</span> <span class="o">=</span> <span class="n">mca_make_slidx</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slidx</span><span class="p">);</span>

	<span class="cm">/* Count processor error sections */</span>
	<span class="n">n_proc_err</span> <span class="o">=</span> <span class="n">slidx_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slidx</span><span class="p">,</span> <span class="n">proc_err</span><span class="p">);</span>

	 <span class="cm">/* Now, OS can recover when there is one processor error section */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_proc_err</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Too Many Errors&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n_proc_err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Weird SAL record ... We can&#39;t do anything */</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;Weird SAL record&quot;</span><span class="p">);</span>

	<span class="cm">/* Make index of processor error section */</span>
	<span class="n">mca_make_peidx</span><span class="p">((</span><span class="n">sal_log_processor_info_t</span><span class="o">*</span><span class="p">)</span>
		<span class="n">slidx_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slidx</span><span class="p">.</span><span class="n">proc_err</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peidx</span><span class="p">);</span>

	<span class="cm">/* Extract Processor BUS_CHECK[0] */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u64</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pbci</span><span class="p">)</span> <span class="o">=</span> <span class="n">peidx_check_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peidx</span><span class="p">,</span> <span class="n">bus_check</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Check whether MCA is global or not */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_mca_global</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbci</span><span class="p">,</span> <span class="n">sos</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fatal_mca</span><span class="p">(</span><span class="s">&quot;global MCA&quot;</span><span class="p">);</span>
	
	<span class="cm">/* Try to recover a processor error */</span>
	<span class="k">return</span> <span class="n">recover_from_processor_error</span><span class="p">(</span><span class="n">platform_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peidx</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">pbci</span><span class="p">,</span> <span class="n">sos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * =============================================================================</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">mca_external_handler_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_record_index_pools</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* register external mca handlers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_reg_MCA_extension</span><span class="p">(</span><span class="n">mca_try_to_recover</span><span class="p">))</span> <span class="p">{</span>	
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ia64_reg_MCA_extension failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">slidx_pool</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">mca_external_handler_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* unregister external mca handlers */</span>
	<span class="n">ia64_unreg_MCA_extension</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">slidx_pool</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">mca_external_handler_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mca_external_handler_exit</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">sal_rec_max</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sal_rec_max</span><span class="p">,</span> <span class="s">&quot;Max size of SAL error record&quot;</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;ia64 platform dependent mca handler driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
