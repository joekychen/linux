<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › acpi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>acpi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  acpi.c - Architecture-Specific Low-Level ACPI Support</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1999 VA Linux Systems</span>
<span class="cm"> *  Copyright (C) 1999,2000 Walt Drummond &lt;drummond@valinux.com&gt;</span>
<span class="cm"> *  Copyright (C) 2000, 2002-2003 Hewlett-Packard Co.</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *  Copyright (C) 2000 Intel Corp.</span>
<span class="cm"> *  Copyright (C) 2000,2001 J.I. Lee &lt;jung-ik.lee@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2001 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2001 Jenna Hall &lt;jenna.s.hall@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2001 Takayoshi Kochi &lt;t-kochi@bq.jp.nec.com&gt;</span>
<span class="cm"> *  Copyright (C) 2002 Erich Focht &lt;efocht@ess.nec.de&gt;</span>
<span class="cm"> *  Copyright (C) 2004 Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;acpi/processor.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/iosapic.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/cyclone.h&gt;</span>
<span class="cp">#include &lt;asm/xen/hypervisor.h&gt;</span>

<span class="cp">#define BAD_MADT_ENTRY(entry, end) (                                        \</span>
<span class="cp">		(!entry) || (unsigned long)entry + sizeof(*entry) &gt; end ||  \</span>
<span class="cp">		((struct acpi_subtable_header *)entry)-&gt;length &lt; sizeof(*entry))</span>

<span class="cp">#define PREFIX			&quot;ACPI: &quot;</span>

<span class="n">u32</span> <span class="n">acpi_rsdt_forced</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">acpi_cpei_override</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">acpi_cpei_phys_cpuid</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">acpi_wakeup_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IA64_GENERIC</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">acpi_find_rsdp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rsdp_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">acpi20</span> <span class="o">!=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">)</span>
		<span class="n">rsdp_phys</span> <span class="o">=</span> <span class="n">efi</span><span class="p">.</span><span class="n">acpi20</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">acpi</span> <span class="o">!=</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PREFIX</span>
		       <span class="s">&quot;v1.0/r0.71 tables no longer supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rsdp_phys</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">__init</span> <span class="o">*</span>
<span class="nf">acpi_get_sysname</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rsdp_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_rsdp</span> <span class="o">*</span><span class="n">rsdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_xsdt</span> <span class="o">*</span><span class="n">xsdt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_INTEL_IOMMU</span>
	<span class="n">u64</span> <span class="n">i</span><span class="p">,</span> <span class="n">nentries</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">rsdp_phys</span> <span class="o">=</span> <span class="n">acpi_find_rsdp</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsdp_phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ACPI 2.0 RSDP not found, default to </span><span class="se">\&quot;</span><span class="s">dig</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="s">&quot;dig&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rsdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">rsdp_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_RSDP</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ACPI_SIG_RSDP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ACPI 2.0 RSDP signature incorrect, default to </span><span class="se">\&quot;</span><span class="s">dig</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="s">&quot;dig&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xsdt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_xsdt</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">xsdt_physical_address</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xsdt</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_XSDT</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ACPI_SIG_XSDT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ACPI 2.0 XSDT signature incorrect, default to </span><span class="se">\&quot;</span><span class="s">dig</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="s">&quot;dig&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">oem_id</span><span class="p">,</span> <span class="s">&quot;HP&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;hpzx1&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">oem_id</span><span class="p">,</span> <span class="s">&quot;SGI&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">oem_table_id</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;UV&quot;</span><span class="p">))</span>
			<span class="k">return</span> <span class="s">&quot;uv&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="s">&quot;sn2&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xen_pv_domain</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">oem_id</span><span class="p">,</span> <span class="s">&quot;XEN&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;xen&quot;</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_INTEL_IOMMU</span>
	<span class="cm">/* Look for Intel IOMMU */</span>
	<span class="n">nentries</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="o">/</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">xsdt</span><span class="o">-&gt;</span><span class="n">table_offset_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nentries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">xsdt</span><span class="o">-&gt;</span><span class="n">table_offset_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_DMAR</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ACPI_SIG_DMAR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="s">&quot;dig_vtd&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="s">&quot;dig&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IA64_GENERIC */</span><span class="cp"></span>

<span class="cp">#define ACPI_MAX_PLATFORM_INTERRUPTS	256</span>

<span class="cm">/* Array to record platform interrupt vectors for generic interrupt routing. */</span>
<span class="kt">int</span> <span class="n">platform_intr_list</span><span class="p">[</span><span class="n">ACPI_MAX_PLATFORM_INTERRUPTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">ACPI_MAX_PLATFORM_INTERRUPTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">acpi_irq_model_id</span> <span class="n">acpi_irq_model</span> <span class="o">=</span> <span class="n">ACPI_IRQ_MODEL_IOSAPIC</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt routing API for device drivers.  Provides interrupt vector for</span>
<span class="cm"> * a generic platform event.  Currently only CPEI is implemented.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">acpi_request_vector</span><span class="p">(</span><span class="n">u32</span> <span class="n">int_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_type</span> <span class="o">&lt;</span> <span class="n">ACPI_MAX_PLATFORM_INTERRUPTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* corrected platform error interrupt */</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="n">platform_intr_list</span><span class="p">[</span><span class="n">int_type</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;acpi_request_vector(): invalid interrupt type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vector</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">__acpi_map_table</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">__acpi_unmap_table</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* --------------------------------------------------------------------------</span>
<span class="cm">                            Boot-time Table Parsing</span>
<span class="cm">   -------------------------------------------------------------------------- */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">available_cpus</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">acpi_table_madt</span> <span class="o">*</span><span class="n">acpi_madt</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">has_8259</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_lapic_addr_ovr</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_local_apic_override</span> <span class="o">*</span><span class="n">lapic</span><span class="p">;</span>

	<span class="n">lapic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_local_apic_override</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">lapic</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lapic</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">ipi_base_addr</span><span class="p">);</span>
		<span class="n">ipi_base_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">lapic</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_lsapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_local_sapic</span> <span class="o">*</span><span class="n">lsapic</span><span class="p">;</span>

	<span class="n">lsapic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_local_sapic</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="cm">/*Skip BAD_MADT_ENTRY check, as lsapic size could vary */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">lapic_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_ENABLED</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_phys_id</span><span class="p">[</span><span class="n">available_cpus</span><span class="p">]</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">eid</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="o">++</span><span class="n">available_cpus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">total_cpus</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_lapic_nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_local_apic_nmi</span> <span class="o">*</span><span class="n">lacpi_nmi</span><span class="p">;</span>

	<span class="n">lacpi_nmi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_local_apic_nmi</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">lacpi_nmi</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* TBD: Support lapic_nmi entries */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_iosapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_io_sapic</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">;</span>

	<span class="n">iosapic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_io_sapic</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">iosapic</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iosapic_init</span><span class="p">(</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">global_irq_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">acpi_madt_rev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_plat_int_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_interrupt_source</span> <span class="o">*</span><span class="n">plintsrc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">;</span>

	<span class="n">plintsrc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_interrupt_source</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">plintsrc</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get vector assignment for this interrupt, set attributes,</span>
<span class="cm">	 * and program the IOSAPIC routing table.</span>
<span class="cm">	 */</span>
	<span class="n">vector</span> <span class="o">=</span> <span class="n">iosapic_register_platform_intr</span><span class="p">(</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
						<span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">global_irq</span><span class="p">,</span>
						<span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">io_sapic_vector</span><span class="p">,</span>
						<span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">eid</span><span class="p">,</span>
						<span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
						<span class="p">((</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">inti_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_POLARITY_MASK</span><span class="p">)</span> <span class="o">==</span>
						 <span class="n">ACPI_MADT_POLARITY_ACTIVE_HIGH</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">IOSAPIC_POL_HIGH</span> <span class="o">:</span> <span class="n">IOSAPIC_POL_LOW</span><span class="p">,</span>
						<span class="p">((</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">inti_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_TRIGGER_MASK</span><span class="p">)</span> <span class="o">==</span>
						 <span class="n">ACPI_MADT_TRIGGER_EDGE</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">IOSAPIC_EDGE</span> <span class="o">:</span> <span class="n">IOSAPIC_LEVEL</span><span class="p">);</span>

	<span class="n">platform_intr_list</span><span class="p">[</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_madt_rev</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_cpei_override</span> <span class="o">=</span> <span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_CPEI_OVERRIDE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the physical id, so we can check when its being removed</span>
<span class="cm">	 */</span>
	<span class="n">acpi_cpei_phys_cpuid</span> <span class="o">=</span> <span class="p">((</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">plintsrc</span><span class="o">-&gt;</span><span class="n">eid</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">can_cpei_retarget</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">cpe_vector</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">force_cpei_retarget</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only if CPEI is supported and the override flag</span>
<span class="cm">	 * is present, otherwise return that its re-targettable</span>
<span class="cm">	 * if we are in polling mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpe_vector</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acpi_cpei_override</span> <span class="o">||</span> <span class="n">force_cpei_retarget</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">is_cpu_cpei_target</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">logical_id</span><span class="p">;</span>

	<span class="n">logical_id</span> <span class="o">=</span> <span class="n">cpu_logical_id</span><span class="p">(</span><span class="n">acpi_cpei_phys_cpuid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">logical_id</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpei_target_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_cpei_phys_cpuid</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_cpei_target_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">acpi_cpei_phys_cpuid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_int_src_ovr</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_interrupt_override</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_interrupt_override</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">iosapic_override_isa_irq</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">source_irq</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">global_irq</span><span class="p">,</span>
				 <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inti_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_POLARITY_MASK</span><span class="p">)</span> <span class="o">==</span>
				  <span class="n">ACPI_MADT_POLARITY_ACTIVE_LOW</span><span class="p">)</span> <span class="o">?</span>
				 <span class="n">IOSAPIC_POL_LOW</span> <span class="o">:</span> <span class="n">IOSAPIC_POL_HIGH</span><span class="p">,</span>
				 <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inti_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_TRIGGER_MASK</span><span class="p">)</span> <span class="o">==</span>
				 <span class="n">ACPI_MADT_TRIGGER_LEVEL</span><span class="p">)</span> <span class="o">?</span>
				 <span class="n">IOSAPIC_LEVEL</span> <span class="o">:</span> <span class="n">IOSAPIC_EDGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_parse_nmi_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_subtable_header</span> <span class="o">*</span> <span class="n">header</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_madt_nmi_source</span> <span class="o">*</span><span class="n">nmi_src</span><span class="p">;</span>

	<span class="n">nmi_src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_nmi_source</span> <span class="o">*</span><span class="p">)</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BAD_MADT_ENTRY</span><span class="p">(</span><span class="n">nmi_src</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* TBD: Support nimsrc entries */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">acpi_madt_oem_check</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">oem_id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oem_table_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">oem_id</span><span class="p">,</span> <span class="s">&quot;IBM&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">oem_table_id</span><span class="p">,</span> <span class="s">&quot;SERMOW&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unfortunately ITC_DRIFT is not yet part of the</span>
<span class="cm">		 * official SAL spec, so the ITC_DRIFT bit is not</span>
<span class="cm">		 * set by the BIOS on this hardware.</span>
<span class="cm">		 */</span>
		<span class="n">sal_platform_features</span> <span class="o">|=</span> <span class="n">IA64_SAL_PLATFORM_FEATURE_ITC_DRIFT</span><span class="p">;</span>

		<span class="n">cyclone_setup</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">acpi_parse_madt</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">acpi_madt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_madt</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span><span class="p">;</span>

	<span class="n">acpi_madt_rev</span> <span class="o">=</span> <span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">revision</span><span class="p">;</span>

	<span class="cm">/* remember the value for reference after free_initmem() */</span>
<span class="cp">#ifdef CONFIG_ITANIUM</span>
	<span class="n">has_8259</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Firmware on old Itanium systems is broken */</span>
<span class="cp">#else</span>
	<span class="n">has_8259</span> <span class="o">=</span> <span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_PCAT_COMPAT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">iosapic_system_init</span><span class="p">(</span><span class="n">has_8259</span><span class="p">);</span>

	<span class="cm">/* Get base address of IPI Message Block */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
		<span class="n">ipi_base_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PREFIX</span> <span class="s">&quot;Local APIC address %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ipi_base_addr</span><span class="p">);</span>

	<span class="n">acpi_madt_oem_check</span><span class="p">(</span><span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">oem_id</span><span class="p">,</span>
			    <span class="n">acpi_madt</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">oem_table_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>

<span class="cp">#undef SLIT_DEBUG</span>

<span class="cp">#define PXM_FLAG_LEN ((MAX_PXM_DOMAINS + 1)/32)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">srat_num_cpus</span><span class="p">;</span>	<span class="cm">/* number of cpus */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">__devinitdata</span> <span class="n">pxm_flag</span><span class="p">[</span><span class="n">PXM_FLAG_LEN</span><span class="p">];</span>
<span class="cp">#define pxm_bit_set(bit)	(set_bit(bit,(void *)pxm_flag))</span>
<span class="cp">#define pxm_bit_test(bit)	(test_bit(bit,(void *)pxm_flag))</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">acpi_table_slit</span> <span class="n">__initdata</span> <span class="o">*</span><span class="n">slit_table</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">early_cpu_possible_map</span> <span class="o">=</span> <span class="n">CPU_MASK_NONE</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">get_processor_proximity_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_srat_cpu_affinity</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">;</span>

	<span class="n">pxm</span> <span class="o">=</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">proximity_domain_lo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">acpi_srat_revision</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pxm</span> <span class="o">+=</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">proximity_domain_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pxm</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">get_memory_proximity_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_srat_mem_affinity</span> <span class="o">*</span><span class="n">ma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">;</span>

	<span class="n">pxm</span> <span class="o">=</span> <span class="n">ma</span><span class="o">-&gt;</span><span class="n">proximity_domain</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">acpi_srat_revision</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pxm</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pxm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ACPI 2.0 SLIT (System Locality Information Table)</span>
<span class="cm"> * http://devresource.hp.com/devresource/Docs/TechPapers/IA64/slit.pdf</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">acpi_numa_slit_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_slit</span> <span class="o">*</span><span class="n">slit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span>
	    <span class="o">+</span> <span class="n">slit</span><span class="o">-&gt;</span><span class="n">locality_count</span> <span class="o">*</span> <span class="n">slit</span><span class="o">-&gt;</span><span class="n">locality_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slit</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ACPI 2.0 SLIT: size mismatch: %d expected, %d actual</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">len</span><span class="p">,</span> <span class="n">slit</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slit_table</span> <span class="o">=</span> <span class="n">slit</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">acpi_numa_processor_affinity_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_srat_cpu_affinity</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_SRAT_CPU_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srat_num_cpus</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">node_cpuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			    <span class="s">&quot;node_cpuid[%ld] is too small, may not be able to use all cpus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">node_cpuid</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pxm</span> <span class="o">=</span> <span class="n">get_processor_proximity_domain</span><span class="p">(</span><span class="n">pa</span><span class="p">);</span>

	<span class="cm">/* record this node in proximity bitmap */</span>
	<span class="n">pxm_bit_set</span><span class="p">(</span><span class="n">pxm</span><span class="p">);</span>

	<span class="n">node_cpuid</span><span class="p">[</span><span class="n">srat_num_cpus</span><span class="p">].</span><span class="n">phys_id</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">apic_id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">local_sapic_eid</span><span class="p">);</span>
	<span class="cm">/* nid should be overridden as logical node id later */</span>
	<span class="n">node_cpuid</span><span class="p">[</span><span class="n">srat_num_cpus</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">pxm</span><span class="p">;</span>
	<span class="n">cpu_set</span><span class="p">(</span><span class="n">srat_num_cpus</span><span class="p">,</span> <span class="n">early_cpu_possible_map</span><span class="p">);</span>
	<span class="n">srat_num_cpus</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">acpi_numa_memory_affinity_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_srat_mem_affinity</span> <span class="o">*</span><span class="n">ma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_memblk_s</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">pend</span><span class="p">;</span>

	<span class="n">pxm</span> <span class="o">=</span> <span class="n">get_memory_proximity_domain</span><span class="p">(</span><span class="n">ma</span><span class="p">);</span>

	<span class="cm">/* fill node memory chunk structure */</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">ma</span><span class="o">-&gt;</span><span class="n">base_address</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ma</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Ignore disabled entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ma</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_SRAT_MEM_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* record this node in proximity bitmap */</span>
	<span class="n">pxm_bit_set</span><span class="p">(</span><span class="n">pxm</span><span class="p">);</span>

	<span class="cm">/* Insertion sort based on base address */</span>
	<span class="n">pend</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_memblk</span><span class="p">[</span><span class="n">num_node_memblks</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_memblk</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">pend</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_paddr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">pend</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">pend</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">;</span> <span class="n">q</span><span class="o">--</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">start_paddr</span> <span class="o">=</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">pxm</span><span class="p">;</span>
	<span class="n">num_node_memblks</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">acpi_numa_arch_fixup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">node_from</span><span class="p">,</span> <span class="n">node_to</span><span class="p">;</span>

	<span class="cm">/* If there&#39;s no SRAT, fix the phys_id and mark node 0 online */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srat_num_cpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">node_cpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_id</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * MCD - This can probably be dropped now.  No need for pxm ID to node ID</span>
<span class="cm">	 * mapping with sparse node numbering iff MAX_PXM_DOMAINS &lt;= MAX_NUMNODES.</span>
<span class="cm">	 */</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PXM_DOMAINS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pxm_bit_test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">acpi_map_pxm_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">node_set_online</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* set logical node id in memory chunk structure */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_node_memblks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">);</span>

	<span class="cm">/* assign memory bank numbers for each chunk on each node */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>

		<span class="n">bank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_node_memblks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node_memblk</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">nid</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
				<span class="n">node_memblk</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bank</span> <span class="o">=</span> <span class="n">bank</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set logical node id in cpu structure */</span>
	<span class="n">for_each_possible_early_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">node_cpuid</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">node_cpuid</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Number of logical nodes in system = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">num_online_nodes</span><span class="p">());</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Number of memory chunks in system = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">num_node_memblks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slit_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">node_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">?</span> <span class="n">LOCAL_DISTANCE</span> <span class="o">:</span>
							<span class="n">REMOTE_DISTANCE</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">numa_slit</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">numa_slit</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slit_table</span><span class="o">-&gt;</span><span class="n">locality_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxm_bit_test</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">node_from</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">slit_table</span><span class="o">-&gt;</span><span class="n">locality_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxm_bit_test</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">node_to</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
			<span class="n">node_distance</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">node_to</span><span class="p">)</span> <span class="o">=</span>
			    <span class="n">slit_table</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">slit_table</span><span class="o">-&gt;</span><span class="n">locality_count</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef SLIT_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ACPI 2.0 SLIT locality table:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
		    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%03d &quot;</span><span class="p">,</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_ACPI_NUMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * success: return IRQ number (&gt;=0)</span>
<span class="cm"> * failure: return &lt; 0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">acpi_register_gsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">triggering</span><span class="p">,</span> <span class="kt">int</span> <span class="n">polarity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_irq_model</span> <span class="o">==</span> <span class="n">ACPI_IRQ_MODEL_PLATFORM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">gsi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_8259</span> <span class="o">&amp;&amp;</span> <span class="n">gsi</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">isa_irq_to_vector</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iosapic_register_intr</span><span class="p">(</span><span class="n">gsi</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">polarity</span> <span class="o">==</span>
				      <span class="n">ACPI_ACTIVE_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="n">IOSAPIC_POL_HIGH</span> <span class="o">:</span>
				     <span class="n">IOSAPIC_POL_LOW</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">triggering</span> <span class="o">==</span>
				      <span class="n">ACPI_EDGE_SENSITIVE</span><span class="p">)</span> <span class="o">?</span> <span class="n">IOSAPIC_EDGE</span> <span class="o">:</span>
				     <span class="n">IOSAPIC_LEVEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">acpi_unregister_gsi</span><span class="p">(</span><span class="n">u32</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_irq_model</span> <span class="o">==</span> <span class="n">ACPI_IRQ_MODEL_PLATFORM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_8259</span> <span class="o">&amp;&amp;</span> <span class="n">gsi</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iosapic_unregister_intr</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">acpi_parse_fadt</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">fadt_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_fadt</span> <span class="o">*</span><span class="n">fadt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fadt_header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="p">)</span><span class="n">table</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fadt_header</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>	<span class="cm">/* Only deal with ACPI 2.0 FADT */</span>

	<span class="n">fadt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_fadt</span> <span class="o">*</span><span class="p">)</span><span class="n">fadt_header</span><span class="p">;</span>

	<span class="n">acpi_register_gsi</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">fadt</span><span class="o">-&gt;</span><span class="n">sci_interrupt</span><span class="p">,</span> <span class="n">ACPI_LEVEL_SENSITIVE</span><span class="p">,</span>
				 <span class="n">ACPI_ACTIVE_LOW</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">early_acpi_boot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * do a partial walk of MADT to determine how many CPUs</span>
<span class="cm">	 * we have including offline CPUs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse</span><span class="p">(</span><span class="n">ACPI_SIG_MADT</span><span class="p">,</span> <span class="n">acpi_parse_madt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;Can&#39;t find MADT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acpi_table_parse_madt</span><span class="p">(</span><span class="n">ACPI_MADT_TYPE_LOCAL_SAPIC</span><span class="p">,</span>
		<span class="n">acpi_parse_lsapic</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span>
		       <span class="s">&quot;Error parsing MADT - no LAPIC entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">available_cpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ACPI: Found 0 CPUS; assuming 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU 0 (0x%04x)&quot;</span><span class="p">,</span> <span class="n">hard_smp_processor_id</span><span class="p">());</span>
		<span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_phys_id</span><span class="p">[</span><span class="n">available_cpus</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">hard_smp_processor_id</span><span class="p">();</span>
		<span class="n">available_cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* We&#39;ve got at least one of these, no? */</span>
	<span class="p">}</span>
	<span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_count</span> <span class="o">=</span> <span class="n">available_cpus</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Make boot-up look pretty */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d CPUs available, %d CPUs total</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">available_cpus</span><span class="p">,</span>
	       <span class="n">total_cpus</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">acpi_boot_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * MADT</span>
<span class="cm">	 * ----</span>
<span class="cm">	 * Parse the Multiple APIC Description Table (MADT), if exists.</span>
<span class="cm">	 * Note that this table provides platform SMP configuration</span>
<span class="cm">	 * information -- the successor to MPS tables.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse</span><span class="p">(</span><span class="n">ACPI_SIG_MADT</span><span class="p">,</span> <span class="n">acpi_parse_madt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;Can&#39;t find MADT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">skip_madt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Local APIC */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span>
	    <span class="p">(</span><span class="n">ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE</span><span class="p">,</span> <span class="n">acpi_parse_lapic_addr_ovr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span>
		       <span class="s">&quot;Error parsing LAPIC address override entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span><span class="p">(</span><span class="n">ACPI_MADT_TYPE_LOCAL_APIC_NMI</span><span class="p">,</span> <span class="n">acpi_parse_lapic_nmi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;Error parsing LAPIC NMI entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* I/O APIC */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span>
	    <span class="p">(</span><span class="n">ACPI_MADT_TYPE_IO_SAPIC</span><span class="p">,</span> <span class="n">acpi_parse_iosapic</span><span class="p">,</span> <span class="n">NR_IOSAPICS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span>
			       <span class="s">&quot;Error parsing MADT - no IOSAPIC entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* System-Level Interrupt Routing */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span>
	    <span class="p">(</span><span class="n">ACPI_MADT_TYPE_INTERRUPT_SOURCE</span><span class="p">,</span> <span class="n">acpi_parse_plat_int_src</span><span class="p">,</span>
	     <span class="n">ACPI_MAX_PLATFORM_INTERRUPTS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span>
		       <span class="s">&quot;Error parsing platform interrupt source entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span>
	    <span class="p">(</span><span class="n">ACPI_MADT_TYPE_INTERRUPT_OVERRIDE</span><span class="p">,</span> <span class="n">acpi_parse_int_src_ovr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span>
		       <span class="s">&quot;Error parsing interrupt source overrides entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse_madt</span><span class="p">(</span><span class="n">ACPI_MADT_TYPE_NMI_SOURCE</span><span class="p">,</span> <span class="n">acpi_parse_nmi_src</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;Error parsing NMI SRC entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="nl">skip_madt:</span>

	<span class="cm">/*</span>
<span class="cm">	 * FADT says whether a legacy keyboard controller is present.</span>
<span class="cm">	 * The FADT also contains an SCI_INT line, by which the system</span>
<span class="cm">	 * gets interrupts such as power and sleep buttons.  If it&#39;s not</span>
<span class="cm">	 * on a Legacy interrupt, it needs to be setup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_table_parse</span><span class="p">(</span><span class="n">ACPI_SIG_FADT</span><span class="p">,</span> <span class="n">acpi_parse_fadt</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;Can&#39;t find FADT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srat_num_cpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_count</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_phys_id</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">!=</span>
			    <span class="n">hard_smp_processor_id</span><span class="p">())</span>
				<span class="n">node_cpuid</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">phys_id</span> <span class="o">=</span>
				    <span class="n">smp_boot_data</span><span class="p">.</span><span class="n">cpu_phys_id</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">build_cpu_to_node_map</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_gsi_to_irq</span><span class="p">(</span><span class="n">u32</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_8259</span> <span class="o">&amp;&amp;</span> <span class="n">gsi</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="n">isa_irq_to_vector</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">gsi_to_irq</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_isa_irq_to_gsi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">isa_irq</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isa_irq</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">gsi</span> <span class="o">=</span> <span class="n">isa_irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  ACPI based hotplug CPU support</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ACPI_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="n">__cpuinit</span>
<span class="kt">int</span> <span class="nf">acpi_map_cpu2node</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">physid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
	<span class="kt">int</span> <span class="n">pxm_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">pxm_id</span> <span class="o">=</span> <span class="n">acpi_get_pxm</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t have cpu-only-node hotadd. But if the system equips</span>
<span class="cm">	 * SRAT table, pxm is already found and node is ready.</span>
<span class="cm">  	 * So, just pxm_to_nid(pxm) is OK.</span>
<span class="cm">	 * This code here is for the system which doesn&#39;t have full SRAT</span>
<span class="cm">  	 * table for possible cpus.</span>
<span class="cm">	 */</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">acpi_map_pxm_to_node</span><span class="p">(</span><span class="n">pxm_id</span><span class="p">);</span>
	<span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">phys_id</span> <span class="o">=</span> <span class="n">physid</span><span class="p">;</span>
	<span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">additional_cpus</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_additional_cpus</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="n">additional_cpus</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;additional_cpus&quot;</span><span class="p">,</span> <span class="n">setup_additional_cpus</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cpu_possible_mask should be static, it cannot change as CPUs</span>
<span class="cm"> * are onlined, or offlined. The reason is per-cpu data-structures</span>
<span class="cm"> * are allocated by some modules at init time, and dont expect to</span>
<span class="cm"> * do this dynamically on cpu arrival/departure.</span>
<span class="cm"> * cpu_present_mask on the other hand can change dynamically.</span>
<span class="cm"> * In case when cpu_hotplug is not compiled, then we resort to current</span>
<span class="cm"> * behaviour, which is cpu_possible == cpu_present.</span>
<span class="cm"> * - Ashok Raj</span>
<span class="cm"> *</span>
<span class="cm"> * Three ways to find out the number of additional hotplug CPUs:</span>
<span class="cm"> * - If the BIOS specified disabled CPUs in ACPI/mptables use that.</span>
<span class="cm"> * - The user can overwrite it with additional_cpus=NUM</span>
<span class="cm"> * - Otherwise don&#39;t reserve additional CPUs.</span>
<span class="cm"> */</span>
<span class="n">__init</span> <span class="kt">void</span> <span class="nf">prefill_possible_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">possible</span><span class="p">,</span> <span class="n">disabled_cpus</span><span class="p">;</span>

	<span class="n">disabled_cpus</span> <span class="o">=</span> <span class="n">total_cpus</span> <span class="o">-</span> <span class="n">available_cpus</span><span class="p">;</span>

 	<span class="k">if</span> <span class="p">(</span><span class="n">additional_cpus</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">disabled_cpus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">additional_cpus</span> <span class="o">=</span> <span class="n">disabled_cpus</span><span class="p">;</span>
 		<span class="k">else</span>
			<span class="n">additional_cpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 	<span class="p">}</span>

	<span class="n">possible</span> <span class="o">=</span> <span class="n">available_cpus</span> <span class="o">+</span> <span class="n">additional_cpus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">possible</span> <span class="o">&gt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="n">possible</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP: Allowing %d CPUs, %d hotplug CPUs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">possible</span><span class="p">,</span> <span class="n">max</span><span class="p">((</span><span class="n">possible</span> <span class="o">-</span> <span class="n">available_cpus</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">possible</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">_acpi_map_lsapic</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_madt_local_sapic</span> <span class="o">*</span><span class="n">lsapic</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="n">tmp_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">physid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">acpi_evaluate_object</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;_MAT&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">||</span> <span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_BUFFER</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lsapic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_local_sapic</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_MADT_TYPE_LOCAL_SAPIC</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">lapic_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_MADT_ENABLED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">physid</span> <span class="o">=</span> <span class="p">((</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">lsapic</span><span class="o">-&gt;</span><span class="n">eid</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
	<span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">;</span>
	<span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cpumask_complement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_map</span><span class="p">,</span> <span class="n">cpu_present_mask</span><span class="p">);</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">acpi_map_cpu2node</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">physid</span><span class="p">);</span>

	<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">physid</span><span class="p">;</span>

	<span class="n">acpi_processor_set_pdc</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="o">*</span><span class="n">pcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* wrapper to silence section mismatch warning */</span>
<span class="kt">int</span> <span class="n">__ref</span> <span class="nf">acpi_map_lsapic</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_acpi_map_lsapic</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">pcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">acpi_map_lsapic</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">acpi_unmap_lsapic</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_cpu_to_sapicid</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
	<span class="cm">/* NUMA specific cleanup&#39;s */</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">acpi_unmap_lsapic</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_ACPI_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
<span class="k">static</span> <span class="n">acpi_status</span> <span class="n">__devinit</span>
<span class="nf">acpi_map_iosapic</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_madt_io_sapic</span> <span class="o">*</span><span class="n">iosapic</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gsi_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">,</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* Only care about objects w/ a method that returns the MADT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">acpi_evaluate_object</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;_MAT&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">||</span> <span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_BUFFER</span> <span class="o">||</span>
	    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iosapic</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iosapic</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_madt_io_sapic</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_MADT_TYPE_IO_SAPIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gsi_base</span> <span class="o">=</span> <span class="n">iosapic</span><span class="o">-&gt;</span><span class="n">global_irq_base</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, it&#39;s an IOSAPIC MADT entry, look for a _PXM value to tell</span>
<span class="cm">	 * us which node to associate this with.</span>
<span class="cm">	 */</span>
	<span class="n">pxm</span> <span class="o">=</span> <span class="n">acpi_get_pxm</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pxm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">pxm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">cpumask_empty</span><span class="p">(</span><span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="cm">/* We know a gsi to node mapping! */</span>
	<span class="n">map_iosapic_to_node</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_map_iosapics</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_get_devices</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">acpi_map_iosapic</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fs_initcall</span><span class="p">(</span><span class="n">acpi_map_iosapics</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_ACPI_NUMA */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">__ref</span> <span class="nf">acpi_register_ioapic</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="n">u64</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gsi_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">iosapic_init</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">gsi_base</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ACPI_NUMA</span>
	<span class="n">acpi_map_iosapic</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_ACPI_NUMA */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">acpi_register_ioapic</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">acpi_unregister_ioapic</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gsi_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iosapic_remove</span><span class="p">(</span><span class="n">gsi_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">acpi_unregister_ioapic</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * acpi_suspend_lowlevel() - save kernel state and suspend.</span>
<span class="cm"> *</span>
<span class="cm"> * TBD when when IA64 starts to support suspend...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">acpi_suspend_lowlevel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
