<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Architecture-specific setup.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2001, 2003-2004 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *	Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 2000, 2004 Intel Corp</span>
<span class="cm"> * 	Rohit Seth &lt;rohit.seth@intel.com&gt;</span>
<span class="cm"> * 	Suresh Siddha &lt;suresh.b.siddha@intel.com&gt;</span>
<span class="cm"> * 	Gordon Jin &lt;gordon.jin@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 VA Linux Systems</span>
<span class="cm"> * Copyright (C) 1999 Walt Drummond &lt;drummond@valinux.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 12/26/04 S.Siddha, G.Jin, R.Seth</span>
<span class="cm"> *			Add multi-threading and multi-core detection</span>
<span class="cm"> * 11/12/01 D.Mosberger Convert get_cpuinfo() to seq_file based show_cpuinfo().</span>
<span class="cm"> * 04/04/00 D.Mosberger renamed cpu_initialized to cpu_online_map</span>
<span class="cm"> * 03/31/00 R.Seth	cpu_initialized and current-&gt;processor fixes</span>
<span class="cm"> * 02/04/00 D.Mosberger	some more get_cpuinfo fixes...</span>
<span class="cm"> * 02/01/00 R.Seth	fixed get_cpuinfo for SMP</span>
<span class="cm"> * 01/07/99 S.Eranian	added the support for command line argument</span>
<span class="cm"> * 06/24/99 W.Drummond	added boot_cpu_data.</span>
<span class="cm"> * 05/28/05 Z. Menyhart	Dynamic stride size for &quot;flush_icache_range()&quot;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/screen_info.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>

<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/mca.h&gt;</span>
<span class="cp">#include &lt;asm/meminit.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt_patch.h&gt;</span>
<span class="cp">#include &lt;asm/patch.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/hpsim.h&gt;</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; (IA64_CPU_SIZE &gt; PAGE_SIZE)</span>
<span class="cp"># error &quot;struct cpuinfo_ia64 too big!&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__per_cpu_offset</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span><span class="p">,</span> <span class="n">ia64_cpu_info</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">local_per_cpu_offset</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_cycles_per_usec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ia64_boot_param</span> <span class="o">*</span><span class="n">ia64_boot_param</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">screen_info</span> <span class="n">screen_info</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vga_console_iobase</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vga_console_membase</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">data_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;Kernel data&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">code_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;Kernel code&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">bss_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;Kernel bss&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_max_cacheline_size</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_iobase</span><span class="p">;</span>	<span class="cm">/* virtual address for I/O accesses */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_iobase</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">io_space</span> <span class="n">io_space</span><span class="p">[</span><span class="n">MAX_IO_SPACES</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">io_space</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_io_spaces</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;flush_icache_range()&quot; needs to know what processor dependent stride size to use</span>
<span class="cm"> * when it makes i-cache(s) coherent with d-caches.</span>
<span class="cm"> */</span>
<span class="cp">#define	I_CACHE_STRIDE_SHIFT	5	</span><span class="cm">/* Safest way to go: 32 bytes by 32 bytes */</span><span class="cp"></span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_i_cache_stride_shift</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * &quot;clflush_cache_range()&quot; needs to know what processor dependent stride size to</span>
<span class="cm"> * use when it flushes cache lines including both d-cache and i-cache.</span>
<span class="cm"> */</span>
<span class="cm">/* Safest way to go: 32 bytes by 32 bytes */</span>
<span class="cp">#define	CACHE_STRIDE_SHIFT	5</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_cache_stride_shift</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The merge_mask variable needs to be set to (max(iommu_page_size(iommu)) - 1).  This</span>
<span class="cm"> * mask specifies a mask of address bits that must be 0 in order for two buffers to be</span>
<span class="cm"> * mergeable by the I/O MMU (i.e., the end address of the first buffer and the start</span>
<span class="cm"> * address of the second buffer must be aligned to (merge_mask+1) in order to be</span>
<span class="cm"> * mergeable).  By default, we assume there is no I/O MMU which can merge physically</span>
<span class="cm"> * discontiguous buffers, so we set the merge_mask to ~0UL, which corresponds to a iommu</span>
<span class="cm"> * page-size of 2^64.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_max_iommu_merge_mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_max_iommu_merge_mask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We use a special marker for the end of memory and it uses the extra (+1) slot</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rsvd_region</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">IA64_MAX_RSVD_REGIONS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num_rsvd_regions</span> <span class="n">__initdata</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Filter incoming memory segments based on the primitive map created from the boot</span>
<span class="cm"> * parameters. Segments contained in the map are removed from the memory ranges. A</span>
<span class="cm"> * caller-specified function is called with the memory ranges that remain after filtering.</span>
<span class="cm"> * This routine does not assume the incoming segments are sorted.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">filter_rsvd_memory</span> <span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="p">,</span> <span class="n">prev_start</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#if IGNORE_PFN0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;warning: skipping physical page 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * lowest possible address(walker uses virtual)</span>
<span class="cm">	 */</span>
	<span class="n">prev_start</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
	<span class="n">func</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_rsvd_regions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">range_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">prev_start</span><span class="p">);</span>
		<span class="n">range_end</span>   <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">range_start</span> <span class="o">&lt;</span> <span class="n">range_end</span><span class="p">)</span>
			<span class="n">call_pernode_memory</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">range_start</span><span class="p">),</span> <span class="n">range_end</span> <span class="o">-</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>

		<span class="cm">/* nothing more available in this segment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">prev_start</span> <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* end of memory marker allows full processing inside loop body */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to &quot;filter_rsvd_memory()&quot;, but the reserved memory ranges</span>
<span class="cm"> * are not filtered out.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">filter_memory</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#if IGNORE_PFN0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">PAGE_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;warning: skipping physical page 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">func</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">call_pernode_memory</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">sort_regions</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rsvd_region</span> <span class="o">*</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* simple bubble sorting */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">max</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">rsvd_region</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
				<span class="n">rsvd_region</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* merge overlaps */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">merge_regions</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rsvd_region</span> <span class="o">*</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">)</span>
			<span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">;</span>
		<span class="o">--</span><span class="n">max</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
			<span class="p">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rsvd_region</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request address space for all standard resources</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">register_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">code_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">_text</span><span class="p">);</span>
	<span class="n">code_resource</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">_etext</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">data_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">_etext</span><span class="p">);</span>
	<span class="n">data_resource</span><span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">_edata</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bss_resource</span><span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">__bss_start</span><span class="p">);</span>
	<span class="n">bss_resource</span><span class="p">.</span><span class="n">end</span>    <span class="o">=</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">_end</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">efi_initialize_iomem_resources</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_resource</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">bss_resource</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">register_memory</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_KEXEC</span>

<span class="cm">/*</span>
<span class="cm"> * This function checks if the reserved crashkernel is allowed on the specific</span>
<span class="cm"> * IA64 machine flavour. Machines without an IO TLB use swiotlb and require</span>
<span class="cm"> * some memory below 4 GB (i.e. in 32 bit area), see the implementation of</span>
<span class="cm"> * lib/swiotlb.c. The hpzx1 architecture has an IO TLB but cannot use that</span>
<span class="cm"> * in kdump case. See the comment in sba_init() in sba_iommu.c.</span>
<span class="cm"> *</span>
<span class="cm"> * So, the only machvec that really supports loading the kdump kernel</span>
<span class="cm"> * over 4 GB is &quot;sn2&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">check_crashkernel_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pbase</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;uv&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">pbase</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_crashkernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_crashkernel</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sort_regions</span><span class="p">(</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">merge_regions</span><span class="p">(</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">kdump_find_rsvd_region</span><span class="p">(</span><span class="n">size</span><span class="p">,</span>
					<span class="n">rsvd_region</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_crashkernel_memory</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: There would be kdump memory &quot;</span>
				<span class="s">&quot;at %ld GB but this is unusable because it &quot;</span>
				<span class="s">&quot;must</span><span class="se">\n</span><span class="s">be below 4 GB. Change the memory &quot;</span>
				<span class="s">&quot;configuration of the machine.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Reserving %ldMB of memory at %ldMB &quot;</span>
					<span class="s">&quot;for crashkernel (System RAM: %ldMB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">total</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">));</span>
			<span class="n">rsvd_region</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
			<span class="n">rsvd_region</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">end</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
			<span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">efi_memmap_res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">;</span>
	<span class="n">efi_memmap_res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">efi_memmap_res</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span>
		<span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">boot_param_res</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="p">);</span>
	<span class="n">boot_param_res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">boot_param_res</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ia64_boot_param</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_crashkernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_memory - setup reserved memory areas</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the reserved memory areas set aside for the boot parameters,</span>
<span class="cm"> * initrd, etc.  There are currently %IA64_MAX_RSVD_REGIONS defined,</span>
<span class="cm"> * see arch/ia64/include/asm/meminit.h if you need to define more.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">reserve_memory</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_memory</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * none of the entries in this table overlap</span>
<span class="cm">	 */</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia64_boot_param</span><span class="p">;</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ia64_boot_param</span><span class="p">);</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap</span><span class="p">);</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_memmap_size</span><span class="p">;</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">command_line</span><span class="p">);</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="p">(</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span>
				<span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">command_line</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia64_imva</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">KERNEL_START</span><span class="p">);</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia64_imva</span><span class="p">(</span><span class="n">_end</span><span class="p">);</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">+=</span> <span class="n">paravirt_reserve_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_start</span><span class="p">);</span>
		<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_size</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CRASH_DUMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve_elfcorehdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">total_memory</span> <span class="o">=</span> <span class="n">efi_memmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">setup_crashkernel</span><span class="p">(</span><span class="n">total_memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

	<span class="cm">/* end of memory marker */</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">rsvd_region</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">end</span>   <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="n">num_rsvd_regions</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IA64_MAX_RSVD_REGIONS</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">);</span>

	<span class="n">sort_regions</span><span class="p">(</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="n">num_rsvd_regions</span><span class="p">);</span>
	<span class="n">num_rsvd_regions</span> <span class="o">=</span> <span class="n">merge_regions</span><span class="p">(</span><span class="n">rsvd_region</span><span class="p">,</span> <span class="n">num_rsvd_regions</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * find_initrd - get initrd parameters from the boot parameter structure</span>
<span class="cm"> *</span>
<span class="cm"> * Grab the initrd start and end from the boot parameter struct given us by</span>
<span class="cm"> * the boot loader.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">find_initrd</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initrd_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_start</span><span class="p">);</span>
		<span class="n">initrd_end</span>   <span class="o">=</span> <span class="n">initrd_start</span><span class="o">+</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_size</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Initial ramdisk at: 0x%lx (%llu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">initrd_start</span><span class="p">,</span> <span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">initrd_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">io_port_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_iobase</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set `iobase&#39; based on the EFI memory map or, failing that, the</span>
<span class="cm">	 * value firmware left in ar.k0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that in ia32 mode, IN/OUT instructions use ar.k0 to compute</span>
<span class="cm">	 * the port&#39;s virtual address, so ia32_load_state() loads it with a</span>
<span class="cm">	 * user virtual address.  But in ia64 mode, glibc uses the</span>
<span class="cm">	 * *physical* address in ar.k0 to mmap the appropriate area from</span>
<span class="cm">	 * /dev/mem, and the inX()/outX() interfaces use MMIO.  In both</span>
<span class="cm">	 * cases, user-mode can only use the legacy 0-64K I/O port space.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ar.k0 is not involved in kernel I/O port accesses, which can use</span>
<span class="cm">	 * any of the I/O port spaces and are done via MMIO using the</span>
<span class="cm">	 * virtual mmio_base from the appropriate io_space[].</span>
<span class="cm">	 */</span>
	<span class="n">phys_iobase</span> <span class="o">=</span> <span class="n">efi_get_iobase</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys_iobase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_iobase</span> <span class="o">=</span> <span class="n">ia64_get_kr</span><span class="p">(</span><span class="n">IA64_KR_IO_BASE</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;No I/O port range found in EFI memory map, &quot;</span>
			<span class="s">&quot;falling back to AR.KR0 (0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phys_iobase</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ia64_iobase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phys_iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_IO_BASE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ia64_iobase</span><span class="p">));</span>

	<span class="cm">/* setup legacy IO port space */</span>
	<span class="n">io_space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="n">ia64_iobase</span><span class="p">;</span>
	<span class="n">io_space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sparse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_io_spaces</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * early_console_setup - setup debugging console</span>
<span class="cm"> *</span>
<span class="cm"> * Consoles started here require little enough setup that we can start using</span>
<span class="cm"> * them very early in the boot process, either right after the machine</span>
<span class="cm"> * vector initialization, or even before if the drivers can detect their hw.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns non-zero if a console couldn&#39;t be setup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">early_console_setup</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">earlycons</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SERIAL_SGI_L1_CONSOLE</span>
	<span class="p">{</span>
		<span class="k">extern</span> <span class="kt">int</span> <span class="n">sn_serial_console_early_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_serial_console_early_setup</span><span class="p">())</span>
			<span class="n">earlycons</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_EFI_PCDP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">efi_setup_pcdp_console</span><span class="p">(</span><span class="n">cmdline</span><span class="p">))</span>
		<span class="n">earlycons</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">simcons_register</span><span class="p">())</span>
		<span class="n">earlycons</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">earlycons</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mark_bsp_online</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* If we register an early console, allow CPU 0 to printk */</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">int</span> <span class="n">nomca</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_nomca</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nomca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nomca&quot;</span><span class="p">,</span> <span class="n">setup_nomca</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CRASH_DUMP</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">reserve_elfcorehdr</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* We get the address using the kernel command line,</span>
<span class="cm">	 * but the size is extracted from the EFI tables.</span>
<span class="cm">	 * Both address and size are required for reservation</span>
<span class="cm">	 * to work properly.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vmcore_usable</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">length</span> <span class="o">=</span> <span class="n">vmcore_find_descriptor_size</span><span class="p">(</span><span class="n">elfcorehdr_addr</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmcore_unusable</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">elfcorehdr_addr</span><span class="p">);</span>
	<span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="o">*</span><span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_VMCORE */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">setup_arch</span> <span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unw_init</span><span class="p">();</span>

	<span class="n">paravirt_arch_setup_early</span><span class="p">();</span>

	<span class="n">ia64_patch_vtop</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">__start___vtop_patchlist</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">__end___vtop_patchlist</span><span class="p">);</span>
	<span class="n">paravirt_patch_apply</span><span class="p">();</span>

	<span class="o">*</span><span class="n">cmdline_p</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">command_line</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="o">*</span><span class="n">cmdline_p</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>

	<span class="n">efi_init</span><span class="p">();</span>
	<span class="n">io_port_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_IA64_GENERIC</span>
	<span class="cm">/* machvec needs to be parsed from the command line</span>
<span class="cm">	 * before parse_early_param() is called to ensure</span>
<span class="cm">	 * that ia64_mv is initialised before any command line</span>
<span class="cm">	 * settings may cause console setup to occur</span>
<span class="cm">	 */</span>
	<span class="n">machvec_init_from_cmdline</span><span class="p">(</span><span class="o">*</span><span class="n">cmdline_p</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">parse_early_param</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">early_console_setup</span><span class="p">(</span><span class="o">*</span><span class="n">cmdline_p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mark_bsp_online</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="cm">/* Initialize the ACPI boot-time table parser */</span>
	<span class="n">acpi_table_init</span><span class="p">();</span>
	<span class="n">early_acpi_boot_init</span><span class="p">();</span>
<span class="cp"># ifdef CONFIG_ACPI_NUMA</span>
	<span class="n">acpi_numa_init</span><span class="p">();</span>
<span class="cp">#  ifdef CONFIG_ACPI_HOTPLUG_CPU</span>
	<span class="n">prefill_possible_map</span><span class="p">();</span>
<span class="cp">#  endif</span>
	<span class="n">per_cpu_scan_finalize</span><span class="p">((</span><span class="n">cpus_weight</span><span class="p">(</span><span class="n">early_cpu_possible_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
		<span class="mi">32</span> <span class="o">:</span> <span class="n">cpus_weight</span><span class="p">(</span><span class="n">early_cpu_possible_map</span><span class="p">)),</span>
		<span class="n">additional_cpus</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">additional_cpus</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp"># endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_APCI_BOOT */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">smp_build_cpu_map</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">find_memory</span><span class="p">();</span>

	<span class="cm">/* process SAL system table: */</span>
	<span class="n">ia64_sal_init</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">sal_systab</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_ITANIUM</span>
	<span class="n">ia64_patch_rse</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">__start___rse_patchlist</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">__end___rse_patchlist</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_phys_stacked</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_pal_rse_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_phys_stacked</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num_phys_stacked</span> <span class="o">&gt;</span> <span class="mi">96</span><span class="p">)</span>
			<span class="n">ia64_patch_rse</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">__start___rse_patchlist</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">__end___rse_patchlist</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">cpu_physical_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">cpu_init</span><span class="p">();</span>	<span class="cm">/* initialize the bootstrap CPU */</span>
	<span class="n">mmu_context_init</span><span class="p">();</span>	<span class="cm">/* initialize context_id bitmap */</span>

	<span class="n">paravirt_banner</span><span class="p">();</span>
	<span class="n">paravirt_arch_setup_console</span><span class="p">(</span><span class="n">cmdline_p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_VT</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conswitchp</span><span class="p">)</span> <span class="p">{</span>
<span class="cp"># if defined(CONFIG_DUMMY_CONSOLE)</span>
		<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_con</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp"># if defined(CONFIG_VGA_CONSOLE)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Non-legacy systems may route legacy VGA MMIO range to system</span>
<span class="cm">		 * memory.  vga_con probes the MMIO hole, so memory looks like</span>
<span class="cm">		 * a VGA device to it.  The EFI memory map can tell us if it&#39;s</span>
<span class="cm">		 * memory so we can avoid this problem.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efi_mem_type</span><span class="p">(</span><span class="mh">0xA0000</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EFI_CONVENTIONAL_MEMORY</span><span class="p">)</span>
			<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vga_con</span><span class="p">;</span>
<span class="cp"># endif</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* enable IA-64 Machine Check Abort Handling unless disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_arch_setup_nomca</span><span class="p">())</span>
		<span class="n">nomca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nomca</span><span class="p">)</span>
		<span class="n">ia64_mca_init</span><span class="p">();</span>

	<span class="n">platform_setup</span><span class="p">(</span><span class="n">cmdline_p</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_IA64_HP_SIM</span>
	<span class="n">check_sal_cache_flush</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">paging_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Display cpu info for all CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">show_cpuinfo</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#	define lpj	c-&gt;loops_per_jiffy</span>
<span class="cp">#	define cpunum	c-&gt;cpu</span>
<span class="cp">#else</span>
<span class="cp">#	define lpj	loops_per_jiffy</span>
<span class="cp">#	define cpunum	0</span>
<span class="cp">#endif</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">feature_name</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">feature_bits</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;branchlong&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;spontaneous deferral&quot;</span><span class="p">},</span>
		<span class="p">{</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;16-byte atomic ops&quot;</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="kt">char</span> <span class="n">features</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="o">*</span><span class="n">sep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">proc_freq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>

	<span class="cm">/* build the feature string: */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="s">&quot;standard&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">features</span><span class="p">);</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">feature_bits</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">feature_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span>
				       <span class="n">feature_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">feature_name</span><span class="p">),</span>
			<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">feature_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">cp</span> <span class="o">-</span> <span class="n">features</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* print unknown features as a hex value */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%s0x%lx&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">proc_freq</span> <span class="o">=</span> <span class="n">cpufreq_quick_get</span><span class="p">(</span><span class="n">cpunum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_freq</span><span class="p">)</span>
		<span class="n">proc_freq</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		   <span class="s">&quot;processor  : %d</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;vendor     : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;arch       : IA-64</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;family     : %u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;model      : %u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;model name : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;revision   : %u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;archrev    : %u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;features   : %s</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;cpu number : %lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;cpu regs   : %u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;cpu MHz    : %lu.%03lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;itc MHz    : %lu.%06lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BogoMIPS   : %lu.%02lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">cpunum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span>
		   <span class="n">c</span><span class="o">-&gt;</span><span class="n">model_name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">archrev</span><span class="p">,</span>
		   <span class="n">features</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ppn</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		   <span class="n">proc_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">proc_freq</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span>
		   <span class="n">c</span><span class="o">-&gt;</span><span class="n">itc_freq</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">itc_freq</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">,</span>
		   <span class="n">lpj</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">500000</span><span class="p">,</span> <span class="p">(</span><span class="n">lpj</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">5000</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;siblings   : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpus_weight</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">[</span><span class="n">cpunum</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">socket_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;physical id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">socket_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cores_per_socket</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			   <span class="s">&quot;core id    : %u</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;thread id  : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">core_id</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">thread_id</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">c_start</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span>
		<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">?</span> <span class="n">cpu_data</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">c_next</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">c_start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">c_stop</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cpuinfo_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span>	<span class="n">c_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span>		<span class="n">c_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span>		<span class="n">c_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span>		<span class="n">show_cpuinfo</span>
<span class="p">};</span>

<span class="cp">#define MAX_BRANDS	8</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">brandname</span><span class="p">[</span><span class="n">MAX_BRANDS</span><span class="p">][</span><span class="mi">128</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">__cpuinit</span>
<span class="nf">get_model_name</span><span class="p">(</span><span class="n">__u8</span> <span class="n">family</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">brand</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_pal_get_brand_info</span><span class="p">(</span><span class="n">brand</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="mh">0x7</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="s">&quot;Merced&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="k">switch</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>: <span class="n">memcpy</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="s">&quot;McKinley&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>: <span class="n">memcpy</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="s">&quot;Madison&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>: <span class="n">memcpy</span><span class="p">(</span><span class="n">brand</span><span class="p">,</span> <span class="s">&quot;Madison up to 9M cache&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_BRANDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">brandname</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">brand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">brandname</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_BRANDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">brandname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">brandname</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">brand</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">overflow</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: Table overflow. Some processor model information will be missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">identify_cpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* id 0 &amp; 1: */</span>
			<span class="kt">char</span> <span class="n">vendor</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

			<span class="cm">/* id 2 */</span>
			<span class="n">u64</span> <span class="n">ppn</span><span class="p">;</span>		<span class="cm">/* processor serial number */</span>

			<span class="cm">/* id 3: */</span>
			<span class="kt">unsigned</span> <span class="n">number</span>		<span class="o">:</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">revision</span>	<span class="o">:</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">model</span>		<span class="o">:</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">family</span>		<span class="o">:</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">archrev</span>	<span class="o">:</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">reserved</span>	<span class="o">:</span> <span class="mi">24</span><span class="p">;</span>

			<span class="cm">/* id 4: */</span>
			<span class="n">u64</span> <span class="n">features</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">field</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cpuid</span><span class="p">;</span>
	<span class="n">pal_vm_info_1_u_t</span> <span class="n">vm1</span><span class="p">;</span>
	<span class="n">pal_vm_info_2_u_t</span> <span class="n">vm2</span><span class="p">;</span>
	<span class="n">pal_status_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">impl_va_msb</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">phys_addr_size</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span>	<span class="cm">/* Itanium defaults */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cpuid</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_cpuid</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">vendor</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* below default values will be overwritten  by identify_siblings() </span>
<span class="cm">	 * for Multi-Threading/Multi-Core capable CPUs</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cores_per_socket</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">num_log</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">socket_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">identify_siblings</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">threads_per_core</span> <span class="o">&gt;</span> <span class="n">smp_num_siblings</span><span class="p">)</span>
		<span class="n">smp_num_siblings</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">threads_per_core</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ppn</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">ppn</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">revision</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">model</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">family</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">archrev</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">archrev</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">features</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">get_model_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_vm_summary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PAL_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">impl_va_msb</span> <span class="o">=</span> <span class="n">vm2</span><span class="p">.</span><span class="n">pal_vm_info_2_s</span><span class="p">.</span><span class="n">impl_va_msb</span><span class="p">;</span>
		<span class="n">phys_addr_size</span> <span class="o">=</span> <span class="n">vm1</span><span class="p">.</span><span class="n">pal_vm_info_1_s</span><span class="p">.</span><span class="n">phys_add_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">unimpl_va_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">7L</span><span class="o">&lt;&lt;</span><span class="mi">61</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">impl_va_msb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">unimpl_pa_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1L</span><span class="o">&lt;&lt;</span><span class="mi">63</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">phys_addr_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the following calculations:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. the max. cache line size.</span>
<span class="cm"> * 2. the minimum of the i-cache stride sizes for &quot;flush_icache_range()&quot;.</span>
<span class="cm"> * 3. the minimum of the cache stride sizes for &quot;clflush_cache_range()&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">get_cache_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">line_size</span><span class="p">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">,</span> <span class="n">levels</span><span class="p">,</span> <span class="n">unique_caches</span><span class="p">;</span>
	<span class="n">pal_cache_config_info_t</span> <span class="n">cci</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_cache_summary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">levels</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unique_caches</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ia64_pal_cache_summary() failed (status=%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">;</span>
		<span class="cm">/* Safest setup for &quot;flush_icache_range()&quot; */</span>
		<span class="n">ia64_i_cache_stride_shift</span> <span class="o">=</span> <span class="n">I_CACHE_STRIDE_SHIFT</span><span class="p">;</span>
		<span class="cm">/* Safest setup for &quot;clflush_cache_range()&quot; */</span>
		<span class="n">ia64_cache_stride_shift</span> <span class="o">=</span> <span class="n">CACHE_STRIDE_SHIFT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">levels</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cache_type (data_or_unified)=2 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_cache_config_info</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ia64_pal_cache_config_info&quot;</span>
				<span class="s">&quot;(l=%lu, 2) failed (status=%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">;</span>
			<span class="cm">/* The safest setup for &quot;flush_icache_range()&quot; */</span>
			<span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span> <span class="o">=</span> <span class="n">I_CACHE_STRIDE_SHIFT</span><span class="p">;</span>
			<span class="cm">/* The safest setup for &quot;clflush_cache_range()&quot; */</span>
			<span class="n">ia64_cache_stride_shift</span> <span class="o">=</span> <span class="n">CACHE_STRIDE_SHIFT</span><span class="p">;</span>
			<span class="n">cci</span><span class="p">.</span><span class="n">pcci_unified</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span> <span class="o">&lt;</span> <span class="n">ia64_cache_stride_shift</span><span class="p">)</span>
				<span class="n">ia64_cache_stride_shift</span> <span class="o">=</span> <span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span><span class="p">;</span>

			<span class="n">line_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cci</span><span class="p">.</span><span class="n">pcci_line_size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">line_size</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">line_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cci</span><span class="p">.</span><span class="n">pcci_unified</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* cache_type (instruction)=1*/</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_cache_config_info</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ia64_pal_cache_config_info&quot;</span>
					<span class="s">&quot;(l=%lu, 1) failed (status=%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="cm">/* The safest setup for flush_icache_range() */</span>
				<span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span> <span class="o">=</span> <span class="n">I_CACHE_STRIDE_SHIFT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span> <span class="o">&lt;</span> <span class="n">ia64_i_cache_stride_shift</span><span class="p">)</span>
			<span class="n">ia64_i_cache_stride_shift</span> <span class="o">=</span> <span class="n">cci</span><span class="p">.</span><span class="n">pcci_stride</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">ia64_max_cacheline_size</span><span class="p">)</span>
		<span class="n">ia64_max_cacheline_size</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpu_init() initializes state that is per-CPU.  This function acts</span>
<span class="cm"> * as a &#39;CPU state barrier&#39;, nothing should get across.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">cpu_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="n">ia64_mmu_init</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_num_phys_stacked</span> <span class="o">=</span> <span class="n">IA64_NUM_PHYS_STACK_REG</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_phys_stacked</span><span class="p">;</span>
	<span class="n">pal_vm_info_2_u_t</span> <span class="n">vmi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">cpu_info</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpu_data</span><span class="p">;</span>

	<span class="n">cpu_data</span> <span class="o">=</span> <span class="n">per_cpu_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/*</span>
<span class="cm">	 * insert boot cpu into sibling and core mapes</span>
<span class="cm">	 * (must be done after per_cpu area is setup)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">cpu_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set ar.k3 so that assembly code in MCA handler can compute</span>
<span class="cm">		 * physical addresses of per cpu variables with a simple:</span>
<span class="cm">		 *   phys = ar.k3 + &amp;per_cpu_var</span>
<span class="cm">		 * and the alt-dtlb-miss handler can set per-cpu mapping into</span>
<span class="cm">		 * the TLB when needed. head.S already did this for cpu0.</span>
<span class="cm">		 */</span>
		<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_PER_CPU_DATA</span><span class="p">,</span>
			    <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">__per_cpu_start</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">get_cache_info</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t pass &quot;local_cpu_data&quot; to identify_cpu() because we haven&#39;t called</span>
<span class="cm">	 * ia64_mmu_init() yet.  And we can&#39;t call ia64_mmu_init() first because it</span>
<span class="cm">	 * depends on the data returned by identify_cpu().  We break the dependency by</span>
<span class="cm">	 * accessing cpu_data() through the canonical per-CPU address.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_info</span> <span class="o">=</span> <span class="n">cpu_data</span> <span class="o">+</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">__ia64_per_cpu_var</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">)</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">);</span>
	<span class="n">identify_cpu</span><span class="p">(</span><span class="n">cpu_info</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MCKINLEY</span>
	<span class="p">{</span>
<span class="cp">#		define FEATURE_SET 16</span>
		<span class="k">struct</span> <span class="n">ia64_pal_retval</span> <span class="n">iprv</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_info</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PAL_CALL_PHYS</span><span class="p">(</span><span class="n">iprv</span><span class="p">,</span> <span class="n">PAL_PROC_GET_FEATURES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FEATURE_SET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">iprv</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iprv</span><span class="p">.</span><span class="n">v0</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iprv</span><span class="p">.</span><span class="n">v2</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span>
				<span class="n">PAL_CALL_PHYS</span><span class="p">(</span><span class="n">iprv</span><span class="p">,</span> <span class="n">PAL_PROC_SET_FEATURES</span><span class="p">,</span>
				              <span class="p">(</span><span class="n">iprv</span><span class="p">.</span><span class="n">v1</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">),</span> <span class="n">FEATURE_SET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Clear the stack memory reserved for pt_regs: */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>

	<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_FPU_OWNER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the page-table base register to a global</span>
<span class="cm">	 * directory with all zeroes.  This ensure that we can handle</span>
<span class="cm">	 * TLB-misses to user address-space even before we created the</span>
<span class="cm">	 * first user address-space.  This may happen, e.g., due to</span>
<span class="cm">	 * aggressive use of lfetch.fault.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_PT_BASE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">empty_zero_page</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize default control register to defer speculative faults except</span>
<span class="cm">	 * for those arising from TLB misses, which are not deferred.  The</span>
<span class="cm">	 * kernel MUST NOT depend on a particular setting of these bits (in other words,</span>
<span class="cm">	 * the kernel must have recovery code for all speculative accesses).  Turn on</span>
<span class="cm">	 * dcr.lc as per recommendation by the architecture team.  Most IA-32 apps</span>
<span class="cm">	 * shouldn&#39;t be affected by this (moral: keep your ia32 locks aligned and you&#39;ll</span>
<span class="cm">	 * be fine).</span>
<span class="cm">	 */</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_DCR</span><span class="p">,</span>  <span class="p">(</span>  <span class="n">IA64_DCR_DP</span> <span class="o">|</span> <span class="n">IA64_DCR_DK</span> <span class="o">|</span> <span class="n">IA64_DCR_DX</span> <span class="o">|</span> <span class="n">IA64_DCR_DR</span>
					<span class="o">|</span> <span class="n">IA64_DCR_DA</span> <span class="o">|</span> <span class="n">IA64_DCR_DD</span> <span class="o">|</span> <span class="n">IA64_DCR_LC</span><span class="p">));</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">ia64_mmu_init</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">));</span>
	<span class="n">ia64_mca_cpu_init</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">));</span>

	<span class="cm">/* Clear ITC to eliminate sched_clock() overflows in human time.  */</span>
	<span class="n">ia64_set_itc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* disable all local interrupt sources: */</span>
	<span class="n">ia64_set_itv</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ia64_set_lrr0</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ia64_set_lrr1</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_PMV</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_CMCV</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* clear TPR &amp; XTP to enable all interrupt classes: */</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_TPR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupts left by SAL/EFI */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ia64_get_ivr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">IA64_SPURIOUS_INT_VECTOR</span><span class="p">)</span>
		<span class="n">ia64_eoi</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">normal_xtp</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* set ia64_ctx.max_rid to the maximum RID that is supported by all CPUs: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_pal_vm_summary</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vmi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vmi</span><span class="p">.</span><span class="n">pal_vm_info_2_s</span><span class="p">.</span><span class="n">rid_size</span> <span class="o">-</span> <span class="mi">3</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">setup_ptcg_sem</span><span class="p">(</span><span class="n">vmi</span><span class="p">.</span><span class="n">pal_vm_info_2_s</span><span class="p">.</span><span class="n">max_purges</span><span class="p">,</span> <span class="n">NPTCG_FROM_PAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;cpu_init: PAL VM summary failed, assuming 18 RID bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">max_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* use architected minimum */</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">max_ctx</span> <span class="o">&lt;</span> <span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">max_ctx</span><span class="p">)</span> <span class="o">==</span> <span class="n">old</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_pal_rse_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_phys_stacked</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;cpu_init: PAL RSE info failed; assuming 96 physical &quot;</span>
		       <span class="s">&quot;stacked regs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">num_phys_stacked</span> <span class="o">=</span> <span class="mi">96</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* size of physical stacked register partition plus 8 bytes: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_phys_stacked</span> <span class="o">&gt;</span> <span class="n">max_num_phys_stacked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_patch_phys_stack_reg</span><span class="p">(</span><span class="n">num_phys_stacked</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">max_num_phys_stacked</span> <span class="o">=</span> <span class="n">num_phys_stacked</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">platform_cpu_init</span><span class="p">();</span>
	<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">default_idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">check_bugs</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_patch_mckinley_e9</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__start___mckinley_e9_bundles</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__end___mckinley_e9_bundles</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">run_dmi_scan</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dmi_scan_machine</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">run_dmi_scan</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
