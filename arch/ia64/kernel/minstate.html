<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › minstate.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>minstate.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;asm/cache.h&gt;</span>

<span class="cp">#include &quot;entry.h&quot;</span>
<span class="cp">#include &quot;paravirt_inst.h&quot;</span>

<span class="cp">#ifdef CONFIG_VIRT_CPU_ACCOUNTING</span>
<span class="cm">/* read ar.itc in advance, and use it before leaving bank 0 */</span>
<span class="cp">#define ACCOUNT_GET_STAMP				\</span>
<span class="cp">(pUStk) mov.m r20=ar.itc;</span>
<span class="cp">#define ACCOUNT_SYS_ENTER				\</span>
<span class="cp">(pUStk) br.call.spnt rp=account_sys_enter		\</span>
<span class="cp">	;;</span>
<span class="cp">#else</span>
<span class="cp">#define ACCOUNT_GET_STAMP</span>
<span class="cp">#define ACCOUNT_SYS_ENTER</span>
<span class="cp">#endif</span>

<span class="p">.</span><span class="n">section</span> <span class="s">&quot;.data..patch.rse&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span>
<span class="p">.</span><span class="n">previous</span>

<span class="cm">/*</span>
<span class="cm"> * DO_SAVE_MIN switches to the kernel stacks (if necessary) and saves</span>
<span class="cm"> * the minimum state necessary that allows us to turn psr.ic back</span>
<span class="cm"> * on.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumed state upon entry:</span>
<span class="cm"> *	psr.ic: off</span>
<span class="cm"> *	r31:	contains saved predicates (pr)</span>
<span class="cm"> *</span>
<span class="cm"> * Upon exit, the state is as follows:</span>
<span class="cm"> *	psr.ic: off</span>
<span class="cm"> *	 r2 = points to &amp;pt_regs.r16</span>
<span class="cm"> *	 r8 = contents of ar.ccv</span>
<span class="cm"> *	 r9 = contents of ar.csd</span>
<span class="cm"> *	r10 = contents of ar.ssd</span>
<span class="cm"> *	r11 = FPSR_DEFAULT</span>
<span class="cm"> *	r12 = kernel sp (kernel virtual address)</span>
<span class="cm"> *	r13 = points to current task_struct (kernel virtual address)</span>
<span class="cm"> *	p15 = TRUE if psr.i is set in cr.ipsr</span>
<span class="cm"> *	predicate registers (other than p2, p3, and p15), b6, r3, r14, r15:</span>
<span class="cm"> *		preserved</span>
<span class="cm"> *</span>
<span class="cm"> * Note that psr.ic is NOT turned on by this macro.  This is so that</span>
<span class="cm"> * we can pass interruption state as arguments to a handler.</span>
<span class="cm"> */</span>
<span class="cp">#define IA64_NATIVE_DO_SAVE_MIN(__COVER,SAVE_IFS,EXTRA,WORKAROUND)				\</span>
<span class="cp">	mov r16=IA64_KR(CURRENT);	</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r27=ar.rsc;			</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r20=r1;			</span><span class="cm">/* A */</span><span class="cp">							\</span>
<span class="cp">	mov r25=ar.unat;		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	MOV_FROM_IPSR(p0,r29);		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r26=ar.pfs;			</span><span class="cm">/* I */</span><span class="cp">							\</span>
<span class="cp">	MOV_FROM_IIP(r28);			</span><span class="cm">/* M */</span><span class="cp">						\</span>
<span class="cp">	mov r21=ar.fpsr;		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	__COVER;				</span><span class="cm">/* B;; (or nothing) */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">	adds r16=IA64_TASK_THREAD_ON_USTACK_OFFSET,r16;						\</span>
<span class="cp">	;;											\</span>
<span class="cp">	ld1 r17=[r16];				</span><span class="cm">/* load current-&gt;thread.on_ustack flag */</span><span class="cp">	\</span>
<span class="cp">	st1 [r16]=r0;				</span><span class="cm">/* clear current-&gt;thread.on_ustack flag */</span><span class="cp">	\</span>
<span class="cp">	adds r1=-IA64_TASK_THREAD_ON_USTACK_OFFSET,r16						\</span>
<span class="cp">	</span><span class="cm">/* switch from user to kernel RBS: */</span><span class="cp">							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	invala;				</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	SAVE_IFS;										\</span>
<span class="cp">	cmp.eq pKStk,pUStk=r0,r17;		</span><span class="cm">/* are we in kernel mode already? */</span><span class="cp">		\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov ar.rsc=0;		</span><span class="cm">/* set enforced lazy mode, pl 0, little-endian, loadrs=0 */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov.m r24=ar.rnat;									\</span>
<span class="cp">(pUStk)	addl r22=IA64_RBS_OFFSET,r1;			</span><span class="cm">/* compute base of RBS */</span><span class="cp">		\</span>
<span class="cp">(pKStk) mov r1=sp;					</span><span class="cm">/* get sp  */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk) lfetch.fault.excl.nt1 [r22];								\</span>
<span class="cp">(pUStk)	addl r1=IA64_STK_OFFSET-IA64_PT_REGS_SIZE,r1;	</span><span class="cm">/* compute base of memory stack */</span><span class="cp">	\</span>
<span class="cp">(pUStk)	mov r23=ar.bspstore;				</span><span class="cm">/* save ar.bspstore */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov ar.bspstore=r22;				</span><span class="cm">/* switch to kernel RBS */</span><span class="cp">		\</span>
<span class="cp">(pKStk) addl r1=-IA64_PT_REGS_SIZE,r1;			</span><span class="cm">/* if in kernel mode, use sp (r12) */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov r18=ar.bsp;										\</span>
<span class="cp">(pUStk)	mov ar.rsc=0x3;		</span><span class="cm">/* set eager mode, pl 0, little-endian, loadrs=0 */</span><span class="cp">		\</span>
<span class="cp">	adds r17=2*L1_CACHE_BYTES,r1;		</span><span class="cm">/* really: biggest cache-line size */</span><span class="cp">		\</span>
<span class="cp">	adds r16=PT(CR_IPSR),r1;								\</span>
<span class="cp">	;;											\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17],L1_CACHE_BYTES;						\</span>
<span class="cp">	st8 [r16]=r29;		</span><span class="cm">/* save cr.ipsr */</span><span class="cp">						\</span>
<span class="cp">	;;											\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17];								\</span>
<span class="cp">	tbit.nz p15,p0=r29,IA64_PSR_I_BIT;							\</span>
<span class="cp">	mov r29=b0										\</span>
<span class="cp">	;;											\</span>
<span class="cp">	WORKAROUND;										\</span>
<span class="cp">	adds r16=PT(R8),r1;	</span><span class="cm">/* initialize first base pointer */</span><span class="cp">				\</span>
<span class="cp">	adds r17=PT(R9),r1;	</span><span class="cm">/* initialize second base pointer */</span><span class="cp">				\</span>
<span class="cp">(pKStk)	mov r18=r0;		</span><span class="cm">/* make sure r18 isn&#39;t NaT */</span><span class="cp">					\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r8,16;								\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r9,16;								\</span>
<span class="cp">        ;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r10,24;							\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r11,24;							\</span>
<span class="cp">        ;;											\</span>
<span class="cp">	st8 [r16]=r28,16;	</span><span class="cm">/* save cr.iip */</span><span class="cp">						\</span>
<span class="cp">	st8 [r17]=r30,16;	</span><span class="cm">/* save cr.ifs */</span><span class="cp">						\</span>
<span class="cp">(pUStk)	sub r18=r18,r22;	</span><span class="cm">/* r18=RSE.ndirty*8 */</span><span class="cp">						\</span>
<span class="cp">	mov r8=ar.ccv;										\</span>
<span class="cp">	mov r9=ar.csd;										\</span>
<span class="cp">	mov r10=ar.ssd;										\</span>
<span class="cp">	movl r11=FPSR_DEFAULT;   </span><span class="cm">/* L-unit */</span><span class="cp">							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r25,16;	</span><span class="cm">/* save ar.unat */</span><span class="cp">						\</span>
<span class="cp">	st8 [r17]=r26,16;	</span><span class="cm">/* save ar.pfs */</span><span class="cp">						\</span>
<span class="cp">	shl r18=r18,16;		</span><span class="cm">/* compute ar.rsc to be used for &quot;loadrs&quot; */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r27,16;	</span><span class="cm">/* save ar.rsc */</span><span class="cp">						\</span>
<span class="cp">(pUStk)	st8 [r17]=r24,16;	</span><span class="cm">/* save ar.rnat */</span><span class="cp">						\</span>
<span class="cp">(pKStk)	adds r17=16,r17;	</span><span class="cm">/* skip over ar_rnat field */</span><span class="cp">					\</span>
<span class="cp">	;;			</span><span class="cm">/* avoid RAW on r16 &amp; r17 */</span><span class="cp">					\</span>
<span class="cp">(pUStk)	st8 [r16]=r23,16;	</span><span class="cm">/* save ar.bspstore */</span><span class="cp">						\</span>
<span class="cp">	st8 [r17]=r31,16;	</span><span class="cm">/* save predicates */</span><span class="cp">						\</span>
<span class="cp">(pKStk)	adds r16=16,r16;	</span><span class="cm">/* skip over ar_bspstore field */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r29,16;	</span><span class="cm">/* save b0 */</span><span class="cp">							\</span>
<span class="cp">	st8 [r17]=r18,16;	</span><span class="cm">/* save ar.rsc value for &quot;loadrs&quot; */</span><span class="cp">				\</span>
<span class="cp">	cmp.eq pNonSys,pSys=r0,r0	</span><span class="cm">/* initialize pSys=0, pNonSys=1 */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r20,16;	</span><span class="cm">/* save original r1 */</span><span class="cp">				\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r12,16;							\</span>
<span class="cp">	adds r12=-16,r1;	</span><span class="cm">/* switch to kernel memory stack (with 16 bytes of scratch) */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r13,16;							\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r21,16;	</span><span class="cm">/* save ar.fpsr */</span><span class="cp">				\</span>
<span class="cp">	mov r13=IA64_KR(CURRENT);	</span><span class="cm">/* establish `current&#39; */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r15,16;							\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r14,16;							\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r2,16;								\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r3,16;								\</span>
<span class="cp">	ACCOUNT_GET_STAMP									\</span>
<span class="cp">	adds r2=IA64_PT_REGS_R16_OFFSET,r1;							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	EXTRA;											\</span>
<span class="cp">	movl r1=__gp;		</span><span class="cm">/* establish kernel global pointer */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">	ACCOUNT_SYS_ENTER									\</span>
<span class="cp">	bsw.1;			</span><span class="cm">/* switch back to bank 1 (must be last in insn group) */</span><span class="cp">	\</span>
<span class="cp">	;;</span>

<span class="cm">/*</span>
<span class="cm"> * SAVE_REST saves the remainder of pt_regs (with psr.ic on).</span>
<span class="cm"> *</span>
<span class="cm"> * Assumed state upon entry:</span>
<span class="cm"> *	psr.ic: on</span>
<span class="cm"> *	r2:	points to &amp;pt_regs.r16</span>
<span class="cm"> *	r3:	points to &amp;pt_regs.r17</span>
<span class="cm"> *	r8:	contents of ar.ccv</span>
<span class="cm"> *	r9:	contents of ar.csd</span>
<span class="cm"> *	r10:	contents of ar.ssd</span>
<span class="cm"> *	r11:	FPSR_DEFAULT</span>
<span class="cm"> *</span>
<span class="cm"> * Registers r14 and r15 are guaranteed not to be touched by SAVE_REST.</span>
<span class="cm"> */</span>
<span class="cp">#define SAVE_REST				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r16,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r17,16;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r18,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r19,16;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r20,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r21,16;		\</span>
<span class="cp">	mov r18=b6;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r22,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r23,16;		\</span>
<span class="cp">	mov r19=b7;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r24,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r25,16;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r26,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r27,16;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r28,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r29,16;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2]=r30,16;		\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3]=r31,32;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov ar.fpsr=r11;	</span><span class="cm">/* M-unit */</span><span class="cp">	\</span>
<span class="cp">	st8 [r2]=r8,8;		</span><span class="cm">/* ar.ccv */</span><span class="cp">	\</span>
<span class="cp">	adds r24=PT(B6)-PT(F7),r3;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	stf.spill [r2]=f6,32;			\</span>
<span class="cp">	stf.spill [r3]=f7,32;			\</span>
<span class="cp">	;;					\</span>
<span class="cp">	stf.spill [r2]=f8,32;			\</span>
<span class="cp">	stf.spill [r3]=f9,32;			\</span>
<span class="cp">	;;					\</span>
<span class="cp">	stf.spill [r2]=f10;			\</span>
<span class="cp">	stf.spill [r3]=f11;			\</span>
<span class="cp">	adds r25=PT(B7)-PT(F11),r3;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r24]=r18,16;       </span><span class="cm">/* b6 */</span><span class="cp">	\</span>
<span class="cp">	st8 [r25]=r19,16;       </span><span class="cm">/* b7 */</span><span class="cp">	\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r24]=r9;        	</span><span class="cm">/* ar.csd */</span><span class="cp">	\</span>
<span class="cp">	st8 [r25]=r10;      	</span><span class="cm">/* ar.ssd */</span><span class="cp">	\</span>
<span class="cp">	;;</span>

<span class="cp">#define RSE_WORKAROUND				\</span>
<span class="cp">(pUStk) extr.u r17=r18,3,6;			\</span>
<span class="cp">(pUStk)	sub r16=r18,r22;			\</span>
<span class="cp">[1:](pKStk)	br.cond.sptk.many 1f;		\</span>
<span class="cp">	.xdata4 &quot;.data..patch.rse&quot;,1b-.		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	cmp.ge p6,p7 = 33,r17;			\</span>
<span class="cp">	;;					\</span>
<span class="cp">(p6)	mov r17=0x310;				\</span>
<span class="cp">(p7)	mov r17=0x308;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">	cmp.leu p1,p0=r16,r17;			\</span>
<span class="cp">(p1)	br.cond.sptk.many 1f;			\</span>
<span class="cp">	dep.z r17=r26,0,62;			\</span>
<span class="cp">	movl r16=2f;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov ar.pfs=r17;				\</span>
<span class="cp">	dep r27=r0,r27,16,14;			\</span>
<span class="cp">	mov b0=r16;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">	br.ret.sptk b0;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">2:						\</span>
<span class="cp">	mov ar.rsc=r0				\</span>
<span class="cp">	;;					\</span>
<span class="cp">	flushrs;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov ar.bspstore=r22			\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov r18=ar.bsp;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">1:						\</span>
<span class="cp">	.pred.rel &quot;mutex&quot;, pKStk, pUStk</span>

<span class="cp">#define SAVE_MIN_WITH_COVER	DO_SAVE_MIN(COVER, mov r30=cr.ifs, , RSE_WORKAROUND)</span>
<span class="cp">#define SAVE_MIN_WITH_COVER_R19	DO_SAVE_MIN(COVER, mov r30=cr.ifs, mov r15=r19, RSE_WORKAROUND)</span>
<span class="cp">#define SAVE_MIN			DO_SAVE_MIN(     , mov r30=r0, , )</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
