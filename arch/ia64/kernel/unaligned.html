<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kernel › unaligned.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>unaligned.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Architecture-specific unaligned trap handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2002, 2004 Hewlett-Packard Co</span>
<span class="cm"> *	Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2002/12/09   Fix rotating register handling (off-by-1 error, missing fr-rotation).  Fix</span>
<span class="cm"> *		get_rse_reg() to not leak kernel bits to user-level (reading an out-of-frame</span>
<span class="cm"> *		stacked register returns an undefined value; it does NOT trigger a</span>
<span class="cm"> *		&quot;rsvd register fault&quot;).</span>
<span class="cm"> * 2001/10/11	Fix unaligned access to rotating registers in s/w pipelined loops.</span>
<span class="cm"> * 2001/08/13	Correct size of extended floats (float_fsz) from 16 to 10 bytes.</span>
<span class="cm"> * 2001/01/17	Add support emulation of unaligned kernel accesses.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &lt;asm/intrinsics.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/rse.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">die_if_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">err</span><span class="p">);</span>

<span class="cp">#undef DEBUG_UNALIGNED_TRAP</span>

<span class="cp">#ifdef DEBUG_UNALIGNED_TRAP</span>
<span class="cp"># define DPRINT(a...)	do { printk(&quot;%s %u: &quot;, __func__, __LINE__); printk (a); } while (0)</span>
<span class="cp"># define DDUMP(str,vp,len)	dump(str, vp, len)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">dump</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">vp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp"># define DPRINT(a...)</span>
<span class="cp"># define DDUMP(str,vp,len)</span>
<span class="cp">#endif</span>

<span class="cp">#define IA64_FIRST_STACKED_GR	32</span>
<span class="cp">#define IA64_FIRST_ROTATING_FR	32</span>
<span class="cp">#define SIGN_EXT9		0xffffffffffffff00ul</span>

<span class="cm">/*</span>
<span class="cm"> *  sysctl settable hook which tells the kernel whether to honor the</span>
<span class="cm"> *  IA64_THREAD_UAC_NOPRINT prctl.  Because this is user settable, we want</span>
<span class="cm"> *  to allow the super user to enable/disable this for security reasons</span>
<span class="cm"> *  (i.e. don&#39;t allow attacker to fill up logs with unaligned accesses).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">no_unaligned_warning</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">unaligned_dump_stack</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * For M-unit:</span>
<span class="cm"> *</span>
<span class="cm"> *  opcode |   m  |   x6    |</span>
<span class="cm"> * --------|------|---------|</span>
<span class="cm"> * [40-37] | [36] | [35:30] |</span>
<span class="cm"> * --------|------|---------|</span>
<span class="cm"> *     4   |   1  |    6    | = 11 bits</span>
<span class="cm"> * --------------------------</span>
<span class="cm"> * However bits [31:30] are not directly useful to distinguish between</span>
<span class="cm"> * load/store so we can use [35:32] instead, which gives the following</span>
<span class="cm"> * mask ([40:32]) using 9 bits. The &#39;e&#39; comes from the fact that we defer</span>
<span class="cm"> * checking the m-bit until later in the load/store emulation.</span>
<span class="cm"> */</span>
<span class="cp">#define IA64_OPCODE_MASK	0x1ef</span>
<span class="cp">#define IA64_OPCODE_SHIFT	32</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-28 Integer Load/Store</span>
<span class="cm"> *</span>
<span class="cm"> * We ignore [35:32]= 0x6, 0x7, 0xE, 0xF</span>
<span class="cm"> *</span>
<span class="cm"> * ld8.fill, st8.fill  MUST be aligned because the RNATs are based on</span>
<span class="cm"> * the address (bits [8:3]), so we must failed.</span>
<span class="cm"> */</span>
<span class="cp">#define LD_OP            0x080</span>
<span class="cp">#define LDS_OP           0x081</span>
<span class="cp">#define LDA_OP           0x082</span>
<span class="cp">#define LDSA_OP          0x083</span>
<span class="cp">#define LDBIAS_OP        0x084</span>
<span class="cp">#define LDACQ_OP         0x085</span>
<span class="cm">/* 0x086, 0x087 are not relevant */</span>
<span class="cp">#define LDCCLR_OP        0x088</span>
<span class="cp">#define LDCNC_OP         0x089</span>
<span class="cp">#define LDCCLRACQ_OP     0x08a</span>
<span class="cp">#define ST_OP            0x08c</span>
<span class="cp">#define STREL_OP         0x08d</span>
<span class="cm">/* 0x08e,0x8f are not relevant */</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-29 Integer Load +Reg</span>
<span class="cm"> *</span>
<span class="cm"> * we use the ld-&gt;m (bit [36:36]) field to determine whether or not we have</span>
<span class="cm"> * a load/store of this form.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-30 Integer Load/Store +Imm</span>
<span class="cm"> *</span>
<span class="cm"> * We ignore [35:32]= 0x6, 0x7, 0xE, 0xF</span>
<span class="cm"> *</span>
<span class="cm"> * ld8.fill, st8.fill  must be aligned because the Nat register are based on</span>
<span class="cm"> * the address, so we must fail and the program must be fixed.</span>
<span class="cm"> */</span>
<span class="cp">#define LD_IMM_OP            0x0a0</span>
<span class="cp">#define LDS_IMM_OP           0x0a1</span>
<span class="cp">#define LDA_IMM_OP           0x0a2</span>
<span class="cp">#define LDSA_IMM_OP          0x0a3</span>
<span class="cp">#define LDBIAS_IMM_OP        0x0a4</span>
<span class="cp">#define LDACQ_IMM_OP         0x0a5</span>
<span class="cm">/* 0x0a6, 0xa7 are not relevant */</span>
<span class="cp">#define LDCCLR_IMM_OP        0x0a8</span>
<span class="cp">#define LDCNC_IMM_OP         0x0a9</span>
<span class="cp">#define LDCCLRACQ_IMM_OP     0x0aa</span>
<span class="cp">#define ST_IMM_OP            0x0ac</span>
<span class="cp">#define STREL_IMM_OP         0x0ad</span>
<span class="cm">/* 0x0ae,0xaf are not relevant */</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-32 Floating-point Load/Store</span>
<span class="cm"> */</span>
<span class="cp">#define LDF_OP           0x0c0</span>
<span class="cp">#define LDFS_OP          0x0c1</span>
<span class="cp">#define LDFA_OP          0x0c2</span>
<span class="cp">#define LDFSA_OP         0x0c3</span>
<span class="cm">/* 0x0c6 is irrelevant */</span>
<span class="cp">#define LDFCCLR_OP       0x0c8</span>
<span class="cp">#define LDFCNC_OP        0x0c9</span>
<span class="cm">/* 0x0cb is irrelevant  */</span>
<span class="cp">#define STF_OP           0x0cc</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-33 Floating-point Load +Reg</span>
<span class="cm"> *</span>
<span class="cm"> * we use the ld-&gt;m (bit [36:36]) field to determine whether or not we have</span>
<span class="cm"> * a load/store of this form.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Table C-34 Floating-point Load/Store +Imm</span>
<span class="cm"> */</span>
<span class="cp">#define LDF_IMM_OP       0x0e0</span>
<span class="cp">#define LDFS_IMM_OP      0x0e1</span>
<span class="cp">#define LDFA_IMM_OP      0x0e2</span>
<span class="cp">#define LDFSA_IMM_OP     0x0e3</span>
<span class="cm">/* 0x0e6 is irrelevant */</span>
<span class="cp">#define LDFCCLR_IMM_OP   0x0e8</span>
<span class="cp">#define LDFCNC_IMM_OP    0x0e9</span>
<span class="cp">#define STF_IMM_OP       0x0ec</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	 <span class="n">qp</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>	<span class="cm">/* [0:5]   */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">r1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>	<span class="cm">/* [6:12]  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">imm</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>	<span class="cm">/* [13:19] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">r3</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>	<span class="cm">/* [20:26] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">x</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* [27:27] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">hint</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* [28:29] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x6_sz</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* [30:31] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x6_op</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* [32:35], x6 = x6_sz|x6_op */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">m</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* [36:36] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">op</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* [37:40] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">pad</span><span class="o">:</span><span class="mi">23</span><span class="p">;</span> <span class="cm">/* [41:63] */</span>
<span class="p">}</span> <span class="n">load_store_t</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">UPD_IMMEDIATE</span><span class="p">,</span>	<span class="cm">/* ldXZ r1=[r3],imm(9) */</span>
	<span class="n">UPD_REG</span>		<span class="cm">/* ldXZ r1=[r3],r2     */</span>
<span class="p">}</span> <span class="n">update_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We use tables to keep track of the offsets of registers in the saved state.</span>
<span class="cm"> * This way we save having big switch/case statements.</span>
<span class="cm"> *</span>
<span class="cm"> * We use bit 0 to indicate switch_stack or pt_regs.</span>
<span class="cm"> * The offset is simply shifted by 1 bit.</span>
<span class="cm"> * A 2-byte value should be enough to hold any kind of offset</span>
<span class="cm"> *</span>
<span class="cm"> * In case the calling convention changes (and thus pt_regs/switch_stack)</span>
<span class="cm"> * simply use RSW instead of RPT or vice-versa.</span>
<span class="cm"> */</span>

<span class="cp">#define RPO(x)	((size_t) &amp;((struct pt_regs *)0)-&gt;x)</span>
<span class="cp">#define RSO(x)	((size_t) &amp;((struct switch_stack *)0)-&gt;x)</span>

<span class="cp">#define RPT(x)		(RPO(x) &lt;&lt; 1)</span>
<span class="cp">#define RSW(x)		(1| RSO(x)&lt;&lt;1)</span>

<span class="cp">#define GR_OFFS(x)	(gr_info[x]&gt;&gt;1)</span>
<span class="cp">#define GR_IN_SW(x)	(gr_info[x] &amp; 0x1)</span>

<span class="cp">#define FR_OFFS(x)	(fr_info[x]&gt;&gt;1)</span>
<span class="cp">#define FR_IN_SW(x)	(fr_info[x] &amp; 0x1)</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">gr_info</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* r0 is read-only : WE SHOULD NEVER GET THIS */</span>

	<span class="n">RPT</span><span class="p">(</span><span class="n">r1</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r2</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r3</span><span class="p">),</span>

	<span class="n">RSW</span><span class="p">(</span><span class="n">r4</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">r5</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">r6</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">r7</span><span class="p">),</span>

	<span class="n">RPT</span><span class="p">(</span><span class="n">r8</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r9</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r10</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r11</span><span class="p">),</span>
	<span class="n">RPT</span><span class="p">(</span><span class="n">r12</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r13</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r14</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r15</span><span class="p">),</span>

	<span class="n">RPT</span><span class="p">(</span><span class="n">r16</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r17</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r18</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r19</span><span class="p">),</span>
	<span class="n">RPT</span><span class="p">(</span><span class="n">r20</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r21</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r22</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r23</span><span class="p">),</span>
	<span class="n">RPT</span><span class="p">(</span><span class="n">r24</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r25</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r26</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r27</span><span class="p">),</span>
	<span class="n">RPT</span><span class="p">(</span><span class="n">r28</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r29</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r30</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">r31</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">fr_info</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* constant : WE SHOULD NEVER GET THIS */</span>
	<span class="mi">0</span><span class="p">,</span>			<span class="cm">/* constant : WE SHOULD NEVER GET THIS */</span>

	<span class="n">RSW</span><span class="p">(</span><span class="n">f2</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f3</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f4</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f5</span><span class="p">),</span>

	<span class="n">RPT</span><span class="p">(</span><span class="n">f6</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">f7</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">f8</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">f9</span><span class="p">),</span>
	<span class="n">RPT</span><span class="p">(</span><span class="n">f10</span><span class="p">),</span> <span class="n">RPT</span><span class="p">(</span><span class="n">f11</span><span class="p">),</span>

	<span class="n">RSW</span><span class="p">(</span><span class="n">f12</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f13</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f14</span><span class="p">),</span>
	<span class="n">RSW</span><span class="p">(</span><span class="n">f15</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f16</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f17</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f18</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f19</span><span class="p">),</span>
	<span class="n">RSW</span><span class="p">(</span><span class="n">f20</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f21</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f22</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f23</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f24</span><span class="p">),</span>
	<span class="n">RSW</span><span class="p">(</span><span class="n">f25</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f26</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f27</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f28</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f29</span><span class="p">),</span>
	<span class="n">RSW</span><span class="p">(</span><span class="n">f30</span><span class="p">),</span> <span class="n">RSW</span><span class="p">(</span><span class="n">f31</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/* Invalidate ALAT entry for integer register REGNO.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">invala_gr</span> <span class="p">(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#	define F(reg)	case reg: ia64_invala_gr(reg); break</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">regno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">F</span><span class="p">(</span>  <span class="mi">0</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">1</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">2</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">3</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">4</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">5</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">6</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">7</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span>  <span class="mi">8</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">9</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">10</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">11</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">12</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">13</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">14</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">16</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">17</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">18</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">19</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">20</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">21</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">22</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">24</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">25</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">26</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">27</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">28</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">29</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">30</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">32</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">33</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">34</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">35</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">36</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">37</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">38</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">39</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">40</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">41</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">42</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">43</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">44</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">45</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">46</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">47</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">48</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">49</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">50</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">51</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">52</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">53</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">54</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">55</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">56</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">57</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">58</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">59</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">60</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">61</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">62</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">63</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">64</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">65</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">66</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">67</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">68</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">69</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">70</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">71</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">72</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">73</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">74</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">75</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">76</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">77</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">78</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">79</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">80</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">81</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">82</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">83</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">84</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">85</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">86</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">87</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">88</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">89</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">90</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">91</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">92</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">93</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">94</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">95</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">96</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">97</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">98</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">99</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">101</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">102</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">103</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">104</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">105</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">106</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">107</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">108</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">109</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">110</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">111</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">112</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">113</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">114</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">115</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">116</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">117</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">118</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">119</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">121</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">122</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">124</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">125</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">126</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#	undef F</span>
<span class="p">}</span>

<span class="cm">/* Invalidate ALAT entry for floating-point register REGNO.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">invala_fr</span> <span class="p">(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#	define F(reg)	case reg: ia64_invala_fr(reg); break</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">regno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">F</span><span class="p">(</span>  <span class="mi">0</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">1</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">2</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">3</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">4</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">5</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">6</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">7</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span>  <span class="mi">8</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span>  <span class="mi">9</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">10</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">11</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">12</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">13</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">14</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">15</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">16</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">17</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">18</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">19</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">20</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">21</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">22</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">24</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">25</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">26</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">27</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">28</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">29</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">30</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">32</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">33</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">34</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">35</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">36</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">37</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">38</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">39</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">40</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">41</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">42</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">43</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">44</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">45</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">46</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">47</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">48</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">49</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">50</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">51</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">52</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">53</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">54</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">55</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">56</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">57</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">58</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">59</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">60</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">61</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">62</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">63</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">64</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">65</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">66</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">67</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">68</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">69</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">70</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">71</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">72</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">73</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">74</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">75</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">76</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">77</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">78</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">79</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">80</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">81</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">82</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">83</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">84</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">85</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">86</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">87</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">88</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">89</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">90</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">91</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">92</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">93</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">94</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">95</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span> <span class="mi">96</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">97</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">98</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span> <span class="mi">99</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">101</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">102</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">103</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">104</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">105</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">106</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">107</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">108</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">109</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">110</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">111</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">112</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">113</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">114</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">115</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">116</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">117</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">118</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">119</span><span class="p">);</span>
		<span class="n">F</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">121</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">122</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">124</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">125</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">126</span><span class="p">);</span> <span class="n">F</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#	undef F</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">rotate_reg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rrb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reg</span> <span class="o">+=</span> <span class="n">rrb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="n">sor</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">-=</span> <span class="n">sor</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_rse_reg</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bsp</span><span class="p">,</span> <span class="o">*</span><span class="n">bspstore</span><span class="p">,</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">rnat_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">ubs_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">kbs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">current</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rnats</span><span class="p">,</span> <span class="n">nat_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">on_kbs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sof</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sor</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">rrb_gr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">&gt;=</span> <span class="n">sof</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this should never happen, as the &quot;rsvd register fault&quot; has higher priority */</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ignoring write to r%lu; only %lu registers are allocated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">sof</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">&lt;</span> <span class="n">sor</span><span class="p">)</span>
		<span class="n">ridx</span> <span class="o">=</span> <span class="n">rotate_reg</span><span class="p">(</span><span class="n">sor</span><span class="p">,</span> <span class="n">rrb_gr</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;r%lu, sw.bspstore=%lx pt.bspstore=%lx sof=%ld sol=%ld ridx=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">r1</span><span class="p">,</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">sof</span><span class="p">,</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">on_kbs</span> <span class="o">=</span> <span class="n">ia64_rse_num_regs</span><span class="p">(</span><span class="n">kbs</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="o">-</span><span class="n">sof</span> <span class="o">+</span> <span class="n">ridx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">kbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the register is on the kernel backing store: easy... */</span>
		<span class="n">rnat_addr</span> <span class="o">=</span> <span class="n">ia64_rse_rnat_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rnat_addr</span> <span class="o">&gt;=</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">)</span>
			<span class="n">rnat_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_rnat</span><span class="p">;</span>
		<span class="n">nat_mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
			<span class="o">*</span><span class="n">rnat_addr</span> <span class="o">|=</span>  <span class="n">nat_mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">rnat_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">nat_mask</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ignoring kernel write to r%lu; register isn&#39;t on the kernel RBS!&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">;</span>
	<span class="n">ubs_end</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">bspstore</span><span class="p">,</span> <span class="n">on_kbs</span><span class="p">);</span>
	<span class="n">bsp</span>     <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">ubs_end</span><span class="p">,</span> <span class="o">-</span><span class="n">sof</span><span class="p">);</span>
	<span class="n">addr</span>    <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">bsp</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ubs_end=%p bsp=%p addr=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bsp</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">ia64_poke</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">rnat_addr</span> <span class="o">=</span> <span class="n">ia64_rse_rnat_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">ia64_peek</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnats</span><span class="p">);</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;rnat @%p = 0x%lx nat=%d old nat=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="n">rnats</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="p">(</span><span class="n">rnats</span> <span class="o">&gt;&gt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">nat_mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
		<span class="n">rnats</span> <span class="o">|=</span>  <span class="n">nat_mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rnats</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">nat_mask</span><span class="p">;</span>
	<span class="n">ia64_poke</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="n">rnats</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;rnat changed to @%p = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="n">rnats</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">get_rse_reg</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bsp</span><span class="p">,</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">rnat_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">ubs_end</span><span class="p">,</span> <span class="o">*</span><span class="n">bspstore</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">kbs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">current</span> <span class="o">+</span> <span class="n">IA64_RBS_OFFSET</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rnats</span><span class="p">,</span> <span class="n">nat_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">on_kbs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sof</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">sor</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">rrb_gr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">&gt;=</span> <span class="n">sof</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read of out-of-frame register returns an undefined value; 0 in our case.  */</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ignoring read from r%lu; only %lu registers are allocated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">sof</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">&lt;</span> <span class="n">sor</span><span class="p">)</span>
		<span class="n">ridx</span> <span class="o">=</span> <span class="n">rotate_reg</span><span class="p">(</span><span class="n">sor</span><span class="p">,</span> <span class="n">rrb_gr</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;r%lu, sw.bspstore=%lx pt.bspstore=%lx sof=%ld sol=%ld ridx=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">r1</span><span class="p">,</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="n">sof</span><span class="p">,</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">on_kbs</span> <span class="o">=</span> <span class="n">ia64_rse_num_regs</span><span class="p">(</span><span class="n">kbs</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">,</span> <span class="o">-</span><span class="n">sof</span> <span class="o">+</span> <span class="n">ridx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">kbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the register is on the kernel backing store: easy... */</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rnat_addr</span> <span class="o">=</span> <span class="n">ia64_rse_rnat_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rnat_addr</span> <span class="o">&gt;=</span> <span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">)</span>
				<span class="n">rnat_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_rnat</span><span class="p">;</span>
			<span class="n">nat_mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="o">*</span><span class="n">nat</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">rnat_addr</span> <span class="o">&amp;</span> <span class="n">nat_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_stack</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ignoring kernel read of r%lu; register isn&#39;t on the RBS!&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bspstore</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ar_bspstore</span><span class="p">;</span>
	<span class="n">ubs_end</span> <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">bspstore</span><span class="p">,</span> <span class="n">on_kbs</span><span class="p">);</span>
	<span class="n">bsp</span>     <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">ubs_end</span><span class="p">,</span> <span class="o">-</span><span class="n">sof</span><span class="p">);</span>
	<span class="n">addr</span>    <span class="o">=</span> <span class="n">ia64_rse_skip_regs</span><span class="p">(</span><span class="n">bsp</span><span class="p">,</span> <span class="n">ridx</span><span class="p">);</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ubs_end=%p bsp=%p addr=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bsp</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">ia64_peek</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rnat_addr</span> <span class="o">=</span> <span class="n">ia64_rse_rnat_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">nat_mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ia64_rse_slot_num</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;rnat @%p = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="n">rnats</span><span class="p">);</span>

		<span class="n">ia64_peek</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ubs_end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">rnat_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rnats</span><span class="p">);</span>
		<span class="o">*</span><span class="n">nat</span> <span class="o">=</span> <span class="p">(</span><span class="n">rnats</span> <span class="o">&amp;</span> <span class="n">nat_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

  <span class="nl">fail:</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">setreg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nat</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">unat</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First takes care of stacked registers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&gt;=</span> <span class="n">IA64_FIRST_STACKED_GR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_rse_reg</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Using r0 as a target raises a General Exception fault which has higher priority</span>
<span class="cm">	 * than the Unaligned Reference fault.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now look at registers in [0-31] range and init correct UNAT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GR_IN_SW</span><span class="p">(</span><span class="n">regnum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sw</span><span class="p">;</span>
		<span class="n">unat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_unat</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>
		<span class="n">unat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">caller_unat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;tmp_base=%lx switch_stack=%s offset=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">addr</span><span class="p">,</span> <span class="n">unat</span><span class="o">==&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_unat</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span><span class="o">:</span><span class="s">&quot;no&quot;</span><span class="p">,</span> <span class="n">GR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * add offset from base of struct</span>
<span class="cm">	 * and do it !</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">GR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">);</span>

	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to clear the corresponding UNAT bit to fully emulate the load</span>
<span class="cm">	 * UNAT bit_pos = GR[r3]{8:3} form EAS-2.4</span>
<span class="cm">	 */</span>
	<span class="n">bitmask</span>   <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">);</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;*0x%lx=0x%lx NaT=%d prev_unat @%p=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">unat</span><span class="p">,</span> <span class="o">*</span><span class="n">unat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">unat</span> <span class="o">|=</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">unat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bitmask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;*0x%lx=0x%lx NaT=%d new unat: %p=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">unat</span><span class="p">,</span><span class="o">*</span><span class="n">unat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the (rotated) index for floating point register REGNUM (REGNUM must be in the</span>
<span class="cm"> * range from 32-127, result is in the range from 0-95.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">fph_index</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rrb_fr</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ifs</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rotate_reg</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="n">rrb_fr</span><span class="p">,</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">-</span> <span class="n">IA64_FIRST_ROTATING_FR</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">setfpreg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fpval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From EAS-2.5: FPDisableFault has higher priority than Unaligned</span>
<span class="cm">	 * Fault. Thus, when we get here, we know the partition is enabled.</span>
<span class="cm">	 * To update f32-f127, there are three choices:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	(1) save f32-f127 to thread.fph and update the values there</span>
<span class="cm">	 *	(2) use a gigantic switch statement to directly access the registers</span>
<span class="cm">	 *	(3) generate code on the fly to update the desired register</span>
<span class="cm">	 *</span>
<span class="cm">	 * For now, we are using approach (1).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&gt;=</span> <span class="n">IA64_FIRST_ROTATING_FR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_sync_fph</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fph</span><span class="p">[</span><span class="n">fph_index</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">regnum</span><span class="p">)]</span> <span class="o">=</span> <span class="o">*</span><span class="n">fpval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * pt_regs or switch_stack ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FR_IN_SW</span><span class="p">(</span><span class="n">regnum</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sw</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;tmp_base=%lx offset=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">FR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">));</span>

		<span class="n">addr</span> <span class="o">+=</span> <span class="n">FR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">fpval</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * mark the low partition as being used now</span>
<span class="cm">		 *</span>
<span class="cm">		 * It is highly unlikely that this bit is not already set, but</span>
<span class="cm">		 * let&#39;s do it for safety.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">|=</span> <span class="n">IA64_PSR_MFL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Those 2 inline functions generate the spilled versions of the constant floating point</span>
<span class="cm"> * registers which can be used with stfX</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float_spill_f0</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float_spill_f1</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">getfpreg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fpval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From EAS-2.5: FPDisableFault has higher priority than</span>
<span class="cm">	 * Unaligned Fault. Thus, when we get here, we know the partition is</span>
<span class="cm">	 * enabled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When regnum &gt; 31, the register is still live and we need to force a save</span>
<span class="cm">	 * to current-&gt;thread.fph to get access to it.  See discussion in setfpreg()</span>
<span class="cm">	 * for reasons and other ways of doing this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&gt;=</span> <span class="n">IA64_FIRST_ROTATING_FR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_flush_fph</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="o">*</span><span class="n">fpval</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fph</span><span class="p">[</span><span class="n">fph_index</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">regnum</span><span class="p">)];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * f0 = 0.0, f1= 1.0. Those registers are constant and are thus</span>
<span class="cm">		 * not saved, we must generate their spilled form on the fly</span>
<span class="cm">		 */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">regnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">float_spill_f0</span><span class="p">(</span><span class="n">fpval</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">float_spill_f1</span><span class="p">(</span><span class="n">fpval</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * pt_regs or switch_stack ?</span>
<span class="cm">			 */</span>
			<span class="n">addr</span> <span class="o">=</span>  <span class="n">FR_IN_SW</span><span class="p">(</span><span class="n">regnum</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sw</span>
						 <span class="o">:</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>

			<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;is_sw=%d tmp_base=%lx offset=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">FR_IN_SW</span><span class="p">(</span><span class="n">regnum</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">FR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">));</span>

			<span class="n">addr</span>  <span class="o">+=</span> <span class="n">FR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">);</span>
			<span class="o">*</span><span class="n">fpval</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span>
<span class="nf">getreg</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="n">sw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">switch_stack</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">unat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&gt;=</span> <span class="n">IA64_FIRST_STACKED_GR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_rse_reg</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">nat</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * take care of r0 (read-only always evaluate to 0)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
			<span class="o">*</span><span class="n">nat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now look at registers in [0-31] range and init correct UNAT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GR_IN_SW</span><span class="p">(</span><span class="n">regnum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sw</span><span class="p">;</span>
		<span class="n">unat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">ar_unat</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="p">;</span>
		<span class="n">unat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sw</span><span class="o">-&gt;</span><span class="n">caller_unat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;addr_base=%lx offset=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>  <span class="n">GR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">));</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="n">GR_OFFS</span><span class="p">(</span><span class="n">regnum</span><span class="p">);</span>

	<span class="o">*</span><span class="n">val</span>  <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * do it only when requested</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nat</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nat</span>  <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">unat</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">emulate_load_updates</span> <span class="p">(</span><span class="n">update_t</span> <span class="n">type</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * IMPORTANT:</span>
<span class="cm">	 * Given the way we handle unaligned speculative loads, we should</span>
<span class="cm">	 * not get to this point in the code but we keep this sanity check,</span>
<span class="cm">	 * just in case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: register update on speculative load, error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;unaligned reference on speculative load with register update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">regs</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * at this point, we know that the base register to update is valid i.e.,</span>
<span class="cm">	 * it&#39;s not r0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">UPD_IMMEDIATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Load +Imm: ldXZ r1=[r3],imm(9)</span>
<span class="cm">		 *</span>
<span class="cm">		 *</span>
<span class="cm">		 * form imm9: [13:19] contain the first 7 bits</span>
<span class="cm">		 */</span>
		<span class="n">imm</span> <span class="o">=</span> <span class="n">ld</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">|</span> <span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * sign extend (1+8bits) if m set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="n">imm</span> <span class="o">|=</span> <span class="n">SIGN_EXT9</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * ifa == r3 and we know that the NaT bit on r3 was clear so</span>
<span class="cm">		 * we can directly use ifa.</span>
<span class="cm">		 */</span>
		<span class="n">ifa</span> <span class="o">+=</span> <span class="n">imm</span><span class="p">;</span>

		<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ld.x=%d ld.m=%d imm=%ld r3=0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">ifa</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nat_r2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Load +Reg Opcode: ldXZ r1=[r3],r2</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: that we update r3 even in the case of ldfX.a</span>
<span class="cm">		 * (where the load does not happen)</span>
<span class="cm">		 *</span>
<span class="cm">		 * The way the load algorithm works, we know that r3 does not</span>
<span class="cm">		 * have its NaT bit set (would have gotten NaT consumption</span>
<span class="cm">		 * before getting the unaligned fault). So we can use ifa</span>
<span class="cm">		 * which equals r3 at this point.</span>
<span class="cm">		 *</span>
<span class="cm">		 * IMPORTANT:</span>
<span class="cm">		 * The above statement holds ONLY because we know that we</span>
<span class="cm">		 * never reach this code when trying to do a ldX.s.</span>
<span class="cm">		 * If we ever make it to here on an ldfX.s then</span>
<span class="cm">		 */</span>
		<span class="n">getreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nat_r2</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">ifa</span> <span class="o">+=</span> <span class="n">r2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * propagate Nat r2 -&gt; r3</span>
<span class="cm">		 */</span>
		<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">nat_r2</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;imm=%d r2=%ld r3=0x%lx nat_r2=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">nat_r2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">emulate_load_int</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * r0, as target, doesn&#39;t need to be checked because Illegal Instruction</span>
<span class="cm">	 * faults have higher priority than unaligned faults.</span>
<span class="cm">	 *</span>
<span class="cm">	 * r0 cannot be found as the base as it would never generate an</span>
<span class="cm">	 * unaligned reference.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * ldX.a we will emulate load and also invalidate the ALAT entry.</span>
<span class="cm">	 * See comment below for explanation on how we handle ldX.a</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;unknown size: x6=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* this assumes little-endian byte-order: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for updates on any kind of loads</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x5</span> <span class="o">||</span> <span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span>
		<span class="n">emulate_load_updates</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x5</span> <span class="o">?</span> <span class="n">UPD_IMMEDIATE</span><span class="o">:</span> <span class="n">UPD_REG</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">ifa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * handling of various loads (based on EAS2.4):</span>
<span class="cm">	 *</span>
<span class="cm">	 * ldX.acq (ordered load):</span>
<span class="cm">	 *	- acquire semantics would have been used, so force fence instead.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ldX.c.clr (check load and clear):</span>
<span class="cm">	 *	- if we get to this handler, it&#39;s because the entry was not in the ALAT.</span>
<span class="cm">	 *	  Therefore the operation reverts to a normal load</span>
<span class="cm">	 *</span>
<span class="cm">	 * ldX.c.nc (check load no clear):</span>
<span class="cm">	 *	- same as previous one</span>
<span class="cm">	 *</span>
<span class="cm">	 * ldX.c.clr.acq (ordered check load and clear):</span>
<span class="cm">	 *	- same as above for c.clr part. The load needs to have acquire semantics. So</span>
<span class="cm">	 *	  we use the fence semantics which is stronger and thus ensures correctness.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ldX.a (advanced load):</span>
<span class="cm">	 *	- suppose ldX.a r1=[r3]. If we get to the unaligned trap it&#39;s because the</span>
<span class="cm">	 *	  address doesn&#39;t match requested size alignment. This means that we would</span>
<span class="cm">	 *	  possibly need more than one load to get the result.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  The load part can be handled just like a normal load, however the difficult</span>
<span class="cm">	 *	  part is to get the right thing into the ALAT. The critical piece of information</span>
<span class="cm">	 *	  in the base address of the load &amp; size. To do that, a ld.a must be executed,</span>
<span class="cm">	 *	  clearly any address can be pushed into the table by using ld1.a r1=[r3]. Now</span>
<span class="cm">	 *	  if we use the same target register, we will be okay for the check.a instruction.</span>
<span class="cm">	 *	  If we look at the store, basically a stX [r3]=r1 checks the ALAT  for any entry</span>
<span class="cm">	 *	  which would overlap within [r3,r3+X] (the size of the load was store in the</span>
<span class="cm">	 *	  ALAT). If such an entry is found the entry is invalidated. But this is not good</span>
<span class="cm">	 *	  enough, take the following example:</span>
<span class="cm">	 *		r3=3</span>
<span class="cm">	 *		ld4.a r1=[r3]</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  Could be emulated by doing:</span>
<span class="cm">	 *		ld1.a r1=[r3],1</span>
<span class="cm">	 *		store to temporary;</span>
<span class="cm">	 *		ld1.a r1=[r3],1</span>
<span class="cm">	 *		store &amp; shift to temporary;</span>
<span class="cm">	 *		ld1.a r1=[r3],1</span>
<span class="cm">	 *		store &amp; shift to temporary;</span>
<span class="cm">	 *		ld1.a r1=[r3]</span>
<span class="cm">	 *		store &amp; shift to temporary;</span>
<span class="cm">	 *		r1=temporary</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  So in this case, you would get the right value is r1 but the wrong info in</span>
<span class="cm">	 *	  the ALAT.  Notice that you could do it in reverse to finish with address 3</span>
<span class="cm">	 *	  but you would still get the size wrong.  To get the size right, one needs to</span>
<span class="cm">	 *	  execute exactly the same kind of load. You could do it from a aligned</span>
<span class="cm">	 *	  temporary location, but you would get the address wrong.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  So no matter what, it is not possible to emulate an advanced load</span>
<span class="cm">	 *	  correctly. But is that really critical ?</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  We will always convert ld.a into a normal load with ALAT invalidated.  This</span>
<span class="cm">	 *	  will enable compiler to do optimization where certain code path after ld.a</span>
<span class="cm">	 *	  is not required to have ld.c/chk.a, e.g., code path with no intervening stores.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  If there is a store after the advanced load, one must either do a ld.c.* or</span>
<span class="cm">	 *	  chk.a.* to reuse the value stored in the ALAT. Both can &quot;fail&quot; (meaning no</span>
<span class="cm">	 *	  entry found in ALAT), and that&#39;s perfectly ok because:</span>
<span class="cm">	 *</span>
<span class="cm">	 *		- ld.c.*, if the entry is not present a  normal load is executed</span>
<span class="cm">	 *		- chk.a.*, if the entry is not present, execution jumps to recovery code</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  In either case, the load can be potentially retried in another form.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  ALAT must be invalidated for the register (so that chk.a or ld.c don&#39;t pick</span>
<span class="cm">	 *	  up a stale entry later). The register base update MUST also be performed.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * when the load has the .acq completer then</span>
<span class="cm">	 * use ordering fence.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0x5</span> <span class="o">||</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0xa</span><span class="p">)</span>
		<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * invalidate ALAT entry in case of advanced load</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="n">invala_gr</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">emulate_store_int</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we get to this handler, Nat bits on both r3 and r2 have already</span>
<span class="cm">	 * been checked. so we don&#39;t need to do it</span>
<span class="cm">	 *</span>
<span class="cm">	 * extract the value to be stored</span>
<span class="cm">	 */</span>
	<span class="n">getreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we rely on the macros in unaligned.h for now i.e.,</span>
<span class="cm">	 * we let the compiler figure out how to read memory gracefully.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need this switch/case because the way the inline function</span>
<span class="cm">	 * works. The code is optimized by the compiler and looks like</span>
<span class="cm">	 * a single switch/case.</span>
<span class="cm">	 */</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;st%d [%lx]=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;unknown size: x6=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this assumes little-endian byte-order: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * stX [r3]=r2,imm(9)</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:</span>
<span class="cm">	 * ld.r3 can never be r0, because r0 would not generate an</span>
<span class="cm">	 * unaligned access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x5</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * form imm9: [12:6] contain first 7bits</span>
<span class="cm">		 */</span>
		<span class="n">imm</span> <span class="o">=</span> <span class="n">ld</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">|</span> <span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * sign extend (8bits) if m set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="n">imm</span> <span class="o">|=</span> <span class="n">SIGN_EXT9</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ifa == r3 (NaT is necessarily cleared)</span>
<span class="cm">		 */</span>
		<span class="n">ifa</span> <span class="o">+=</span> <span class="n">imm</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;imm=%lx r3=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">ifa</span><span class="p">);</span>

		<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t have alat_invalidate_multiple() so we need</span>
<span class="cm">	 * to do the complete flush :-&lt;&lt;</span>
<span class="cm">	 */</span>
	<span class="n">ia64_invala</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * stX.rel: use fence instead of release</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0xd</span><span class="p">)</span>
		<span class="n">mb</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * floating point operations sizes in bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">float_fsz</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
	<span class="mi">10</span><span class="p">,</span> <span class="cm">/* extended precision (e) */</span>
	<span class="mi">8</span><span class="p">,</span>  <span class="cm">/* integer (8)            */</span>
	<span class="mi">4</span><span class="p">,</span>  <span class="cm">/* single precision (s)   */</span>
	<span class="mi">8</span>   <span class="cm">/* double precision (d)   */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem2float_extended</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldfe</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem2float_integer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldf8</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem2float_single</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldfs</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem2float_double</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldfd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stf_spill</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float2mem_extended</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldf_fill</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stfe</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float2mem_integer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldf_fill</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stf8</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float2mem_single</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldf_fill</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stfs</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">float2mem_double</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">final</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ldf_fill</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_stfd</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">emulate_load_floatpair</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_init</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_final</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">float_fsz</span><span class="p">[</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * fr0 &amp; fr1 don&#39;t need to be checked because Illegal Instruction faults have</span>
<span class="cm">	 * higher priority than unaligned faults.</span>
<span class="cm">	 *</span>
<span class="cm">	 * r0 cannot be found as the base as it would never generate an unaligned</span>
<span class="cm">	 * reference.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure we get clean buffers</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_init</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_final</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * ldfpX.a: we don&#39;t try to emulate anything but we must</span>
<span class="cm">	 * invalidate the ALAT entry and execute updates, if any.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">!=</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This assumes little-endian byte-order.  Note that there is no &quot;ldfpe&quot;</span>
<span class="cm">		 * instruction:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">ifa</span> <span class="o">+</span> <span class="n">len</span><span class="p">),</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ld.r1=%d ld.imm=%d x6_sz=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">);</span>
		<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;frp_init =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX fixme</span>
<span class="cm">		 * Could optimize inlines by using ldfpX &amp; 2 spills</span>
<span class="cm">		 */</span>
		<span class="k">switch</span><span class="p">(</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">mem2float_extended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">mem2float_extended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">mem2float_integer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">mem2float_integer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">mem2float_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">mem2float_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">mem2float_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">mem2float_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;fpr_final =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">len</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX fixme</span>
<span class="cm">		 *</span>
<span class="cm">		 * A possible optimization would be to drop fpr_final and directly</span>
<span class="cm">		 * use the storage from the saved context i.e., the actual final</span>
<span class="cm">		 * destination (pt_regs, switch_stack or thread structure).</span>
<span class="cm">		 */</span>
		<span class="n">setfpreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">setfpreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for updates: only immediate updates are available for this</span>
<span class="cm">	 * instruction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the immediate is implicit given the ldsz of the operation:</span>
<span class="cm">		 * single: 8 (2x4) and for  all others it&#39;s 16 (2x8)</span>
<span class="cm">		 */</span>
		<span class="n">ifa</span> <span class="o">+=</span> <span class="n">len</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * IMPORTANT:</span>
<span class="cm">		 * the fact that we force the NaT of r3 to zero is ONLY valid</span>
<span class="cm">		 * as long as we don&#39;t come here with a ldfpX.s.</span>
<span class="cm">		 * For this reason we keep this sanity check</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: register update on speculative load pair, error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>

		<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate ALAT entries, if any, for both registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">invala_fr</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">);</span>
		<span class="n">invala_fr</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">emulate_load_float</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_final</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">float_fsz</span><span class="p">[</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * fr0 &amp; fr1 don&#39;t need to be checked because Illegal Instruction</span>
<span class="cm">	 * faults have higher priority than unaligned faults.</span>
<span class="cm">	 *</span>
<span class="cm">	 * r0 cannot be found as the base as it would never generate an</span>
<span class="cm">	 * unaligned reference.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure we get clean buffers</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_init</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_final</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * ldfX.a we don&#39;t try to emulate anything but we must</span>
<span class="cm">	 * invalidate the ALAT entry.</span>
<span class="cm">	 * See comments in ldX for descriptions on how the various loads are handled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">!=</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ld.r1=%d x6_sz=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">);</span>
		<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;fpr_init =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we only do something for x6_op={0,8,9}</span>
<span class="cm">		 */</span>
		<span class="k">switch</span><span class="p">(</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">mem2float_extended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">mem2float_integer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">mem2float_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">mem2float_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;fpr_final =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX fixme</span>
<span class="cm">		 *</span>
<span class="cm">		 * A possible optimization would be to drop fpr_final and directly</span>
<span class="cm">		 * use the storage from the saved context i.e., the actual final</span>
<span class="cm">		 * destination (pt_regs, switch_stack or thread structure).</span>
<span class="cm">		 */</span>
		<span class="n">setfpreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * check for updates on any loads</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x7</span> <span class="o">||</span> <span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span>
		<span class="n">emulate_load_updates</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x7</span> <span class="o">?</span> <span class="n">UPD_IMMEDIATE</span><span class="o">:</span> <span class="n">UPD_REG</span><span class="p">,</span> <span class="n">ld</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">ifa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * invalidate ALAT entry in case of advanced floating point loads</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_op</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="n">invala_fr</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">emulate_store_float</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">load_store_t</span> <span class="n">ld</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fpr_final</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">float_fsz</span><span class="p">[</span><span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure we get clean buffers</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_init</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fpr_final</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we get to this handler, Nat bits on both r3 and r2 have already</span>
<span class="cm">	 * been checked. so we don&#39;t need to do it</span>
<span class="cm">	 *</span>
<span class="cm">	 * extract the value to be stored</span>
<span class="cm">	 */</span>
	<span class="n">getfpreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * during this step, we extract the spilled registers from the saved</span>
<span class="cm">	 * context i.e., we refill. Then we store (no spill) to temporary</span>
<span class="cm">	 * aligned location</span>
<span class="cm">	 */</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">float2mem_extended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">float2mem_integer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">float2mem_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">float2mem_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ld.r1=%d x6_sz=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">);</span>
	<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;fpr_init =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_init</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">DDUMP</span><span class="p">(</span><span class="s">&quot;fpr_final =&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpr_final</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * stfX [r3]=r2,imm(9)</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE:</span>
<span class="cm">	 * ld.r3 can never be r0, because r0 would not generate an</span>
<span class="cm">	 * unaligned access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="mh">0x7</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * form imm9: [12:6] contain first 7bits</span>
<span class="cm">		 */</span>
		<span class="n">imm</span> <span class="o">=</span> <span class="n">ld</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">|</span> <span class="n">ld</span><span class="p">.</span><span class="n">r1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * sign extend (8bits) if m set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">m</span><span class="p">)</span>
			<span class="n">imm</span> <span class="o">|=</span> <span class="n">SIGN_EXT9</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ifa == r3 (NaT is necessarily cleared)</span>
<span class="cm">		 */</span>
		<span class="n">ifa</span> <span class="o">+=</span> <span class="n">imm</span><span class="p">;</span>

		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;imm=%lx r3=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">ifa</span><span class="p">);</span>

		<span class="n">setreg</span><span class="p">(</span><span class="n">ld</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t have alat_invalidate_multiple() so we need</span>
<span class="cm">	 * to do the complete flush :-&lt;&lt;</span>
<span class="cm">	 */</span>
	<span class="n">ia64_invala</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure we log the unaligned access, so that user/sysadmin can notice it and</span>
<span class="cm"> * eventually fix the program.  However, we don&#39;t want to do that for every access so we</span>
<span class="cm"> * pace it with jiffies.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">logging_rate_limit</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">ia64_handle_unaligned</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ifa</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_psr</span> <span class="o">*</span><span class="n">ipsr</span> <span class="o">=</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bundle</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">si</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">load_store_t</span> <span class="n">insn</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">be</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we don&#39;t support big-endian accesses */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;big-endian unaligned accesses are not supported&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">force_sigbus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Treat kernel accesses for which there is an exception handler entry the same as</span>
<span class="cm">	 * user-level unaligned accesses.  Otherwise, a clever program could trick this</span>
<span class="cm">	 * handler into reading an arbitrary kernel addresses...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="n">eh</span> <span class="o">=</span> <span class="n">search_exception_tables</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">||</span> <span class="n">eh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_UAC_SIGBUS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">force_sigbus</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_unaligned_warning</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IA64_THREAD_UAC_NOPRINT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logging_rate_limit</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>	<span class="cm">/* comm[] is at most 16 bytes... */</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s(%d): unaligned access to 0x%016lx, &quot;</span>
				      <span class="s">&quot;ip=0x%016lx</span><span class="se">\n\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
				      <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
				      <span class="n">ifa</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+</span> <span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t call tty_write_message() if we&#39;re in the kernel; we might</span>
<span class="cm">			 * be holding locks...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
				<span class="n">tty_write_message</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* drop &#39;\r&#39; */</span>
			<span class="cm">/* watch for command names containing %s */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">no_unaligned_warning</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s(%d) encountered an &quot;</span>
				       <span class="s">&quot;unaligned exception which required</span><span class="se">\n</span><span class="s">&quot;</span>
				       <span class="s">&quot;kernel assistance, which degrades &quot;</span>
				       <span class="s">&quot;the performance of the application.</span><span class="se">\n</span><span class="s">&quot;</span>
				       <span class="s">&quot;Unaligned exception warnings have &quot;</span>
				       <span class="s">&quot;been disabled by the system &quot;</span>
				       <span class="s">&quot;administrator</span><span class="se">\n</span><span class="s">&quot;</span>
				       <span class="s">&quot;echo 0 &gt; /proc/sys/kernel/ignore-&quot;</span>
				       <span class="s">&quot;unaligned-usertrap to re-enable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logging_rate_limit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kernel unaligned access to 0x%016lx, ip=0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ifa</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+</span> <span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unaligned_dump_stack</span><span class="p">)</span>
				<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;iip=%lx ifa=%lx isr=%lx (ei=%d, sp=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span><span class="p">,</span> <span class="n">ifa</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span><span class="p">,</span> <span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">,</span> <span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * extract the instruction from the bundle given the slot number</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="mi">0</span>: <span class="n">u</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">5</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="mi">1</span>: <span class="n">u</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">46</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="mi">2</span>: <span class="n">u</span><span class="p">.</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">bundle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">23</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">l</span> <span class="o">&gt;&gt;</span> <span class="n">IA64_OPCODE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IA64_OPCODE_MASK</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;opcode=%lx ld.qp=%d ld.r1=%d ld.imm=%d ld.r3=%d ld.x=%d ld.hint=%d &quot;</span>
	       <span class="s">&quot;ld.x6=0x%x ld.m=%d ld.op=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">qp</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">imm</span><span class="p">,</span>
	       <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">hint</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x6_sz</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">op</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * IMPORTANT:</span>
<span class="cm">	 * Notice that the switch statement DOES not cover all possible instructions</span>
<span class="cm">	 * that DO generate unaligned references. This is made on purpose because for some</span>
<span class="cm">	 * instructions it DOES NOT make sense to try and emulate the access. Sometimes it</span>
<span class="cm">	 * is WRONG to try and emulate. Here is a list of instruction we don&#39;t emulate i.e.,</span>
<span class="cm">	 * the program will get a signal and die:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	load/store:</span>
<span class="cm">	 *		- ldX.spill</span>
<span class="cm">	 *		- stX.spill</span>
<span class="cm">	 *	Reason: RNATs are based on addresses</span>
<span class="cm">	 *		- ld16</span>
<span class="cm">	 *		- st16</span>
<span class="cm">	 *	Reason: ld16 and st16 are supposed to occur in a single</span>
<span class="cm">	 *		memory op</span>
<span class="cm">	 *</span>
<span class="cm">	 *	synchronization:</span>
<span class="cm">	 *		- cmpxchg</span>
<span class="cm">	 *		- fetchadd</span>
<span class="cm">	 *		- xchg</span>
<span class="cm">	 *	Reason: ATOMIC operations cannot be emulated properly using multiple</span>
<span class="cm">	 *	        instructions.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	speculative loads:</span>
<span class="cm">	 *		- ldX.sZ</span>
<span class="cm">	 *	Reason: side effects, code must be ready to deal with failure so simpler</span>
<span class="cm">	 *		to let the load fail.</span>
<span class="cm">	 * ---------------------------------------------------------------------------------</span>
<span class="cm">	 * XXX fixme</span>
<span class="cm">	 *</span>
<span class="cm">	 * I would like to get rid of this switch case and do something</span>
<span class="cm">	 * more elegant.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">LDS_OP</span>:
	      <span class="k">case</span> <span class="n">LDSA_OP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
			<span class="cm">/* oops, really a semaphore op (cmpxchg, etc) */</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="cm">/* no break */</span>
	      <span class="k">case</span> <span class="n">LDS_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDSA_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDFS_OP</span>:
	      <span class="k">case</span> <span class="n">LDFSA_OP</span>:
	      <span class="k">case</span> <span class="n">LDFS_IMM_OP</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The instruction will be retried with deferred exceptions turned on, and</span>
<span class="cm">		 * we should get Nat bit installed</span>
<span class="cm">		 *</span>
<span class="cm">		 * IMPORTANT: When PSR_ED is set, the register &amp; immediate update forms</span>
<span class="cm">		 * are actually executed even though the operation failed. So we don&#39;t</span>
<span class="cm">		 * need to take care of this.</span>
<span class="cm">		 */</span>
		<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;forcing PSR_ED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_ipsr</span> <span class="o">|=</span> <span class="n">IA64_PSR_ED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">LD_OP</span>:
	      <span class="k">case</span> <span class="n">LDA_OP</span>:
	      <span class="k">case</span> <span class="n">LDBIAS_OP</span>:
	      <span class="k">case</span> <span class="n">LDACQ_OP</span>:
	      <span class="k">case</span> <span class="n">LDCCLR_OP</span>:
	      <span class="k">case</span> <span class="n">LDCNC_OP</span>:
	      <span class="k">case</span> <span class="n">LDCCLRACQ_OP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
			<span class="cm">/* oops, really a semaphore op (cmpxchg, etc) */</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="cm">/* no break */</span>
	      <span class="k">case</span> <span class="n">LD_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDA_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDBIAS_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDACQ_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDCCLR_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDCNC_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDCCLRACQ_IMM_OP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_load_int</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">ST_OP</span>:
	      <span class="k">case</span> <span class="n">STREL_OP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
			<span class="cm">/* oops, really a semaphore op (cmpxchg, etc) */</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="cm">/* no break */</span>
	      <span class="k">case</span> <span class="n">ST_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">STREL_IMM_OP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_store_int</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">LDF_OP</span>:
	      <span class="k">case</span> <span class="n">LDFA_OP</span>:
	      <span class="k">case</span> <span class="n">LDFCCLR_OP</span>:
	      <span class="k">case</span> <span class="n">LDFCNC_OP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_load_floatpair</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_load_float</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">LDF_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDFA_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDFCCLR_IMM_OP</span>:
	      <span class="k">case</span> <span class="n">LDFCNC_IMM_OP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_load_float</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="k">case</span> <span class="n">STF_OP</span>:
	      <span class="k">case</span> <span class="n">STF_IMM_OP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">emulate_store_float</span><span class="p">(</span><span class="n">ifa</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	      <span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * given today&#39;s architecture this case is not likely to happen because a</span>
<span class="cm">		 * memory access instruction (M) can never be in the last slot of a</span>
<span class="cm">		 * bundle. But let&#39;s keep it for now.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="n">DPRINT</span><span class="p">(</span><span class="s">&quot;ipsr-&gt;ri=%d iip=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ipsr</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span><span class="p">);</span>
  <span class="nl">done:</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>		<span class="cm">/* restore original address limit */</span>
	<span class="k">return</span><span class="p">;</span>

  <span class="nl">failure:</span>
	<span class="cm">/* something went wrong... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_handle_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;error during unaligned kernel access</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/* NOT_REACHED */</span>
	<span class="p">}</span>
  <span class="nl">force_sigbus:</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGBUS</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">BUS_ADRALN</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ifa</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_isr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">si</span><span class="p">.</span><span class="n">si_imm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
