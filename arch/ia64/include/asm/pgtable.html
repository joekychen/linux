<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_PGTABLE_H</span>
<span class="cp">#define _ASM_IA64_PGTABLE_H</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains the functions and defines necessary to modify and use</span>
<span class="cm"> * the IA-64 page table tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This hopefully works with any (fixed) IA-64 page-size, as defined</span>
<span class="cm"> * in &lt;asm/page.h&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2005 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;asm/mman.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>

<span class="cp">#define IA64_MAX_PHYS_BITS	50	</span><span class="cm">/* max. number of physical address bits (architected) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * First, define the various bits in a PTE.  Note that the PTE format</span>
<span class="cm"> * matches the VHPT short format, the firt doubleword of the VHPD long</span>
<span class="cm"> * format, and the first doubleword of the TLB insertion format.</span>
<span class="cm"> */</span>
<span class="cp">#define _PAGE_P_BIT		0</span>
<span class="cp">#define _PAGE_A_BIT		5</span>
<span class="cp">#define _PAGE_D_BIT		6</span>

<span class="cp">#define _PAGE_P			(1 &lt;&lt; _PAGE_P_BIT)	</span><span class="cm">/* page present bit */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_WB		(0x0 &lt;&lt;  2)	</span><span class="cm">/* write back memory attribute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_UC		(0x4 &lt;&lt;  2)	</span><span class="cm">/* uncacheable memory attribute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_UCE		(0x5 &lt;&lt;  2)	</span><span class="cm">/* UC exported attribute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_WC		(0x6 &lt;&lt;  2)	</span><span class="cm">/* write coalescing memory attribute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_NAT		(0x7 &lt;&lt;  2)	</span><span class="cm">/* not-a-thing attribute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_MA_MASK		(0x7 &lt;&lt;  2)</span>
<span class="cp">#define _PAGE_PL_0		(0 &lt;&lt;  7)	</span><span class="cm">/* privilege level 0 (kernel) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PL_1		(1 &lt;&lt;  7)	</span><span class="cm">/* privilege level 1 (unused) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PL_2		(2 &lt;&lt;  7)	</span><span class="cm">/* privilege level 2 (unused) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PL_3		(3 &lt;&lt;  7)	</span><span class="cm">/* privilege level 3 (user) */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PL_MASK		(3 &lt;&lt;  7)</span>
<span class="cp">#define _PAGE_AR_R		(0 &lt;&lt;  9)	</span><span class="cm">/* read only */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_RX		(1 &lt;&lt;  9)	</span><span class="cm">/* read &amp; execute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_RW		(2 &lt;&lt;  9)	</span><span class="cm">/* read &amp; write */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_RWX		(3 &lt;&lt;  9)	</span><span class="cm">/* read, write &amp; execute */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_R_RW		(4 &lt;&lt;  9)	</span><span class="cm">/* read / read &amp; write */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_RX_RWX		(5 &lt;&lt;  9)	</span><span class="cm">/* read &amp; exec / read, write &amp; exec */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_RWX_RW		(6 &lt;&lt;  9)	</span><span class="cm">/* read, write &amp; exec / read &amp; write */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_X_RX		(7 &lt;&lt;  9)	</span><span class="cm">/* exec &amp; promote / read &amp; exec */</span><span class="cp"></span>
<span class="cp">#define _PAGE_AR_MASK		(7 &lt;&lt;  9)</span>
<span class="cp">#define _PAGE_AR_SHIFT		9</span>
<span class="cp">#define _PAGE_A			(1 &lt;&lt; _PAGE_A_BIT)	</span><span class="cm">/* page accessed bit */</span><span class="cp"></span>
<span class="cp">#define _PAGE_D			(1 &lt;&lt; _PAGE_D_BIT)	</span><span class="cm">/* page dirty bit */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PPN_MASK		(((__IA64_UL(1) &lt;&lt; IA64_MAX_PHYS_BITS) - 1) &amp; ~0xfffUL)</span>
<span class="cp">#define _PAGE_ED		(__IA64_UL(1) &lt;&lt; 52)	</span><span class="cm">/* exception deferral */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PROTNONE		(__IA64_UL(1) &lt;&lt; 63)</span>

<span class="cm">/* Valid only for a PTE with the present bit cleared: */</span>
<span class="cp">#define _PAGE_FILE		(1 &lt;&lt; 1)		</span><span class="cm">/* see swap &amp; file pte remarks below */</span><span class="cp"></span>

<span class="cp">#define _PFN_MASK		_PAGE_PPN_MASK</span>
<span class="cm">/* Mask of bits which may be changed by pte_modify(); the odd bits are there for _PAGE_PROTNONE */</span>
<span class="cp">#define _PAGE_CHG_MASK	(_PAGE_P | _PAGE_PROTNONE | _PAGE_PL_MASK | _PAGE_AR_MASK | _PAGE_ED)</span>

<span class="cp">#define _PAGE_SIZE_4K	12</span>
<span class="cp">#define _PAGE_SIZE_8K	13</span>
<span class="cp">#define _PAGE_SIZE_16K	14</span>
<span class="cp">#define _PAGE_SIZE_64K	16</span>
<span class="cp">#define _PAGE_SIZE_256K	18</span>
<span class="cp">#define _PAGE_SIZE_1M	20</span>
<span class="cp">#define _PAGE_SIZE_4M	22</span>
<span class="cp">#define _PAGE_SIZE_16M	24</span>
<span class="cp">#define _PAGE_SIZE_64M	26</span>
<span class="cp">#define _PAGE_SIZE_256M	28</span>
<span class="cp">#define _PAGE_SIZE_1G	30</span>
<span class="cp">#define _PAGE_SIZE_4G	32</span>

<span class="cp">#define __ACCESS_BITS		_PAGE_ED | _PAGE_A | _PAGE_P | _PAGE_MA_WB</span>
<span class="cp">#define __DIRTY_BITS_NO_ED	_PAGE_A | _PAGE_P | _PAGE_D | _PAGE_MA_WB</span>
<span class="cp">#define __DIRTY_BITS		_PAGE_ED | __DIRTY_BITS_NO_ED</span>

<span class="cm">/*</span>
<span class="cm"> * How many pointers will a page table level hold expressed in shift</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTD_SHIFT	(PAGE_SHIFT-3)</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for fourth level:</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTE	(__IA64_UL(1) &lt;&lt; (PTRS_PER_PTD_SHIFT))</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for third level:</span>
<span class="cm"> *</span>
<span class="cm"> * PMD_SHIFT determines the size of the area a third-level page table</span>
<span class="cm"> * can map.</span>
<span class="cm"> */</span>
<span class="cp">#define PMD_SHIFT	(PAGE_SHIFT + (PTRS_PER_PTD_SHIFT))</span>
<span class="cp">#define PMD_SIZE	(1UL &lt;&lt; PMD_SHIFT)</span>
<span class="cp">#define PMD_MASK	(~(PMD_SIZE-1))</span>
<span class="cp">#define PTRS_PER_PMD	(1UL &lt;&lt; (PTRS_PER_PTD_SHIFT))</span>

<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cm">/*</span>
<span class="cm"> * Definitions for second level:</span>
<span class="cm"> *</span>
<span class="cm"> * PUD_SHIFT determines the size of the area a second-level page table</span>
<span class="cm"> * can map.</span>
<span class="cm"> */</span>
<span class="cp">#define PUD_SHIFT	(PMD_SHIFT + (PTRS_PER_PTD_SHIFT))</span>
<span class="cp">#define PUD_SIZE	(1UL &lt;&lt; PUD_SHIFT)</span>
<span class="cp">#define PUD_MASK	(~(PUD_SIZE-1))</span>
<span class="cp">#define PTRS_PER_PUD	(1UL &lt;&lt; (PTRS_PER_PTD_SHIFT))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for first level:</span>
<span class="cm"> *</span>
<span class="cm"> * PGDIR_SHIFT determines what a first-level page table entry can map.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cp">#define PGDIR_SHIFT		(PUD_SHIFT + (PTRS_PER_PTD_SHIFT))</span>
<span class="cp">#else</span>
<span class="cp">#define PGDIR_SHIFT		(PMD_SHIFT + (PTRS_PER_PTD_SHIFT))</span>
<span class="cp">#endif</span>
<span class="cp">#define PGDIR_SIZE		(__IA64_UL(1) &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK		(~(PGDIR_SIZE-1))</span>
<span class="cp">#define PTRS_PER_PGD_SHIFT	PTRS_PER_PTD_SHIFT</span>
<span class="cp">#define PTRS_PER_PGD		(1UL &lt;&lt; PTRS_PER_PGD_SHIFT)</span>
<span class="cp">#define USER_PTRS_PER_PGD	(5*PTRS_PER_PGD/8)	</span><span class="cm">/* regions 0-4 are user regions */</span><span class="cp"></span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>

<span class="cm">/*</span>
<span class="cm"> * All the normal masks have the &quot;page accessed&quot; bits on, as any time</span>
<span class="cm"> * they are used, the page is accessed. They are cleared only by the</span>
<span class="cm"> * page-out routines.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_A)</span>
<span class="cp">#define PAGE_SHARED	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RW)</span>
<span class="cp">#define PAGE_READONLY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)</span>
<span class="cp">#define PAGE_COPY	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_R)</span>
<span class="cp">#define PAGE_COPY_EXEC	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)</span>
<span class="cp">#define PAGE_GATE	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_X_RX)</span>
<span class="cp">#define PAGE_KERNEL	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX)</span>
<span class="cp">#define PAGE_KERNELRX	__pgprot(__ACCESS_BITS | _PAGE_PL_0 | _PAGE_AR_RX)</span>
<span class="cp">#define PAGE_KERNEL_UC	__pgprot(__DIRTY_BITS  | _PAGE_PL_0 | _PAGE_AR_RWX | \</span>
<span class="cp">				 _PAGE_MA_UC)</span>

<span class="cp"># ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for mm_struct */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Next come the mappings that determine how mmap() protection bits</span>
<span class="cm"> * (PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE) get implemented.  The</span>
<span class="cm"> * _P version gets used for a private shared memory segment, the _S</span>
<span class="cm"> * version gets used for a shared memory segment with MAP_SHARED on.</span>
<span class="cm"> * In a private shared memory segment, we do a copy-on-write if a task</span>
<span class="cm"> * attempts to write to the page.</span>
<span class="cm"> */</span>
	<span class="cm">/* xwr */</span>
<span class="cp">#define __P000	PAGE_NONE</span>
<span class="cp">#define __P001	PAGE_READONLY</span>
<span class="cp">#define __P010	PAGE_READONLY	</span><span class="cm">/* write to priv pg -&gt; copy &amp; make writable */</span><span class="cp"></span>
<span class="cp">#define __P011	PAGE_READONLY	</span><span class="cm">/* ditto */</span><span class="cp"></span>
<span class="cp">#define __P100	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_X_RX)</span>
<span class="cp">#define __P101	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)</span>
<span class="cp">#define __P110	PAGE_COPY_EXEC</span>
<span class="cp">#define __P111	PAGE_COPY_EXEC</span>

<span class="cp">#define __S000	PAGE_NONE</span>
<span class="cp">#define __S001	PAGE_READONLY</span>
<span class="cp">#define __S010	PAGE_SHARED	</span><span class="cm">/* we don&#39;t have (and don&#39;t need) write-only */</span><span class="cp"></span>
<span class="cp">#define __S011	PAGE_SHARED</span>
<span class="cp">#define __S100	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_X_RX)</span>
<span class="cp">#define __S101	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RX)</span>
<span class="cp">#define __S110	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RWX)</span>
<span class="cp">#define __S111	__pgprot(__ACCESS_BITS | _PAGE_PL_3 | _PAGE_AR_RWX)</span>

<span class="cp">#define pgd_ERROR(e)	printk(&quot;%s:%d: bad pgd %016lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>
<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cp">#define pud_ERROR(e)	printk(&quot;%s:%d: bad pud %016lx.\n&quot;, __FILE__, __LINE__, pud_val(e))</span>
<span class="cp">#endif</span>
<span class="cp">#define pmd_ERROR(e)	printk(&quot;%s:%d: bad pmd %016lx.\n&quot;, __FILE__, __LINE__, pmd_val(e))</span>
<span class="cp">#define pte_ERROR(e)	printk(&quot;%s:%d: bad pte %016lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>


<span class="cm">/*</span>
<span class="cm"> * Some definitions to translate between mem_map, PTEs, and page addresses:</span>
<span class="cm"> */</span>


<span class="cm">/* Quick test to see if ADDR is a (potentially) valid physical address. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">ia64_phys_addr_valid</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">unimpl_pa_mask</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kern_addr_valid(ADDR) tests if ADDR is pointing to valid kernel</span>
<span class="cm"> * memory.  For the return value to be meaningful, ADDR must be &gt;=</span>
<span class="cm"> * PAGE_OFFSET.  This operation can be relatively expensive (e.g.,</span>
<span class="cm"> * require a hash-, or multi-level tree-lookup or something of that</span>
<span class="cm"> * sort) but it guarantees to return TRUE only if accessing the page</span>
<span class="cm"> * at that address does not cause an error.  Note that there may be</span>
<span class="cm"> * addresses for which kern_addr_valid() returns FALSE even though an</span>
<span class="cm"> * access would not cause an error (e.g., this is typically true for</span>
<span class="cm"> * memory mapped I/O regions.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX Need to implement this for IA-64.</span>
<span class="cm"> */</span>
<span class="cp">#define kern_addr_valid(addr)	(1)</span>


<span class="cm">/*</span>
<span class="cm"> * Now come the defines and routines to manage and access the three-level</span>
<span class="cm"> * page table.</span>
<span class="cm"> */</span>


<span class="cp">#define VMALLOC_START		(RGN_BASE(RGN_GATE) + 0x200000000UL)</span>
<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
<span class="cp"># define VMALLOC_END_INIT	(RGN_BASE(RGN_GATE) + (1UL &lt;&lt; (4*PAGE_SHIFT - 9)))</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VMALLOC_END</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#if defined(CONFIG_SPARSEMEM) &amp;&amp; defined(CONFIG_SPARSEMEM_VMEMMAP)</span>
<span class="cm">/* SPARSEMEM_VMEMMAP uses half of vmalloc... */</span>
<span class="cp"># define VMALLOC_END		(RGN_BASE(RGN_GATE) + (1UL &lt;&lt; (4*PAGE_SHIFT - 10)))</span>
<span class="cp"># define vmemmap		((struct page *)VMALLOC_END)</span>
<span class="cp">#else</span>
<span class="cp"># define VMALLOC_END		(RGN_BASE(RGN_GATE) + (1UL &lt;&lt; (4*PAGE_SHIFT - 9)))</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* fs/proc/kcore.c */</span>
<span class="cp">#define	kc_vaddr_to_offset(v) ((v) - RGN_BASE(RGN_GATE))</span>
<span class="cp">#define	kc_offset_to_vaddr(o) ((o) + RGN_BASE(RGN_GATE))</span>

<span class="cp">#define RGN_MAP_SHIFT (PGDIR_SHIFT + PTRS_PER_PGD_SHIFT - 3)</span>
<span class="cp">#define RGN_MAP_LIMIT	((1UL &lt;&lt; RGN_MAP_SHIFT) - PAGE_SIZE)	</span><span class="cm">/* per region addr limit */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert page frame number (pfn) and a protection value to a page</span>
<span class="cm"> * table entry (pte).</span>
<span class="cm"> */</span>
<span class="cp">#define pfn_pte(pfn, pgprot) \</span>
<span class="cp">({ pte_t __pte; pte_val(__pte) = ((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot); __pte; })</span>

<span class="cm">/* Extract pfn from pte.  */</span>
<span class="cp">#define pte_pfn(_pte)		((pte_val(_pte) &amp; _PFN_MASK) &gt;&gt; PAGE_SHIFT)</span>

<span class="cp">#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))</span>

<span class="cm">/* This takes a physical page address that is used by the remapping functions */</span>
<span class="cp">#define mk_pte_phys(physpage, pgprot) \</span>
<span class="cp">({ pte_t __pte; pte_val(__pte) = physpage + pgprot_val(pgprot); __pte; })</span>

<span class="cp">#define pte_modify(_pte, newprot) \</span>
<span class="cp">	(__pte((pte_val(_pte) &amp; ~_PAGE_CHG_MASK) | (pgprot_val(newprot) &amp; _PAGE_CHG_MASK)))</span>

<span class="cp">#define pte_none(pte) 			(!pte_val(pte))</span>
<span class="cp">#define pte_present(pte)		(pte_val(pte) &amp; (_PAGE_P | _PAGE_PROTNONE))</span>
<span class="cp">#define pte_clear(mm,addr,pte)		(pte_val(*(pte)) = 0UL)</span>
<span class="cm">/* pte_page() returns the &quot;struct page *&quot; corresponding to the PTE: */</span>
<span class="cp">#define pte_page(pte)			virt_to_page(((pte_val(pte) &amp; _PFN_MASK) + PAGE_OFFSET))</span>

<span class="cp">#define pmd_none(pmd)			(!pmd_val(pmd))</span>
<span class="cp">#define pmd_bad(pmd)			(!ia64_phys_addr_valid(pmd_val(pmd)))</span>
<span class="cp">#define pmd_present(pmd)		(pmd_val(pmd) != 0UL)</span>
<span class="cp">#define pmd_clear(pmdp)			(pmd_val(*(pmdp)) = 0UL)</span>
<span class="cp">#define pmd_page_vaddr(pmd)		((unsigned long) __va(pmd_val(pmd) &amp; _PFN_MASK))</span>
<span class="cp">#define pmd_page(pmd)			virt_to_page((pmd_val(pmd) + PAGE_OFFSET))</span>

<span class="cp">#define pud_none(pud)			(!pud_val(pud))</span>
<span class="cp">#define pud_bad(pud)			(!ia64_phys_addr_valid(pud_val(pud)))</span>
<span class="cp">#define pud_present(pud)		(pud_val(pud) != 0UL)</span>
<span class="cp">#define pud_clear(pudp)			(pud_val(*(pudp)) = 0UL)</span>
<span class="cp">#define pud_page_vaddr(pud)		((unsigned long) __va(pud_val(pud) &amp; _PFN_MASK))</span>
<span class="cp">#define pud_page(pud)			virt_to_page((pud_val(pud) + PAGE_OFFSET))</span>

<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cp">#define pgd_none(pgd)			(!pgd_val(pgd))</span>
<span class="cp">#define pgd_bad(pgd)			(!ia64_phys_addr_valid(pgd_val(pgd)))</span>
<span class="cp">#define pgd_present(pgd)		(pgd_val(pgd) != 0UL)</span>
<span class="cp">#define pgd_clear(pgdp)			(pgd_val(*(pgdp)) = 0UL)</span>
<span class="cp">#define pgd_page_vaddr(pgd)		((unsigned long) __va(pgd_val(pgd) &amp; _PFN_MASK))</span>
<span class="cp">#define pgd_page(pgd)			virt_to_page((pgd_val(pgd) + PAGE_OFFSET))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The following have defined behavior only work if pte_present() is true.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_write(pte)	((unsigned) (((pte_val(pte) &amp; _PAGE_AR_MASK) &gt;&gt; _PAGE_AR_SHIFT) - 2) &lt;= 4)</span>
<span class="cp">#define pte_exec(pte)		((pte_val(pte) &amp; _PAGE_AR_RX) != 0)</span>
<span class="cp">#define pte_dirty(pte)		((pte_val(pte) &amp; _PAGE_D) != 0)</span>
<span class="cp">#define pte_young(pte)		((pte_val(pte) &amp; _PAGE_A) != 0)</span>
<span class="cp">#define pte_file(pte)		((pte_val(pte) &amp; _PAGE_FILE) != 0)</span>
<span class="cp">#define pte_special(pte)	0</span>

<span class="cm">/*</span>
<span class="cm"> * Note: we convert AR_RWX to AR_RX and AR_RW to AR_R by clearing the 2nd bit in the</span>
<span class="cm"> * access rights:</span>
<span class="cm"> */</span>
<span class="cp">#define pte_wrprotect(pte)	(__pte(pte_val(pte) &amp; ~_PAGE_AR_RW))</span>
<span class="cp">#define pte_mkwrite(pte)	(__pte(pte_val(pte) | _PAGE_AR_RW))</span>
<span class="cp">#define pte_mkold(pte)		(__pte(pte_val(pte) &amp; ~_PAGE_A))</span>
<span class="cp">#define pte_mkyoung(pte)	(__pte(pte_val(pte) | _PAGE_A))</span>
<span class="cp">#define pte_mkclean(pte)	(__pte(pte_val(pte) &amp; ~_PAGE_D))</span>
<span class="cp">#define pte_mkdirty(pte)	(__pte(pte_val(pte) | _PAGE_D))</span>
<span class="cp">#define pte_mkhuge(pte)		(__pte(pte_val(pte)))</span>
<span class="cp">#define pte_mkspecial(pte)	(pte)</span>

<span class="cm">/*</span>
<span class="cm"> * Because ia64&#39;s Icache and Dcache is not coherent (on a cpu), we need to</span>
<span class="cm"> * sync icache and dcache when we insert *new* executable page.</span>
<span class="cm"> *  __ia64_sync_icache_dcache() check Pg_arch_1 bit and flush icache</span>
<span class="cm"> * if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> *  set_pte() is also called by the kernel, but we can expect that the kernel</span>
<span class="cm"> *  flushes icache explicitly if necessary.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_present_exec_user(pte)\</span>
<span class="cp">	((pte_val(pte) &amp; (_PAGE_P | _PAGE_PL_MASK | _PAGE_AR_RX)) == \</span>
<span class="cp">		(_PAGE_P | _PAGE_PL_3 | _PAGE_AR_RX))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ia64_sync_icache_dcache</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pteval</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* page is present &amp;&amp; page is user  &amp;&amp; page is executable</span>
<span class="cm">	 * &amp;&amp; (page swapin or new page or page migraton</span>
<span class="cm">	 *	|| copy_on_write with page copying.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_present_exec_user</span><span class="p">(</span><span class="n">pteval</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="n">pteval</span><span class="p">)))</span>
		<span class="cm">/* load_module() calles flush_icache_range() explicitly*/</span>
		<span class="n">__ia64_sync_icache_dcache</span><span class="p">(</span><span class="n">pteval</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pteval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)</span>

<span class="cm">/*</span>
<span class="cm"> * Make page protection values cacheable, uncacheable, or write-</span>
<span class="cm"> * combining.  Note that &quot;protection&quot; is really a misnomer here as the</span>
<span class="cm"> * protection value contains the memory attribute bits, dirty bits, and</span>
<span class="cm"> * various other bits as well.</span>
<span class="cm"> */</span>
<span class="cp">#define pgprot_cacheable(prot)		__pgprot((pgprot_val(prot) &amp; ~_PAGE_MA_MASK) | _PAGE_MA_WB)</span>
<span class="cp">#define pgprot_noncached(prot)		__pgprot((pgprot_val(prot) &amp; ~_PAGE_MA_MASK) | _PAGE_MA_UC)</span>
<span class="cp">#define pgprot_writecombine(prot)	__pgprot((pgprot_val(prot) &amp; ~_PAGE_MA_MASK) | _PAGE_MA_WC)</span>

<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pgprot_t</span> <span class="n">phys_mem_access_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">vma_prot</span><span class="p">);</span>
<span class="cp">#define __HAVE_PHYS_MEM_ACCESS_PROT</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">pgd_index</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">region</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">61</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l1index</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PGDIR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">PTRS_PER_PGD</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">region</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">6</span><span class="p">))</span> <span class="o">|</span> <span class="n">l1index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The offset in the 1-level directory is given by the 3 region bits</span>
<span class="cm">   (61..63) and the level-1 bits.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgd_t</span><span class="o">*</span>
<span class="nf">pgd_offset</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* In the kernel&#39;s mapped region we completely ignore the region number</span>
<span class="cm">   (since we know it&#39;s in region number 5). */</span>
<span class="cp">#define pgd_offset_k(addr) \</span>
<span class="cp">	(init_mm.pgd + (((addr) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1)))</span>

<span class="cm">/* Look up a pgd entry in the gate area.  On IA-64, the gate-area</span>
<span class="cm">   resides in the kernel-mapped segment, hence we use pgd_offset_k()</span>
<span class="cm">   here.  */</span>
<span class="cp">#define pgd_offset_gate(mm, addr)	pgd_offset_k(addr)</span>

<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cm">/* Find an entry in the second-level page table.. */</span>
<span class="cp">#define pud_offset(dir,addr) \</span>
<span class="cp">	((pud_t *) pgd_page_vaddr(*(dir)) + (((addr) &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD - 1)))</span>
<span class="cp">#endif</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="cp">#define pmd_offset(dir,addr) \</span>
<span class="cp">	((pmd_t *) pud_page_vaddr(*(dir)) + (((addr) &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD - 1)))</span>

<span class="cm">/*</span>
<span class="cm"> * Find an entry in the third-level page table.  This looks more complicated than it</span>
<span class="cm"> * should be because some platforms place page tables in high memory.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_index(addr)	 	(((addr) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>
<span class="cp">#define pte_offset_kernel(dir,addr)	((pte_t *) pmd_page_vaddr(*(dir)) + pte_index(addr))</span>
<span class="cp">#define pte_offset_map(dir,addr)	pte_offset_kernel(dir, addr)</span>
<span class="cp">#define pte_unmap(pte)			do { } while (0)</span>

<span class="cm">/* atomic versions of the some PTE manipulations: */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ptep_test_and_clear_young</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_young</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">_PAGE_A_BIT</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_young</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span>
<span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">(</span><span class="n">xchg</span><span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptep</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">__pte</span> <span class="p">(</span><span class="n">old</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">pte_t</span> <span class="n">old_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">old_pte</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">pte_same</span> <span class="p">(</span><span class="n">pte_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define update_mmu_cache(vma, address, ptep) do { } while (0)</span>

<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">PTRS_PER_PGD</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Note: The macros below rely on the fact that MAX_SWAPFILES_SHIFT &lt;= number of</span>
<span class="cm"> *	 bits in the swap-type field of the swap pte.  It would be nice to</span>
<span class="cm"> *	 enforce that, but we can&#39;t easily include &lt;linux/swap.h&gt; here.</span>
<span class="cm"> *	 (Of course, better still would be to define MAX_SWAPFILES_SHIFT here...).</span>
<span class="cm"> *</span>
<span class="cm"> * Format of swap pte:</span>
<span class="cm"> *	bit   0   : present bit (must be zero)</span>
<span class="cm"> *	bit   1   : _PAGE_FILE (must be zero)</span>
<span class="cm"> *	bits  2- 8: swap-type</span>
<span class="cm"> *	bits  9-62: swap offset</span>
<span class="cm"> *	bit  63   : _PAGE_PROTNONE bit</span>
<span class="cm"> *</span>
<span class="cm"> * Format of file pte:</span>
<span class="cm"> *	bit   0   : present bit (must be zero)</span>
<span class="cm"> *	bit   1   : _PAGE_FILE (must be one)</span>
<span class="cm"> *	bits  2-62: file_offset/PAGE_SIZE</span>
<span class="cm"> *	bit  63   : _PAGE_PROTNONE bit</span>
<span class="cm"> */</span>
<span class="cp">#define __swp_type(entry)		(((entry).val &gt;&gt; 2) &amp; 0x7f)</span>
<span class="cp">#define __swp_offset(entry)		(((entry).val &lt;&lt; 1) &gt;&gt; 10)</span>
<span class="cp">#define __swp_entry(type,offset)	((swp_entry_t) { ((type) &lt;&lt; 2) | ((long) (offset) &lt;&lt; 9) })</span>
<span class="cp">#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)		((pte_t) { (x).val })</span>

<span class="cp">#define PTE_FILE_MAX_BITS		61</span>
<span class="cp">#define pte_to_pgoff(pte)		((pte_val(pte) &lt;&lt; 1) &gt;&gt; 3)</span>
<span class="cp">#define pgoff_to_pte(off)		((pte_t) { ((off) &lt;&lt; 2) | _PAGE_FILE })</span>

<span class="cp">#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\</span>
<span class="cp">		remap_pfn_range(vma, vaddr, pfn, size, prot)</span>

<span class="cm">/*</span>
<span class="cm"> * ZERO_PAGE is a global shared page that is always zero: used</span>
<span class="cm"> * for zero-mapped memory areas etc..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">zero_page_memmap_ptr</span><span class="p">;</span>
<span class="cp">#define ZERO_PAGE(vaddr) (zero_page_memmap_ptr)</span>

<span class="cm">/* We provide our own get_unmapped_area to cope with VA holes for userland */</span>
<span class="cp">#define HAVE_ARCH_UNMAPPED_AREA</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp">#define HUGETLB_PGDIR_SHIFT	(HPAGE_SHIFT + 2*(PAGE_SHIFT-3))</span>
<span class="cp">#define HUGETLB_PGDIR_SIZE	(__IA64_UL(1) &lt;&lt; HUGETLB_PGDIR_SHIFT)</span>
<span class="cp">#define HUGETLB_PGDIR_MASK	(~(HUGETLB_PGDIR_SIZE-1))</span>
<span class="cp">#endif</span>


<span class="cp">#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="cm">/*</span>
<span class="cm"> * Update PTEP with ENTRY, which is guaranteed to be a less</span>
<span class="cm"> * restrictive PTE.  That is, ENTRY may have the ACCESSED, DIRTY, and</span>
<span class="cm"> * WRITABLE bits turned on, when the value at PTEP did not.  The</span>
<span class="cm"> * WRITABLE bit may only be turned if SAFELY_WRITABLE is TRUE.</span>
<span class="cm"> *</span>
<span class="cm"> * SAFELY_WRITABLE is TRUE if we can update the value at PTEP without</span>
<span class="cm"> * having to worry about races.  On SMP machines, there are only two</span>
<span class="cm"> * cases where this is true:</span>
<span class="cm"> *</span>
<span class="cm"> *	(1) *PTEP has the PRESENT bit turned OFF</span>
<span class="cm"> *	(2) ENTRY has the DIRTY bit turned ON</span>
<span class="cm"> *</span>
<span class="cm"> * On ia64, we could implement this routine with a cmpxchg()-loop</span>
<span class="cm"> * which ORs in the _PAGE_A/_PAGE_D bit if they&#39;re set in ENTRY.</span>
<span class="cm"> * However, like on x86, we can get a more streamlined version by</span>
<span class="cm"> * observing that it is OK to drop ACCESSED bit updates when</span>
<span class="cm"> * SAFELY_WRITABLE is FALSE.  Besides being rare, all that would do is</span>
<span class="cm"> * result in an extra Access-bit fault, which would then turn on the</span>
<span class="cm"> * ACCESSED bit in the low-level fault handler (iaccess_bit or</span>
<span class="cm"> * daccess_bit in ivt.S).</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp"># define ptep_set_access_flags(__vma, __addr, __ptep, __entry, __safely_writable) \</span>
<span class="cp">({									\</span>
<span class="cp">	int __changed = !pte_same(*(__ptep), __entry);			\</span>
<span class="cp">	if (__changed &amp;&amp; __safely_writable) {				\</span>
<span class="cp">		set_pte(__ptep, __entry);				\</span>
<span class="cp">		flush_tlb_page(__vma, __addr);				\</span>
<span class="cp">	}								\</span>
<span class="cp">	__changed;							\</span>
<span class="cp">})</span>
<span class="cp">#else</span>
<span class="cp"># define ptep_set_access_flags(__vma, __addr, __ptep, __entry, __safely_writable) \</span>
<span class="cp">({									\</span>
<span class="cp">	int __changed = !pte_same(*(__ptep), __entry);			\</span>
<span class="cp">	if (__changed) {						\</span>
<span class="cp">		set_pte_at((__vma)-&gt;vm_mm, (__addr), __ptep, __entry);	\</span>
<span class="cp">		flush_tlb_page(__vma, __addr);				\</span>
<span class="cp">	}								\</span>
<span class="cp">	__changed;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#  ifdef CONFIG_VIRTUAL_MEM_MAP</span>
  <span class="cm">/* arch mem_map init routine is needed due to holes in a virtual mem_map */</span>
<span class="cp">#   define __HAVE_ARCH_MEMMAP_INIT</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="n">memmap_init</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">);</span>
<span class="cp">#  endif </span><span class="cm">/* CONFIG_VIRTUAL_MEM_MAP */</span><span class="cp"></span>
<span class="cp"># endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Identity-mapped regions use a large page size.  We&#39;ll call such large pages</span>
<span class="cm"> * &quot;granules&quot;.  If you can think of a better name that&#39;s unambiguous, let me</span>
<span class="cm"> * know...</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_IA64_GRANULE_64MB)</span>
<span class="cp"># define IA64_GRANULE_SHIFT	_PAGE_SIZE_64M</span>
<span class="cp">#elif defined(CONFIG_IA64_GRANULE_16MB)</span>
<span class="cp"># define IA64_GRANULE_SHIFT	_PAGE_SIZE_16M</span>
<span class="cp">#endif</span>
<span class="cp">#define IA64_GRANULE_SIZE	(1 &lt;&lt; IA64_GRANULE_SHIFT)</span>
<span class="cm">/*</span>
<span class="cm"> * log2() of the page size we use to map the kernel image (IA64_TR_KERNEL):</span>
<span class="cm"> */</span>
<span class="cp">#define KERNEL_TR_PAGE_SHIFT	_PAGE_SIZE_64M</span>
<span class="cp">#define KERNEL_TR_PAGE_SIZE	(1 &lt;&lt; KERNEL_TR_PAGE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * No page table caches to initialise</span>
<span class="cm"> */</span>
<span class="cp">#define pgtable_cache_init()	do { } while (0)</span>

<span class="cm">/* These tell get_user_pages() that the first gate page is accessible from user-level.  */</span>
<span class="cp">#define FIXADDR_USER_START	GATE_ADDR</span>
<span class="cp">#ifdef HAVE_BUGGY_SEGREL</span>
<span class="cp"># define FIXADDR_USER_END	(GATE_ADDR + 2*PAGE_SIZE)</span>
<span class="cp">#else</span>
<span class="cp"># define FIXADDR_USER_END	(GATE_ADDR + 2*PERCPU_PAGE_SIZE)</span>
<span class="cp">#endif</span>

<span class="cp">#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="cp">#define __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="cp">#define __HAVE_ARCH_PTE_SAME</span>
<span class="cp">#define __HAVE_ARCH_PGD_OFFSET_GATE</span>


<span class="cp">#ifndef CONFIG_PGTABLE_4</span>
<span class="cp">#include &lt;asm-generic/pgtable-nopud.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
