<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › paravirt_privop.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>paravirt_privop.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> * Copyright (c) 2008 Isaku Yamahata &lt;yamahata at valinux co jp&gt;</span>
<span class="cm"> *                    VA Linux Systems Japan K.K.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_IA64_PARAVIRT_PRIVOP_H</span>
<span class="cp">#define _ASM_IA64_PARAVIRT_PRIVOP_H</span>

<span class="cp">#ifdef CONFIG_PARAVIRT</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/kregs.h&gt; </span><span class="cm">/* for IA64_PSR_I */</span><span class="cp"></span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * replacement of intrinsics operations.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pv_cpu_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">thash</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_cpuid</span><span class="p">)(</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_pmd</span><span class="p">)(</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">getreg</span><span class="p">)(</span><span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setreg</span><span class="p">)(</span><span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptcga</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rr</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rr</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_rr0_to_rr4</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val1</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val3</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val4</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ssm_i</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rsm_i</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_psr_i</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">intrin_local_irq_restore</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pv_cpu_ops</span> <span class="n">pv_cpu_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_native_setreg_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">regnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_native_getreg_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">regnum</span><span class="p">);</span>

<span class="cm">/************************************************/</span>
<span class="cm">/* Instructions paravirtualized for performance */</span>
<span class="cm">/************************************************/</span>

<span class="cp">#ifndef ASM_SUPPORTED</span>
<span class="cp">#define paravirt_ssm_i()	pv_cpu_ops.ssm_i()</span>
<span class="cp">#define paravirt_rsm_i()	pv_cpu_ops.rsm_i()</span>
<span class="cp">#define __paravirt_getreg()	pv_cpu_ops.getreg()</span>
<span class="cp">#endif</span>

<span class="cm">/* mask for ia64_native_ssm/rsm() must be constant.(&quot;i&quot; constraing).</span>
<span class="cm"> * static inline function doesn&#39;t satisfy it. */</span>
<span class="cp">#define paravirt_ssm(mask)			\</span>
<span class="cp">	do {					\</span>
<span class="cp">		if ((mask) == IA64_PSR_I)	\</span>
<span class="cp">			paravirt_ssm_i();	\</span>
<span class="cp">		else				\</span>
<span class="cp">			ia64_native_ssm(mask);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define paravirt_rsm(mask)			\</span>
<span class="cp">	do {					\</span>
<span class="cp">		if ((mask) == IA64_PSR_I)	\</span>
<span class="cp">			paravirt_rsm_i();	\</span>
<span class="cp">		else				\</span>
<span class="cp">			ia64_native_rsm(mask);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/* returned ip value should be the one in the caller,</span>
<span class="cm"> * not in __paravirt_getreg() */</span>
<span class="cp">#define paravirt_getreg(reg)					\</span>
<span class="cp">	({							\</span>
<span class="cp">		unsigned long res;				\</span>
<span class="cp">		if ((reg) == _IA64_REG_IP)			\</span>
<span class="cp">			res = ia64_native_getreg(_IA64_REG_IP); \</span>
<span class="cp">		else						\</span>
<span class="cp">			res = __paravirt_getreg(reg);		\</span>
<span class="cp">		res;						\</span>
<span class="cp">	})</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * replacement of hand written assembly codes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pv_cpu_asm_switch</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">switch_to</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leave_syscall</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">work_processed_syscall</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leave_kernel</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">paravirt_cpu_asm_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pv_cpu_asm_switch</span> <span class="o">*</span><span class="n">cpu_asm_switch</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define IA64_PARAVIRT_ASM_FUNC(name)	paravirt_ ## name</span>

<span class="cp">#else</span>

<span class="cm">/* fallback for native case */</span>
<span class="cp">#define IA64_PARAVIRT_ASM_FUNC(name)	ia64_native_ ## name</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PARAVIRT */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_PARAVIRT) &amp;&amp; defined(ASM_SUPPORTED)</span>
<span class="cp">#define paravirt_dv_serialize_data()	ia64_dv_serialize_data()</span>
<span class="cp">#else</span>
<span class="cp">#define paravirt_dv_serialize_data()	</span><span class="cm">/* nothing */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* these routines utilize privilege-sensitive or performance-sensitive</span>
<span class="cm"> * privileged instructions so the code must be replaced with</span>
<span class="cm"> * paravirtualized versions */</span>
<span class="cp">#define ia64_switch_to			IA64_PARAVIRT_ASM_FUNC(switch_to)</span>
<span class="cp">#define ia64_leave_syscall		IA64_PARAVIRT_ASM_FUNC(leave_syscall)</span>
<span class="cp">#define ia64_work_processed_syscall	\</span>
<span class="cp">	IA64_PARAVIRT_ASM_FUNC(work_processed_syscall)</span>
<span class="cp">#define ia64_leave_kernel		IA64_PARAVIRT_ASM_FUNC(leave_kernel)</span>


<span class="cp">#if defined(CONFIG_PARAVIRT)</span>
<span class="cm">/******************************************************************************</span>
<span class="cm"> * binary patching infrastructure</span>
<span class="cm"> */</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_FC				1</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_THASH			2</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_GET_CPUID			3</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_GET_PMD			4</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_PTCGA			5</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_GET_RR			6</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_SET_RR			7</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_SET_RR0_TO_RR4		8</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_SSM_I			9</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_RSM_I			10</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_GET_PSR_I			11</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_INTRIN_LOCAL_IRQ_RESTORE	12</span>

<span class="cm">/* PARAVIRT_PATY_TYPE_[GS]ETREG + _IA64_REG_xxx */</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_GETREG			0x10000000</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_SETREG			0x20000000</span>

<span class="cm">/*</span>
<span class="cm"> * struct task_struct* (*ia64_switch_to)(void* next_task);</span>
<span class="cm"> * void *ia64_leave_syscall;</span>
<span class="cm"> * void *ia64_work_processed_syscall</span>
<span class="cm"> * void *ia64_leave_kernel;</span>
<span class="cm"> */</span>

<span class="cp">#define PARAVIRT_PATCH_TYPE_BR_START			0x30000000</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_BR_SWITCH_TO		\</span>
<span class="cp">	(PARAVIRT_PATCH_TYPE_BR_START + 0)</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_BR_LEAVE_SYSCALL		\</span>
<span class="cp">	(PARAVIRT_PATCH_TYPE_BR_START + 1)</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_BR_WORK_PROCESSED_SYSCALL	\</span>
<span class="cp">	(PARAVIRT_PATCH_TYPE_BR_START + 2)</span>
<span class="cp">#define PARAVIRT_PATCH_TYPE_BR_LEAVE_KERNEL		\</span>
<span class="cp">	(PARAVIRT_PATCH_TYPE_BR_START + 3)</span>

<span class="cp">#ifdef ASM_SUPPORTED</span>
<span class="cp">#include &lt;asm/paravirt_patch.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * pv_cpu_ops calling stub.</span>
<span class="cm"> * normal function call convension can&#39;t be written by gcc</span>
<span class="cm"> * inline assembly.</span>
<span class="cm"> *</span>
<span class="cm"> * from the caller&#39;s point of view,</span>
<span class="cm"> * the following registers will be clobbered.</span>
<span class="cm"> * r2, r3</span>
<span class="cm"> * r8-r15</span>
<span class="cm"> * r16, r17</span>
<span class="cm"> * b6, b7</span>
<span class="cm"> * p6-p15</span>
<span class="cm"> * ar.ccv</span>
<span class="cm"> *</span>
<span class="cm"> * from the callee&#39;s point of view ,</span>
<span class="cm"> * the following registers can be used.</span>
<span class="cm"> * r2, r3: scratch</span>
<span class="cm"> * r8: scratch, input argument0 and return value</span>
<span class="cm"> * r0-r15: scratch, input argument1-5</span>
<span class="cm"> * b6: return pointer</span>
<span class="cm"> * b7: scratch</span>
<span class="cm"> * p6-p15: scratch</span>
<span class="cm"> * ar.ccv: scratch</span>
<span class="cm"> *</span>
<span class="cm"> * other registers must not be changed. especially</span>
<span class="cm"> * b0: rp: preserved. gcc ignores b0 in clobbered register.</span>
<span class="cm"> * r16: saved gp</span>
<span class="cm"> */</span>
<span class="cm">/* 5 bundles */</span>
<span class="cp">#define __PARAVIRT_BR							\</span>
<span class="cp">	&quot;;;\n&quot;								\</span>
<span class="cp">	&quot;{ .mlx\n&quot;							\</span>
<span class="cp">	&quot;nop 0\n&quot;							\</span>
<span class="cp">	&quot;movl r2 = %[op_addr]\n&quot;</span><span class="cm">/* get function pointer address */</span><span class="cp">	\</span>
<span class="cp">	&quot;;;\n&quot;								\</span>
<span class="cp">	&quot;}\n&quot;								\</span>
<span class="cp">	&quot;1:\n&quot;								\</span>
<span class="cp">	&quot;{ .mii\n&quot;							\</span>
<span class="cp">	&quot;ld8 r2 = [r2]\n&quot;	</span><span class="cm">/* load function descriptor address */</span><span class="cp">	\</span>
<span class="cp">	&quot;mov r17 = ip\n&quot;	</span><span class="cm">/* get ip to calc return address */</span><span class="cp">	\</span>
<span class="cp">	&quot;mov r16 = gp\n&quot;	</span><span class="cm">/* save gp */</span><span class="cp">				\</span>
<span class="cp">	&quot;;;\n&quot;								\</span>
<span class="cp">	&quot;}\n&quot;								\</span>
<span class="cp">	&quot;{ .mii\n&quot;							\</span>
<span class="cp">	&quot;ld8 r3 = [r2], 8\n&quot;	</span><span class="cm">/* load entry address */</span><span class="cp">		\</span>
<span class="cp">	&quot;adds r17 =  1f - 1b, r17\n&quot;	</span><span class="cm">/* calculate return address */</span><span class="cp">	\</span>
<span class="cp">	&quot;;;\n&quot;								\</span>
<span class="cp">	&quot;mov b7 = r3\n&quot;		</span><span class="cm">/* set entry address */</span><span class="cp">			\</span>
<span class="cp">	&quot;}\n&quot;								\</span>
<span class="cp">	&quot;{ .mib\n&quot;							\</span>
<span class="cp">	&quot;ld8 gp = [r2]\n&quot;	</span><span class="cm">/* load gp value */</span><span class="cp">			\</span>
<span class="cp">	&quot;mov b6 = r17\n&quot;	</span><span class="cm">/* set return address */</span><span class="cp">		\</span>
<span class="cp">	&quot;br.cond.sptk.few b7\n&quot;	</span><span class="cm">/* intrinsics are very short isns */</span><span class="cp">	\</span>
<span class="cp">	&quot;}\n&quot;								\</span>
<span class="cp">	&quot;1:\n&quot;								\</span>
<span class="cp">	&quot;{ .mii\n&quot;							\</span>
<span class="cp">	&quot;mov gp = r16\n&quot;	</span><span class="cm">/* restore gp value */</span><span class="cp">			\</span>
<span class="cp">	&quot;nop 0\n&quot;							\</span>
<span class="cp">	&quot;nop 0\n&quot;							\</span>
<span class="cp">	&quot;;;\n&quot;								\</span>
<span class="cp">	&quot;}\n&quot;</span>

<span class="cp">#define PARAVIRT_OP(op)				\</span>
<span class="cp">	[op_addr] &quot;i&quot;(&amp;pv_cpu_ops.op)</span>

<span class="cp">#define PARAVIRT_TYPE(type)			\</span>
<span class="cp">	PARAVIRT_PATCH_TYPE_ ## type</span>

<span class="cp">#define PARAVIRT_REG_CLOBBERS0					\</span>
<span class="cp">	&quot;r2&quot;, &quot;r3&quot;, </span><span class="cm">/*&quot;r8&quot;,*/</span><span class="cp"> &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;, &quot;r14&quot;,	\</span>
<span class="cp">		&quot;r15&quot;, &quot;r16&quot;, &quot;r17&quot;</span>

<span class="cp">#define PARAVIRT_REG_CLOBBERS1					\</span>
<span class="cp">	&quot;r2&quot;,&quot;r3&quot;, </span><span class="cm">/*&quot;r8&quot;,*/</span><span class="cp"> &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;, &quot;r14&quot;,		\</span>
<span class="cp">		&quot;r15&quot;, &quot;r16&quot;, &quot;r17&quot;</span>

<span class="cp">#define PARAVIRT_REG_CLOBBERS2					\</span>
<span class="cp">	&quot;r2&quot;, &quot;r3&quot;, </span><span class="cm">/*&quot;r8&quot;, &quot;r9&quot;,*/</span><span class="cp"> &quot;r10&quot;, &quot;r11&quot;, &quot;r14&quot;,	\</span>
<span class="cp">		&quot;r15&quot;, &quot;r16&quot;, &quot;r17&quot;</span>

<span class="cp">#define PARAVIRT_REG_CLOBBERS5					\</span>
<span class="cp">	&quot;r2&quot;, &quot;r3&quot;, </span><span class="cm">/*&quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;, &quot;r14&quot;,*/</span><span class="cp">	\</span>
<span class="cp">		&quot;r15&quot;, &quot;r16&quot;, &quot;r17&quot;</span>

<span class="cp">#define PARAVIRT_BR_CLOBBERS			\</span>
<span class="cp">	&quot;b6&quot;, &quot;b7&quot;</span>

<span class="cp">#define PARAVIRT_PR_CLOBBERS						\</span>
<span class="cp">	&quot;p6&quot;, &quot;p7&quot;, &quot;p8&quot;, &quot;p9&quot;, &quot;p10&quot;, &quot;p11&quot;, &quot;p12&quot;, &quot;p13&quot;, &quot;p14&quot;, &quot;p15&quot;</span>

<span class="cp">#define PARAVIRT_AR_CLOBBERS			\</span>
<span class="cp">	&quot;ar.ccv&quot;</span>

<span class="cp">#define PARAVIRT_CLOBBERS0			\</span>
<span class="cp">		PARAVIRT_REG_CLOBBERS0,		\</span>
<span class="cp">		PARAVIRT_BR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_PR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_AR_CLOBBERS,		\</span>
<span class="cp">		&quot;memory&quot;</span>

<span class="cp">#define PARAVIRT_CLOBBERS1			\</span>
<span class="cp">		PARAVIRT_REG_CLOBBERS1,		\</span>
<span class="cp">		PARAVIRT_BR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_PR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_AR_CLOBBERS,		\</span>
<span class="cp">		&quot;memory&quot;</span>

<span class="cp">#define PARAVIRT_CLOBBERS2			\</span>
<span class="cp">		PARAVIRT_REG_CLOBBERS2,		\</span>
<span class="cp">		PARAVIRT_BR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_PR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_AR_CLOBBERS,		\</span>
<span class="cp">		&quot;memory&quot;</span>

<span class="cp">#define PARAVIRT_CLOBBERS5			\</span>
<span class="cp">		PARAVIRT_REG_CLOBBERS5,		\</span>
<span class="cp">		PARAVIRT_BR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_PR_CLOBBERS,		\</span>
<span class="cp">		PARAVIRT_AR_CLOBBERS,		\</span>
<span class="cp">		&quot;memory&quot;</span>

<span class="cp">#define PARAVIRT_BR0(op, type)					\</span>
<span class="cp">	register unsigned long ia64_clobber asm (&quot;r8&quot;);		\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">					  PARAVIRT_TYPE(type))	\</span>
<span class="cp">		      :	&quot;=r&quot;(ia64_clobber)			\</span>
<span class="cp">		      : PARAVIRT_OP(op)				\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS0)</span>

<span class="cp">#define PARAVIRT_BR0_RET(op, type)				\</span>
<span class="cp">	register unsigned long ia64_intri_res asm (&quot;r8&quot;);	\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">					  PARAVIRT_TYPE(type))	\</span>
<span class="cp">		      : &quot;=r&quot;(ia64_intri_res)			\</span>
<span class="cp">		      : PARAVIRT_OP(op)				\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS0)</span>

<span class="cp">#define PARAVIRT_BR1(op, type, arg1)				\</span>
<span class="cp">	register unsigned long __##arg1 asm (&quot;r8&quot;) = arg1;	\</span>
<span class="cp">	register unsigned long ia64_clobber asm (&quot;r8&quot;);		\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">					  PARAVIRT_TYPE(type))	\</span>
<span class="cp">		      :	&quot;=r&quot;(ia64_clobber)			\</span>
<span class="cp">		      : PARAVIRT_OP(op), &quot;0&quot;(__##arg1)		\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS1)</span>

<span class="cp">#define PARAVIRT_BR1_RET(op, type, arg1)			\</span>
<span class="cp">	register unsigned long ia64_intri_res asm (&quot;r8&quot;);	\</span>
<span class="cp">	register unsigned long __##arg1 asm (&quot;r8&quot;) = arg1;	\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">					  PARAVIRT_TYPE(type))	\</span>
<span class="cp">		      : &quot;=r&quot;(ia64_intri_res)			\</span>
<span class="cp">		      : PARAVIRT_OP(op), &quot;0&quot;(__##arg1)		\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS1)</span>

<span class="cp">#define PARAVIRT_BR1_VOID(op, type, arg1)			\</span>
<span class="cp">	register void *__##arg1 asm (&quot;r8&quot;) = arg1;		\</span>
<span class="cp">	register unsigned long ia64_clobber asm (&quot;r8&quot;);		\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">					  PARAVIRT_TYPE(type))	\</span>
<span class="cp">		      :	&quot;=r&quot;(ia64_clobber)			\</span>
<span class="cp">		      : PARAVIRT_OP(op), &quot;0&quot;(__##arg1)		\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS1)</span>

<span class="cp">#define PARAVIRT_BR2(op, type, arg1, arg2)				\</span>
<span class="cp">	register unsigned long __##arg1 asm (&quot;r8&quot;) = arg1;		\</span>
<span class="cp">	register unsigned long __##arg2 asm (&quot;r9&quot;) = arg2;		\</span>
<span class="cp">	register unsigned long ia64_clobber1 asm (&quot;r8&quot;);		\</span>
<span class="cp">	register unsigned long ia64_clobber2 asm (&quot;r9&quot;);		\</span>
<span class="cp">	asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,		\</span>
<span class="cp">					  PARAVIRT_TYPE(type))		\</span>
<span class="cp">		      : &quot;=r&quot;(ia64_clobber1), &quot;=r&quot;(ia64_clobber2)	\</span>
<span class="cp">		      : PARAVIRT_OP(op), &quot;0&quot;(__##arg1), &quot;1&quot;(__##arg2)	\</span>
<span class="cp">		      : PARAVIRT_CLOBBERS2)</span>


<span class="cp">#define PARAVIRT_DEFINE_CPU_OP0(op, type)		\</span>
<span class="cp">	static inline void				\</span>
<span class="cp">	paravirt_ ## op (void)				\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR0(op, type);			\</span>
<span class="cp">	}</span>

<span class="cp">#define PARAVIRT_DEFINE_CPU_OP0_RET(op, type)		\</span>
<span class="cp">	static inline unsigned long			\</span>
<span class="cp">	paravirt_ ## op (void)				\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR0_RET(op, type);		\</span>
<span class="cp">		return ia64_intri_res;			\</span>
<span class="cp">	}</span>

<span class="cp">#define PARAVIRT_DEFINE_CPU_OP1_VOID(op, type)		\</span>
<span class="cp">	static inline void				\</span>
<span class="cp">	paravirt_ ## op (void *arg1)			\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR1_VOID(op, type, arg1);	\</span>
<span class="cp">	}</span>

<span class="cp">#define PARAVIRT_DEFINE_CPU_OP1(op, type)		\</span>
<span class="cp">	static inline void				\</span>
<span class="cp">	paravirt_ ## op (unsigned long arg1)		\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR1(op, type, arg1);		\</span>
<span class="cp">	}</span>

<span class="cp">#define PARAVIRT_DEFINE_CPU_OP1_RET(op, type)		\</span>
<span class="cp">	static inline unsigned long			\</span>
<span class="cp">	paravirt_ ## op (unsigned long arg1)		\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR1_RET(op, type, arg1);	\</span>
<span class="cp">		return ia64_intri_res;			\</span>
<span class="cp">	}</span>

<span class="cp">#define PARAVIRT_DEFINE_CPU_OP2(op, type)		\</span>
<span class="cp">	static inline void				\</span>
<span class="cp">	paravirt_ ## op (unsigned long arg1,		\</span>
<span class="cp">			 unsigned long arg2)		\</span>
<span class="cp">	{						\</span>
<span class="cp">		PARAVIRT_BR2(op, type, arg1, arg2);	\</span>
<span class="cp">	}</span>


<span class="n">PARAVIRT_DEFINE_CPU_OP1_VOID</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">FC</span><span class="p">);</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP1_RET</span><span class="p">(</span><span class="n">thash</span><span class="p">,</span> <span class="n">THASH</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP1_RET</span><span class="p">(</span><span class="n">get_cpuid</span><span class="p">,</span> <span class="n">GET_CPUID</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP1_RET</span><span class="p">(</span><span class="n">get_pmd</span><span class="p">,</span> <span class="n">GET_PMD</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP2</span><span class="p">(</span><span class="n">ptcga</span><span class="p">,</span> <span class="n">PTCGA</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP1_RET</span><span class="p">(</span><span class="n">get_rr</span><span class="p">,</span> <span class="n">GET_RR</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP2</span><span class="p">(</span><span class="n">set_rr</span><span class="p">,</span> <span class="n">SET_RR</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP0</span><span class="p">(</span><span class="n">ssm_i</span><span class="p">,</span> <span class="n">SSM_I</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP0</span><span class="p">(</span><span class="n">rsm_i</span><span class="p">,</span> <span class="n">RSM_I</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP0_RET</span><span class="p">(</span><span class="n">get_psr_i</span><span class="p">,</span> <span class="n">GET_PSR_I</span><span class="p">)</span>
<span class="n">PARAVIRT_DEFINE_CPU_OP1</span><span class="p">(</span><span class="n">intrin_local_irq_restore</span><span class="p">,</span> <span class="n">INTRIN_LOCAL_IRQ_RESTORE</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="n">paravirt_set_rr0_to_rr4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val1</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val3</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__val0</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">val0</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__val1</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r9&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">val1</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__val2</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">val2</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__val3</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">val3</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__val4</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r14&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">val4</span><span class="p">;</span>

	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_clobber0</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r8&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_clobber1</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r9&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_clobber2</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r10&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_clobber3</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r11&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_clobber4</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r14&quot;</span><span class="p">);</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="n">paravirt_alt_bundle</span><span class="p">(</span><span class="n">__PARAVIRT_BR</span><span class="p">,</span>
					  <span class="n">PARAVIRT_TYPE</span><span class="p">(</span><span class="n">SET_RR0_TO_RR4</span><span class="p">))</span>
		      <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ia64_clobber0</span><span class="p">),</span>
			<span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ia64_clobber1</span><span class="p">),</span>
			<span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ia64_clobber2</span><span class="p">),</span>
			<span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ia64_clobber3</span><span class="p">),</span>
			<span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">ia64_clobber4</span><span class="p">)</span>
		      <span class="o">:</span> <span class="n">PARAVIRT_OP</span><span class="p">(</span><span class="n">set_rr0_to_rr4</span><span class="p">),</span>
			<span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">__val0</span><span class="p">),</span> <span class="s">&quot;1&quot;</span><span class="p">(</span><span class="n">__val1</span><span class="p">),</span> <span class="s">&quot;2&quot;</span><span class="p">(</span><span class="n">__val2</span><span class="p">),</span>
			<span class="s">&quot;3&quot;</span><span class="p">(</span><span class="n">__val3</span><span class="p">),</span> <span class="s">&quot;4&quot;</span><span class="p">(</span><span class="n">__val4</span><span class="p">)</span>
		      <span class="o">:</span> <span class="n">PARAVIRT_CLOBBERS5</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* unsigned long paravirt_getreg(int reg) */</span>
<span class="cp">#define __paravirt_getreg(reg)						\</span>
<span class="cp">	({								\</span>
<span class="cp">		register unsigned long ia64_intri_res asm (&quot;r8&quot;);	\</span>
<span class="cp">		register unsigned long __reg asm (&quot;r8&quot;) = (reg);	\</span>
<span class="cp">									\</span>
<span class="cp">		asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">						  PARAVIRT_TYPE(GETREG) \</span>
<span class="cp">						  + (reg))		\</span>
<span class="cp">			      : &quot;=r&quot;(ia64_intri_res)			\</span>
<span class="cp">			      : PARAVIRT_OP(getreg), &quot;0&quot;(__reg)		\</span>
<span class="cp">			      : PARAVIRT_CLOBBERS1);			\</span>
<span class="cp">									\</span>
<span class="cp">		ia64_intri_res;						\</span>
<span class="cp">	})</span>

<span class="cm">/* void paravirt_setreg(int reg, unsigned long val) */</span>
<span class="cp">#define paravirt_setreg(reg, val)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		register unsigned long __val asm (&quot;r8&quot;) = val;		\</span>
<span class="cp">		register unsigned long __reg asm (&quot;r9&quot;) = reg;		\</span>
<span class="cp">		register unsigned long ia64_clobber1 asm (&quot;r8&quot;);	\</span>
<span class="cp">		register unsigned long ia64_clobber2 asm (&quot;r9&quot;);	\</span>
<span class="cp">									\</span>
<span class="cp">		asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\</span>
<span class="cp">						  PARAVIRT_TYPE(SETREG) \</span>
<span class="cp">						  + (reg))		\</span>
<span class="cp">			      : &quot;=r&quot;(ia64_clobber1),			\</span>
<span class="cp">				&quot;=r&quot;(ia64_clobber2)			\</span>
<span class="cp">			      : PARAVIRT_OP(setreg),			\</span>
<span class="cp">				&quot;1&quot;(__reg), &quot;0&quot;(__val)			\</span>
<span class="cp">			      : PARAVIRT_CLOBBERS2);			\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* ASM_SUPPORTED */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PARAVIRT &amp;&amp; ASM_SUPPOTED */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_PARAVIRT_PRIVOP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
