<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › gcc_intrin.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>gcc_intrin.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_GCC_INTRIN_H</span>
<span class="cp">#define _ASM_IA64_GCC_INTRIN_H</span>
<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002,2003 Jun Nakajima &lt;jun.nakajima@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 2002,2003 Suresh Siddha &lt;suresh.b.siddha@intel.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/* define this macro to get some asm stmts included in &#39;c&#39; files */</span>
<span class="cp">#define ASM_SUPPORTED</span>

<span class="cm">/* Optimization barrier */</span>
<span class="cm">/* The &quot;volatile&quot; is due to gcc bugs */</span>
<span class="cp">#define ia64_barrier()	asm volatile (&quot;&quot;:::&quot;memory&quot;)</span>

<span class="cp">#define ia64_stop()	asm volatile (&quot;;;&quot;::)</span>

<span class="cp">#define ia64_invala_gr(regnum)	asm volatile (&quot;invala.e r%0&quot; :: &quot;i&quot;(regnum))</span>

<span class="cp">#define ia64_invala_fr(regnum)	asm volatile (&quot;invala.e f%0&quot; :: &quot;i&quot;(regnum))</span>

<span class="cp">#define ia64_flushrs() asm volatile (&quot;flushrs;;&quot;:::&quot;memory&quot;)</span>

<span class="cp">#define ia64_loadrs() asm volatile (&quot;loadrs;;&quot;:::&quot;memory&quot;)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_bad_param_for_setreg</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_bad_param_for_getreg</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ia64_r13</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;r13&quot;</span><span class="p">)</span> <span class="n">__used</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define ia64_native_setreg(regnum, val)						\</span>
<span class="cp">({										\</span>
<span class="cp">	switch (regnum) {							\</span>
<span class="cp">	    case _IA64_REG_PSR_L:						\</span>
<span class="cp">		    asm volatile (&quot;mov psr.l=%0&quot; :: &quot;r&quot;(val) : &quot;memory&quot;);	\</span>
<span class="cp">		    break;							\</span>
<span class="cp">	    case _IA64_REG_AR_KR0 ... _IA64_REG_AR_EC:				\</span>
<span class="cp">		    asm volatile (&quot;mov ar%0=%1&quot; ::				\</span>
<span class="cp">		    			  &quot;i&quot; (regnum - _IA64_REG_AR_KR0),	\</span>
<span class="cp">					  &quot;r&quot;(val): &quot;memory&quot;);			\</span>
<span class="cp">		    break;							\</span>
<span class="cp">	    case _IA64_REG_CR_DCR ... _IA64_REG_CR_LRR1:			\</span>
<span class="cp">		    asm volatile (&quot;mov cr%0=%1&quot; ::				\</span>
<span class="cp">				          &quot;i&quot; (regnum - _IA64_REG_CR_DCR),	\</span>
<span class="cp">					  &quot;r&quot;(val): &quot;memory&quot; );			\</span>
<span class="cp">		    break;							\</span>
<span class="cp">	    case _IA64_REG_SP:							\</span>
<span class="cp">		    asm volatile (&quot;mov r12=%0&quot; ::				\</span>
<span class="cp">			    		  &quot;r&quot;(val): &quot;memory&quot;);			\</span>
<span class="cp">		    break;							\</span>
<span class="cp">	    case _IA64_REG_GP:							\</span>
<span class="cp">		    asm volatile (&quot;mov gp=%0&quot; :: &quot;r&quot;(val) : &quot;memory&quot;);		\</span>
<span class="cp">		break;								\</span>
<span class="cp">	    default:								\</span>
<span class="cp">		    ia64_bad_param_for_setreg();				\</span>
<span class="cp">		    break;							\</span>
<span class="cp">	}									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_native_getreg(regnum)						\</span>
<span class="cp">({										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">										\</span>
<span class="cp">	switch (regnum) {							\</span>
<span class="cp">	case _IA64_REG_GP:							\</span>
<span class="cp">		asm volatile (&quot;mov %0=gp&quot; : &quot;=r&quot;(ia64_intri_res));		\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_IP:							\</span>
<span class="cp">		asm volatile (&quot;mov %0=ip&quot; : &quot;=r&quot;(ia64_intri_res));		\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_PSR:							\</span>
<span class="cp">		asm volatile (&quot;mov %0=psr&quot; : &quot;=r&quot;(ia64_intri_res));		\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_TP:	</span><span class="cm">/* for current() */</span><span class="cp">				\</span>
<span class="cp">		ia64_intri_res = ia64_r13;					\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_AR_KR0 ... _IA64_REG_AR_EC:				\</span>
<span class="cp">		asm volatile (&quot;mov %0=ar%1&quot; : &quot;=r&quot; (ia64_intri_res)		\</span>
<span class="cp">				      : &quot;i&quot;(regnum - _IA64_REG_AR_KR0));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_CR_DCR ... _IA64_REG_CR_LRR1:				\</span>
<span class="cp">		asm volatile (&quot;mov %0=cr%1&quot; : &quot;=r&quot; (ia64_intri_res)		\</span>
<span class="cp">				      : &quot;i&quot; (regnum - _IA64_REG_CR_DCR));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case _IA64_REG_SP:							\</span>
<span class="cp">		asm volatile (&quot;mov %0=sp&quot; : &quot;=r&quot; (ia64_intri_res));		\</span>
<span class="cp">		break;								\</span>
<span class="cp">	default:								\</span>
<span class="cp">		ia64_bad_param_for_getreg();					\</span>
<span class="cp">		break;								\</span>
<span class="cp">	}									\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_hint_pause 0</span>

<span class="cp">#define ia64_hint(mode)						\</span>
<span class="cp">({								\</span>
<span class="cp">	switch (mode) {						\</span>
<span class="cp">	case ia64_hint_pause:					\</span>
<span class="cp">		asm volatile (&quot;hint @pause&quot; ::: &quot;memory&quot;);	\</span>
<span class="cp">		break;						\</span>
<span class="cp">	}							\</span>
<span class="cp">})</span>


<span class="cm">/* Integer values for mux1 instruction */</span>
<span class="cp">#define ia64_mux1_brcst 0</span>
<span class="cp">#define ia64_mux1_mix   8</span>
<span class="cp">#define ia64_mux1_shuf  9</span>
<span class="cp">#define ia64_mux1_alt  10</span>
<span class="cp">#define ia64_mux1_rev  11</span>

<span class="cp">#define ia64_mux1(x, mode)							\</span>
<span class="cp">({										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">										\</span>
<span class="cp">	switch (mode) {								\</span>
<span class="cp">	case ia64_mux1_brcst:							\</span>
<span class="cp">		asm (&quot;mux1 %0=%1,@brcst&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case ia64_mux1_mix:							\</span>
<span class="cp">		asm (&quot;mux1 %0=%1,@mix&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case ia64_mux1_shuf:							\</span>
<span class="cp">		asm (&quot;mux1 %0=%1,@shuf&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case ia64_mux1_alt:							\</span>
<span class="cp">		asm (&quot;mux1 %0=%1,@alt&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	case ia64_mux1_rev:							\</span>
<span class="cp">		asm (&quot;mux1 %0=%1,@rev&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">		break;								\</span>
<span class="cp">	}									\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#if __GNUC__ &gt;= 4 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)</span>
<span class="cp"># define ia64_popcnt(x)		__builtin_popcountl(x)</span>
<span class="cp">#else</span>
<span class="cp"># define ia64_popcnt(x)						\</span>
<span class="cp">  ({								\</span>
<span class="cp">	__u64 ia64_intri_res;					\</span>
<span class="cp">	asm (&quot;popcnt %0=%1&quot; : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (x));	\</span>
<span class="cp">								\</span>
<span class="cp">	ia64_intri_res;						\</span>
<span class="cp">  })</span>
<span class="cp">#endif</span>

<span class="cp">#define ia64_getf_exp(x)					\</span>
<span class="cp">({								\</span>
<span class="cp">	long ia64_intri_res;					\</span>
<span class="cp">								\</span>
<span class="cp">	asm (&quot;getf.exp %0=%1&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;f&quot;(x));	\</span>
<span class="cp">								\</span>
<span class="cp">	ia64_intri_res;						\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_shrp(a, b, count)								\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm (&quot;shrp %0=%1,%2,%3&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(a), &quot;r&quot;(b), &quot;i&quot;(count));	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_ldfs(regnum, x)					\</span>
<span class="cp">({								\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);			\</span>
<span class="cp">	asm volatile (&quot;ldfs %0=[%1]&quot; :&quot;=f&quot;(__f__): &quot;r&quot;(x));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_ldfd(regnum, x)					\</span>
<span class="cp">({								\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);			\</span>
<span class="cp">	asm volatile (&quot;ldfd %0=[%1]&quot; :&quot;=f&quot;(__f__): &quot;r&quot;(x));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_ldfe(regnum, x)					\</span>
<span class="cp">({								\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);			\</span>
<span class="cp">	asm volatile (&quot;ldfe %0=[%1]&quot; :&quot;=f&quot;(__f__): &quot;r&quot;(x));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_ldf8(regnum, x)					\</span>
<span class="cp">({								\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);			\</span>
<span class="cp">	asm volatile (&quot;ldf8 %0=[%1]&quot; :&quot;=f&quot;(__f__): &quot;r&quot;(x));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_ldf_fill(regnum, x)				\</span>
<span class="cp">({								\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);			\</span>
<span class="cp">	asm volatile (&quot;ldf.fill %0=[%1]&quot; :&quot;=f&quot;(__f__): &quot;r&quot;(x));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_st4_rel_nta(m, val)					\</span>
<span class="cp">({									\</span>
<span class="cp">	asm volatile (&quot;st4.rel.nta [%0] = %1\n\t&quot; :: &quot;r&quot;(m), &quot;r&quot;(val));	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_stfs(x, regnum)						\</span>
<span class="cp">({									\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);				\</span>
<span class="cp">	asm volatile (&quot;stfs [%0]=%1&quot; :: &quot;r&quot;(x), &quot;f&quot;(__f__) : &quot;memory&quot;);	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_stfd(x, regnum)						\</span>
<span class="cp">({									\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);				\</span>
<span class="cp">	asm volatile (&quot;stfd [%0]=%1&quot; :: &quot;r&quot;(x), &quot;f&quot;(__f__) : &quot;memory&quot;);	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_stfe(x, regnum)						\</span>
<span class="cp">({									\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);				\</span>
<span class="cp">	asm volatile (&quot;stfe [%0]=%1&quot; :: &quot;r&quot;(x), &quot;f&quot;(__f__) : &quot;memory&quot;);	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_stf8(x, regnum)						\</span>
<span class="cp">({									\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);				\</span>
<span class="cp">	asm volatile (&quot;stf8 [%0]=%1&quot; :: &quot;r&quot;(x), &quot;f&quot;(__f__) : &quot;memory&quot;);	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_stf_spill(x, regnum)						\</span>
<span class="cp">({										\</span>
<span class="cp">	register double __f__ asm (&quot;f&quot;#regnum);					\</span>
<span class="cp">	asm volatile (&quot;stf.spill [%0]=%1&quot; :: &quot;r&quot;(x), &quot;f&quot;(__f__) : &quot;memory&quot;);	\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_fetchadd4_acq(p, inc)						\</span>
<span class="cp">({										\</span>
<span class="cp">										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;fetchadd4.acq %0=[%1],%2&quot;				\</span>
<span class="cp">				: &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(p), &quot;i&quot; (inc)	\</span>
<span class="cp">				: &quot;memory&quot;);					\</span>
<span class="cp">										\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_fetchadd4_rel(p, inc)						\</span>
<span class="cp">({										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;fetchadd4.rel %0=[%1],%2&quot;				\</span>
<span class="cp">				: &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(p), &quot;i&quot; (inc)	\</span>
<span class="cp">				: &quot;memory&quot;);					\</span>
<span class="cp">										\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_fetchadd8_acq(p, inc)						\</span>
<span class="cp">({										\</span>
<span class="cp">										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;fetchadd8.acq %0=[%1],%2&quot;				\</span>
<span class="cp">				: &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(p), &quot;i&quot; (inc)	\</span>
<span class="cp">				: &quot;memory&quot;);					\</span>
<span class="cp">										\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_fetchadd8_rel(p, inc)						\</span>
<span class="cp">({										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;fetchadd8.rel %0=[%1],%2&quot;				\</span>
<span class="cp">				: &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(p), &quot;i&quot; (inc)	\</span>
<span class="cp">				: &quot;memory&quot;);					\</span>
<span class="cp">										\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_xchg1(ptr,x)							\</span>
<span class="cp">({										\</span>
<span class="cp">	__u64 ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;xchg1 %0=[%1],%2&quot;					\</span>
<span class="cp">		      : &quot;=r&quot; (ia64_intri_res) : &quot;r&quot; (ptr), &quot;r&quot; (x) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_xchg2(ptr,x)						\</span>
<span class="cp">({									\</span>
<span class="cp">	__u64 ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;xchg2 %0=[%1],%2&quot; : &quot;=r&quot; (ia64_intri_res)	\</span>
<span class="cp">		      : &quot;r&quot; (ptr), &quot;r&quot; (x) : &quot;memory&quot;);			\</span>
<span class="cp">	ia64_intri_res;							\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_xchg4(ptr,x)						\</span>
<span class="cp">({									\</span>
<span class="cp">	__u64 ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;xchg4 %0=[%1],%2&quot; : &quot;=r&quot; (ia64_intri_res)	\</span>
<span class="cp">		      : &quot;r&quot; (ptr), &quot;r&quot; (x) : &quot;memory&quot;);			\</span>
<span class="cp">	ia64_intri_res;							\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_xchg8(ptr,x)						\</span>
<span class="cp">({									\</span>
<span class="cp">	__u64 ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;xchg8 %0=[%1],%2&quot; : &quot;=r&quot; (ia64_intri_res)	\</span>
<span class="cp">		      : &quot;r&quot; (ptr), &quot;r&quot; (x) : &quot;memory&quot;);			\</span>
<span class="cp">	ia64_intri_res;							\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg1_acq(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg1.acq %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg1_rel(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg1.rel %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg2_acq(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg2.acq %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg2_rel(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">											\</span>
<span class="cp">	asm volatile (&quot;cmpxchg2.rel %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg4_acq(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg4.acq %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg4_rel(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg4.rel %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg8_acq(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">	asm volatile (&quot;cmpxchg8.acq %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_cmpxchg8_rel(ptr, new, old)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__u64 ia64_intri_res;								\</span>
<span class="cp">	asm volatile (&quot;mov ar.ccv=%0;;&quot; :: &quot;rO&quot;(old));					\</span>
<span class="cp">											\</span>
<span class="cp">	asm volatile (&quot;cmpxchg8.rel %0=[%1],%2,ar.ccv&quot;:					\</span>
<span class="cp">			      &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(ptr), &quot;r&quot;(new) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_mf()	asm volatile (&quot;mf&quot; ::: &quot;memory&quot;)</span>
<span class="cp">#define ia64_mfa()	asm volatile (&quot;mf.a&quot; ::: &quot;memory&quot;)</span>

<span class="cp">#define ia64_invala() asm volatile (&quot;invala&quot; ::: &quot;memory&quot;)</span>

<span class="cp">#define ia64_native_thash(addr)							\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;thash %0=%1&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot; (addr));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_srlz_i()	asm volatile (&quot;;; srlz.i ;;&quot; ::: &quot;memory&quot;)</span>
<span class="cp">#define ia64_srlz_d()	asm volatile (&quot;;; srlz.d&quot; ::: &quot;memory&quot;);</span>

<span class="cp">#ifdef HAVE_SERIALIZE_DIRECTIVE</span>
<span class="cp"># define ia64_dv_serialize_data()		asm volatile (&quot;.serialize.data&quot;);</span>
<span class="cp"># define ia64_dv_serialize_instruction()	asm volatile (&quot;.serialize.instruction&quot;);</span>
<span class="cp">#else</span>
<span class="cp"># define ia64_dv_serialize_data()</span>
<span class="cp"># define ia64_dv_serialize_instruction()</span>
<span class="cp">#endif</span>

<span class="cp">#define ia64_nop(x)	asm volatile (&quot;nop %0&quot;::&quot;i&quot;(x));</span>

<span class="cp">#define ia64_itci(addr)	asm volatile (&quot;itc.i %0;;&quot; :: &quot;r&quot;(addr) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_itcd(addr)	asm volatile (&quot;itc.d %0;;&quot; :: &quot;r&quot;(addr) : &quot;memory&quot;)</span>


<span class="cp">#define ia64_itri(trnum, addr) asm volatile (&quot;itr.i itr[%0]=%1&quot;				\</span>
<span class="cp">					     :: &quot;r&quot;(trnum), &quot;r&quot;(addr) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_itrd(trnum, addr) asm volatile (&quot;itr.d dtr[%0]=%1&quot;				\</span>
<span class="cp">					     :: &quot;r&quot;(trnum), &quot;r&quot;(addr) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_tpa(addr)								\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_pa;							\</span>
<span class="cp">	asm volatile (&quot;tpa %0 = %1&quot; : &quot;=r&quot;(ia64_pa) : &quot;r&quot;(addr) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_pa;								\</span>
<span class="cp">})</span>

<span class="cp">#define __ia64_set_dbr(index, val)						\</span>
<span class="cp">	asm volatile (&quot;mov dbr[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_set_ibr(index, val)						\</span>
<span class="cp">	asm volatile (&quot;mov ibr[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_set_pkr(index, val)						\</span>
<span class="cp">	asm volatile (&quot;mov pkr[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_set_pmc(index, val)						\</span>
<span class="cp">	asm volatile (&quot;mov pmc[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_set_pmd(index, val)						\</span>
<span class="cp">	asm volatile (&quot;mov pmd[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_native_set_rr(index, val)							\</span>
<span class="cp">	asm volatile (&quot;mov rr[%0]=%1&quot; :: &quot;r&quot;(index), &quot;r&quot;(val) : &quot;memory&quot;);</span>

<span class="cp">#define ia64_native_get_cpuid(index)							\</span>
<span class="cp">({											\</span>
<span class="cp">	unsigned long ia64_intri_res;							\</span>
<span class="cp">	asm volatile (&quot;mov %0=cpuid[%r1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;rO&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;									\</span>
<span class="cp">})</span>

<span class="cp">#define __ia64_get_dbr(index)							\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=dbr[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_get_ibr(index)							\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=ibr[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_get_pkr(index)							\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=pkr[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_get_pmc(index)							\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=pmc[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>


<span class="cp">#define ia64_native_get_pmd(index)						\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=pmd[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot;(index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_native_get_rr(index)						\</span>
<span class="cp">({										\</span>
<span class="cp">	unsigned long ia64_intri_res;						\</span>
<span class="cp">	asm volatile (&quot;mov %0=rr[%1]&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot; (index));	\</span>
<span class="cp">	ia64_intri_res;								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_native_fc(addr)	asm volatile (&quot;fc %0&quot; :: &quot;r&quot;(addr) : &quot;memory&quot;)</span>


<span class="cp">#define ia64_sync_i()	asm volatile (&quot;;; sync.i&quot; ::: &quot;memory&quot;)</span>

<span class="cp">#define ia64_native_ssm(mask)	asm volatile (&quot;ssm %0&quot;:: &quot;i&quot;((mask)) : &quot;memory&quot;)</span>
<span class="cp">#define ia64_native_rsm(mask)	asm volatile (&quot;rsm %0&quot;:: &quot;i&quot;((mask)) : &quot;memory&quot;)</span>
<span class="cp">#define ia64_sum(mask)	asm volatile (&quot;sum %0&quot;:: &quot;i&quot;((mask)) : &quot;memory&quot;)</span>
<span class="cp">#define ia64_rum(mask)	asm volatile (&quot;rum %0&quot;:: &quot;i&quot;((mask)) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_ptce(addr)	asm volatile (&quot;ptc.e %0&quot; :: &quot;r&quot;(addr))</span>

<span class="cp">#define ia64_native_ptcga(addr, size)						\</span>
<span class="cp">do {										\</span>
<span class="cp">	asm volatile (&quot;ptc.ga %0,%1&quot; :: &quot;r&quot;(addr), &quot;r&quot;(size) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_dv_serialize_data();						\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ia64_ptcl(addr, size)							\</span>
<span class="cp">do {										\</span>
<span class="cp">	asm volatile (&quot;ptc.l %0,%1&quot; :: &quot;r&quot;(addr), &quot;r&quot;(size) : &quot;memory&quot;);	\</span>
<span class="cp">	ia64_dv_serialize_data();						\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define ia64_ptri(addr, size)						\</span>
<span class="cp">	asm volatile (&quot;ptr.i %0,%1&quot; :: &quot;r&quot;(addr), &quot;r&quot;(size) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_ptrd(addr, size)						\</span>
<span class="cp">	asm volatile (&quot;ptr.d %0,%1&quot; :: &quot;r&quot;(addr), &quot;r&quot;(size) : &quot;memory&quot;)</span>

<span class="cp">#define ia64_ttag(addr)							\</span>
<span class="cp">({									  \</span>
<span class="cp">	__u64 ia64_intri_res;						   \</span>
<span class="cp">	asm volatile (&quot;ttag %0=%1&quot; : &quot;=r&quot;(ia64_intri_res) : &quot;r&quot; (addr));   \</span>
<span class="cp">	ia64_intri_res;							 \</span>
<span class="cp">})</span>


<span class="cm">/* Values for lfhint in ia64_lfetch and ia64_lfetch_fault */</span>

<span class="cp">#define ia64_lfhint_none   0</span>
<span class="cp">#define ia64_lfhint_nt1    1</span>
<span class="cp">#define ia64_lfhint_nt2    2</span>
<span class="cp">#define ia64_lfhint_nta    3</span>

<span class="cp">#define ia64_lfetch(lfhint, y)					\</span>
<span class="cp">({								\</span>
<span class="cp">        switch (lfhint) {					\</span>
<span class="cp">        case ia64_lfhint_none:					\</span>
<span class="cp">                asm volatile (&quot;lfetch [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;						\</span>
<span class="cp">        case ia64_lfhint_nt1:					\</span>
<span class="cp">                asm volatile (&quot;lfetch.nt1 [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;						\</span>
<span class="cp">        case ia64_lfhint_nt2:					\</span>
<span class="cp">                asm volatile (&quot;lfetch.nt2 [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;						\</span>
<span class="cp">        case ia64_lfhint_nta:					\</span>
<span class="cp">                asm volatile (&quot;lfetch.nta [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;						\</span>
<span class="cp">        }							\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_lfetch_excl(lfhint, y)					\</span>
<span class="cp">({									\</span>
<span class="cp">        switch (lfhint) {						\</span>
<span class="cp">        case ia64_lfhint_none:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.excl [%0]&quot; :: &quot;r&quot;(y));		\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt1:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.excl.nt1 [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt2:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.excl.nt2 [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nta:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.excl.nta [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        }								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_lfetch_fault(lfhint, y)					\</span>
<span class="cp">({									\</span>
<span class="cp">        switch (lfhint) {						\</span>
<span class="cp">        case ia64_lfhint_none:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault [%0]&quot; : : &quot;r&quot;(y));		\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt1:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.nt1 [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt2:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.nt2 [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nta:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.nta [%0]&quot; : : &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        }								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_lfetch_fault_excl(lfhint, y)				\</span>
<span class="cp">({									\</span>
<span class="cp">        switch (lfhint) {						\</span>
<span class="cp">        case ia64_lfhint_none:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.excl [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt1:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.excl.nt1 [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nt2:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.excl.nt2 [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        case ia64_lfhint_nta:						\</span>
<span class="cp">                asm volatile (&quot;lfetch.fault.excl.nta [%0]&quot; :: &quot;r&quot;(y));	\</span>
<span class="cp">                break;							\</span>
<span class="cp">        }								\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_native_intrin_local_irq_restore(x)			\</span>
<span class="cp">do {								\</span>
<span class="cp">	asm volatile (&quot;;;   cmp.ne p6,p7=%0,r0;;&quot;		\</span>
<span class="cp">		      &quot;(p6) ssm psr.i;&quot;				\</span>
<span class="cp">		      &quot;(p7) rsm psr.i;;&quot;			\</span>
<span class="cp">		      &quot;(p6) srlz.d&quot;				\</span>
<span class="cp">		      :: &quot;r&quot;((x)) : &quot;p6&quot;, &quot;p7&quot;, &quot;memory&quot;);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_GCC_INTRIN_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
