<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › elf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>elf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_ELF_H</span>
<span class="cp">#define _ASM_IA64_ELF_H</span>

<span class="cm">/*</span>
<span class="cm"> * ELF-specific definitions.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-1999, 2002-2004 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;asm/fpu.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/auxvec.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="cm"> */</span>
<span class="cp">#define elf_check_arch(x) ((x)-&gt;e_machine == EM_IA_64)</span>

<span class="cm">/*</span>
<span class="cm"> * These are used to set parameters in the core dumps.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_CLASS	ELFCLASS64</span>
<span class="cp">#define ELF_DATA	ELFDATA2LSB</span>
<span class="cp">#define ELF_ARCH	EM_IA_64</span>

<span class="cp">#define CORE_DUMP_USE_REGSET</span>

<span class="cm">/* Least-significant four bits of ELF header&#39;s e_flags are OS-specific.  The bits are</span>
<span class="cm">   interpreted as follows by Linux: */</span>
<span class="cp">#define EF_IA_64_LINUX_EXECUTABLE_STACK	0x1	</span><span class="cm">/* is stack (&amp; heap) executable by default? */</span><span class="cp"></span>

<span class="cp">#define ELF_EXEC_PAGESIZE	PAGE_SIZE</span>

<span class="cm">/*</span>
<span class="cm"> * This is the location that an ET_DYN program is loaded if exec&#39;ed.</span>
<span class="cm"> * Typical use of this is to invoke &quot;./ld.so someprog&quot; to test out a</span>
<span class="cm"> * new version of the loader.  We need to make sure that it is out of</span>
<span class="cm"> * the way of the program that it will &quot;exec&quot;, and that there is</span>
<span class="cm"> * sufficient room for the brk.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_ET_DYN_BASE		(TASK_UNMAPPED_BASE + 0x800000000UL)</span>

<span class="cp">#define PT_IA_64_UNWIND		0x70000001</span>

<span class="cm">/* IA-64 relocations: */</span>
<span class="cp">#define R_IA64_NONE		0x00	</span><span class="cm">/* none */</span><span class="cp"></span>
<span class="cp">#define R_IA64_IMM14		0x21	</span><span class="cm">/* symbol + addend, add imm14 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_IMM22		0x22	</span><span class="cm">/* symbol + addend, add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_IMM64		0x23	</span><span class="cm">/* symbol + addend, mov imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DIR32MSB		0x24	</span><span class="cm">/* symbol + addend, data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DIR32LSB		0x25	</span><span class="cm">/* symbol + addend, data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DIR64MSB		0x26	</span><span class="cm">/* symbol + addend, data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DIR64LSB		0x27	</span><span class="cm">/* symbol + addend, data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL22		0x2a	</span><span class="cm">/* @gprel(sym+add), add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL64I		0x2b	</span><span class="cm">/* @gprel(sym+add), mov imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL32MSB	0x2c	</span><span class="cm">/* @gprel(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL32LSB	0x2d	</span><span class="cm">/* @gprel(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL64MSB	0x2e	</span><span class="cm">/* @gprel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_GPREL64LSB	0x2f	</span><span class="cm">/* @gprel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF22		0x32	</span><span class="cm">/* @ltoff(sym+add), add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF64I		0x33	</span><span class="cm">/* @ltoff(sym+add), mov imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PLTOFF22		0x3a	</span><span class="cm">/* @pltoff(sym+add), add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PLTOFF64I	0x3b	</span><span class="cm">/* @pltoff(sym+add), mov imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PLTOFF64MSB	0x3e	</span><span class="cm">/* @pltoff(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PLTOFF64LSB	0x3f	</span><span class="cm">/* @pltoff(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_FPTR64I		0x43	</span><span class="cm">/* @fptr(sym+add), mov imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_FPTR32MSB	0x44	</span><span class="cm">/* @fptr(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_FPTR32LSB	0x45	</span><span class="cm">/* @fptr(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_FPTR64MSB	0x46	</span><span class="cm">/* @fptr(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_FPTR64LSB	0x47	</span><span class="cm">/* @fptr(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL60B		0x48	</span><span class="cm">/* @pcrel(sym+add), brl */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL21B		0x49	</span><span class="cm">/* @pcrel(sym+add), ptb, call */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL21M		0x4a	</span><span class="cm">/* @pcrel(sym+add), chk.s */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL21F		0x4b	</span><span class="cm">/* @pcrel(sym+add), fchkf */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL32MSB	0x4c	</span><span class="cm">/* @pcrel(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL32LSB	0x4d	</span><span class="cm">/* @pcrel(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL64MSB	0x4e	</span><span class="cm">/* @pcrel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL64LSB	0x4f	</span><span class="cm">/* @pcrel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR22	0x52	</span><span class="cm">/* @ltoff(@fptr(s+a)), imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR64I	0x53	</span><span class="cm">/* @ltoff(@fptr(s+a)), imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR32MSB	0x54	</span><span class="cm">/* @ltoff(@fptr(s+a)), 4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR32LSB	0x55	</span><span class="cm">/* @ltoff(@fptr(s+a)), 4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR64MSB	0x56	</span><span class="cm">/* @ltoff(@fptr(s+a)), 8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_FPTR64LSB	0x57	</span><span class="cm">/* @ltoff(@fptr(s+a)), 8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SEGREL32MSB	0x5c	</span><span class="cm">/* @segrel(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SEGREL32LSB	0x5d	</span><span class="cm">/* @segrel(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SEGREL64MSB	0x5e	</span><span class="cm">/* @segrel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SEGREL64LSB	0x5f	</span><span class="cm">/* @segrel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SECREL32MSB	0x64	</span><span class="cm">/* @secrel(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SECREL32LSB	0x65	</span><span class="cm">/* @secrel(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SECREL64MSB	0x66	</span><span class="cm">/* @secrel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SECREL64LSB	0x67	</span><span class="cm">/* @secrel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_REL32MSB		0x6c	</span><span class="cm">/* data 4 + REL */</span><span class="cp"></span>
<span class="cp">#define R_IA64_REL32LSB		0x6d	</span><span class="cm">/* data 4 + REL */</span><span class="cp"></span>
<span class="cp">#define R_IA64_REL64MSB		0x6e	</span><span class="cm">/* data 8 + REL */</span><span class="cp"></span>
<span class="cp">#define R_IA64_REL64LSB		0x6f	</span><span class="cm">/* data 8 + REL */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTV32MSB		0x74	</span><span class="cm">/* symbol + addend, data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTV32LSB		0x75	</span><span class="cm">/* symbol + addend, data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTV64MSB		0x76	</span><span class="cm">/* symbol + addend, data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTV64LSB		0x77	</span><span class="cm">/* symbol + addend, data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL21BI	0x79	</span><span class="cm">/* @pcrel(sym+add), ptb, call */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL22		0x7a	</span><span class="cm">/* @pcrel(sym+add), imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_PCREL64I		0x7b	</span><span class="cm">/* @pcrel(sym+add), imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_IPLTMSB		0x80	</span><span class="cm">/* dynamic reloc, imported PLT, MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_IPLTLSB		0x81	</span><span class="cm">/* dynamic reloc, imported PLT, LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_COPY		0x84	</span><span class="cm">/* dynamic reloc, data copy */</span><span class="cp"></span>
<span class="cp">#define R_IA64_SUB		0x85	</span><span class="cm">/* -symbol + addend, add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF22X		0x86	</span><span class="cm">/* LTOFF22, relaxable.  */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LDXMOV		0x87	</span><span class="cm">/* Use of LTOFF22X.  */</span><span class="cp"></span>
<span class="cp">#define R_IA64_TPREL14		0x91	</span><span class="cm">/* @tprel(sym+add), add imm14 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_TPREL22		0x92	</span><span class="cm">/* @tprel(sym+add), add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_TPREL64I		0x93	</span><span class="cm">/* @tprel(sym+add), add imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_TPREL64MSB	0x96	</span><span class="cm">/* @tprel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_TPREL64LSB	0x97	</span><span class="cm">/* @tprel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_TPREL22	0x9a	</span><span class="cm">/* @ltoff(@tprel(s+a)), add imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPMOD64MSB	0xa6	</span><span class="cm">/* @dtpmod(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPMOD64LSB	0xa7	</span><span class="cm">/* @dtpmod(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_DTPMOD22	0xaa	</span><span class="cm">/* @ltoff(@dtpmod(s+a)), imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL14		0xb1	</span><span class="cm">/* @dtprel(sym+add), imm14 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL22		0xb2	</span><span class="cm">/* @dtprel(sym+add), imm22 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL64I	0xb3	</span><span class="cm">/* @dtprel(sym+add), imm64 */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL32MSB	0xb4	</span><span class="cm">/* @dtprel(sym+add), data4 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL32LSB	0xb5	</span><span class="cm">/* @dtprel(sym+add), data4 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL64MSB	0xb6	</span><span class="cm">/* @dtprel(sym+add), data8 MSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_DTPREL64LSB	0xb7	</span><span class="cm">/* @dtprel(sym+add), data8 LSB */</span><span class="cp"></span>
<span class="cp">#define R_IA64_LTOFF_DTPREL22	0xba	</span><span class="cm">/* @ltoff(@dtprel(s+a)), imm22 */</span><span class="cp"></span>

<span class="cm">/* IA-64 specific section flags: */</span>
<span class="cp">#define SHF_IA_64_SHORT		0x10000000	</span><span class="cm">/* section near gp */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * We use (abuse?) this macro to insert the (empty) vm_area that is</span>
<span class="cm"> * used to map the register backing store.  I don&#39;t see any better</span>
<span class="cm"> * place to do this, but we should discuss this with Linus once we can</span>
<span class="cm"> * talk to him...</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_init_addr_space</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#define ELF_PLAT_INIT(_r, load_addr)	ia64_init_addr_space()</span>

<span class="cm">/* ELF register definitions.  This is needed for core dump support.  */</span>

<span class="cm">/*</span>
<span class="cm"> * elf_gregset_t contains the application-level state in the following order:</span>
<span class="cm"> *	r0-r31</span>
<span class="cm"> *	NaT bits (for r0-r31; bit N == 1 iff rN is a NaT)</span>
<span class="cm"> *	predicate registers (p0-p63)</span>
<span class="cm"> *	b0-b7</span>
<span class="cm"> *	ip cfm psr</span>
<span class="cm"> *	ar.rsc ar.bsp ar.bspstore ar.rnat</span>
<span class="cm"> *	ar.ccv ar.unat ar.fpsr ar.pfs ar.lc ar.ec ar.csd ar.ssd</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_NGREG	128	</span><span class="cm">/* we really need just 72 but let&#39;s leave some headroom... */</span><span class="cp"></span>
<span class="cp">#define ELF_NFPREG	128	</span><span class="cm">/* f0 and f1 could be omitted, but so what... */</span><span class="cp"></span>

<span class="cm">/* elf_gregset_t register offsets */</span>
<span class="cp">#define ELF_GR_0_OFFSET     0</span>
<span class="cp">#define ELF_NAT_OFFSET     (32 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_PR_OFFSET      (33 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_BR_0_OFFSET    (34 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_CR_IIP_OFFSET  (42 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_CFM_OFFSET     (43 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_CR_IPSR_OFFSET (44 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_GR_OFFSET(i)   (ELF_GR_0_OFFSET + i * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_BR_OFFSET(i)   (ELF_BR_0_OFFSET + i * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_RSC_OFFSET  (45 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_BSP_OFFSET  (46 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_BSPSTORE_OFFSET (47 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_RNAT_OFFSET (48 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_CCV_OFFSET  (49 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_UNAT_OFFSET (50 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_FPSR_OFFSET (51 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_PFS_OFFSET  (52 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_LC_OFFSET   (53 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_EC_OFFSET   (54 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_CSD_OFFSET  (55 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_SSD_OFFSET  (56 * sizeof(elf_greg_t))</span>
<span class="cp">#define ELF_AR_END_OFFSET  (57 * sizeof(elf_greg_t))</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_fpxregset_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_greg_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_greg_t</span> <span class="n">elf_gregset_t</span><span class="p">[</span><span class="n">ELF_NGREG</span><span class="p">];</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">elf_fpreg_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">elf_fpreg_t</span> <span class="n">elf_fpregset_t</span><span class="p">[</span><span class="n">ELF_NFPREG</span><span class="p">];</span>



<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>	<span class="cm">/* forward declaration... */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_elf_core_copy_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">elf_gregset_t</span> <span class="n">dst</span><span class="p">);</span>
<span class="cp">#define ELF_CORE_COPY_REGS(_dest,_regs)	ia64_elf_core_copy_regs(_regs, _dest);</span>

<span class="cm">/* This macro yields a bitmask that programs can use to figure out</span>
<span class="cm">   what instruction set this CPU supports.  */</span>
<span class="cp">#define ELF_HWCAP 	0</span>

<span class="cm">/* This macro yields a string that ld.so will use to load</span>
<span class="cm">   implementation specific libraries for optimization.  Not terribly</span>
<span class="cm">   relevant until we have real hardware to play with... */</span>
<span class="cp">#define ELF_PLATFORM	NULL</span>

<span class="cp">#define SET_PERSONALITY(ex)	\</span>
<span class="cp">	set_personality((current-&gt;personality &amp; ~PER_MASK) | PER_LINUX)</span>

<span class="cp">#define elf_read_implies_exec(ex, executable_stack)					\</span>
<span class="cp">	((executable_stack!=EXSTACK_DISABLE_X) &amp;&amp; ((ex).e_flags &amp; EF_IA_64_LINUX_EXECUTABLE_STACK) != 0)</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cp">#define GATE_EHDR	((const struct elfhdr *) GATE_ADDR)</span>

<span class="cm">/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
<span class="cp">#define ARCH_DLINFO								\</span>
<span class="cp">do {										\</span>
<span class="cp">	extern char __kernel_syscall_via_epc[];					\</span>
<span class="cp">	NEW_AUX_ENT(AT_SYSINFO, (unsigned long) __kernel_syscall_via_epc);	\</span>
<span class="cp">	NEW_AUX_ENT(AT_SYSINFO_EHDR, (unsigned long) GATE_EHDR);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * format for entries in the Global Offset Table</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">got_entry</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Layout of the Function Descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fdesc</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">ip</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">gp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_ELF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
