<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › page.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>page.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_PAGE_H</span>
<span class="cp">#define _ASM_IA64_PAGE_H</span>
<span class="cm">/*</span>
<span class="cm"> * Pagetable related stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998, 1999, 2002 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/intrinsics.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The top three bits of an IA64 address are its Region Number.</span>
<span class="cm"> * Different regions are assigned to different purposes.</span>
<span class="cm"> */</span>
<span class="cp">#define RGN_SHIFT	(61)</span>
<span class="cp">#define RGN_BASE(r)	(__IA64_UL_CONST(r)&lt;&lt;RGN_SHIFT)</span>
<span class="cp">#define RGN_BITS	(RGN_BASE(-1))</span>

<span class="cp">#define RGN_KERNEL	7	</span><span class="cm">/* Identity mapped region */</span><span class="cp"></span>
<span class="cp">#define RGN_UNCACHED    6	</span><span class="cm">/* Identity mapped I/O region */</span><span class="cp"></span>
<span class="cp">#define RGN_GATE	5	</span><span class="cm">/* Gate page, Kernel text, etc */</span><span class="cp"></span>
<span class="cp">#define RGN_HPAGE	4	</span><span class="cm">/* For Huge TLB pages */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PAGE_SHIFT determines the actual kernel page size.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_IA64_PAGE_SIZE_4KB)</span>
<span class="cp"># define PAGE_SHIFT	12</span>
<span class="cp">#elif defined(CONFIG_IA64_PAGE_SIZE_8KB)</span>
<span class="cp"># define PAGE_SHIFT	13</span>
<span class="cp">#elif defined(CONFIG_IA64_PAGE_SIZE_16KB)</span>
<span class="cp"># define PAGE_SHIFT	14</span>
<span class="cp">#elif defined(CONFIG_IA64_PAGE_SIZE_64KB)</span>
<span class="cp"># define PAGE_SHIFT	16</span>
<span class="cp">#else</span>
<span class="cp"># error Unsupported page size!</span>
<span class="cp">#endif</span>

<span class="cp">#define PAGE_SIZE		(__IA64_UL_CONST(1) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define PAGE_MASK		(~(PAGE_SIZE - 1))</span>

<span class="cp">#define PERCPU_PAGE_SHIFT	18	</span><span class="cm">/* log2() of max. size of per-CPU area */</span><span class="cp"></span>
<span class="cp">#define PERCPU_PAGE_SIZE	(__IA64_UL_CONST(1) &lt;&lt; PERCPU_PAGE_SHIFT)</span>


<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp"># define HPAGE_REGION_BASE	RGN_BASE(RGN_HPAGE)</span>
<span class="cp"># define HPAGE_SHIFT		hpage_shift</span>
<span class="cp"># define HPAGE_SHIFT_DEFAULT	28	</span><span class="cm">/* check ia64 SDM for architecture supported size */</span><span class="cp"></span>
<span class="cp"># define HPAGE_SIZE		(__IA64_UL_CONST(1) &lt;&lt; HPAGE_SHIFT)</span>
<span class="cp"># define HPAGE_MASK		(~(HPAGE_SIZE - 1))</span>

<span class="cp"># define HAVE_ARCH_HUGETLB_UNMAPPED_AREA</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="cp">#ifdef __ASSEMBLY__</span>
<span class="cp"># define __pa(x)		((x) - PAGE_OFFSET)</span>
<span class="cp"># define __va(x)		((x) + PAGE_OFFSET)</span>
<span class="cp">#else </span><span class="cm">/* !__ASSEMBLY */</span><span class="cp"></span>
<span class="cp">#  define STRICT_MM_TYPECHECKS</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_page</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">copy_page</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * clear_user_page() and copy_user_page() can&#39;t be inline functions because</span>
<span class="cm"> * flush_dcache_page() can&#39;t be defined until later...</span>
<span class="cm"> */</span>
<span class="cp">#define clear_user_page(addr, vaddr, page)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	clear_page(addr);			\</span>
<span class="cp">	flush_dcache_page(page);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define copy_user_page(to, from, vaddr, page)	\</span>
<span class="cp">do {						\</span>
<span class="cp">	copy_page((to), (from));		\</span>
<span class="cp">	flush_dcache_page(page);		\</span>
<span class="cp">} while (0)</span>


<span class="cp">#define __alloc_zeroed_user_highpage(movableflags, vma, vaddr)		\</span>
<span class="cp">({									\</span>
<span class="cp">	struct page *page = alloc_page_vma(				\</span>
<span class="cp">		GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr);	\</span>
<span class="cp">	if (page)							\</span>
<span class="cp"> 		flush_dcache_page(page);				\</span>
<span class="cp">	page;								\</span>
<span class="cp">})</span>

<span class="cp">#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE</span>

<span class="cp">#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ia64_pfn_valid</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># define ia64_pfn_valid(pfn) 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">vmem_map</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DISCONTIGMEM</span>
<span class="cp"># define page_to_pfn(page)	((unsigned long) (page - vmem_map))</span>
<span class="cp"># define pfn_to_page(pfn)	(vmem_map + (pfn))</span>
<span class="cp">#else</span>
<span class="cp"># include &lt;asm-generic/memory_model.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cp"># include &lt;asm-generic/memory_model.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FLATMEM</span>
<span class="cp"># define pfn_valid(pfn)		(((pfn) &lt; max_mapnr) &amp;&amp; ia64_pfn_valid(pfn))</span>
<span class="cp">#elif defined(CONFIG_DISCONTIGMEM)</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_low_pfn</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low_pfn</span><span class="p">;</span>
<span class="cp"># define pfn_valid(pfn)		(((pfn) &gt;= min_low_pfn) &amp;&amp; ((pfn) &lt; max_low_pfn) &amp;&amp; ia64_pfn_valid(pfn))</span>
<span class="cp">#endif</span>

<span class="cp">#define page_to_phys(page)	(page_to_pfn(page) &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define pfn_to_kaddr(pfn)	__va((pfn) &lt;&lt; PAGE_SHIFT)</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ia64_va</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">:</span> <span class="mi">61</span><span class="p">;</span>		<span class="cm">/* intra-region offset */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span> <span class="o">:</span>  <span class="mi">3</span><span class="p">;</span>		<span class="cm">/* region number */</span>
	<span class="p">}</span> <span class="n">f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ia64_va</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Note: These macros depend on the fact that PAGE_OFFSET has all</span>
<span class="cm"> * region bits set to 1 and all other bits set to zero.  They are</span>
<span class="cm"> * expressed in this way to ensure they result in a single &quot;dep&quot;</span>
<span class="cm"> * instruction.</span>
<span class="cm"> */</span>
<span class="cp">#define __pa(x)		({ia64_va _v; _v.l = (long) (x); _v.f.reg = 0; _v.l;})</span>
<span class="cp">#define __va(x)		({ia64_va _v; _v.l = (long) (x); _v.f.reg = -1; _v.p;})</span>

<span class="cp">#define REGION_NUMBER(x)	({ia64_va _v; _v.l = (long) (x); _v.f.reg;})</span>
<span class="cp">#define REGION_OFFSET(x)	({ia64_va _v; _v.l = (long) (x); _v.f.off;})</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="cp"># define htlbpage_to_page(x)	(((unsigned long) REGION_NUMBER(x) &lt;&lt; 61)			\</span>
<span class="cp">				 | (REGION_OFFSET(x) &gt;&gt; (HPAGE_SHIFT-PAGE_SHIFT)))</span>
<span class="cp"># define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hpage_shift</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span>
<span class="nf">get_order</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">ia64_getf_exp</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mh">0xffff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#ifdef STRICT_MM_TYPECHECKS</span>
  <span class="cm">/*</span>
<span class="cm">   * These are used to make use of C type-checking..</span>
<span class="cm">   */</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span> <span class="n">pte_t</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd</span><span class="p">;</span> <span class="p">}</span> <span class="n">pmd_t</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pud</span><span class="p">;</span> <span class="p">}</span> <span class="n">pud_t</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgd_t</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot</span><span class="p">;</span> <span class="p">}</span> <span class="n">pgprot_t</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgtable_t</span><span class="p">;</span>

<span class="cp"># define pte_val(x)	((x).pte)</span>
<span class="cp"># define pmd_val(x)	((x).pmd)</span>
<span class="cp">#ifdef CONFIG_PGTABLE_4</span>
<span class="cp"># define pud_val(x)	((x).pud)</span>
<span class="cp">#endif</span>
<span class="cp"># define pgd_val(x)	((x).pgd)</span>
<span class="cp"># define pgprot_val(x)	((x).pgprot)</span>

<span class="cp"># define __pte(x)	((pte_t) { (x) } )</span>
<span class="cp"># define __pmd(x)	((pmd_t) { (x) } )</span>
<span class="cp"># define __pgprot(x)	((pgprot_t) { (x) } )</span>

<span class="cp">#else </span><span class="cm">/* !STRICT_MM_TYPECHECKS */</span><span class="cp"></span>
  <span class="cm">/*</span>
<span class="cm">   * .. while these make it easier on the compiler</span>
<span class="cm">   */</span>
<span class="cp"># ifndef __ASSEMBLY__</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmd_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgprot_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pgtable_t</span><span class="p">;</span>
<span class="cp"># endif</span>

<span class="cp"># define pte_val(x)	(x)</span>
<span class="cp"># define pmd_val(x)	(x)</span>
<span class="cp"># define pgd_val(x)	(x)</span>
<span class="cp"># define pgprot_val(x)	(x)</span>

<span class="cp"># define __pte(x)	(x)</span>
<span class="cp"># define __pgd(x)	(x)</span>
<span class="cp"># define __pgprot(x)	(x)</span>
<span class="cp">#endif </span><span class="cm">/* !STRICT_MM_TYPECHECKS */</span><span class="cp"></span>

<span class="cp">#define PAGE_OFFSET			RGN_BASE(RGN_KERNEL)</span>

<span class="cp">#define VM_DATA_DEFAULT_FLAGS		(VM_READ | VM_WRITE |					\</span>
<span class="cp">					 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC |		\</span>
<span class="cp">					 (((current-&gt;personality &amp; READ_IMPLIES_EXEC) != 0)	\</span>
<span class="cp">					  ? VM_EXEC : 0))</span>

<span class="cp">#define GATE_ADDR		RGN_BASE(RGN_GATE)</span>

<span class="cm">/*</span>
<span class="cm"> * 0xa000000000000000+2*PERCPU_PAGE_SIZE</span>
<span class="cm"> * - 0xa000000000000000+3*PERCPU_PAGE_SIZE remain unmapped (guard page)</span>
<span class="cm"> */</span>
<span class="cp">#define KERNEL_START		 (GATE_ADDR+__IA64_UL_CONST(0x100000000))</span>
<span class="cp">#define PERCPU_ADDR		(-PERCPU_PAGE_SIZE)</span>
<span class="cp">#define LOAD_OFFSET		(KERNEL_START - KERNEL_TR_PAGE_SIZE)</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_PAGE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
