<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › mca_asm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mca_asm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File:	mca_asm.h</span>
<span class="cm"> * Purpose:	Machine check handling specific defines</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (C) Vijay Chander &lt;vijay@engr.sgi.com&gt;</span>
<span class="cm"> * Copyright (C) Srinivasa Thirumalachar &lt;sprasad@engr.sgi.com&gt;</span>
<span class="cm"> * Copyright (C) 2000 Hewlett-Packard Co.</span>
<span class="cm"> * Copyright (C) 2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 2002 Intel Corp.</span>
<span class="cm"> * Copyright (C) 2002 Jenna Hall &lt;jenna.s.hall@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 2005 Silicon Graphics, Inc</span>
<span class="cm"> * Copyright (C) 2005 Keith Owens &lt;kaos@sgi.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_IA64_MCA_ASM_H</span>
<span class="cp">#define _ASM_IA64_MCA_ASM_H</span>

<span class="cp">#include &lt;asm/percpu.h&gt;</span>

<span class="cp">#define PSR_IC		13</span>
<span class="cp">#define PSR_I		14</span>
<span class="cp">#define	PSR_DT		17</span>
<span class="cp">#define PSR_RT		27</span>
<span class="cp">#define PSR_MC		35</span>
<span class="cp">#define PSR_IT		36</span>
<span class="cp">#define PSR_BN		44</span>

<span class="cm">/*</span>
<span class="cm"> * This macro converts a instruction virtual address to a physical address</span>
<span class="cm"> * Right now for simulation purposes the virtual addresses are</span>
<span class="cm"> * direct mapped to physical addresses.</span>
<span class="cm"> *	1. Lop off bits 61 thru 63 in the virtual address</span>
<span class="cm"> */</span>
<span class="cp">#define INST_VA_TO_PA(addr)							\</span>
<span class="cp">	dep	addr	= 0, addr, 61, 3</span>
<span class="cm">/*</span>
<span class="cm"> * This macro converts a data virtual address to a physical address</span>
<span class="cm"> * Right now for simulation purposes the virtual addresses are</span>
<span class="cm"> * direct mapped to physical addresses.</span>
<span class="cm"> *	1. Lop off bits 61 thru 63 in the virtual address</span>
<span class="cm"> */</span>
<span class="cp">#define DATA_VA_TO_PA(addr)							\</span>
<span class="cp">	tpa	addr	= addr</span>
<span class="cm">/*</span>
<span class="cm"> * This macro converts a data physical address to a virtual address</span>
<span class="cm"> * Right now for simulation purposes the virtual addresses are</span>
<span class="cm"> * direct mapped to physical addresses.</span>
<span class="cm"> *	1. Put 0x7 in bits 61 thru 63.</span>
<span class="cm"> */</span>
<span class="cp">#define DATA_PA_TO_VA(addr,temp)							\</span>
<span class="cp">	mov	temp	= 0x7	;;							\</span>
<span class="cp">	dep	addr	= temp, addr, 61, 3</span>

<span class="cp">#define GET_THIS_PADDR(reg, var)		\</span>
<span class="cp">	mov	reg = IA64_KR(PER_CPU_DATA);;	\</span>
<span class="cp">        addl	reg = THIS_CPU(var), reg</span>

<span class="cm">/*</span>
<span class="cm"> * This macro jumps to the instruction at the given virtual address</span>
<span class="cm"> * and starts execution in physical mode with all the address</span>
<span class="cm"> * translations turned off.</span>
<span class="cm"> *	1.	Save the current psr</span>
<span class="cm"> *	2.	Make sure that all the upper 32 bits are off</span>
<span class="cm"> *</span>
<span class="cm"> *	3.	Clear the interrupt enable and interrupt state collection bits</span>
<span class="cm"> *		in the psr before updating the ipsr and iip.</span>
<span class="cm"> *</span>
<span class="cm"> *	4.	Turn off the instruction, data and rse translation bits of the psr</span>
<span class="cm"> *		and store the new value into ipsr</span>
<span class="cm"> *		Also make sure that the interrupts are disabled.</span>
<span class="cm"> *		Ensure that we are in little endian mode.</span>
<span class="cm"> *		[psr.{rt, it, dt, i, be} = 0]</span>
<span class="cm"> *</span>
<span class="cm"> *	5.	Get the physical address corresponding to the virtual address</span>
<span class="cm"> *		of the next instruction bundle and put it in iip.</span>
<span class="cm"> *		(Using magic numbers 24 and 40 in the deposint instruction since</span>
<span class="cm"> *		 the IA64_SDK code directly maps to lower 24bits as physical address</span>
<span class="cm"> *		 from a virtual address).</span>
<span class="cm"> *</span>
<span class="cm"> *	6.	Do an rfi to move the values from ipsr to psr and iip to ip.</span>
<span class="cm"> */</span>
<span class="cp">#define  PHYSICAL_MODE_ENTER(temp1, temp2, start_addr, old_psr)				\</span>
<span class="cp">	mov	old_psr = psr;								\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	old_psr = 0, old_psr, 32, 32;						\</span>
<span class="cp">											\</span>
<span class="cp">	mov	ar.rsc = 0 ;								\</span>
<span class="cp">	;;										\</span>
<span class="cp">	srlz.d;										\</span>
<span class="cp">	mov	temp2 = ar.bspstore;							\</span>
<span class="cp">	;;										\</span>
<span class="cp">	DATA_VA_TO_PA(temp2);								\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	temp1 = ar.rnat;							\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	ar.bspstore = temp2;							\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	ar.rnat = temp1;							\</span>
<span class="cp">	mov	temp1 = psr;								\</span>
<span class="cp">	mov	temp2 = psr;								\</span>
<span class="cp">	;;										\</span>
<span class="cp">											\</span>
<span class="cp">	dep	temp2 = 0, temp2, PSR_IC, 2;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	psr.l = temp2;								\</span>
<span class="cp">	;;										\</span>
<span class="cp">	srlz.d;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, 32, 32;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, PSR_IT, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, PSR_DT, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, PSR_RT, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, PSR_I, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = 0, temp1, PSR_IC, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	dep	temp1 = -1, temp1, PSR_MC, 1;						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	cr.ipsr = temp1;							\</span>
<span class="cp">	;;										\</span>
<span class="cp">	LOAD_PHYSICAL(p0, temp2, start_addr);						\</span>
<span class="cp">	;;										\</span>
<span class="cp">	mov	cr.iip = temp2;								\</span>
<span class="cp">	mov	cr.ifs = r0;								\</span>
<span class="cp">	DATA_VA_TO_PA(sp);								\</span>
<span class="cp">	DATA_VA_TO_PA(gp);								\</span>
<span class="cp">	;;										\</span>
<span class="cp">	srlz.i;										\</span>
<span class="cp">	;;										\</span>
<span class="cp">	nop	1;									\</span>
<span class="cp">	nop	2;									\</span>
<span class="cp">	nop	1;									\</span>
<span class="cp">	nop	2;									\</span>
<span class="cp">	rfi;										\</span>
<span class="cp">	;;</span>

<span class="cm">/*</span>
<span class="cm"> * This macro jumps to the instruction at the given virtual address</span>
<span class="cm"> * and starts execution in virtual mode with all the address</span>
<span class="cm"> * translations turned on.</span>
<span class="cm"> *	1.	Get the old saved psr</span>
<span class="cm"> *</span>
<span class="cm"> *	2.	Clear the interrupt state collection bit in the current psr.</span>
<span class="cm"> *</span>
<span class="cm"> *	3.	Set the instruction translation bit back in the old psr</span>
<span class="cm"> *		Note we have to do this since we are right now saving only the</span>
<span class="cm"> *		lower 32-bits of old psr.(Also the old psr has the data and</span>
<span class="cm"> *		rse translation bits on)</span>
<span class="cm"> *</span>
<span class="cm"> *	4.	Set ipsr to this old_psr with &quot;it&quot; bit set and &quot;bn&quot; = 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	5.	Reset the current thread pointer (r13).</span>
<span class="cm"> *</span>
<span class="cm"> *	6.	Set iip to the virtual address of the next instruction bundle.</span>
<span class="cm"> *</span>
<span class="cm"> *	7.	Do an rfi to move ipsr to psr and iip to ip.</span>
<span class="cm"> */</span>

<span class="cp">#define VIRTUAL_MODE_ENTER(temp1, temp2, start_addr, old_psr)	\</span>
<span class="cp">	mov	temp2 = psr;					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	old_psr = temp2;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp2 = 0, temp2, PSR_IC, 2;			\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	psr.l = temp2;					\</span>
<span class="cp">	mov	ar.rsc = 0;					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	srlz.d;							\</span>
<span class="cp">	mov	r13 = ar.k6;					\</span>
<span class="cp">	mov	temp2 = ar.bspstore;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	DATA_PA_TO_VA(temp2,temp1);				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	temp1 = ar.rnat;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	ar.bspstore = temp2;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	ar.rnat = temp1;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	temp1 = old_psr;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	temp2 = 1;					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp1 = temp2, temp1, PSR_IC, 1;		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp1 = temp2, temp1, PSR_IT, 1;		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp1 = temp2, temp1, PSR_DT, 1;		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp1 = temp2, temp1, PSR_RT, 1;		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	dep	temp1 = temp2, temp1, PSR_BN, 1;		\</span>
<span class="cp">	;;							\</span>
<span class="cp">								\</span>
<span class="cp">	mov     cr.ipsr = temp1;				\</span>
<span class="cp">	movl	temp2 = start_addr;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov	cr.iip = temp2;					\</span>
<span class="cp">	movl	gp = __gp					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	DATA_PA_TO_VA(sp, temp1);				\</span>
<span class="cp">	srlz.i;							\</span>
<span class="cp">	;;							\</span>
<span class="cp">	nop	1;						\</span>
<span class="cp">	nop	2;						\</span>
<span class="cp">	nop	1;						\</span>
<span class="cp">	rfi							\</span>
<span class="cp">	;;</span>

<span class="cm">/*</span>
<span class="cm"> * The MCA and INIT stacks in struct ia64_mca_cpu look like normal kernel</span>
<span class="cm"> * stacks, except that the SAL/OS state and a switch_stack are stored near the</span>
<span class="cm"> * top of the MCA/INIT stack.  To support concurrent entry to MCA or INIT, as</span>
<span class="cm"> * well as MCA over INIT, each event needs its own SAL/OS state.  All entries</span>
<span class="cm"> * are 16 byte aligned.</span>
<span class="cm"> *</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      |          pt_regs          |</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      |        switch_stack       |</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      |        SAL/OS state       |</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      |    16 byte scratch area   |</span>
<span class="cm"> *      +---------------------------+ &lt;-------- SP at start of C MCA handler</span>
<span class="cm"> *      |           .....           |</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      | RBS for MCA/INIT handler  |</span>
<span class="cm"> *      +---------------------------+</span>
<span class="cm"> *      | struct task for MCA/INIT  |</span>
<span class="cm"> *      +---------------------------+ &lt;-------- Bottom of MCA/INIT stack</span>
<span class="cm"> */</span>

<span class="cp">#define ALIGN16(x)			((x)&amp;~15)</span>
<span class="cp">#define MCA_PT_REGS_OFFSET		ALIGN16(KERNEL_STACK_SIZE-IA64_PT_REGS_SIZE)</span>
<span class="cp">#define MCA_SWITCH_STACK_OFFSET		ALIGN16(MCA_PT_REGS_OFFSET-IA64_SWITCH_STACK_SIZE)</span>
<span class="cp">#define MCA_SOS_OFFSET			ALIGN16(MCA_SWITCH_STACK_OFFSET-IA64_SAL_OS_STATE_SIZE)</span>
<span class="cp">#define MCA_SP_OFFSET			ALIGN16(MCA_SOS_OFFSET-16)</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_MCA_ASM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
