<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_PROCESSOR_H</span>
<span class="cp">#define _ASM_IA64_PROCESSOR_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 1998-2004 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *	Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 Asit Mallick &lt;asit.k.mallick@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 Don Dugger &lt;don.dugger@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 11/24/98	S.Eranian	added ia64_set_iva()</span>
<span class="cm"> * 12/03/99	D. Mosberger	implement thread_saved_pc() via kernel unwind API</span>
<span class="cm"> * 06/16/00	A. Mallick	added csd/ssd/tssd for ia32 support</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;asm/intrinsics.h&gt;</span>
<span class="cp">#include &lt;asm/kregs.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/ustack.h&gt;</span>

<span class="cp">#define __ARCH_WANT_UNLOCKED_CTXSW</span>
<span class="cp">#define ARCH_HAS_PREFETCH_SWITCH_STACK</span>

<span class="cp">#define IA64_NUM_PHYS_STACK_REG	96</span>
<span class="cp">#define IA64_NUM_DBG_REGS	8</span>

<span class="cp">#define DEFAULT_MAP_BASE	__IA64_UL_CONST(0x2000000000000000)</span>
<span class="cp">#define DEFAULT_TASK_SIZE	__IA64_UL_CONST(0xa000000000000000)</span>

<span class="cm">/*</span>
<span class="cm"> * TASK_SIZE really is a mis-named.  It really is the maximum user</span>
<span class="cm"> * space address (plus one).  On IA-64, there are five regions of 2TB</span>
<span class="cm"> * each (assuming 8KB page size), for a total of 8TB of user virtual</span>
<span class="cm"> * address space.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_SIZE       	DEFAULT_TASK_SIZE</span>

<span class="cm">/*</span>
<span class="cm"> * This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE	(current-&gt;thread.map_base)</span>

<span class="cp">#define IA64_THREAD_FPH_VALID	(__IA64_UL(1) &lt;&lt; 0)	</span><span class="cm">/* floating-point high state valid? */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_DBG_VALID	(__IA64_UL(1) &lt;&lt; 1)	</span><span class="cm">/* debug registers valid? */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_PM_VALID	(__IA64_UL(1) &lt;&lt; 2)	</span><span class="cm">/* performance registers valid? */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_UAC_NOPRINT	(__IA64_UL(1) &lt;&lt; 3)	</span><span class="cm">/* don&#39;t log unaligned accesses */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_UAC_SIGBUS	(__IA64_UL(1) &lt;&lt; 4)	</span><span class="cm">/* generate SIGBUS on unaligned acc. */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_MIGRATION	(__IA64_UL(1) &lt;&lt; 5)	</span><span class="cm">/* require migration</span>
<span class="cm">							   sync at ctx sw */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_FPEMU_NOPRINT (__IA64_UL(1) &lt;&lt; 6)	</span><span class="cm">/* don&#39;t log any fpswa faults */</span><span class="cp"></span>
<span class="cp">#define IA64_THREAD_FPEMU_SIGFPE  (__IA64_UL(1) &lt;&lt; 7)	</span><span class="cm">/* send a SIGFPE for fpswa faults */</span><span class="cp"></span>

<span class="cp">#define IA64_THREAD_UAC_SHIFT	3</span>
<span class="cp">#define IA64_THREAD_UAC_MASK	(IA64_THREAD_UAC_NOPRINT | IA64_THREAD_UAC_SIGBUS)</span>
<span class="cp">#define IA64_THREAD_FPEMU_SHIFT	6</span>
<span class="cp">#define IA64_THREAD_FPEMU_MASK	(IA64_THREAD_FPEMU_NOPRINT | IA64_THREAD_FPEMU_SIGFPE)</span>


<span class="cm">/*</span>
<span class="cm"> * This shift should be large enough to be able to represent 1000000000/itc_freq with good</span>
<span class="cm"> * accuracy while being small enough to fit 10*1000000000&lt;&lt;IA64_NSEC_PER_CYC_SHIFT in 64 bits</span>
<span class="cm"> * (this will give enough slack to represent 10 seconds worth of time as a scaled number).</span>
<span class="cm"> */</span>
<span class="cp">#define IA64_NSEC_PER_CYC_SHIFT	30</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/fpu.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/rse.h&gt;</span>
<span class="cp">#include &lt;asm/unwind.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cp">#include &lt;asm/nodedata.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* like above but expressed as bitfields for more efficient access: */</span>
<span class="k">struct</span> <span class="n">ia64_psr</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">reserved0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">be</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">up</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ac</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">mfl</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">mfh</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">reserved1</span> <span class="o">:</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ic</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">pk</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">reserved2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">dt</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">dfl</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">dfh</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">sp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">pp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">di</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">si</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">db</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">lp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">tb</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rt</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">reserved3</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cpl</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">is</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">mc</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">it</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">id</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">da</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">dd</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ss</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ri</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ed</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bn</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">reserved4</span> <span class="o">:</span> <span class="mi">19</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ia64_isr</span> <span class="p">{</span>
	<span class="n">__u64</span>  <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">code</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">vector</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">reserved1</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">w</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">r</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">na</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">sp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">rs</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">ir</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">ni</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">so</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">ei</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">ed</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">reserved2</span> <span class="o">:</span> <span class="mi">20</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ia64_lid</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u64</span>  <span class="n">rv</span>  <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">__u64</span>  <span class="n">eid</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">__u64</span>  <span class="n">id</span>  <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">__u64</span>  <span class="n">ig</span>  <span class="o">:</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ia64_tpr</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">ig0</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">mic</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">rsv</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">mmi</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">ig1</span> <span class="o">:</span> <span class="mi">47</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ia64_itir</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">rv3</span>  <span class="o">:</span>  <span class="mi">2</span><span class="p">;</span> <span class="cm">/* 0-1 */</span>
		<span class="n">__u64</span> <span class="n">ps</span>   <span class="o">:</span>  <span class="mi">6</span><span class="p">;</span> <span class="cm">/* 2-7 */</span>
		<span class="n">__u64</span> <span class="n">key</span>  <span class="o">:</span> <span class="mi">24</span><span class="p">;</span> <span class="cm">/* 8-31 */</span>
		<span class="n">__u64</span> <span class="n">rv4</span>  <span class="o">:</span> <span class="mi">32</span><span class="p">;</span> <span class="cm">/* 32-63 */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">union</span>  <span class="n">ia64_rr</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u64</span>  <span class="n">ve</span>	<span class="o">:</span>  <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* enable hw walker */</span>
		<span class="n">__u64</span>  <span class="n">reserved0</span><span class="o">:</span>  <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* reserved */</span>
		<span class="n">__u64</span>  <span class="n">ps</span>	<span class="o">:</span>  <span class="mi">6</span><span class="p">;</span>  <span class="cm">/* log page size */</span>
		<span class="n">__u64</span>  <span class="n">rid</span>	<span class="o">:</span> <span class="mi">24</span><span class="p">;</span>  <span class="cm">/* region id */</span>
		<span class="n">__u64</span>  <span class="n">reserved1</span><span class="o">:</span> <span class="mi">32</span><span class="p">;</span>  <span class="cm">/* reserved */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * CPU type, hardware bug flags, and per-CPU state.  Frequently used</span>
<span class="cm"> * state comes earlier:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">softirq_pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itm_delta</span><span class="p">;</span>	<span class="cm">/* # of clock cycles between clock ticks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itm_next</span><span class="p">;</span>		<span class="cm">/* interval timer mask value to use for next clock tick */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsec_per_cyc</span><span class="p">;</span>	<span class="cm">/* (1000000000&lt;&lt;IA64_NSEC_PER_CYC_SHIFT)/itc_freq */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unimpl_va_mask</span><span class="p">;</span>	<span class="cm">/* mask of unimplemented virtual address bits (from PAL) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unimpl_pa_mask</span><span class="p">;</span>	<span class="cm">/* mask of unimplemented physical address bits (from PAL) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itc_freq</span><span class="p">;</span>		<span class="cm">/* frequency of ITC counter */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">proc_freq</span><span class="p">;</span>	<span class="cm">/* frequency of processor */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cyc_per_usec</span><span class="p">;</span>	<span class="cm">/* itc_freq/1000000 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptce_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptce_count</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptce_stride</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ksoftirqd</span><span class="p">;</span>	<span class="cm">/* kernel softirq daemon for this CPU */</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">socket_id</span><span class="p">;</span>	<span class="cm">/* physical processor socket id */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">core_id</span><span class="p">;</span>	<span class="cm">/* core id */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">thread_id</span><span class="p">;</span> <span class="cm">/* thread id */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_log</span><span class="p">;</span>	<span class="cm">/* Total number of logical processors on</span>
<span class="cm">				 * this socket that were successfully booted */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cores_per_socket</span><span class="p">;</span>	<span class="cm">/* Cores per processor socket */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">threads_per_core</span><span class="p">;</span>	<span class="cm">/* Threads per core */</span>
<span class="cp">#endif</span>

	<span class="cm">/* CPUID-derived information: */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ppn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">features</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">revision</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">archrev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">vendor</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">model_name</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">struct</span> <span class="n">ia64_node_data</span> <span class="o">*</span><span class="n">node_data</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span><span class="p">,</span> <span class="n">ia64_cpu_info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;local&quot; data variable.  It refers to the per-CPU data of the currently executing</span>
<span class="cm"> * CPU, much like &quot;current&quot; points to the per-task data of the currently executing task.</span>
<span class="cm"> * Do not use the address of local_cpu_data, since it will be different from</span>
<span class="cm"> * cpu_data(smp_processor_id())!</span>
<span class="cm"> */</span>
<span class="cp">#define local_cpu_data		(&amp;__ia64_per_cpu_var(ia64_cpu_info))</span>
<span class="cp">#define cpu_data(cpu)		(&amp;per_cpu(ia64_cpu_info, cpu))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">print_cpu_info</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="cp">#define SET_UNALIGN_CTL(task,value)								\</span>
<span class="cp">({												\</span>
<span class="cp">	(task)-&gt;thread.flags = (((task)-&gt;thread.flags &amp; ~IA64_THREAD_UAC_MASK)			\</span>
<span class="cp">				| (((value) &lt;&lt; IA64_THREAD_UAC_SHIFT) &amp; IA64_THREAD_UAC_MASK));	\</span>
<span class="cp">	0;											\</span>
<span class="cp">})</span>
<span class="cp">#define GET_UNALIGN_CTL(task,addr)								\</span>
<span class="cp">({												\</span>
<span class="cp">	put_user(((task)-&gt;thread.flags &amp; IA64_THREAD_UAC_MASK) &gt;&gt; IA64_THREAD_UAC_SHIFT,	\</span>
<span class="cp">		 (int __user *) (addr));							\</span>
<span class="cp">})</span>

<span class="cp">#define SET_FPEMU_CTL(task,value)								\</span>
<span class="cp">({												\</span>
<span class="cp">	(task)-&gt;thread.flags = (((task)-&gt;thread.flags &amp; ~IA64_THREAD_FPEMU_MASK)		\</span>
<span class="cp">			  | (((value) &lt;&lt; IA64_THREAD_FPEMU_SHIFT) &amp; IA64_THREAD_FPEMU_MASK));	\</span>
<span class="cp">	0;											\</span>
<span class="cp">})</span>
<span class="cp">#define GET_FPEMU_CTL(task,addr)								\</span>
<span class="cp">({												\</span>
<span class="cp">	put_user(((task)-&gt;thread.flags &amp; IA64_THREAD_FPEMU_MASK) &gt;&gt; IA64_THREAD_FPEMU_SHIFT,	\</span>
<span class="cp">		 (int __user *) (addr));							\</span>
<span class="cp">})</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* various thread flags (see IA64_THREAD_*) */</span>
	<span class="cm">/* writing on_ustack is performance-critical, so it&#39;s worth spending 8 bits on it... */</span>
	<span class="n">__u8</span> <span class="n">on_ustack</span><span class="p">;</span>			<span class="cm">/* executing on user-stacks? */</span>
	<span class="n">__u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u64</span> <span class="n">ksp</span><span class="p">;</span>			<span class="cm">/* kernel stack pointer */</span>
	<span class="n">__u64</span> <span class="n">map_base</span><span class="p">;</span>			<span class="cm">/* base address for get_unmapped_area() */</span>
	<span class="n">__u64</span> <span class="n">rbs_bot</span><span class="p">;</span>			<span class="cm">/* the base address for the RBS */</span>
	<span class="kt">int</span> <span class="n">last_fph_cpu</span><span class="p">;</span>		<span class="cm">/* CPU that may hold the contents of f32-f127 */</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pfm_context</span><span class="p">;</span>		     <span class="cm">/* pointer to detailed PMU context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfm_needs_checking</span><span class="p">;</span>    <span class="cm">/* when &gt;0, pending perfmon work on kernel exit */</span>
<span class="cp"># define INIT_THREAD_PM		.pfm_context =		NULL,     \</span>
<span class="cp">				.pfm_needs_checking =	0UL,</span>
<span class="cp">#else</span>
<span class="cp"># define INIT_THREAD_PM</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbr</span><span class="p">[</span><span class="n">IA64_NUM_DBG_REGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibr</span><span class="p">[</span><span class="n">IA64_NUM_DBG_REGS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="n">fph</span><span class="p">[</span><span class="mi">96</span><span class="p">];</span>	<span class="cm">/* saved/loaded on demand */</span>
<span class="p">};</span>

<span class="cp">#define INIT_THREAD {						\</span>
<span class="cp">	.flags =	0,					\</span>
<span class="cp">	.on_ustack =	0,					\</span>
<span class="cp">	.ksp =		0,					\</span>
<span class="cp">	.map_base =	DEFAULT_MAP_BASE,			\</span>
<span class="cp">	.rbs_bot =	STACK_TOP - DEFAULT_USER_STACK_SIZE,	\</span>
<span class="cp">	.last_fph_cpu =  -1,					\</span>
<span class="cp">	INIT_THREAD_PM						\</span>
<span class="cp">	.dbr =		{0, },					\</span>
<span class="cp">	.ibr =		{0, },					\</span>
<span class="cp">	.fph =		{{{{0}}}, }				\</span>
<span class="cp">}</span>

<span class="cp">#define start_thread(regs,new_ip,new_sp) do {							\</span>
<span class="cp">	regs-&gt;cr_ipsr = ((regs-&gt;cr_ipsr | (IA64_PSR_BITS_TO_SET | IA64_PSR_CPL))		\</span>
<span class="cp">			 &amp; ~(IA64_PSR_BITS_TO_CLEAR | IA64_PSR_RI | IA64_PSR_IS));		\</span>
<span class="cp">	regs-&gt;cr_iip = new_ip;									\</span>
<span class="cp">	regs-&gt;ar_rsc = 0xf;		</span><span class="cm">/* eager mode, privilege level 3 */</span><span class="cp">			\</span>
<span class="cp">	regs-&gt;ar_rnat = 0;									\</span>
<span class="cp">	regs-&gt;ar_bspstore = current-&gt;thread.rbs_bot;						\</span>
<span class="cp">	regs-&gt;ar_fpsr = FPSR_DEFAULT;								\</span>
<span class="cp">	regs-&gt;loadrs = 0;									\</span>
<span class="cp">	regs-&gt;r8 = get_dumpable(current-&gt;mm);	</span><span class="cm">/* set &quot;don&#39;t zap registers&quot; flag */</span><span class="cp">		\</span>
<span class="cp">	regs-&gt;r12 = new_sp - 16;	</span><span class="cm">/* allocate 16 byte scratch area */</span><span class="cp">			\</span>
<span class="cp">	if (unlikely(!get_dumpable(current-&gt;mm))) {							\</span>
<span class="cp">		</span><span class="cm">/*										\</span>
<span class="cm">		 * Zap scratch regs to avoid leaking bits between processes with different	\</span>
<span class="cm">		 * uid/privileges.								\</span>
<span class="cm">		 */</span><span class="cp">										\</span>
<span class="cp">		regs-&gt;ar_pfs = 0; regs-&gt;b0 = 0; regs-&gt;pr = 0;					\</span>
<span class="cp">		regs-&gt;r1 = 0; regs-&gt;r9  = 0; regs-&gt;r11 = 0; regs-&gt;r13 = 0; regs-&gt;r15 = 0;	\</span>
<span class="cp">	}											\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Forward declarations, a strange C thing... */</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Free all resources held by a thread. This is called after the</span>
<span class="cm"> * parent of DEAD_TASK has collected the exit status of the task via</span>
<span class="cm"> * wait().</span>
<span class="cm"> */</span>
<span class="cp">#define release_thread(dead_task)</span>

<span class="cm">/*</span>
<span class="cm"> * This is the mechanism for creating a new kernel thread.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE 1: Only a kernel-only process (ie the swapper or direct</span>
<span class="cm"> * descendants who haven&#39;t done an &quot;execve()&quot;) should use this: it</span>
<span class="cm"> * will work within a system call from a &quot;real&quot; process, but the</span>
<span class="cm"> * process memory space will not be free&#39;d until both the parent and</span>
<span class="cm"> * the child have exited.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE 2: This MUST NOT be an inlined function.  Otherwise, we get</span>
<span class="cm"> * into trouble in init/main.c when the child thread returns to</span>
<span class="cm"> * do_basic_setup() and the timing is such that free_initmem() has</span>
<span class="cm"> * been called already.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">pid_t</span> <span class="n">kernel_thread</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Get wait channel for task P.  */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* Return instruction pointer of blocked task TSK.  */</span>
<span class="cp">#define KSTK_EIP(tsk)					\</span>
<span class="cp">  ({							\</span>
<span class="cp">	struct pt_regs *_regs = task_pt_regs(tsk);	\</span>
<span class="cp">	_regs-&gt;cr_iip + ia64_psr(_regs)-&gt;ri;		\</span>
<span class="cp">  })</span>

<span class="cm">/* Return stack pointer of blocked task TSK.  */</span>
<span class="cp">#define KSTK_ESP(tsk)  ((tsk)-&gt;thread.ksp)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_getreg_unknown_kr</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_setreg_unknown_kr</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define ia64_get_kr(regnum)					\</span>
<span class="cp">({								\</span>
<span class="cp">	unsigned long r = 0;					\</span>
<span class="cp">								\</span>
<span class="cp">	switch (regnum) {					\</span>
<span class="cp">	    case 0: r = ia64_getreg(_IA64_REG_AR_KR0); break;	\</span>
<span class="cp">	    case 1: r = ia64_getreg(_IA64_REG_AR_KR1); break;	\</span>
<span class="cp">	    case 2: r = ia64_getreg(_IA64_REG_AR_KR2); break;	\</span>
<span class="cp">	    case 3: r = ia64_getreg(_IA64_REG_AR_KR3); break;	\</span>
<span class="cp">	    case 4: r = ia64_getreg(_IA64_REG_AR_KR4); break;	\</span>
<span class="cp">	    case 5: r = ia64_getreg(_IA64_REG_AR_KR5); break;	\</span>
<span class="cp">	    case 6: r = ia64_getreg(_IA64_REG_AR_KR6); break;	\</span>
<span class="cp">	    case 7: r = ia64_getreg(_IA64_REG_AR_KR7); break;	\</span>
<span class="cp">	    default: ia64_getreg_unknown_kr(); break;		\</span>
<span class="cp">	}							\</span>
<span class="cp">	r;							\</span>
<span class="cp">})</span>

<span class="cp">#define ia64_set_kr(regnum, r) 					\</span>
<span class="cp">({								\</span>
<span class="cp">	switch (regnum) {					\</span>
<span class="cp">	    case 0: ia64_setreg(_IA64_REG_AR_KR0, r); break;	\</span>
<span class="cp">	    case 1: ia64_setreg(_IA64_REG_AR_KR1, r); break;	\</span>
<span class="cp">	    case 2: ia64_setreg(_IA64_REG_AR_KR2, r); break;	\</span>
<span class="cp">	    case 3: ia64_setreg(_IA64_REG_AR_KR3, r); break;	\</span>
<span class="cp">	    case 4: ia64_setreg(_IA64_REG_AR_KR4, r); break;	\</span>
<span class="cp">	    case 5: ia64_setreg(_IA64_REG_AR_KR5, r); break;	\</span>
<span class="cp">	    case 6: ia64_setreg(_IA64_REG_AR_KR6, r); break;	\</span>
<span class="cp">	    case 7: ia64_setreg(_IA64_REG_AR_KR7, r); break;	\</span>
<span class="cp">	    default: ia64_setreg_unknown_kr(); break;		\</span>
<span class="cp">	}							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * The following three macros can&#39;t be inline functions because we don&#39;t have struct</span>
<span class="cm"> * task_struct at this point.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Return TRUE if task T owns the fph partition of the CPU we&#39;re running on.</span>
<span class="cm"> * Must be called from code that has preemption disabled.</span>
<span class="cm"> */</span>
<span class="cp">#define ia64_is_local_fpu_owner(t)								\</span>
<span class="cp">({												\</span>
<span class="cp">	struct task_struct *__ia64_islfo_task = (t);						\</span>
<span class="cp">	(__ia64_islfo_task-&gt;thread.last_fph_cpu == smp_processor_id()				\</span>
<span class="cp">	 &amp;&amp; __ia64_islfo_task == (struct task_struct *) ia64_get_kr(IA64_KR_FPU_OWNER));	\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * Mark task T as owning the fph partition of the CPU we&#39;re running on.</span>
<span class="cm"> * Must be called from code that has preemption disabled.</span>
<span class="cm"> */</span>
<span class="cp">#define ia64_set_local_fpu_owner(t) do {						\</span>
<span class="cp">	struct task_struct *__ia64_slfo_task = (t);					\</span>
<span class="cp">	__ia64_slfo_task-&gt;thread.last_fph_cpu = smp_processor_id();			\</span>
<span class="cp">	ia64_set_kr(IA64_KR_FPU_OWNER, (unsigned long) __ia64_slfo_task);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/* Mark the fph partition of task T as being invalid on all CPUs.  */</span>
<span class="cp">#define ia64_drop_fpu(t)	((t)-&gt;thread.last_fph_cpu = -1)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ia64_init_fpu</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ia64_save_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fph</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ia64_load_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fph</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_save_debug_regs</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">save_area</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_load_debug_regs</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">save_area</span><span class="p">);</span>

<span class="cp">#define ia64_fph_enable()	do { ia64_rsm(IA64_PSR_DFH); ia64_srlz_d(); } while (0)</span>
<span class="cp">#define ia64_fph_disable()	do { ia64_ssm(IA64_PSR_DFH); ia64_srlz_d(); } while (0)</span>

<span class="cm">/* load fp 0.0 into fph */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_init_fpu</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ia64_fph_enable</span><span class="p">();</span>
	<span class="n">__ia64_init_fpu</span><span class="p">();</span>
	<span class="n">ia64_fph_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* save f32-f127 at FPH */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_save_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fph</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ia64_fph_enable</span><span class="p">();</span>
	<span class="n">__ia64_save_fpu</span><span class="p">(</span><span class="n">fph</span><span class="p">);</span>
	<span class="n">ia64_fph_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* load f32-f127 from FPH */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_load_fpu</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_fpreg</span> <span class="o">*</span><span class="n">fph</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ia64_fph_enable</span><span class="p">();</span>
	<span class="n">__ia64_load_fpu</span><span class="p">(</span><span class="n">fph</span><span class="p">);</span>
	<span class="n">ia64_fph_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">ia64_clear_ic</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">psr</span><span class="p">;</span>
	<span class="n">psr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_PSR</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_rsm</span><span class="p">(</span><span class="n">IA64_PSR_I</span> <span class="o">|</span> <span class="n">IA64_PSR_IC</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">psr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restore the psr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_psr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">psr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_PSR_L</span><span class="p">,</span> <span class="n">psr</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert a translation into an instruction and/or data translation</span>
<span class="cm"> * register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_itr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">tr_num</span><span class="p">,</span>
	  <span class="n">__u64</span> <span class="n">vmaddr</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">pte</span><span class="p">,</span>
	  <span class="n">__u64</span> <span class="n">log_page_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_ITIR</span><span class="p">,</span> <span class="p">(</span><span class="n">log_page_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IFA</span><span class="p">,</span> <span class="n">vmaddr</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">ia64_itri</span><span class="p">(</span><span class="n">tr_num</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="n">ia64_itrd</span><span class="p">(</span><span class="n">tr_num</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert a translation into the instruction and/or data translation</span>
<span class="cm"> * cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_itc</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">vmaddr</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">pte</span><span class="p">,</span>
	  <span class="n">__u64</span> <span class="n">log_page_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_ITIR</span><span class="p">,</span> <span class="p">(</span><span class="n">log_page_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IFA</span><span class="p">,</span> <span class="n">vmaddr</span><span class="p">);</span>
	<span class="n">ia64_stop</span><span class="p">();</span>
	<span class="cm">/* as per EAS2.6, itc must be the last instruction in an instruction group */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">ia64_itci</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="n">ia64_itcd</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Purge a range of addresses from instruction and/or data translation</span>
<span class="cm"> * register(s).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_ptr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">vmaddr</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">log_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">ia64_ptri</span><span class="p">(</span><span class="n">vmaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">log_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="n">ia64_ptrd</span><span class="p">(</span><span class="n">vmaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">log_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Set the interrupt vector address.  The address must be suitably aligned (32KB).  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_iva</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ivt_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IVA</span><span class="p">,</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">ivt_addr</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Set the page table address and control bits.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_pta</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">pta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note: srlz.i implies srlz.d */</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_PTA</span><span class="p">,</span> <span class="n">pta</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_eoi</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_EOI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define cpu_relax()	ia64_hint(ia64_hint_pause)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ia64_get_irr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">/</span> <span class="mi">64</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">%</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">irr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="n">irr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IRR0</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">irr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IRR1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="n">irr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IRR2</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="n">irr</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IRR3</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_lrr0</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_LRR0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_lrr1</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_setreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_LRR1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Given the address to which a spill occurred, return the unat bit</span>
<span class="cm"> * number that corresponds to this address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">ia64_unat_pos</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">spill_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">__u64</span><span class="p">)</span> <span class="n">spill_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the NaT bit of an integer register which was spilled at address</span>
<span class="cm"> * SPILL_ADDR.  UNAT is the mask to be updated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_unat</span> <span class="p">(</span><span class="n">__u64</span> <span class="o">*</span><span class="n">unat</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">spill_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">ia64_unat_pos</span><span class="p">(</span><span class="n">spill_addr</span><span class="p">);</span>
	<span class="n">__u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>

	<span class="o">*</span><span class="n">unat</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">unat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">nat</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return saved PC of a blocked thread.</span>
<span class="cm"> * Note that the only way T can block is through a call to schedule() -&gt; switch_to().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">thread_saved_pc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unw_frame_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>

	<span class="n">unw_init_from_blocked_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unw_unwind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">unw_get_ip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the current instruction/program counter value.</span>
<span class="cm"> */</span>
<span class="cp">#define current_text_addr() \</span>
<span class="cp">	({ void *_pc; _pc = (void *)ia64_getreg(_IA64_REG_IP); _pc; })</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">ia64_get_ivr</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IVR</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_dbr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ia64_set_dbr</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_ITANIUM</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">ia64_get_dbr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">regnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">__ia64_get_dbr</span><span class="p">(</span><span class="n">regnum</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_ITANIUM</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">ia64_rotr</span> <span class="p">(</span><span class="n">__u64</span> <span class="n">w</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">n</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define ia64_rotl(w,n)	ia64_rotr((w), (64) - (n))</span>

<span class="cm">/*</span>
<span class="cm"> * Take a mapped kernel address and return the equivalent address</span>
<span class="cm"> * in the region 7 identity mapped virtual area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ia64_imva</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ia64_tpa</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ARCH_HAS_PREFETCH</span>
<span class="cp">#define ARCH_HAS_PREFETCHW</span>
<span class="cp">#define ARCH_HAS_SPINLOCK_PREFETCH</span>
<span class="cp">#define PREFETCH_STRIDE			L1_CACHE_BYTES</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">prefetch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="n">ia64_lfetch</span><span class="p">(</span><span class="n">ia64_lfhint_none</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">prefetchw</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_lfetch_excl</span><span class="p">(</span><span class="n">ia64_lfhint_none</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define spin_lock_prefetch(x)	prefetchw(x)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boot_option_idle_override</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">idle_boot_override</span> <span class="p">{</span><span class="n">IDLE_NO_OVERRIDE</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IDLE_HALT</span><span class="p">,</span> <span class="n">IDLE_FORCE_MWAIT</span><span class="p">,</span>
			 <span class="n">IDLE_NOMWAIT</span><span class="p">,</span> <span class="n">IDLE_POLL</span><span class="p">};</span>

<span class="kt">void</span> <span class="n">default_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define ia64_platform_is(x) (strcmp(x, platform_name) == 0)</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
