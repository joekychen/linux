<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › sn › shubio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>shubio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_IA64_SN_SHUBIO_H</span>
<span class="cp">#define _ASM_IA64_SN_SHUBIO_H</span>

<span class="cp">#define HUB_WIDGET_ID_MAX	0xf</span>
<span class="cp">#define IIO_NUM_ITTES		7</span>
<span class="cp">#define HUB_NUM_BIG_WINDOW	(IIO_NUM_ITTES - 1)</span>

<span class="cp">#define		IIO_WID			0x00400000	</span><span class="cm">/* Crosstalk Widget Identification */</span><span class="cp"></span>
							<span class="cm">/* This register is also accessible from</span>
<span class="cm">							 * Crosstalk at address 0x0.  */</span>
<span class="cp">#define		IIO_WSTAT		0x00400008	</span><span class="cm">/* Crosstalk Widget Status */</span><span class="cp"></span>
<span class="cp">#define		IIO_WCR			0x00400020	</span><span class="cm">/* Crosstalk Widget Control Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ILAPR		0x00400100	</span><span class="cm">/* IO Local Access Protection Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ILAPO		0x00400108	</span><span class="cm">/* IO Local Access Protection Override */</span><span class="cp"></span>
<span class="cp">#define		IIO_IOWA		0x00400110	</span><span class="cm">/* IO Outbound Widget Access */</span><span class="cp"></span>
<span class="cp">#define		IIO_IIWA		0x00400118	</span><span class="cm">/* IO Inbound Widget Access */</span><span class="cp"></span>
<span class="cp">#define		IIO_IIDEM		0x00400120	</span><span class="cm">/* IO Inbound Device Error Mask */</span><span class="cp"></span>
<span class="cp">#define		IIO_ILCSR		0x00400128	</span><span class="cm">/* IO LLP Control and Status Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ILLR		0x00400130	</span><span class="cm">/* IO LLP Log Register    */</span><span class="cp"></span>
<span class="cp">#define		IIO_IIDSR		0x00400138	</span><span class="cm">/* IO Interrupt Destination */</span><span class="cp"></span>

<span class="cp">#define		IIO_IGFX0		0x00400140	</span><span class="cm">/* IO Graphics Node-Widget Map 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IGFX1		0x00400148	</span><span class="cm">/* IO Graphics Node-Widget Map 1 */</span><span class="cp"></span>

<span class="cp">#define		IIO_ISCR0		0x00400150	</span><span class="cm">/* IO Scratch Register 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ISCR1		0x00400158	</span><span class="cm">/* IO Scratch Register 1 */</span><span class="cp"></span>

<span class="cp">#define		IIO_ITTE1		0x00400160	</span><span class="cm">/* IO Translation Table Entry 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE2		0x00400168	</span><span class="cm">/* IO Translation Table Entry 2 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE3		0x00400170	</span><span class="cm">/* IO Translation Table Entry 3 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE4		0x00400178	</span><span class="cm">/* IO Translation Table Entry 4 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE5		0x00400180	</span><span class="cm">/* IO Translation Table Entry 5 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE6		0x00400188	</span><span class="cm">/* IO Translation Table Entry 6 */</span><span class="cp"></span>
<span class="cp">#define		IIO_ITTE7		0x00400190	</span><span class="cm">/* IO Translation Table Entry 7 */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPRB0		0x00400198	</span><span class="cm">/* IO PRB Entry 0   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRB8		0x004001A0	</span><span class="cm">/* IO PRB Entry 8   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRB9		0x004001A8	</span><span class="cm">/* IO PRB Entry 9   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBA		0x004001B0	</span><span class="cm">/* IO PRB Entry A   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBB		0x004001B8	</span><span class="cm">/* IO PRB Entry B   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBC		0x004001C0	</span><span class="cm">/* IO PRB Entry C   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBD		0x004001C8	</span><span class="cm">/* IO PRB Entry D   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBE		0x004001D0	</span><span class="cm">/* IO PRB Entry E   */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRBF		0x004001D8	</span><span class="cm">/* IO PRB Entry F   */</span><span class="cp"></span>

<span class="cp">#define		IIO_IXCC		0x004001E0	</span><span class="cm">/* IO Crosstalk Credit Count Timeout */</span><span class="cp"></span>
<span class="cp">#define		IIO_IMEM		0x004001E8	</span><span class="cm">/* IO Miscellaneous Error Mask */</span><span class="cp"></span>
<span class="cp">#define		IIO_IXTT		0x004001F0	</span><span class="cm">/* IO Crosstalk Timeout Threshold */</span><span class="cp"></span>
<span class="cp">#define		IIO_IECLR		0x004001F8	</span><span class="cm">/* IO Error Clear Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBCR		0x00400200	</span><span class="cm">/* IO BTE Control Register */</span><span class="cp"></span>

<span class="cp">#define		IIO_IXSM		0x00400208	</span><span class="cm">/* IO Crosstalk Spurious Message */</span><span class="cp"></span>
<span class="cp">#define		IIO_IXSS		0x00400210	</span><span class="cm">/* IO Crosstalk Spurious Sideband */</span><span class="cp"></span>

<span class="cp">#define		IIO_ILCT		0x00400218	</span><span class="cm">/* IO LLP Channel Test    */</span><span class="cp"></span>

<span class="cp">#define		IIO_IIEPH1 		0x00400220	</span><span class="cm">/* IO Incoming Error Packet Header, Part 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IIEPH2 		0x00400228	</span><span class="cm">/* IO Incoming Error Packet Header, Part 2 */</span><span class="cp"></span>

<span class="cp">#define		IIO_ISLAPR 		0x00400230	</span><span class="cm">/* IO SXB Local Access Protection Regster */</span><span class="cp"></span>
<span class="cp">#define		IIO_ISLAPO 		0x00400238	</span><span class="cm">/* IO SXB Local Access Protection Override */</span><span class="cp"></span>

<span class="cp">#define		IIO_IWI			0x00400240	</span><span class="cm">/* IO Wrapper Interrupt Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IWEL		0x00400248	</span><span class="cm">/* IO Wrapper Error Log Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IWC			0x00400250	</span><span class="cm">/* IO Wrapper Control Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IWS			0x00400258	</span><span class="cm">/* IO Wrapper Status Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IWEIM		0x00400260	</span><span class="cm">/* IO Wrapper Error Interrupt Masking Register */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPCA		0x00400300	</span><span class="cm">/* IO PRB Counter Adjust */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPRTE0_A		0x00400308	</span><span class="cm">/* IO PIO Read Address Table Entry 0, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE1_A		0x00400310	</span><span class="cm">/* IO PIO Read Address Table Entry 1, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE2_A		0x00400318	</span><span class="cm">/* IO PIO Read Address Table Entry 2, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE3_A		0x00400320	</span><span class="cm">/* IO PIO Read Address Table Entry 3, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE4_A		0x00400328	</span><span class="cm">/* IO PIO Read Address Table Entry 4, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE5_A		0x00400330	</span><span class="cm">/* IO PIO Read Address Table Entry 5, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE6_A		0x00400338	</span><span class="cm">/* IO PIO Read Address Table Entry 6, Part A */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE7_A		0x00400340	</span><span class="cm">/* IO PIO Read Address Table Entry 7, Part A */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPRTE0_B		0x00400348	</span><span class="cm">/* IO PIO Read Address Table Entry 0, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE1_B		0x00400350	</span><span class="cm">/* IO PIO Read Address Table Entry 1, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE2_B		0x00400358	</span><span class="cm">/* IO PIO Read Address Table Entry 2, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE3_B		0x00400360	</span><span class="cm">/* IO PIO Read Address Table Entry 3, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE4_B		0x00400368	</span><span class="cm">/* IO PIO Read Address Table Entry 4, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE5_B		0x00400370	</span><span class="cm">/* IO PIO Read Address Table Entry 5, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE6_B		0x00400378	</span><span class="cm">/* IO PIO Read Address Table Entry 6, Part B */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPRTE7_B		0x00400380	</span><span class="cm">/* IO PIO Read Address Table Entry 7, Part B */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPDR		0x00400388	</span><span class="cm">/* IO PIO Deallocation Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICDR		0x00400390	</span><span class="cm">/* IO CRB Entry Deallocation Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IFDR		0x00400398	</span><span class="cm">/* IO IOQ FIFO Depth Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_IIAP		0x004003A0	</span><span class="cm">/* IO IIQ Arbitration Parameters */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICMR		0x004003A8	</span><span class="cm">/* IO CRB Management Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICCR		0x004003B0	</span><span class="cm">/* IO CRB Control Register */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICTO		0x004003B8	</span><span class="cm">/* IO CRB Timeout   */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICTP		0x004003C0	</span><span class="cm">/* IO CRB Timeout Prescalar */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB0_A		0x00400400	</span><span class="cm">/* IO CRB Entry 0_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB0_B		0x00400408	</span><span class="cm">/* IO CRB Entry 0_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB0_C		0x00400410	</span><span class="cm">/* IO CRB Entry 0_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB0_D		0x00400418	</span><span class="cm">/* IO CRB Entry 0_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB0_E		0x00400420	</span><span class="cm">/* IO CRB Entry 0_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB1_A		0x00400430	</span><span class="cm">/* IO CRB Entry 1_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB1_B		0x00400438	</span><span class="cm">/* IO CRB Entry 1_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB1_C		0x00400440	</span><span class="cm">/* IO CRB Entry 1_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB1_D		0x00400448	</span><span class="cm">/* IO CRB Entry 1_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB1_E		0x00400450	</span><span class="cm">/* IO CRB Entry 1_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB2_A		0x00400460	</span><span class="cm">/* IO CRB Entry 2_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB2_B		0x00400468	</span><span class="cm">/* IO CRB Entry 2_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB2_C		0x00400470	</span><span class="cm">/* IO CRB Entry 2_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB2_D		0x00400478	</span><span class="cm">/* IO CRB Entry 2_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB2_E		0x00400480	</span><span class="cm">/* IO CRB Entry 2_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB3_A		0x00400490	</span><span class="cm">/* IO CRB Entry 3_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB3_B		0x00400498	</span><span class="cm">/* IO CRB Entry 3_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB3_C		0x004004a0	</span><span class="cm">/* IO CRB Entry 3_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB3_D		0x004004a8	</span><span class="cm">/* IO CRB Entry 3_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB3_E		0x004004b0	</span><span class="cm">/* IO CRB Entry 3_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB4_A		0x004004c0	</span><span class="cm">/* IO CRB Entry 4_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB4_B		0x004004c8	</span><span class="cm">/* IO CRB Entry 4_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB4_C		0x004004d0	</span><span class="cm">/* IO CRB Entry 4_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB4_D		0x004004d8	</span><span class="cm">/* IO CRB Entry 4_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB4_E		0x004004e0	</span><span class="cm">/* IO CRB Entry 4_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB5_A		0x004004f0	</span><span class="cm">/* IO CRB Entry 5_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB5_B		0x004004f8	</span><span class="cm">/* IO CRB Entry 5_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB5_C		0x00400500	</span><span class="cm">/* IO CRB Entry 5_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB5_D		0x00400508	</span><span class="cm">/* IO CRB Entry 5_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB5_E		0x00400510	</span><span class="cm">/* IO CRB Entry 5_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB6_A		0x00400520	</span><span class="cm">/* IO CRB Entry 6_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB6_B		0x00400528	</span><span class="cm">/* IO CRB Entry 6_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB6_C		0x00400530	</span><span class="cm">/* IO CRB Entry 6_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB6_D		0x00400538	</span><span class="cm">/* IO CRB Entry 6_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB6_E		0x00400540	</span><span class="cm">/* IO CRB Entry 6_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB7_A		0x00400550	</span><span class="cm">/* IO CRB Entry 7_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB7_B		0x00400558	</span><span class="cm">/* IO CRB Entry 7_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB7_C		0x00400560	</span><span class="cm">/* IO CRB Entry 7_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB7_D		0x00400568	</span><span class="cm">/* IO CRB Entry 7_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB7_E		0x00400570	</span><span class="cm">/* IO CRB Entry 7_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB8_A		0x00400580	</span><span class="cm">/* IO CRB Entry 8_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB8_B		0x00400588	</span><span class="cm">/* IO CRB Entry 8_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB8_C		0x00400590	</span><span class="cm">/* IO CRB Entry 8_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB8_D		0x00400598	</span><span class="cm">/* IO CRB Entry 8_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB8_E		0x004005a0	</span><span class="cm">/* IO CRB Entry 8_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRB9_A		0x004005b0	</span><span class="cm">/* IO CRB Entry 9_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB9_B		0x004005b8	</span><span class="cm">/* IO CRB Entry 9_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB9_C		0x004005c0	</span><span class="cm">/* IO CRB Entry 9_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB9_D		0x004005c8	</span><span class="cm">/* IO CRB Entry 9_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRB9_E		0x004005d0	</span><span class="cm">/* IO CRB Entry 9_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRBA_A		0x004005e0	</span><span class="cm">/* IO CRB Entry A_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBA_B		0x004005e8	</span><span class="cm">/* IO CRB Entry A_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBA_C		0x004005f0	</span><span class="cm">/* IO CRB Entry A_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBA_D		0x004005f8	</span><span class="cm">/* IO CRB Entry A_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBA_E		0x00400600	</span><span class="cm">/* IO CRB Entry A_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRBB_A		0x00400610	</span><span class="cm">/* IO CRB Entry B_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBB_B		0x00400618	</span><span class="cm">/* IO CRB Entry B_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBB_C		0x00400620	</span><span class="cm">/* IO CRB Entry B_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBB_D		0x00400628	</span><span class="cm">/* IO CRB Entry B_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBB_E		0x00400630	</span><span class="cm">/* IO CRB Entry B_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRBC_A		0x00400640	</span><span class="cm">/* IO CRB Entry C_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBC_B		0x00400648	</span><span class="cm">/* IO CRB Entry C_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBC_C		0x00400650	</span><span class="cm">/* IO CRB Entry C_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBC_D		0x00400658	</span><span class="cm">/* IO CRB Entry C_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBC_E		0x00400660	</span><span class="cm">/* IO CRB Entry C_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRBD_A		0x00400670	</span><span class="cm">/* IO CRB Entry D_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBD_B		0x00400678	</span><span class="cm">/* IO CRB Entry D_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBD_C		0x00400680	</span><span class="cm">/* IO CRB Entry D_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBD_D		0x00400688	</span><span class="cm">/* IO CRB Entry D_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBD_E		0x00400690	</span><span class="cm">/* IO CRB Entry D_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICRBE_A		0x004006a0	</span><span class="cm">/* IO CRB Entry E_A */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBE_B		0x004006a8	</span><span class="cm">/* IO CRB Entry E_B */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBE_C		0x004006b0	</span><span class="cm">/* IO CRB Entry E_C */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBE_D		0x004006b8	</span><span class="cm">/* IO CRB Entry E_D */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICRBE_E		0x004006c0	</span><span class="cm">/* IO CRB Entry E_E */</span><span class="cp"></span>

<span class="cp">#define		IIO_ICSML		0x00400700	</span><span class="cm">/* IO CRB Spurious Message Low */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICSMM		0x00400708	</span><span class="cm">/* IO CRB Spurious Message Middle */</span><span class="cp"></span>
<span class="cp">#define		IIO_ICSMH		0x00400710	</span><span class="cm">/* IO CRB Spurious Message High */</span><span class="cp"></span>

<span class="cp">#define		IIO_IDBSS		0x00400718	</span><span class="cm">/* IO Debug Submenu Select */</span><span class="cp"></span>

<span class="cp">#define		IIO_IBLS0		0x00410000	</span><span class="cm">/* IO BTE Length Status 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBSA0		0x00410008	</span><span class="cm">/* IO BTE Source Address 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBDA0		0x00410010	</span><span class="cm">/* IO BTE Destination Address 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBCT0		0x00410018	</span><span class="cm">/* IO BTE Control Terminate 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBNA0		0x00410020	</span><span class="cm">/* IO BTE Notification Address 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBIA0		0x00410028	</span><span class="cm">/* IO BTE Interrupt Address 0 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBLS1		0x00420000	</span><span class="cm">/* IO BTE Length Status 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBSA1		0x00420008	</span><span class="cm">/* IO BTE Source Address 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBDA1		0x00420010	</span><span class="cm">/* IO BTE Destination Address 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBCT1		0x00420018	</span><span class="cm">/* IO BTE Control Terminate 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBNA1		0x00420020	</span><span class="cm">/* IO BTE Notification Address 1 */</span><span class="cp"></span>
<span class="cp">#define		IIO_IBIA1		0x00420028	</span><span class="cm">/* IO BTE Interrupt Address 1 */</span><span class="cp"></span>

<span class="cp">#define		IIO_IPCR		0x00430000	</span><span class="cm">/* IO Performance Control */</span><span class="cp"></span>
<span class="cp">#define		IIO_IPPR		0x00430008	</span><span class="cm">/* IO Performance Profiling */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register echoes some information from the         *</span>
<span class="cm"> * LB_REV_ID register. It is available through Crosstalk as described   *</span>
<span class="cm"> * above. The REV_NUM and MFG_NUM fields receive their values from      *</span>
<span class="cm"> * the REVISION and MANUFACTURER fields in the LB_REV_ID register.      *</span>
<span class="cm"> * The PART_NUM field&#39;s value is the Crosstalk device ID number that    *</span>
<span class="cm"> * Steve Miller assigned to the SHub chip.                              *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_wid_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_wid_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">w_rsvd_1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_mfg_num</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_part_num</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rev_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_wid_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_wid_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  The fields in this register are set upon detection of an error      *</span>
<span class="cm"> * and cleared by various mechanisms, as explained in the               *</span>
<span class="cm"> * description.                                                         *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_wstat_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_wstat_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">w_pending</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_xt_crd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_xt_tail_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd_3</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_tx_mx_rty</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd_2</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_llp_tx_cnt</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd_1</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_crazy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd</span><span class="o">:</span><span class="mi">31</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_wstat_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_wstat_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This is a read-write enabled register. It controls     *</span>
<span class="cm"> * various aspects of the Crosstalk flow control.                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_wcr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_wcr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">w_wid</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_tag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd_1</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_dst_crd</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_f_bad_pkt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_dir_con</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_e_thresh</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">w_rsvd</span><span class="o">:</span><span class="mi">41</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_wcr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_wcr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register&#39;s value is a bit vector that guards      *</span>
<span class="cm"> * access to local registers within the II as well as to external       *</span>
<span class="cm"> * Crosstalk widgets. Each bit in the register corresponds to a         *</span>
<span class="cm"> * particular region in the system; a region consists of one, two or    *</span>
<span class="cm"> * four nodes (depending on the value of the REGION_SIZE field in the   *</span>
<span class="cm"> * LB_REV_ID register, which is documented in Section 8.3.1.1). The     *</span>
<span class="cm"> * protection provided by this register applies to PIO read             *</span>
<span class="cm"> * operations as well as PIO write operations. The II will perform a    *</span>
<span class="cm"> * PIO read or write request only if the bit for the requestor&#39;s        *</span>
<span class="cm"> * region is set; otherwise, the II will not perform the requested      *</span>
<span class="cm"> * operation and will return an error response. When a PIO read or      *</span>
<span class="cm"> * write request targets an external Crosstalk widget, then not only    *</span>
<span class="cm"> * must the bit for the requestor&#39;s region be set in the ILAPR, but     *</span>
<span class="cm"> * also the target widget&#39;s bit in the IOWA register must be set in     *</span>
<span class="cm"> * order for the II to perform the requested operation; otherwise,      *</span>
<span class="cm"> * the II will return an error response. Hence, the protection          *</span>
<span class="cm"> * provided by the IOWA register supplements the protection provided    *</span>
<span class="cm"> * by the ILAPR for requests that target external Crosstalk widgets.    *</span>
<span class="cm"> * This register itself can be accessed only by the nodes whose         *</span>
<span class="cm"> * region ID bits are enabled in this same register. It can also be     *</span>
<span class="cm"> * accessed through the IAlias space by the local processors.           *</span>
<span class="cm"> * The reset value of this register allows access by all nodes.         *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ilapr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ilapr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_region</span><span class="o">:</span><span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ilapr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ilapr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  A write to this register of the 64-bit value           *</span>
<span class="cm"> * &quot;SGIrules&quot; in ASCII, will cause the bit in the ILAPR register        *</span>
<span class="cm"> * corresponding to the region of the requestor to be set (allow        *</span>
<span class="cm"> * access). A write of any other value will be ignored. Access          *</span>
<span class="cm"> * protection for this register is &quot;SGIrules&quot;.                          *</span>
<span class="cm"> * This register can also be accessed through the IAlias space.         *</span>
<span class="cm"> * However, this access will not change the access permissions in the   *</span>
<span class="cm"> * ILAPR.                                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ilapo_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ilapo_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_io_ovrride</span><span class="o">:</span><span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ilapo_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ilapo_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register qualifies all the PIO and Graphics writes launched    *</span>
<span class="cm"> * from the SHUB towards a widget.                                      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iowa_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iowa_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w0_oac</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wx_oac</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iowa_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iowa_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register qualifies all the requests launched      *</span>
<span class="cm"> * from a widget towards the Shub. This register is intended to be      *</span>
<span class="cm"> * used by software in case of misbehaving widgets.                     *</span>
<span class="cm"> *									*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iiwa_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iiwa_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w0_iac</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wx_iac</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iiwa_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iiwa_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register qualifies all the operations launched    *</span>
<span class="cm"> * from a widget towards the SHub. It allows individual access          *</span>
<span class="cm"> * control for up to 8 devices per widget. A device refers to           *</span>
<span class="cm"> * individual DMA master hosted by a widget.                            *</span>
<span class="cm"> * The bits in each field of this register are cleared by the Shub      *</span>
<span class="cm"> * upon detection of an error which requires the device to be           *</span>
<span class="cm"> * disabled. These fields assume that 0=TNUM=7 (i.e., Bridge-centric    *</span>
<span class="cm"> * Crosstalk). Whether or not a device has access rights to this        *</span>
<span class="cm"> * Shub is determined by an AND of the device enable bit in the         *</span>
<span class="cm"> * appropriate field of this register and the corresponding bit in      *</span>
<span class="cm"> * the Wx_IAC field (for the widget which this device belongs to).      *</span>
<span class="cm"> * The bits in this field are set by writing a 1 to them. Incoming      *</span>
<span class="cm"> * replies from Crosstalk are not subject to this access control        *</span>
<span class="cm"> * mechanism.                                                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iidem_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iidem_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w8_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w9_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wa_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wb_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wc_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wd_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_we_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wf_dxs</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iidem_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iidem_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the various programmable fields necessary    *</span>
<span class="cm"> * for controlling and observing the LLP signals.                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ilcsr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ilcsr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_nullto</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_4</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_wrmrst</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_llp_en</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_bm8</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_llp_stat</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_remote_power</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_maxrtry</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_d_avail_sel</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_maxbrst</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">22</span><span class="p">;</span>

	<span class="p">}</span> <span class="n">ii_ilcsr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ilcsr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This is simply a status registers that monitors the LLP error       *</span>
<span class="cm"> * rate.								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_illr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_illr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_sn_cnt</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cb_cnt</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_illr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_illr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  All II-detected non-BTE error interrupts are           *</span>
<span class="cm"> * specified via this register.                                         *</span>
<span class="cm"> * NOTE: The PI interrupt register address is hardcoded in the II. If   *</span>
<span class="cm"> * PI_ID==0, then the II sends an interrupt request (Duplonet PWRI      *</span>
<span class="cm"> * packet) to address offset 0x0180_0090 within the local register      *</span>
<span class="cm"> * address space of PI0 on the node specified by the NODE field. If     *</span>
<span class="cm"> * PI_ID==1, then the II sends the interrupt request to address         *</span>
<span class="cm"> * offset 0x01A0_0090 within the local register address space of PI1    *</span>
<span class="cm"> * on the node specified by the NODE field.                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iidsr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iidsr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_level</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pi_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_node</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_3</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_enable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_int_sent</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pi0_forward_int</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pi1_forward_int</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">30</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iidsr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iidsr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are two instances of this register. This register is used     *</span>
<span class="cm"> * for matching up the incoming responses from the graphics widget to   *</span>
<span class="cm"> * the processor that initiated the graphics operation. The             *</span>
<span class="cm"> * write-responses are converted to graphics credits and returned to    *</span>
<span class="cm"> * the processor so that the processor interface can manage the flow    *</span>
<span class="cm"> * control.                                                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_igfx0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_igfx0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pi_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_n_num</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_p_num</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">46</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_igfx0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_igfx0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are two instances of this register. This register is used     *</span>
<span class="cm"> * for matching up the incoming responses from the graphics widget to   *</span>
<span class="cm"> * the processor that initiated the graphics operation. The             *</span>
<span class="cm"> * write-responses are converted to graphics credits and returned to    *</span>
<span class="cm"> * the processor so that the processor interface can manage the flow    *</span>
<span class="cm"> * control.                                                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_igfx1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_igfx1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pi_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_n_num</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_p_num</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">46</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_igfx1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_igfx1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are two instances of this registers. These registers are      *</span>
<span class="cm"> * used as scratch registers for software use.                          *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iscr0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iscr0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_scratch</span><span class="o">:</span><span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iscr0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iscr0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are two instances of this registers. These registers are      *</span>
<span class="cm"> * used as scratch registers for software use.                          *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iscr1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iscr1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_scratch</span><span class="o">:</span><span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iscr1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iscr1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a Shub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the SHub is thus the lower 16 GBytes per widget       * </span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the Shub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a Shub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the Shub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the Shub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte2_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte2_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte2_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte2_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a Shub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the Shub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the SHub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte3_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte3_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte3_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte3_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a SHub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the SHub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the SHub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte4_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte4_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte4_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte4_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a SHub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the Shub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the Shub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte5_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte5_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte5_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte5_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a Shub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the Shub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the Shub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte6_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte6_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte6_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte6_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are seven instances of translation table entry   *</span>
<span class="cm"> * registers. Each register maps a Shub Big Window to a 48-bit          *</span>
<span class="cm"> * address on Crosstalk.                                                *</span>
<span class="cm"> * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *</span>
<span class="cm"> * number) are used to select one of these 7 registers. The Widget      *</span>
<span class="cm"> * number field is then derived from the W_NUM field for synthesizing   *</span>
<span class="cm"> * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *</span>
<span class="cm"> * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *</span>
<span class="cm"> * are padded with zeros. Although the maximum Crosstalk space          *</span>
<span class="cm"> * addressable by the Shub is thus the lower 16 GBytes per widget       *</span>
<span class="cm"> * (M-mode), however only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt; of this       *</span>
<span class="cm"> * space can be accessed.                                               *</span>
<span class="cm"> * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *</span>
<span class="cm"> * Window number) are used to select one of these 7 registers. The      *</span>
<span class="cm"> * Widget number field is then derived from the W_NUM field for         *</span>
<span class="cm"> * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *</span>
<span class="cm"> * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *</span>
<span class="cm"> * field is used as Crosstalk[47], and remainder of the Crosstalk       *</span>
<span class="cm"> * address bits (Crosstalk[46:34]) are always zero. While the maximum   *</span>
<span class="cm"> * Crosstalk space addressable by the SHub is thus the lower            *</span>
<span class="cm"> * 8-GBytes per widget (N-mode), only &lt;SUP &gt;7&lt;/SUP&gt;/&lt;SUB &gt;32nds&lt;/SUB&gt;   *</span>
<span class="cm"> * of this space can be accessed.                                       *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_itte7_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_itte7_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_offset</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_w_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iosp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_itte7_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_itte7_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprb0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprb0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprb0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprb0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprb8_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprb8_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprb8_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprb8_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprb9_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprb9_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprb9_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprb9_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.        *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> *									*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprba_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprba_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprba_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprba_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprbb_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprbb_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprbb_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprbb_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprbc_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprbc_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprbc_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprbc_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprbd_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprbd_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprbd_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprbd_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of SHub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprbe_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprbe_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprbe_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprbe_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 9 instances of this register, one per        *</span>
<span class="cm"> * actual widget in this implementation of Shub and Crossbow.           *</span>
<span class="cm"> * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *</span>
<span class="cm"> * refers to Crossbow&#39;s internal space.                                 *</span>
<span class="cm"> * This register contains the state elements per widget that are        *</span>
<span class="cm"> * necessary to manage the PIO flow control on Crosstalk and on the     *</span>
<span class="cm"> * Router Network. See the PIO Flow Control chapter for a complete      *</span>
<span class="cm"> * description of this register                                         *</span>
<span class="cm"> * The SPUR_WR bit requires some explanation. When this register is     *</span>
<span class="cm"> * written, the new value of the C field is captured in an internal     *</span>
<span class="cm"> * register so the hardware can remember what the programmer wrote      *</span>
<span class="cm"> * into the credit counter. The SPUR_WR bit sets whenever the C field   *</span>
<span class="cm"> * increments above this stored value, which indicates that there       *</span>
<span class="cm"> * have been more responses received than requests sent. The SPUR_WR    *</span>
<span class="cm"> * bit cannot be cleared until a value is written to the IPRBx          *</span>
<span class="cm"> * register; the write will correct the C field and capture its new     *</span>
<span class="cm"> * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *</span>
<span class="cm"> * SPUR_WR bit will persist if IPRBx hasn&#39;t yet been written.           *</span>
<span class="cm"> * .    								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprbf_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprbf_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_c</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_na</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_nb</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_m</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_of_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_wr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mult_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprbe_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprbf_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register specifies the timeout value to use for monitoring     *</span>
<span class="cm"> * Crosstalk credits which are used outbound to Crosstalk. An           *</span>
<span class="cm"> * internal counter called the Crosstalk Credit Timeout Counter         *</span>
<span class="cm"> * increments every 128 II clocks. The counter starts counting          *</span>
<span class="cm"> * anytime the credit count drops below a threshold, and resets to      *</span>
<span class="cm"> * zero (stops counting) anytime the credit count is at or above the    *</span>
<span class="cm"> * threshold. The threshold is 1 credit in direct connect mode and 2    *</span>
<span class="cm"> * in Crossbow connect mode. When the internal Crosstalk Credit         *</span>
<span class="cm"> * Timeout Counter reaches the value programmed in this register, a     *</span>
<span class="cm"> * Crosstalk Credit Timeout has occurred. The internal counter is not   *</span>
<span class="cm"> * readable from software, and stops counting at its maximum value,     *</span>
<span class="cm"> * so it cannot cause more than one interrupt.                          *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ixcc_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ixcc_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_time_out</span><span class="o">:</span><span class="mi">26</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">38</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ixcc_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ixcc_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register qualifies all the PIO and DMA            *</span>
<span class="cm"> * operations launched from widget 0 towards the SHub. In               *</span>
<span class="cm"> * addition, it also qualifies accesses by the BTE streams.             *</span>
<span class="cm"> * The bits in each field of this register are cleared by the SHub      *</span>
<span class="cm"> * upon detection of an error which requires widget 0 or the BTE        *</span>
<span class="cm"> * streams to be terminated. Whether or not widget x has access         *</span>
<span class="cm"> * rights to this SHub is determined by an AND of the device            *</span>
<span class="cm"> * enable bit in the appropriate field of this register and bit 0 in    *</span>
<span class="cm"> * the Wx_IAC field. The bits in this field are set by writing a 1 to   *</span>
<span class="cm"> * them. Incoming replies from Crosstalk are not subject to this        *</span>
<span class="cm"> * access control mechanism.                                            *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_imem_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_imem_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_w0_esd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_3</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_b0_esd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_b1_esd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_clr_precise</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_imem_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_imem_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register specifies the timeout value to use for   *</span>
<span class="cm"> * monitoring Crosstalk tail flits coming into the Shub in the          *</span>
<span class="cm"> * TAIL_TO field. An internal counter associated with this register     *</span>
<span class="cm"> * is incremented every 128 II internal clocks (7 bits). The counter    *</span>
<span class="cm"> * starts counting anytime a header micropacket is received and stops   *</span>
<span class="cm"> * counting (and resets to zero) any time a micropacket with a Tail     *</span>
<span class="cm"> * bit is received. Once the counter reaches the threshold value        *</span>
<span class="cm"> * programmed in this register, it generates an interrupt to the        *</span>
<span class="cm"> * processor that is programmed into the IIDSR. The counter saturates   *</span>
<span class="cm"> * (does not roll over) at its maximum value, so it cannot cause        *</span>
<span class="cm"> * another interrupt until after it is cleared.                         *</span>
<span class="cm"> * The register also contains the Read Response Timeout values. The     *</span>
<span class="cm"> * Prescalar is 23 bits, and counts II clocks. An internal counter      *</span>
<span class="cm"> * increments on every II clock and when it reaches the value in the    *</span>
<span class="cm"> * Prescalar field, all IPRTE registers with their valid bits set       *</span>
<span class="cm"> * have their Read Response timers bumped. Whenever any of them match   *</span>
<span class="cm"> * the value in the RRSP_TO field, a Read Response Timeout has          *</span>
<span class="cm"> * occurred, and error handling occurs as described in the Error        *</span>
<span class="cm"> * Handling section of this document.                                   *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ixtt_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ixtt_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_tail_to</span><span class="o">:</span><span class="mi">26</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rrsp_ps</span><span class="o">:</span><span class="mi">23</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rrsp_to</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ixtt_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ixtt_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Writing a 1 to the fields of this register clears the appropriate   *</span>
<span class="cm"> * error bits in other areas of SHub. Note that when the                *</span>
<span class="cm"> * E_PRB_x bits are used to clear error bits in PRB registers,          *</span>
<span class="cm"> * SPUR_RD and SPUR_WR may persist, because they require additional     *</span>
<span class="cm"> * action to clear them. See the IPRBx and IXSS Register                *</span>
<span class="cm"> * specifications.                                                      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ieclr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ieclr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_e_prb_0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_8</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_9</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_a</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_b</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_c</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_d</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_e</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_prb_f</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_crazy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_bte_0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_e_bte_1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved_1</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_spur_rd_hdr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_intr_to</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_read_miss</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_rep_cred_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_req_cred_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_ii_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved_2</span><span class="o">:</span><span class="mi">21</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ieclr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ieclr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register controls both BTEs. SOFT_RESET is intended for        *</span>
<span class="cm"> * recovery after an error. COUNT controls the total number of CRBs     *</span>
<span class="cm"> * that both BTEs (combined) can use, which affects total BTE           *</span>
<span class="cm"> * bandwidth.                                                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibcr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibcr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_count</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_soft_reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">55</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibcr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibcr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the header of a spurious read response       *</span>
<span class="cm"> * received from Crosstalk. A spurious read response is defined as a    *</span>
<span class="cm"> * read response received by II from a widget for which (1) the SIDN    *</span>
<span class="cm"> * has a value between 1 and 7, inclusive (II never sends requests to   *</span>
<span class="cm"> * these widgets (2) there is no valid IPRTE register which             *</span>
<span class="cm"> * corresponds to the TNUM, or (3) the widget indicated in SIDN is      *</span>
<span class="cm"> * not the same as the widget recorded in the IPRTE register            *</span>
<span class="cm"> * referenced by the TNUM. If this condition is true, and if the        *</span>
<span class="cm"> * IXSS[VALID] bit is clear, then the header of the spurious read       *</span>
<span class="cm"> * response is capture in IXSM and IXSS, and IXSS[VALID] is set. The    *</span>
<span class="cm"> * errant header is thereby captured, and no further spurious read      *</span>
<span class="cm"> * respones are captured until IXSS[VALID] is cleared by setting the    *</span>
<span class="cm"> * appropriate bit in IECLR. Every time a spurious read response is     *</span>
<span class="cm"> * detected, the SPUR_RD bit of the PRB corresponding to the incoming   *</span>
<span class="cm"> * message&#39;s SIDN field is set. This always happens, regarless of       *</span>
<span class="cm"> * whether a header is captured. The programmer should check            *</span>
<span class="cm"> * IXSM[SIDN] to determine which widget sent the spurious response,     *</span>
<span class="cm"> * because there may be more than one SPUR_RD bit set in the PRB        *</span>
<span class="cm"> * registers. The widget indicated by IXSM[SIDN] was the first          *</span>
<span class="cm"> * spurious read response to be received since the last time            *</span>
<span class="cm"> * IXSS[VALID] was clear. The SPUR_RD bit of the corresponding PRB      *</span>
<span class="cm"> * will be set. Any SPUR_RD bits in any other PRB registers indicate    *</span>
<span class="cm"> * spurious messages from other widets which were detected after the    *</span>
<span class="cm"> * header was captured..                                                *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ixsm_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ixsm_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_byte_en</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tag</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_alt_pactyp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_bo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vbpm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_gbr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ds</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ct</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tnum</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pactyp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_sidn</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_didn</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ixsm_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ixsm_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the sideband bits of a spurious read         *</span>
<span class="cm"> * response received from Crosstalk.                                    *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ixss_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ixss_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_sideband</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">55</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ixss_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ixss_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register enables software to access the II LLP&#39;s test port.    *</span>
<span class="cm"> * Refer to the LLP 2.5 documentation for an explanation of the test    *</span>
<span class="cm"> * port. Software can write to this register to program the values      *</span>
<span class="cm"> * for the control fields (TestErrCapture, TestClear, TestFlit,         *</span>
<span class="cm"> * TestMask and TestSeed). Similarly, software can read from this       *</span>
<span class="cm"> * register to obtain the values of the test port&#39;s status outputs      *</span>
<span class="cm"> * (TestCBerr, TestValid and TestData).                                 *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ilct_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ilct_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_test_seed</span><span class="o">:</span><span class="mi">20</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_mask</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_data</span><span class="o">:</span><span class="mi">20</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_cberr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_flit</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_clear</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_test_err_capture</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">9</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ilct_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ilct_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  If the II detects an illegal incoming Duplonet packet (request or   *</span>
<span class="cm"> * reply) when VALID==0 in the IIEPH1 register, then it saves the       *</span>
<span class="cm"> * contents of the packet&#39;s header flit in the IIEPH1 and IIEPH2        *</span>
<span class="cm"> * registers, sets the VALID bit in IIEPH1, clears the OVERRUN bit,     *</span>
<span class="cm"> * and assigns a value to the ERR_TYPE field which indicates the        *</span>
<span class="cm"> * specific nature of the error. The II recognizes four different       *</span>
<span class="cm"> * types of errors: short request packets (ERR_TYPE==2), short reply    *</span>
<span class="cm"> * packets (ERR_TYPE==3), long request packets (ERR_TYPE==4) and long   *</span>
<span class="cm"> * reply packets (ERR_TYPE==5). The encodings for these types of        *</span>
<span class="cm"> * errors were chosen to be consistent with the same types of errors    *</span>
<span class="cm"> * indicated by the ERR_TYPE field in the LB_ERROR_HDR1 register (in    *</span>
<span class="cm"> * the LB unit). If the II detects an illegal incoming Duplonet         *</span>
<span class="cm"> * packet when VALID==1 in the IIEPH1 register, then it merely sets     *</span>
<span class="cm"> * the OVERRUN bit to indicate that a subsequent error has happened,    *</span>
<span class="cm"> * and does nothing further.                                            *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iieph1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iieph1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_command</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_5</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_suppl</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_3</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_err_type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_overrun</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iieph1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iieph1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register holds the Address field from the header flit of an    *</span>
<span class="cm"> * incoming erroneous Duplonet packet, along with the tail bit which    *</span>
<span class="cm"> * accompanied this header flit. This register is essentially an        *</span>
<span class="cm"> * extension of IIEPH1. Two registers were necessary because the 64     *</span>
<span class="cm"> * bits available in only a single register were insufficient to        *</span>
<span class="cm"> * capture the entire header flit of an erroneous packet.               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iieph2_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iieph2_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_0</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tail</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iieph2_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iieph2_u_t</span><span class="p">;</span>

<span class="cm">/******************************/</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register&#39;s value is a bit vector that guards access from SXBs  *</span>
<span class="cm"> * to local registers within the II as well as to external Crosstalk    *</span>
<span class="cm"> * widgets								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_islapr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_islapr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_region</span><span class="o">:</span><span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_islapr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_islapr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  A write to this register of the 56-bit value &quot;Pup+Bun&quot; will cause	*</span>
<span class="cm"> * the bit in the ISLAPR register corresponding to the region of the	*</span>
<span class="cm"> * requestor to be set (access allowed).				(</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_islapo_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_islapo_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_io_sbx_ovrride</span><span class="o">:</span><span class="mi">56</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_islapo_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_islapo_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Determines how long the wrapper will wait aftr an interrupt is	*</span>
<span class="cm"> * initially issued from the II before it times out the outstanding	*</span>
<span class="cm"> * interrupt and drops it from the interrupt queue.			* </span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iwi_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iwi_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_prescale</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_timeout</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd1</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_intrpt_retry_period</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd2</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iwi_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iwi_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Log errors which have occurred in the II wrapper. The errors are	*</span>
<span class="cm"> * cleared by writing to the IECLR register.				* </span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iwel_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iwel_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_intr_timed_out</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_read_miss</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd2</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_rep_cred_over_under</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_req_cred_over_under</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd3</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_ii_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd4</span><span class="o">:</span><span class="mi">30</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iwel_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iwel_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Controls the II wrapper.						* </span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iwc_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iwc_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_dma_byte_swap</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_read_lines_reset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_cred_over_under_log</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd2</span><span class="o">:</span><span class="mi">19</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_rep_iq_depth</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd3</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_req_iq_depth</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd4</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_depth</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd5</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_force_rep_cred</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_force_req_cred</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iwc_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iwc_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Status in the II wrapper.						* </span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iws_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iws_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_xn_rep_iq_credits</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_req_iq_credits</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd1</span><span class="o">:</span><span class="mi">51</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iws_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iws_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Masks errors in the IWEL register.					*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iweim_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iweim_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_intr_timed_out</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cam_read_miss</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_underflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_rep_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iiq_req_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd2</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_rep_cred_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_req_cred_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd3</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ii_xn_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xn_ii_invalid_cmd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd4</span><span class="o">:</span><span class="mi">30</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iweim_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iweim_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  A write to this register causes a particular field in the           *</span>
<span class="cm"> * corresponding widget&#39;s PRB entry to be adjusted up or down by 1.     *</span>
<span class="cm"> * This counter should be used when recovering from error and reset     *</span>
<span class="cm"> * conditions. Note that software would be capable of causing           *</span>
<span class="cm"> * inadvertent overflow or underflow of these counters.                 *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ipca_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ipca_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_wid</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_adjust</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_field</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ipca_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ipca_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte0a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte0a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte0a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte0a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte1a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte1a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte1a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte1a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte2a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte2a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte2a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte2a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte3a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte3a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte3a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte3a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte4a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte4a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte4a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte4a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte5a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte5a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte5a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte5a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte6a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte6a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte6a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte6a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte7a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte7a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">54</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprtea7_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte7a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte0b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte0b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte0b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte0b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte1b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte1b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte1b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte1b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte2b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte2b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte2b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte2b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte3b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte3b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte3b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte3b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte4b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte4b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte4b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte4b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte5b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte5b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte5b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte5b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte6b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte6b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>

	<span class="p">}</span> <span class="n">ii_iprte6b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte6b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  There are 8 instances of this register. This register contains      *</span>
<span class="cm"> * the information that the II has to remember once it has launched a   *</span>
<span class="cm"> * PIO Read operation. The contents are used to form the correct        *</span>
<span class="cm"> * Router Network packet and direct the Crosstalk reply to the          *</span>
<span class="cm"> * appropriate processor.                                               *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iprte7b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iprte7b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_address</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iprte7b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iprte7b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  SHub II contains a feature which did not exist in      *</span>
<span class="cm"> * the Hub which automatically cleans up after a Read Response          *</span>
<span class="cm"> * timeout, including deallocation of the IPRTE and recovery of IBuf    *</span>
<span class="cm"> * space. The inclusion of this register in SHub is for backward        *</span>
<span class="cm"> * compatibility                                                        *</span>
<span class="cm"> * A write to this register causes an entry from the table of           *</span>
<span class="cm"> * outstanding PIO Read Requests to be freed and returned to the        *</span>
<span class="cm"> * stack of free entries. This register is used in handling the         *</span>
<span class="cm"> * timeout errors that result in a PIO Reply never returning from       *</span>
<span class="cm"> * Crosstalk.                                                           *</span>
<span class="cm"> * Note that this register does not affect the contents of the IPRTE    *</span>
<span class="cm"> * registers. The Valid bits in those registers have to be              *</span>
<span class="cm"> * specifically turned off by software.                                 *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ipdr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ipdr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_te</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pnd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init_rpcnt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">58</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ipdr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ipdr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  A write to this register causes a CRB entry to be returned to the   *</span>
<span class="cm"> * queue of free CRBs. The entry should have previously been cleared    *</span>
<span class="cm"> * (mark bit) via backdoor access to the pertinent CRB entry. This      *</span>
<span class="cm"> * register is used in the last step of handling the errors that are    *</span>
<span class="cm"> * captured and marked in CRB entries.  Briefly: 1) first error for     *</span>
<span class="cm"> * DMA write from a particular device, and first error for a            *</span>
<span class="cm"> * particular BTE stream, lead to a marked CRB entry, and processor     *</span>
<span class="cm"> * interrupt, 2) software reads the error information captured in the   *</span>
<span class="cm"> * CRB entry, and presumably takes some corrective action, 3)           *</span>
<span class="cm"> * software clears the mark bit, and finally 4) software writes to      *</span>
<span class="cm"> * the ICDR register to return the CRB entry to the list of free CRB    *</span>
<span class="cm"> * entries.                                                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icdr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icdr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_crb_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pnd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">59</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icdr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icdr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register provides debug access to two FIFOs inside of II.      *</span>
<span class="cm"> * Both IOQ_MAX* fields of this register contain the instantaneous      *</span>
<span class="cm"> * depth (in units of the number of available entries) of the           *</span>
<span class="cm"> * associated IOQ FIFO.  A read of this register will return the        *</span>
<span class="cm"> * number of free entries on each FIFO at the time of the read.  So     *</span>
<span class="cm"> * when a FIFO is idle, the associated field contains the maximum       *</span>
<span class="cm"> * depth of the FIFO.  This register is writable for debug reasons      *</span>
<span class="cm"> * and is intended to be written with the maximum desired FIFO depth    *</span>
<span class="cm"> * while the FIFO is idle. Software must assure that II is idle when    *</span>
<span class="cm"> * this register is written. If there are any active entries in any     *</span>
<span class="cm"> * of these FIFOs when this register is written, the results are        *</span>
<span class="cm"> * undefined.                                                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ifdr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ifdr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_ioq_max_rq</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_set_ioq_rq</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ioq_max_rp</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_set_ioq_rp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ifdr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ifdr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register allows the II to become sluggish in removing          *</span>
<span class="cm"> * messages from its inbound queue (IIQ). This will cause messages to   *</span>
<span class="cm"> * back up in either virtual channel. Disabling the &quot;molasses&quot; mode     *</span>
<span class="cm"> * subsequently allows the II to be tested under stress. In the         *</span>
<span class="cm"> * sluggish (&quot;Molasses&quot;) mode, the localized effects of congestion      *</span>
<span class="cm"> * can be observed.                                                     *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iiap_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iiap_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rq_mls</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rp_mls</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">50</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iiap_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iiap_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register allows several parameters of CRB operation to be      *</span>
<span class="cm"> * set. Note that writing to this register can have catastrophic side   *</span>
<span class="cm"> * effects, if the CRB is not quiescent, i.e. if the CRB is             *</span>
<span class="cm"> * processing protocol messages when the write occurs.                  *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icmr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icmr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_sp_msg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rd_hdr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_4</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_c_cnt</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_3</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_clr_rqpd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_clr_rppd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_fc_cnt</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_crb_vld</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_crb_mark</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_precise</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icmr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icmr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register allows control of the table portion of the CRB        *</span>
<span class="cm"> * logic via software. Control operations from this register have       *</span>
<span class="cm"> * priority over all incoming Crosstalk or BTE requests.                *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_iccr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_iccr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_crb_num</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cmd</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_pending</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_iccr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_iccr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register allows the maximum timeout value to be programmed.    *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icto_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icto_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_timeout</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">56</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icto_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icto_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register allows the timeout prescalar to be programmed. An     *</span>
<span class="cm"> * internal counter is associated with this register. When the          *</span>
<span class="cm"> * internal counter reaches the value of the PRESCALE field, the        *</span>
<span class="cm"> * timer registers in all valid CRBs are incremented (CRBx_D[TIMEOUT]   *</span>
<span class="cm"> * field). The internal counter resets to zero, and then continues      *</span>
<span class="cm"> * counting.                                                            *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ictp_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ictp_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_prescale</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">40</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ictp_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ictp_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *</span>
<span class="cm"> * used for Crosstalk operations (both cacheline and partial            *</span>
<span class="cm"> * operations) or BTE/IO. Because the CRB entries are very wide, five   *</span>
<span class="cm"> * registers (_A to _E) are required to read and write each entry.      *</span>
<span class="cm"> * The CRB Entry registers can be conceptualized as rows and columns    *</span>
<span class="cm"> * (illustrated in the table above). Each row contains the 4            *</span>
<span class="cm"> * registers required for a single CRB Entry. The first doubleword      *</span>
<span class="cm"> * (column) for each entry is labeled A, and the second doubleword      *</span>
<span class="cm"> * (higher address) is labeled B, the third doubleword is labeled C,    *</span>
<span class="cm"> * the fourth doubleword is labeled D and the fifth doubleword is       *</span>
<span class="cm"> * labeled E. All CRB entries have their addresses on a quarter         *</span>
<span class="cm"> * cacheline aligned boundary.                   *</span>
<span class="cm"> * Upon reset, only the following fields are initialized: valid         *</span>
<span class="cm"> * (VLD), priority count, timeout, timeout valid, and context valid.    *</span>
<span class="cm"> * All other bits should be cleared by software before use (after       *</span>
<span class="cm"> * recovering any potential error state from before the reset).         *</span>
<span class="cm"> * The following four tables summarize the format for the four          *</span>
<span class="cm"> * registers that are used for each ICRB# Entry.                        *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icrb0_a_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icrb0_a_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ia_iow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ia_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ia_addr</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ia_tnum</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ia_sidn</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ia_rsvd</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icrb0_a_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icrb0_a_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *</span>
<span class="cm"> * used for Crosstalk operations (both cacheline and partial            *</span>
<span class="cm"> * operations) or BTE/IO. Because the CRB entries are very wide, five   *</span>
<span class="cm"> * registers (_A to _E) are required to read and write each entry.      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icrb0_b_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icrb0_b_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ib_xt_err</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_mark</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_ln_uce</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_errcode</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_stall__bte_1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_stall__bte_0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_stall__intr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_stall_ib</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_intvn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_wb</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_hold</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_ack</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_resp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_ack_cnt</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_rsvd</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_exc</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_imsg</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_imsgtype</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_use_old</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ib_rsvd_1</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icrb0_b_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icrb0_b_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *</span>
<span class="cm"> * used for Crosstalk operations (both cacheline and partial            *</span>
<span class="cm"> * operations) or BTE/IO. Because the CRB entries are very wide, five   *</span>
<span class="cm"> * registers (_A to _E) are required to read and write each entry.      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icrb0_c_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icrb0_c_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ic_source</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_size</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_ct</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_bte_num</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_gbr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_resprqd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_bo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_suppl</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ic_rsvd</span><span class="o">:</span><span class="mi">27</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icrb0_c_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icrb0_c_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *</span>
<span class="cm"> * used for Crosstalk operations (both cacheline and partial            *</span>
<span class="cm"> * operations) or BTE/IO. Because the CRB entries are very wide, five   *</span>
<span class="cm"> * registers (_A to _E) are required to read and write each entry.      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icrb0_d_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icrb0_d_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">id_pa_be</span><span class="o">:</span><span class="mi">43</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">id_bte_op</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">id_pr_psc</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">id_pr_cnt</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">id_sleep</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">id_rsvd</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icrb0_d_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icrb0_d_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *</span>
<span class="cm"> * used for Crosstalk operations (both cacheline and partial            *</span>
<span class="cm"> * operations) or BTE/IO. Because the CRB entries are very wide, five   *</span>
<span class="cm"> * registers (_A to _E) are required to read and write each entry.      *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icrb0_e_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icrb0_e_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ie_timeout</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ie_context</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ie_rsvd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ie_tvld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ie_cvld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ie_rsvd_0</span><span class="o">:</span><span class="mi">38</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icrb0_e_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icrb0_e_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the lower 64 bits of the header of the       *</span>
<span class="cm"> * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *</span>
<span class="cm"> * register is set.                                                     *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icsml_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icsml_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_tt_addr</span><span class="o">:</span><span class="mi">47</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_newsuppl_ex</span><span class="o">:</span><span class="mi">14</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_overflow</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icsml_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icsml_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the middle 64 bits of the header of the      *</span>
<span class="cm"> * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *</span>
<span class="cm"> * register is set.                                                     *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icsmm_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icsmm_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_tt_ack_cnt</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved</span><span class="o">:</span><span class="mi">53</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icsmm_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icsmm_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the microscopic state, all the inputs to     *</span>
<span class="cm"> * the protocol table, captured with the spurious message. Valid when   *</span>
<span class="cm"> * the SP_MSG bit in the ICMR register is set.                          *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_icsmh_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_icsmh_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_tt_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_xerr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ft_cwact_o</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ft_wact_o</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ft_active_o</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_sync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mnusg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_mnusz</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_plusz</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_plusg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_exc</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_wb</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_hold</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_ack</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_resp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_intvn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_g_stall_bte1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_g_stall_bte0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_g_stall_il</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_g_stall_ib</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_imsg</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_imsgtype</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_use_old</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_respreqd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_bte_num</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_cbn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_match</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_lt_34</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_ge_34</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_lt_18</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_ge_18</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_lt_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rpcnt_ge_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rqcnt_lt_18</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rqcnt_ge_18</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rqcnt_lt_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rqcnt_ge_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_device</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_tt_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_reserved</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_icsmh_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_icsmh_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  The Shub DEBUG unit provides a 3-bit selection signal to the        *</span>
<span class="cm"> * II core and a 3-bit selection signal to the fsbclk domain in the II  *</span>
<span class="cm"> * wrapper.                                                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_idbss_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_idbss_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_iioclk_core_submenu</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_fsbclk_wrapper_submenu</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_iioclk_menu</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">43</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_idbss_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_idbss_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register is used to set up the length for a       *</span>
<span class="cm"> * transfer and then to monitor the progress of that transfer. This     *</span>
<span class="cm"> * register needs to be initialized before a transfer is started. A     *</span>
<span class="cm"> * legitimate write to this register will set the Busy bit, clear the   *</span>
<span class="cm"> * Error bit, and initialize the length to the value desired.           *</span>
<span class="cm"> * While the transfer is in progress, hardware will decrement the       *</span>
<span class="cm"> * length field with each successful block that is copied. Once the     *</span>
<span class="cm"> * transfer completes, hardware will clear the Busy bit. The length     *</span>
<span class="cm"> * field will also contain the number of cache lines left to be         *</span>
<span class="cm"> * transferred.                                                         *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibls0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibls0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_length</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_busy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">43</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibls0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibls0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register should be loaded before a transfer is started. The    *</span>
<span class="cm"> * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *</span>
<span class="cm"> * address as described in Section 1.3, Figure2 and Figure3. Since      *</span>
<span class="cm"> * the bottom 7 bits of the address are always taken to be zero, BTE    *</span>
<span class="cm"> * transfers are always cacheline-aligned.                              *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibsa0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibsa0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">42</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibsa0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibsa0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register should be loaded before a transfer is started. The    *</span>
<span class="cm"> * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *</span>
<span class="cm"> * address as described in Section 1.3, Figure2 and Figure3. Since      *</span>
<span class="cm"> * the bottom 7 bits of the address are always taken to be zero, BTE    *</span>
<span class="cm"> * transfers are always cacheline-aligned.                              *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibda0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibda0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">42</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibda0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibda0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Writing to this register sets up the attributes of the transfer     *</span>
<span class="cm"> * and initiates the transfer operation. Reading this register has      *</span>
<span class="cm"> * the side effect of terminating any transfer in progress. Note:       *</span>
<span class="cm"> * stopping a transfer midstream could have an adverse impact on the    *</span>
<span class="cm"> * other BTE. If a BTE stream has to be stopped (due to error           *</span>
<span class="cm"> * handling for example), both BTE streams should be stopped and        *</span>
<span class="cm"> * their transfers discarded.                                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibct0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibct0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_zerofill</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_notify</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_poison</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">55</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibct0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibct0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the address to which the WINV is sent.       *</span>
<span class="cm"> * This address has to be cache line aligned.                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibna0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibna0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">42</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibna0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibna0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the programmable level as well as the node   *</span>
<span class="cm"> * ID and PI unit of the processor to which the interrupt will be       *</span>
<span class="cm"> * sent.								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibia0_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibia0_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_node_id</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_level</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">41</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibia0_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibia0_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * Description:  This register is used to set up the length for a       *</span>
<span class="cm"> * transfer and then to monitor the progress of that transfer. This     *</span>
<span class="cm"> * register needs to be initialized before a transfer is started. A     *</span>
<span class="cm"> * legitimate write to this register will set the Busy bit, clear the   *</span>
<span class="cm"> * Error bit, and initialize the length to the value desired.           *</span>
<span class="cm"> * While the transfer is in progress, hardware will decrement the       *</span>
<span class="cm"> * length field with each successful block that is copied. Once the     *</span>
<span class="cm"> * transfer completes, hardware will clear the Busy bit. The length     *</span>
<span class="cm"> * field will also contain the number of cache lines left to be         *</span>
<span class="cm"> * transferred.                                                         *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibls1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibls1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_length</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_busy</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">43</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibls1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibls1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register should be loaded before a transfer is started. The    *</span>
<span class="cm"> * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *</span>
<span class="cm"> * address as described in Section 1.3, Figure2 and Figure3. Since      *</span>
<span class="cm"> * the bottom 7 bits of the address are always taken to be zero, BTE    *</span>
<span class="cm"> * transfers are always cacheline-aligned.                              *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibsa1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibsa1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">33</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibsa1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibsa1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register should be loaded before a transfer is started. The    *</span>
<span class="cm"> * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *</span>
<span class="cm"> * address as described in Section 1.3, Figure2 and Figure3. Since      *</span>
<span class="cm"> * the bottom 7 bits of the address are always taken to be zero, BTE    *</span>
<span class="cm"> * transfers are always cacheline-aligned.                              *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibda1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibda1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">33</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibda1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibda1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  Writing to this register sets up the attributes of the transfer     *</span>
<span class="cm"> * and initiates the transfer operation. Reading this register has      *</span>
<span class="cm"> * the side effect of terminating any transfer in progress. Note:       *</span>
<span class="cm"> * stopping a transfer midstream could have an adverse impact on the    *</span>
<span class="cm"> * other BTE. If a BTE stream has to be stopped (due to error           *</span>
<span class="cm"> * handling for example), both BTE streams should be stopped and        *</span>
<span class="cm"> * their transfers discarded.                                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibct1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibct1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_zerofill</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_notify</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_poison</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">55</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibct1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibct1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the address to which the WINV is sent.       *</span>
<span class="cm"> * This address has to be cache line aligned.                           *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibna1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibna1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">33</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibna1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibna1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register contains the programmable level as well as the node   *</span>
<span class="cm"> * ID and PI unit of the processor to which the interrupt will be       *</span>
<span class="cm"> * sent.								*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ibia1_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ibia1_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_pi_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_node_id</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_level</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">41</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ibia1_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ibia1_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *  This register defines the resources that feed information into      *</span>
<span class="cm"> * the two performance counters located in the IO Performance           *</span>
<span class="cm"> * Profiling Register. There are 17 different quantities that can be    *</span>
<span class="cm"> * measured. Given these 17 different options, the two performance      *</span>
<span class="cm"> * counters have 15 of them in common; menu selections 0 through 0xE    *</span>
<span class="cm"> * are identical for each performance counter. As for the other two     *</span>
<span class="cm"> * options, one is available from one performance counter and the       *</span>
<span class="cm"> * other is available from the other performance counter. Hence, the    *</span>
<span class="cm"> * II supports all 17*16=272 possible combinations of quantities to     *</span>
<span class="cm"> * measure.                                                             *</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ipcr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ipcr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_ippr0_c</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ippr1_c</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_icct</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ipcr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ipcr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> *									*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ii_ippr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ii_ippr_regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_ippr0</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_ippr1</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ii_ippr_fld_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ii_ippr_u_t</span><span class="p">;</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> *									*</span>
<span class="cm"> * The following defines which were not formed into structures are	*</span>
<span class="cm"> * probably identical to another register, and the name of the		*</span>
<span class="cm"> * register is provided against each of these registers. This		*</span>
<span class="cm"> * information needs to be checked carefully				*</span>
<span class="cm"> *									*</span>
<span class="cm"> *		IIO_ICRB1_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB1_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB1_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB1_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB1_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB2_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB2_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB2_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB2_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB2_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB3_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB3_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB3_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB3_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB3_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB4_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB4_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB4_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB4_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB4_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB5_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB5_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB5_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB5_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB5_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB6_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB6_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB6_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB6_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB6_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB7_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB7_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB7_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB7_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB7_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB8_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB8_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB8_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB8_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB8_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRB9_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRB9_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRB9_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRB9_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRB9_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRBA_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRBA_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRBA_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRBA_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRBA_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRBB_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRBB_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRBB_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRBB_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRBB_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRBC_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRBC_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRBC_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRBC_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRBC_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRBD_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRBD_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRBD_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRBD_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRBD_E		IIO_ICRB0_E			*</span>
<span class="cm"> *		IIO_ICRBE_A		IIO_ICRB0_A			*</span>
<span class="cm"> *		IIO_ICRBE_B		IIO_ICRB0_B			*</span>
<span class="cm"> *		IIO_ICRBE_C		IIO_ICRB0_C			*</span>
<span class="cm"> *		IIO_ICRBE_D		IIO_ICRB0_D			*</span>
<span class="cm"> *		IIO_ICRBE_E		IIO_ICRB0_E			*</span>
<span class="cm"> *									*</span>
<span class="cm"> ************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Slightly friendlier names for some common registers.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_WIDGET              IIO_WID		</span><span class="cm">/* Widget identification */</span><span class="cp"></span>
<span class="cp">#define IIO_WIDGET_STAT         IIO_WSTAT	</span><span class="cm">/* Widget status register */</span><span class="cp"></span>
<span class="cp">#define IIO_WIDGET_CTRL         IIO_WCR		</span><span class="cm">/* Widget control register */</span><span class="cp"></span>
<span class="cp">#define IIO_PROTECT             IIO_ILAPR	</span><span class="cm">/* IO interface protection */</span><span class="cp"></span>
<span class="cp">#define IIO_PROTECT_OVRRD       IIO_ILAPO	</span><span class="cm">/* IO protect override */</span><span class="cp"></span>
<span class="cp">#define IIO_OUTWIDGET_ACCESS    IIO_IOWA	</span><span class="cm">/* Outbound widget access */</span><span class="cp"></span>
<span class="cp">#define IIO_INWIDGET_ACCESS     IIO_IIWA	</span><span class="cm">/* Inbound widget access */</span><span class="cp"></span>
<span class="cp">#define IIO_INDEV_ERR_MASK      IIO_IIDEM	</span><span class="cm">/* Inbound device error mask */</span><span class="cp"></span>
<span class="cp">#define IIO_LLP_CSR             IIO_ILCSR	</span><span class="cm">/* LLP control and status */</span><span class="cp"></span>
<span class="cp">#define IIO_LLP_LOG             IIO_ILLR	</span><span class="cm">/* LLP log */</span><span class="cp"></span>
<span class="cp">#define IIO_XTALKCC_TOUT        IIO_IXCC	</span><span class="cm">/* Xtalk credit count timeout */</span><span class="cp"></span>
<span class="cp">#define IIO_XTALKTT_TOUT        IIO_IXTT	</span><span class="cm">/* Xtalk tail timeout */</span><span class="cp"></span>
<span class="cp">#define IIO_IO_ERR_CLR          IIO_IECLR	</span><span class="cm">/* IO error clear */</span><span class="cp"></span>
<span class="cp">#define IIO_IGFX_0 		IIO_IGFX0</span>
<span class="cp">#define IIO_IGFX_1 		IIO_IGFX1</span>
<span class="cp">#define IIO_IBCT_0		IIO_IBCT0</span>
<span class="cp">#define IIO_IBCT_1		IIO_IBCT1</span>
<span class="cp">#define IIO_IBLS_0		IIO_IBLS0</span>
<span class="cp">#define IIO_IBLS_1		IIO_IBLS1</span>
<span class="cp">#define IIO_IBSA_0		IIO_IBSA0</span>
<span class="cp">#define IIO_IBSA_1		IIO_IBSA1</span>
<span class="cp">#define IIO_IBDA_0		IIO_IBDA0</span>
<span class="cp">#define IIO_IBDA_1		IIO_IBDA1</span>
<span class="cp">#define IIO_IBNA_0		IIO_IBNA0</span>
<span class="cp">#define IIO_IBNA_1		IIO_IBNA1</span>
<span class="cp">#define IIO_IBIA_0		IIO_IBIA0</span>
<span class="cp">#define IIO_IBIA_1		IIO_IBIA1</span>
<span class="cp">#define IIO_IOPRB_0		IIO_IPRB0</span>

<span class="cp">#define IIO_PRTE_A(_x)		(IIO_IPRTE0_A + (8 * (_x)))</span>
<span class="cp">#define IIO_PRTE_B(_x)		(IIO_IPRTE0_B + (8 * (_x)))</span>
<span class="cp">#define IIO_NUM_PRTES		8	</span><span class="cm">/* Total number of PRB table entries */</span><span class="cp"></span>
<span class="cp">#define IIO_WIDPRTE_A(x)	IIO_PRTE_A(((x) - 8))	</span><span class="cm">/* widget ID to its PRTE num */</span><span class="cp"></span>
<span class="cp">#define IIO_WIDPRTE_B(x)	IIO_PRTE_B(((x) - 8))	</span><span class="cm">/* widget ID to its PRTE num */</span><span class="cp"></span>

<span class="cp">#define IIO_NUM_IPRBS 		9</span>

<span class="cp">#define IIO_LLP_CSR_IS_UP		0x00002000</span>
<span class="cp">#define IIO_LLP_CSR_LLP_STAT_MASK       0x00003000</span>
<span class="cp">#define IIO_LLP_CSR_LLP_STAT_SHFT       12</span>

<span class="cp">#define IIO_LLP_CB_MAX  0xffff	</span><span class="cm">/* in ILLR CB_CNT, Max Check Bit errors */</span><span class="cp"></span>
<span class="cp">#define IIO_LLP_SN_MAX  0xffff	</span><span class="cm">/* in ILLR SN_CNT, Max Sequence Number errors */</span><span class="cp"></span>

<span class="cm">/* key to IIO_PROTECT_OVRRD */</span>
<span class="cp">#define IIO_PROTECT_OVRRD_KEY   0x53474972756c6573ull	</span><span class="cm">/* &quot;SGIrules&quot; */</span><span class="cp"></span>

<span class="cm">/* BTE register names */</span>
<span class="cp">#define IIO_BTE_STAT_0          IIO_IBLS_0	</span><span class="cm">/* Also BTE length/status 0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_SRC_0           IIO_IBSA_0	</span><span class="cm">/* Also BTE source address  0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_DEST_0          IIO_IBDA_0	</span><span class="cm">/* Also BTE dest. address 0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_CTRL_0          IIO_IBCT_0	</span><span class="cm">/* Also BTE control/terminate 0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_NOTIFY_0        IIO_IBNA_0	</span><span class="cm">/* Also BTE notification 0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_INT_0           IIO_IBIA_0	</span><span class="cm">/* Also BTE interrupt 0 */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_OFF_0           0	</span><span class="cm">/* Base offset from BTE 0 regs. */</span><span class="cp"></span>
<span class="cp">#define IIO_BTE_OFF_1   	(IIO_IBLS_1 - IIO_IBLS_0)	</span><span class="cm">/* Offset from base to BTE 1 */</span><span class="cp"></span>

<span class="cm">/* BTE register offsets from base */</span>
<span class="cp">#define BTEOFF_STAT             0</span>
<span class="cp">#define BTEOFF_SRC      	(IIO_BTE_SRC_0 - IIO_BTE_STAT_0)</span>
<span class="cp">#define BTEOFF_DEST     	(IIO_BTE_DEST_0 - IIO_BTE_STAT_0)</span>
<span class="cp">#define BTEOFF_CTRL     	(IIO_BTE_CTRL_0 - IIO_BTE_STAT_0)</span>
<span class="cp">#define BTEOFF_NOTIFY   	(IIO_BTE_NOTIFY_0 - IIO_BTE_STAT_0)</span>
<span class="cp">#define BTEOFF_INT      	(IIO_BTE_INT_0 - IIO_BTE_STAT_0)</span>

<span class="cm">/* names used in shub diags */</span>
<span class="cp">#define IIO_BASE_BTE0   IIO_IBLS_0</span>
<span class="cp">#define IIO_BASE_BTE1   IIO_IBLS_1</span>

<span class="cm">/*</span>
<span class="cm"> * Macro which takes the widget number, and returns the</span>
<span class="cm"> * IO PRB address of that widget.</span>
<span class="cm"> * value _x is expected to be a widget number in the range</span>
<span class="cm"> * 0, 8 - 0xF</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_IOPRB(_x)	(IIO_IOPRB_0 + ( ( (_x) &lt; HUB_WIDGET_ID_MIN ? \</span>
<span class="cp">                	(_x) : \</span>
<span class="cp">                	(_x) - (HUB_WIDGET_ID_MIN-1)) &lt;&lt; 3) )</span>

<span class="cm">/* GFX Flow Control Node/Widget Register */</span>
<span class="cp">#define IIO_IGFX_W_NUM_BITS	4	</span><span class="cm">/* size of widget num field */</span><span class="cp"></span>
<span class="cp">#define IIO_IGFX_W_NUM_MASK	((1&lt;&lt;IIO_IGFX_W_NUM_BITS)-1)</span>
<span class="cp">#define IIO_IGFX_W_NUM_SHIFT	0</span>
<span class="cp">#define IIO_IGFX_PI_NUM_BITS	1	</span><span class="cm">/* size of PI num field */</span><span class="cp"></span>
<span class="cp">#define IIO_IGFX_PI_NUM_MASK	((1&lt;&lt;IIO_IGFX_PI_NUM_BITS)-1)</span>
<span class="cp">#define IIO_IGFX_PI_NUM_SHIFT	4</span>
<span class="cp">#define IIO_IGFX_N_NUM_BITS	8	</span><span class="cm">/* size of node num field */</span><span class="cp"></span>
<span class="cp">#define IIO_IGFX_N_NUM_MASK	((1&lt;&lt;IIO_IGFX_N_NUM_BITS)-1)</span>
<span class="cp">#define IIO_IGFX_N_NUM_SHIFT	5</span>
<span class="cp">#define IIO_IGFX_P_NUM_BITS	1	</span><span class="cm">/* size of processor num field */</span><span class="cp"></span>
<span class="cp">#define IIO_IGFX_P_NUM_MASK	((1&lt;&lt;IIO_IGFX_P_NUM_BITS)-1)</span>
<span class="cp">#define IIO_IGFX_P_NUM_SHIFT	16</span>
<span class="cp">#define IIO_IGFX_INIT(widget, pi, node, cpu)				(\</span>
<span class="cp">	(((widget) &amp; IIO_IGFX_W_NUM_MASK) &lt;&lt; IIO_IGFX_W_NUM_SHIFT) |	 \</span>
<span class="cp">	(((pi)     &amp; IIO_IGFX_PI_NUM_MASK)&lt;&lt; IIO_IGFX_PI_NUM_SHIFT)|	 \</span>
<span class="cp">	(((node)   &amp; IIO_IGFX_N_NUM_MASK) &lt;&lt; IIO_IGFX_N_NUM_SHIFT) |	 \</span>
<span class="cp">	(((cpu)    &amp; IIO_IGFX_P_NUM_MASK) &lt;&lt; IIO_IGFX_P_NUM_SHIFT))</span>

<span class="cm">/* Scratch registers (all bits available) */</span>
<span class="cp">#define IIO_SCRATCH_REG0        IIO_ISCR0</span>
<span class="cp">#define IIO_SCRATCH_REG1        IIO_ISCR1</span>
<span class="cp">#define IIO_SCRATCH_MASK        0xffffffffffffffffUL</span>

<span class="cp">#define IIO_SCRATCH_BIT0_0      0x0000000000000001UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_1      0x0000000000000002UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_2      0x0000000000000004UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_3      0x0000000000000008UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_4      0x0000000000000010UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_5      0x0000000000000020UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_6      0x0000000000000040UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_7      0x0000000000000080UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_8      0x0000000000000100UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_9      0x0000000000000200UL</span>
<span class="cp">#define IIO_SCRATCH_BIT0_A      0x0000000000000400UL</span>

<span class="cp">#define IIO_SCRATCH_BIT1_0      0x0000000000000001UL</span>
<span class="cp">#define IIO_SCRATCH_BIT1_1      0x0000000000000002UL</span>
<span class="cm">/* IO Translation Table Entries */</span>
<span class="cp">#define IIO_NUM_ITTES   7	</span><span class="cm">/* ITTEs numbered 0..6 */</span><span class="cp"></span>
					<span class="cm">/* Hw manuals number them 1..7! */</span>
<span class="cm">/*</span>
<span class="cm"> * IIO_IMEM Register fields.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_IMEM_W0ESD  0x1UL	</span><span class="cm">/* Widget 0 shut down due to error */</span><span class="cp"></span>
<span class="cp">#define IIO_IMEM_B0ESD	(1UL &lt;&lt; 4)	</span><span class="cm">/* BTE 0 shut down due to error */</span><span class="cp"></span>
<span class="cp">#define IIO_IMEM_B1ESD	(1UL &lt;&lt; 8)	</span><span class="cm">/* BTE 1 Shut down due to error */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * As a permanent workaround for a bug in the PI side of the shub, we&#39;ve</span>
<span class="cm"> * redefined big window 7 as small window 0.</span>
<span class="cm"> XXX does this still apply for SN1??</span>
<span class="cm"> */</span>
<span class="cp">#define HUB_NUM_BIG_WINDOW	(IIO_NUM_ITTES - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Use the top big window as a surrogate for the first small window</span>
<span class="cm"> */</span>
<span class="cp">#define SWIN0_BIGWIN            HUB_NUM_BIG_WINDOW</span>

<span class="cp">#define ILCSR_WARM_RESET        0x100</span>

<span class="cm">/*</span>
<span class="cm"> * CRB manipulation macros</span>
<span class="cm"> *	The CRB macros are slightly complicated, since there are up to</span>
<span class="cm"> *	four registers associated with each CRB entry.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_NUM_CRBS            15	</span><span class="cm">/* Number of CRBs */</span><span class="cp"></span>
<span class="cp">#define IIO_NUM_PC_CRBS         4	</span><span class="cm">/* Number of partial cache CRBs */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_OFFSET         8</span>
<span class="cp">#define IIO_ICRB_0              IIO_ICRB0_A</span>
<span class="cp">#define IIO_ICRB_ADDR_SHFT	2	</span><span class="cm">/* Shift to get proper address */</span><span class="cp"></span>
<span class="cm">/* XXX - This is now tuneable:</span>
<span class="cm">        #define IIO_FIRST_PC_ENTRY 12</span>
<span class="cm"> */</span>

<span class="cp">#define IIO_ICRB_A(_x)	((u64)(IIO_ICRB_0 + (6 * IIO_ICRB_OFFSET * (_x))))</span>
<span class="cp">#define IIO_ICRB_B(_x)	((u64)((char *)IIO_ICRB_A(_x) + 1*IIO_ICRB_OFFSET))</span>
<span class="cp">#define IIO_ICRB_C(_x)	((u64)((char *)IIO_ICRB_A(_x) + 2*IIO_ICRB_OFFSET))</span>
<span class="cp">#define IIO_ICRB_D(_x)	((u64)((char *)IIO_ICRB_A(_x) + 3*IIO_ICRB_OFFSET))</span>
<span class="cp">#define IIO_ICRB_E(_x)	((u64)((char *)IIO_ICRB_A(_x) + 4*IIO_ICRB_OFFSET))</span>

<span class="cp">#define TNUM_TO_WIDGET_DEV(_tnum)	(_tnum &amp; 0x7)</span>

<span class="cm">/*</span>
<span class="cm"> * values for &quot;ecode&quot; field</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_ICRB_ECODE_DERR     0	</span><span class="cm">/* Directory error due to IIO access */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_PERR     1	</span><span class="cm">/* Poison error on IO access */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_WERR     2	</span><span class="cm">/* Write error by IIO access</span>
<span class="cm">					 * e.g. WINV to a Read only line. */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_AERR     3	</span><span class="cm">/* Access error caused by IIO access */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_PWERR    4	</span><span class="cm">/* Error on partial write */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_PRERR    5	</span><span class="cm">/* Error on partial read  */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_TOUT     6	</span><span class="cm">/* CRB timeout before deallocating */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_ECODE_XTERR    7	</span><span class="cm">/* Incoming xtalk pkt had error bit */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Values for field imsgtype</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_ICRB_IMSGT_XTALK    0	</span><span class="cm">/* Incoming Meessage from Xtalk */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_IMSGT_BTE      1	</span><span class="cm">/* Incoming message from BTE    */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_IMSGT_SN1NET   2	</span><span class="cm">/* Incoming message from SN1 net */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_IMSGT_CRB      3	</span><span class="cm">/* Incoming message from CRB ???  */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * values for field initiator.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_ICRB_INIT_XTALK     0	</span><span class="cm">/* Message originated in xtalk  */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_INIT_BTE0      0x1	</span><span class="cm">/* Message originated in BTE 0  */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_INIT_SN1NET    0x2	</span><span class="cm">/* Message originated in SN1net */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_INIT_CRB       0x3	</span><span class="cm">/* Message originated in CRB ?  */</span><span class="cp"></span>
<span class="cp">#define IIO_ICRB_INIT_BTE1      0x5	</span><span class="cm">/* MEssage originated in BTE 1  */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Number of credits Hub widget has while sending req/response to</span>
<span class="cm"> * xbow.</span>
<span class="cm"> * Value of 3 is required by Xbow 1.1</span>
<span class="cm"> * We may be able to increase this to 4 with Xbow 1.2.</span>
<span class="cm"> */</span>
<span class="cp">#define		   HUBII_XBOW_CREDIT       3</span>
<span class="cp">#define		   HUBII_XBOW_REV2_CREDIT  4</span>

<span class="cm">/*</span>
<span class="cm"> * Number of credits that xtalk devices should use when communicating</span>
<span class="cm"> * with a SHub (depth of SHub&#39;s queue).</span>
<span class="cm"> */</span>
<span class="cp">#define HUB_CREDIT 4</span>

<span class="cm">/*</span>
<span class="cm"> * Some IIO_PRB fields</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_PRB_MULTI_ERR	(1LL &lt;&lt; 63)</span>
<span class="cp">#define IIO_PRB_SPUR_RD		(1LL &lt;&lt; 51)</span>
<span class="cp">#define IIO_PRB_SPUR_WR		(1LL &lt;&lt; 50)</span>
<span class="cp">#define IIO_PRB_RD_TO		(1LL &lt;&lt; 49)</span>
<span class="cp">#define IIO_PRB_ERROR		(1LL &lt;&lt; 48)</span>

<span class="cm">/*************************************************************************</span>

<span class="cm"> Some of the IIO field masks and shifts are defined here.</span>
<span class="cm"> This is in order to maintain compatibility in SN0 and SN1 code</span>
<span class="cm"> </span>
<span class="cm">**************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * ICMR register fields</span>
<span class="cm"> * (Note: the IIO_ICMR_P_CNT and IIO_ICMR_PC_VLD from Hub are not</span>
<span class="cm"> * present in SHub)</span>
<span class="cm"> */</span>

<span class="cp">#define IIO_ICMR_CRB_VLD_SHFT   20</span>
<span class="cp">#define IIO_ICMR_CRB_VLD_MASK	(0x7fffUL &lt;&lt; IIO_ICMR_CRB_VLD_SHFT)</span>

<span class="cp">#define IIO_ICMR_FC_CNT_SHFT    16</span>
<span class="cp">#define IIO_ICMR_FC_CNT_MASK	(0xf &lt;&lt; IIO_ICMR_FC_CNT_SHFT)</span>

<span class="cp">#define IIO_ICMR_C_CNT_SHFT     4</span>
<span class="cp">#define IIO_ICMR_C_CNT_MASK	(0xf &lt;&lt; IIO_ICMR_C_CNT_SHFT)</span>

<span class="cp">#define IIO_ICMR_PRECISE	(1UL &lt;&lt; 52)</span>
<span class="cp">#define IIO_ICMR_CLR_RPPD	(1UL &lt;&lt; 13)</span>
<span class="cp">#define IIO_ICMR_CLR_RQPD	(1UL &lt;&lt; 12)</span>

<span class="cm">/*</span>
<span class="cm"> * IIO PIO Deallocation register field masks : (IIO_IPDR)</span>
<span class="cm"> XXX present but not needed in bedrock?  See the manual.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_IPDR_PND    	(1 &lt;&lt; 4)</span>

<span class="cm">/*</span>
<span class="cm"> * IIO CRB deallocation register field masks: (IIO_ICDR)</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_ICDR_PND    	(1 &lt;&lt; 4)</span>

<span class="cm">/* </span>
<span class="cm"> * IO BTE Length/Status (IIO_IBLS) register bit field definitions</span>
<span class="cm"> */</span>
<span class="cp">#define IBLS_BUSY		(0x1UL &lt;&lt; 20)</span>
<span class="cp">#define IBLS_ERROR_SHFT		16</span>
<span class="cp">#define IBLS_ERROR		(0x1UL &lt;&lt; IBLS_ERROR_SHFT)</span>
<span class="cp">#define IBLS_LENGTH_MASK	0xffff</span>

<span class="cm">/*</span>
<span class="cm"> * IO BTE Control/Terminate register (IBCT) register bit field definitions</span>
<span class="cm"> */</span>
<span class="cp">#define IBCT_POISON		(0x1UL &lt;&lt; 8)</span>
<span class="cp">#define IBCT_NOTIFY		(0x1UL &lt;&lt; 4)</span>
<span class="cp">#define IBCT_ZFIL_MODE		(0x1UL &lt;&lt; 0)</span>

<span class="cm">/*</span>
<span class="cm"> * IIO Incoming Error Packet Header (IIO_IIEPH1/IIO_IIEPH2)</span>
<span class="cm"> */</span>
<span class="cp">#define IIEPH1_VALID		(1UL &lt;&lt; 44)</span>
<span class="cp">#define IIEPH1_OVERRUN		(1UL &lt;&lt; 40)</span>
<span class="cp">#define IIEPH1_ERR_TYPE_SHFT	32</span>
<span class="cp">#define IIEPH1_ERR_TYPE_MASK	0xf</span>
<span class="cp">#define IIEPH1_SOURCE_SHFT	20</span>
<span class="cp">#define IIEPH1_SOURCE_MASK	11</span>
<span class="cp">#define IIEPH1_SUPPL_SHFT	8</span>
<span class="cp">#define IIEPH1_SUPPL_MASK	11</span>
<span class="cp">#define IIEPH1_CMD_SHFT		0</span>
<span class="cp">#define IIEPH1_CMD_MASK		7</span>

<span class="cp">#define IIEPH2_TAIL		(1UL &lt;&lt; 40)</span>
<span class="cp">#define IIEPH2_ADDRESS_SHFT	0</span>
<span class="cp">#define IIEPH2_ADDRESS_MASK	38</span>

<span class="cp">#define IIEPH1_ERR_SHORT_REQ	2</span>
<span class="cp">#define IIEPH1_ERR_SHORT_REPLY	3</span>
<span class="cp">#define IIEPH1_ERR_LONG_REQ	4</span>
<span class="cp">#define IIEPH1_ERR_LONG_REPLY	5</span>

<span class="cm">/*</span>
<span class="cm"> * IO Error Clear register bit field definitions</span>
<span class="cm"> */</span>
<span class="cp">#define IECLR_PI1_FWD_INT	(1UL &lt;&lt; 31)	</span><span class="cm">/* clear PI1_FORWARD_INT in iidsr */</span><span class="cp"></span>
<span class="cp">#define IECLR_PI0_FWD_INT	(1UL &lt;&lt; 30)	</span><span class="cm">/* clear PI0_FORWARD_INT in iidsr */</span><span class="cp"></span>
<span class="cp">#define IECLR_SPUR_RD_HDR	(1UL &lt;&lt; 29)	</span><span class="cm">/* clear valid bit in ixss reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_BTE1		(1UL &lt;&lt; 18)	</span><span class="cm">/* clear bte error 1 */</span><span class="cp"></span>
<span class="cp">#define IECLR_BTE0		(1UL &lt;&lt; 17)	</span><span class="cm">/* clear bte error 0 */</span><span class="cp"></span>
<span class="cp">#define IECLR_CRAZY		(1UL &lt;&lt; 16)	</span><span class="cm">/* clear crazy bit in wstat reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_F		(1UL &lt;&lt; 15)	</span><span class="cm">/* clear err bit in PRB_F reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_E		(1UL &lt;&lt; 14)	</span><span class="cm">/* clear err bit in PRB_E reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_D		(1UL &lt;&lt; 13)	</span><span class="cm">/* clear err bit in PRB_D reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_C		(1UL &lt;&lt; 12)	</span><span class="cm">/* clear err bit in PRB_C reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_B		(1UL &lt;&lt; 11)	</span><span class="cm">/* clear err bit in PRB_B reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_A		(1UL &lt;&lt; 10)	</span><span class="cm">/* clear err bit in PRB_A reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_9		(1UL &lt;&lt; 9)	</span><span class="cm">/* clear err bit in PRB_9 reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_8		(1UL &lt;&lt; 8)	</span><span class="cm">/* clear err bit in PRB_8 reg */</span><span class="cp"></span>
<span class="cp">#define IECLR_PRB_0		(1UL &lt;&lt; 0)	</span><span class="cm">/* clear err bit in PRB_0 reg */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * IIO CRB control register Fields: IIO_ICCR </span>
<span class="cm"> */</span>
<span class="cp">#define	IIO_ICCR_PENDING	0x10000</span>
<span class="cp">#define	IIO_ICCR_CMD_MASK	0xFF</span>
<span class="cp">#define	IIO_ICCR_CMD_SHFT	7</span>
<span class="cp">#define	IIO_ICCR_CMD_NOP	0x0	</span><span class="cm">/* No Op */</span><span class="cp"></span>
<span class="cp">#define	IIO_ICCR_CMD_WAKE	0x100	</span><span class="cm">/* Reactivate CRB entry and process */</span><span class="cp"></span>
<span class="cp">#define	IIO_ICCR_CMD_TIMEOUT	0x200	</span><span class="cm">/* Make CRB timeout &amp; mark invalid */</span><span class="cp"></span>
<span class="cp">#define	IIO_ICCR_CMD_EJECT	0x400	</span><span class="cm">/* Contents of entry written to memory</span>
<span class="cm">					 * via a WB</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define	IIO_ICCR_CMD_FLUSH	0x800</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * CRB Register description.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING</span>
<span class="cm"> * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING</span>
<span class="cm"> * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING</span>
<span class="cm"> * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING</span>
<span class="cm"> * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING</span>
<span class="cm"> *</span>
<span class="cm"> * Many of the fields in CRB are status bits used by hardware</span>
<span class="cm"> * for implementation of the protocol. It&#39;s very dangerous to</span>
<span class="cm"> * mess around with the CRB registers.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s OK to read the CRB registers and try to make sense out of the</span>
<span class="cm"> * fields in CRB.</span>
<span class="cm"> *</span>
<span class="cm"> * Updating CRB requires all activities in Hub IIO to be quiesced.</span>
<span class="cm"> * otherwise, a write to CRB could corrupt other CRB entries.</span>
<span class="cm"> * CRBs are here only as a back door peek to shub IIO&#39;s status.</span>
<span class="cm"> * Quiescing implies  no dmas no PIOs</span>
<span class="cm"> * either directly from the cpu or from sn0net.</span>
<span class="cm"> * this is not something that can be done easily. So, AVOID updating</span>
<span class="cm"> * CRBs.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Easy access macros for CRBs, all 5 registers (A-E)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">ii_icrb0_a_u_t</span> <span class="n">icrba_t</span><span class="p">;</span>
<span class="cp">#define a_sidn		ii_icrb0_a_fld_s.ia_sidn</span>
<span class="cp">#define a_tnum		ii_icrb0_a_fld_s.ia_tnum</span>
<span class="cp">#define a_addr          ii_icrb0_a_fld_s.ia_addr</span>
<span class="cp">#define a_valid         ii_icrb0_a_fld_s.ia_vld</span>
<span class="cp">#define a_iow           ii_icrb0_a_fld_s.ia_iow</span>
<span class="cp">#define a_regvalue	ii_icrb0_a_regval</span>

<span class="k">typedef</span> <span class="n">ii_icrb0_b_u_t</span> <span class="n">icrbb_t</span><span class="p">;</span>
<span class="cp">#define b_use_old       ii_icrb0_b_fld_s.ib_use_old</span>
<span class="cp">#define b_imsgtype      ii_icrb0_b_fld_s.ib_imsgtype</span>
<span class="cp">#define b_imsg          ii_icrb0_b_fld_s.ib_imsg</span>
<span class="cp">#define b_initiator     ii_icrb0_b_fld_s.ib_init</span>
<span class="cp">#define b_exc           ii_icrb0_b_fld_s.ib_exc</span>
<span class="cp">#define b_ackcnt        ii_icrb0_b_fld_s.ib_ack_cnt</span>
<span class="cp">#define b_resp          ii_icrb0_b_fld_s.ib_resp</span>
<span class="cp">#define b_ack           ii_icrb0_b_fld_s.ib_ack</span>
<span class="cp">#define b_hold          ii_icrb0_b_fld_s.ib_hold</span>
<span class="cp">#define b_wb            ii_icrb0_b_fld_s.ib_wb</span>
<span class="cp">#define b_intvn         ii_icrb0_b_fld_s.ib_intvn</span>
<span class="cp">#define b_stall_ib      ii_icrb0_b_fld_s.ib_stall_ib</span>
<span class="cp">#define b_stall_int     ii_icrb0_b_fld_s.ib_stall__intr</span>
<span class="cp">#define b_stall_bte_0   ii_icrb0_b_fld_s.ib_stall__bte_0</span>
<span class="cp">#define b_stall_bte_1   ii_icrb0_b_fld_s.ib_stall__bte_1</span>
<span class="cp">#define b_error         ii_icrb0_b_fld_s.ib_error</span>
<span class="cp">#define b_ecode         ii_icrb0_b_fld_s.ib_errcode</span>
<span class="cp">#define b_lnetuce       ii_icrb0_b_fld_s.ib_ln_uce</span>
<span class="cp">#define b_mark          ii_icrb0_b_fld_s.ib_mark</span>
<span class="cp">#define b_xerr          ii_icrb0_b_fld_s.ib_xt_err</span>
<span class="cp">#define b_regvalue	ii_icrb0_b_regval</span>

<span class="k">typedef</span> <span class="n">ii_icrb0_c_u_t</span> <span class="n">icrbc_t</span><span class="p">;</span>
<span class="cp">#define c_suppl         ii_icrb0_c_fld_s.ic_suppl</span>
<span class="cp">#define c_barrop        ii_icrb0_c_fld_s.ic_bo</span>
<span class="cp">#define c_doresp        ii_icrb0_c_fld_s.ic_resprqd</span>
<span class="cp">#define c_gbr           ii_icrb0_c_fld_s.ic_gbr</span>
<span class="cp">#define c_btenum        ii_icrb0_c_fld_s.ic_bte_num</span>
<span class="cp">#define c_cohtrans      ii_icrb0_c_fld_s.ic_ct</span>
<span class="cp">#define c_xtsize        ii_icrb0_c_fld_s.ic_size</span>
<span class="cp">#define c_source        ii_icrb0_c_fld_s.ic_source</span>
<span class="cp">#define c_regvalue	ii_icrb0_c_regval</span>

<span class="k">typedef</span> <span class="n">ii_icrb0_d_u_t</span> <span class="n">icrbd_t</span><span class="p">;</span>
<span class="cp">#define d_sleep         ii_icrb0_d_fld_s.id_sleep</span>
<span class="cp">#define d_pricnt        ii_icrb0_d_fld_s.id_pr_cnt</span>
<span class="cp">#define d_pripsc        ii_icrb0_d_fld_s.id_pr_psc</span>
<span class="cp">#define d_bteop         ii_icrb0_d_fld_s.id_bte_op</span>
<span class="cp">#define d_bteaddr       ii_icrb0_d_fld_s.id_pa_be	</span><span class="cm">/* ic_pa_be fld has 2 names */</span><span class="cp"></span>
<span class="cp">#define d_benable       ii_icrb0_d_fld_s.id_pa_be	</span><span class="cm">/* ic_pa_be fld has 2 names */</span><span class="cp"></span>
<span class="cp">#define d_regvalue	ii_icrb0_d_regval</span>

<span class="k">typedef</span> <span class="n">ii_icrb0_e_u_t</span> <span class="n">icrbe_t</span><span class="p">;</span>
<span class="cp">#define icrbe_ctxtvld   ii_icrb0_e_fld_s.ie_cvld</span>
<span class="cp">#define icrbe_toutvld   ii_icrb0_e_fld_s.ie_tvld</span>
<span class="cp">#define icrbe_context   ii_icrb0_e_fld_s.ie_context</span>
<span class="cp">#define icrbe_timeout   ii_icrb0_e_fld_s.ie_timeout</span>
<span class="cp">#define e_regvalue	ii_icrb0_e_regval</span>

<span class="cm">/* Number of widgets supported by shub */</span>
<span class="cp">#define HUB_NUM_WIDGET          9</span>
<span class="cp">#define HUB_WIDGET_ID_MIN       0x8</span>
<span class="cp">#define HUB_WIDGET_ID_MAX       0xf</span>

<span class="cp">#define HUB_WIDGET_PART_NUM     0xc120</span>
<span class="cp">#define MAX_HUBS_PER_XBOW       2</span>

<span class="cm">/* A few more #defines for backwards compatibility */</span>
<span class="cp">#define iprb_t          ii_iprb0_u_t</span>
<span class="cp">#define iprb_regval     ii_iprb0_regval</span>
<span class="cp">#define iprb_mult_err	ii_iprb0_fld_s.i_mult_err</span>
<span class="cp">#define iprb_spur_rd	ii_iprb0_fld_s.i_spur_rd</span>
<span class="cp">#define iprb_spur_wr	ii_iprb0_fld_s.i_spur_wr</span>
<span class="cp">#define iprb_rd_to	ii_iprb0_fld_s.i_rd_to</span>
<span class="cp">#define iprb_ovflow     ii_iprb0_fld_s.i_of_cnt</span>
<span class="cp">#define iprb_error      ii_iprb0_fld_s.i_error</span>
<span class="cp">#define iprb_ff         ii_iprb0_fld_s.i_f</span>
<span class="cp">#define iprb_mode       ii_iprb0_fld_s.i_m</span>
<span class="cp">#define iprb_bnakctr    ii_iprb0_fld_s.i_nb</span>
<span class="cp">#define iprb_anakctr    ii_iprb0_fld_s.i_na</span>
<span class="cp">#define iprb_xtalkctr   ii_iprb0_fld_s.i_c</span>

<span class="cp">#define LNK_STAT_WORKING        0x2		</span><span class="cm">/* LLP is working */</span><span class="cp"></span>

<span class="cp">#define IIO_WSTAT_ECRAZY	(1ULL &lt;&lt; 32)	</span><span class="cm">/* Hub gone crazy */</span><span class="cp"></span>
<span class="cp">#define IIO_WSTAT_TXRETRY	(1ULL &lt;&lt; 9)	</span><span class="cm">/* Hub Tx Retry timeout */</span><span class="cp"></span>
<span class="cp">#define IIO_WSTAT_TXRETRY_MASK  0x7F		</span><span class="cm">/* should be 0xFF?? */</span><span class="cp"></span>
<span class="cp">#define IIO_WSTAT_TXRETRY_SHFT  16</span>
<span class="cp">#define IIO_WSTAT_TXRETRY_CNT(w)	(((w) &gt;&gt; IIO_WSTAT_TXRETRY_SHFT) &amp; \</span>
<span class="cp">                          		IIO_WSTAT_TXRETRY_MASK)</span>

<span class="cm">/* Number of II perf. counters we can multiplex at once */</span>

<span class="cp">#define IO_PERF_SETS	32</span>

<span class="cm">/* Bit for the widget in inbound access register */</span>
<span class="cp">#define IIO_IIWA_WIDGET(_w)	((u64)(1ULL &lt;&lt; _w))</span>
<span class="cm">/* Bit for the widget in outbound access register */</span>
<span class="cp">#define IIO_IOWA_WIDGET(_w)	((u64)(1ULL &lt;&lt; _w))</span>

<span class="cm">/* NOTE: The following define assumes that we are going to get</span>
<span class="cm"> * widget numbers from 8 thru F and the device numbers within</span>
<span class="cm"> * widget from 0 thru 7.</span>
<span class="cm"> */</span>
<span class="cp">#define IIO_IIDEM_WIDGETDEV_MASK(w, d)	((u64)(1ULL &lt;&lt; (8 * ((w) - 8) + (d))))</span>

<span class="cm">/* IO Interrupt Destination Register */</span>
<span class="cp">#define IIO_IIDSR_SENT_SHIFT    28</span>
<span class="cp">#define IIO_IIDSR_SENT_MASK     0x30000000</span>
<span class="cp">#define IIO_IIDSR_ENB_SHIFT     24</span>
<span class="cp">#define IIO_IIDSR_ENB_MASK      0x01000000</span>
<span class="cp">#define IIO_IIDSR_NODE_SHIFT    9</span>
<span class="cp">#define IIO_IIDSR_NODE_MASK     0x000ff700</span>
<span class="cp">#define IIO_IIDSR_PI_ID_SHIFT   8</span>
<span class="cp">#define IIO_IIDSR_PI_ID_MASK    0x00000100</span>
<span class="cp">#define IIO_IIDSR_LVL_SHIFT     0</span>
<span class="cp">#define IIO_IIDSR_LVL_MASK      0x000000ff</span>

<span class="cm">/* Xtalk timeout threshold register (IIO_IXTT) */</span>
<span class="cp">#define IXTT_RRSP_TO_SHFT	55	</span><span class="cm">/* read response timeout */</span><span class="cp"></span>
<span class="cp">#define IXTT_RRSP_TO_MASK	(0x1FULL &lt;&lt; IXTT_RRSP_TO_SHFT)</span>
<span class="cp">#define IXTT_RRSP_PS_SHFT	32	</span><span class="cm">/* read responsed TO prescalar */</span><span class="cp"></span>
<span class="cp">#define IXTT_RRSP_PS_MASK	(0x7FFFFFULL &lt;&lt; IXTT_RRSP_PS_SHFT)</span>
<span class="cp">#define IXTT_TAIL_TO_SHFT	0	</span><span class="cm">/* tail timeout counter threshold */</span><span class="cp"></span>
<span class="cp">#define IXTT_TAIL_TO_MASK	(0x3FFFFFFULL &lt;&lt; IXTT_TAIL_TO_SHFT)</span>

<span class="cm">/*</span>
<span class="cm"> * The IO LLP control status register and widget control register</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">hubii_wcr_u</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">wcr_reg_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">wcr_widget_id</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span>	<span class="cm">/* LLP crossbar credit */</span>
		 <span class="nl">wcr_tag_mode:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Tag mode */</span>
		 <span class="nl">wcr_rsvd1:</span><span class="mi">8</span><span class="p">,</span>	<span class="cm">/* Reserved */</span>
		 <span class="nl">wcr_xbar_crd:</span><span class="mi">3</span><span class="p">,</span>	<span class="cm">/* LLP crossbar credit */</span>
		 <span class="nl">wcr_f_bad_pkt:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Force bad llp pkt enable */</span>
		 <span class="nl">wcr_dir_con:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* widget direct connect */</span>
		 <span class="nl">wcr_e_thresh:</span><span class="mi">5</span><span class="p">,</span>	<span class="cm">/* elasticity threshold */</span>
		 <span class="nl">wcr_rsvd:</span><span class="mi">41</span><span class="p">;</span>	<span class="cm">/* unused */</span>
	<span class="p">}</span> <span class="n">wcr_fields_s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">hubii_wcr_t</span><span class="p">;</span>

<span class="cp">#define iwcr_dir_con    wcr_fields_s.wcr_dir_con</span>

<span class="cm">/* The structures below are defined to extract and modify the ii</span>
<span class="cm">performance registers */</span>

<span class="cm">/* io_perf_sel allows the caller to specify what tests will be</span>
<span class="cm">   performed */</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">io_perf_sel</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">perf_sel_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">perf_ippr0</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="n">perf_ippr1</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="n">perf_icct</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span> <span class="n">perf_rsvd</span><span class="o">:</span><span class="mi">48</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">perf_sel_bits</span><span class="p">;</span>
<span class="p">}</span> <span class="n">io_perf_sel_t</span><span class="p">;</span>

<span class="cm">/* io_perf_cnt is to extract the count from the shub registers. Due to</span>
<span class="cm">   hardware problems there is only one counter, not two. */</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">io_perf_cnt</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">perf_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">perf_cnt</span><span class="o">:</span><span class="mi">20</span><span class="p">,</span> <span class="n">perf_rsvd2</span><span class="o">:</span><span class="mi">12</span><span class="p">,</span> <span class="n">perf_rsvd1</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">perf_cnt_bits</span><span class="p">;</span>

<span class="p">}</span> <span class="n">io_perf_cnt_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">iprte_a</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">i_rsvd_1</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_addr</span><span class="o">:</span><span class="mi">38</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_init</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_source</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_rsvd</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_widget</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_to_cnt</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">i_vld</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">iprte_fields</span><span class="p">;</span>
<span class="p">}</span> <span class="n">iprte_a_t</span><span class="p">;</span>

<span class="cp">#endif				</span><span class="cm">/* _ASM_IA64_SN_SHUBIO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
