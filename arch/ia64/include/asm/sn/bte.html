<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › sn › bte.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>bte.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2007 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>


<span class="cp">#ifndef _ASM_IA64_SN_BTE_H</span>
<span class="cp">#define _ASM_IA64_SN_BTE_H</span>

<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/types.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shub_mmr.h&gt;</span>

<span class="cp">#define IBCT_NOTIFY             (0x1UL &lt;&lt; 4)</span>
<span class="cp">#define IBCT_ZFIL_MODE          (0x1UL &lt;&lt; 0)</span>

<span class="cm">/* #define BTE_DEBUG */</span>
<span class="cm">/* #define BTE_DEBUG_VERBOSE */</span>

<span class="cp">#ifdef BTE_DEBUG</span>
<span class="cp">#  define BTE_PRINTK(x) printk x	</span><span class="cm">/* Terse */</span><span class="cp"></span>
<span class="cp">#  ifdef BTE_DEBUG_VERBOSE</span>
<span class="cp">#    define BTE_PRINTKV(x) printk x	</span><span class="cm">/* Verbose */</span><span class="cp"></span>
<span class="cp">#  else</span>
<span class="cp">#    define BTE_PRINTKV(x)</span>
<span class="cp">#  endif </span><span class="cm">/* BTE_DEBUG_VERBOSE */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#  define BTE_PRINTK(x)</span>
<span class="cp">#  define BTE_PRINTKV(x)</span>
<span class="cp">#endif	</span><span class="cm">/* BTE_DEBUG */</span><span class="cp"></span>


<span class="cm">/* BTE status register only supports 16 bits for length field */</span>
<span class="cp">#define BTE_LEN_BITS (16)</span>
<span class="cp">#define BTE_LEN_MASK ((1 &lt;&lt; BTE_LEN_BITS) - 1)</span>
<span class="cp">#define BTE_MAX_XFER (BTE_LEN_MASK &lt;&lt; L1_CACHE_SHIFT)</span>


<span class="cm">/* Define hardware */</span>
<span class="cp">#define BTES_PER_NODE (is_shub2() ? 4 : 2)</span>
<span class="cp">#define MAX_BTES_PER_NODE 4</span>

<span class="cp">#define BTE2OFF_CTRL	0</span>
<span class="cp">#define BTE2OFF_SRC	(SH2_BT_ENG_SRC_ADDR_0 - SH2_BT_ENG_CSR_0)</span>
<span class="cp">#define BTE2OFF_DEST	(SH2_BT_ENG_DEST_ADDR_0 - SH2_BT_ENG_CSR_0)</span>
<span class="cp">#define BTE2OFF_NOTIFY	(SH2_BT_ENG_NOTIF_ADDR_0 - SH2_BT_ENG_CSR_0)</span>

<span class="cp">#define BTE_BASE_ADDR(interface) 				\</span>
<span class="cp">    (is_shub2() ? (interface == 0) ? SH2_BT_ENG_CSR_0 :		\</span>
<span class="cp">		  (interface == 1) ? SH2_BT_ENG_CSR_1 :		\</span>
<span class="cp">		  (interface == 2) ? SH2_BT_ENG_CSR_2 :		\</span>
<span class="cp">		  		     SH2_BT_ENG_CSR_3 		\</span>
<span class="cp">		: (interface == 0) ? IIO_IBLS0 : IIO_IBLS1)</span>

<span class="cp">#define BTE_SOURCE_ADDR(base)					\</span>
<span class="cp">    (is_shub2() ? base + (BTE2OFF_SRC/8) 			\</span>
<span class="cp">		: base + (BTEOFF_SRC/8))</span>

<span class="cp">#define BTE_DEST_ADDR(base)					\</span>
<span class="cp">    (is_shub2() ? base + (BTE2OFF_DEST/8) 			\</span>
<span class="cp">		: base + (BTEOFF_DEST/8))</span>

<span class="cp">#define BTE_CTRL_ADDR(base)					\</span>
<span class="cp">    (is_shub2() ? base + (BTE2OFF_CTRL/8) 			\</span>
<span class="cp">		: base + (BTEOFF_CTRL/8))</span>

<span class="cp">#define BTE_NOTIF_ADDR(base)					\</span>
<span class="cp">    (is_shub2() ? base + (BTE2OFF_NOTIFY/8) 			\</span>
<span class="cp">		: base + (BTEOFF_NOTIFY/8))</span>

<span class="cm">/* Define hardware modes */</span>
<span class="cp">#define BTE_NOTIFY IBCT_NOTIFY</span>
<span class="cp">#define BTE_NORMAL BTE_NOTIFY</span>
<span class="cp">#define BTE_ZERO_FILL (BTE_NOTIFY | IBCT_ZFIL_MODE)</span>
<span class="cm">/* Use a reserved bit to let the caller specify a wait for any BTE */</span>
<span class="cp">#define BTE_WACQUIRE 0x4000</span>
<span class="cm">/* Use the BTE on the node with the destination memory */</span>
<span class="cp">#define BTE_USE_DEST (BTE_WACQUIRE &lt;&lt; 1)</span>
<span class="cm">/* Use any available BTE interface on any node for the transfer */</span>
<span class="cp">#define BTE_USE_ANY (BTE_USE_DEST &lt;&lt; 1)</span>
<span class="cm">/* macro to force the IBCT0 value valid */</span>
<span class="cp">#define BTE_VALID_MODE(x) ((x) &amp; (IBCT_NOTIFY | IBCT_ZFIL_MODE))</span>

<span class="cp">#define BTE_ACTIVE		(IBLS_BUSY | IBLS_ERROR)</span>
<span class="cp">#define BTE_WORD_AVAILABLE	(IBLS_BUSY &lt;&lt; 1)</span>
<span class="cp">#define BTE_WORD_BUSY		(~BTE_WORD_AVAILABLE)</span>

<span class="cm">/*</span>
<span class="cm"> * Some macros to simplify reading.</span>
<span class="cm"> * Start with macros to locate the BTE control registers.</span>
<span class="cm"> */</span>
<span class="cp">#define BTE_LNSTAT_LOAD(_bte)						\</span>
<span class="cp">			HUB_L(_bte-&gt;bte_base_addr)</span>
<span class="cp">#define BTE_LNSTAT_STORE(_bte, _x)					\</span>
<span class="cp">			HUB_S(_bte-&gt;bte_base_addr, (_x))</span>
<span class="cp">#define BTE_SRC_STORE(_bte, _x)						\</span>
<span class="cp">({									\</span>
<span class="cp">		u64 __addr = ((_x) &amp; ~AS_MASK);				\</span>
<span class="cp">		if (is_shub2()) 					\</span>
<span class="cp">			__addr = SH2_TIO_PHYS_TO_DMA(__addr);		\</span>
<span class="cp">		HUB_S(_bte-&gt;bte_source_addr, __addr);			\</span>
<span class="cp">})</span>
<span class="cp">#define BTE_DEST_STORE(_bte, _x)					\</span>
<span class="cp">({									\</span>
<span class="cp">		u64 __addr = ((_x) &amp; ~AS_MASK);				\</span>
<span class="cp">		if (is_shub2()) 					\</span>
<span class="cp">			__addr = SH2_TIO_PHYS_TO_DMA(__addr);		\</span>
<span class="cp">		HUB_S(_bte-&gt;bte_destination_addr, __addr);		\</span>
<span class="cp">})</span>
<span class="cp">#define BTE_CTRL_STORE(_bte, _x)					\</span>
<span class="cp">			HUB_S(_bte-&gt;bte_control_addr, (_x))</span>
<span class="cp">#define BTE_NOTIF_STORE(_bte, _x)					\</span>
<span class="cp">({									\</span>
<span class="cp">		u64 __addr = ia64_tpa((_x) &amp; ~AS_MASK);			\</span>
<span class="cp">		if (is_shub2()) 					\</span>
<span class="cp">			__addr = SH2_TIO_PHYS_TO_DMA(__addr);		\</span>
<span class="cp">		HUB_S(_bte-&gt;bte_notify_addr, __addr);			\</span>
<span class="cp">})</span>

<span class="cp">#define BTE_START_TRANSFER(_bte, _len, _mode)				\</span>
<span class="cp">	is_shub2() ? BTE_CTRL_STORE(_bte, IBLS_BUSY | (_mode &lt;&lt; 24) | _len) \</span>
<span class="cp">		: BTE_LNSTAT_STORE(_bte, _len);				\</span>
<span class="cp">		  BTE_CTRL_STORE(_bte, _mode)</span>

<span class="cm">/* Possible results from bte_copy and bte_unaligned_copy */</span>
<span class="cm">/* The following error codes map into the BTE hardware codes</span>
<span class="cm"> * IIO_ICRB_ECODE_* (in shubio.h). The hardware uses</span>
<span class="cm"> * an error code of 0 (IIO_ICRB_ECODE_DERR), but we want zero</span>
<span class="cm"> * to mean BTE_SUCCESS, so add one (BTEFAIL_OFFSET) to the error</span>
<span class="cm"> * codes to give the following error codes.</span>
<span class="cm"> */</span>
<span class="cp">#define BTEFAIL_OFFSET	1</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">BTE_SUCCESS</span><span class="p">,</span>		<span class="cm">/* 0 is success */</span>
	<span class="n">BTEFAIL_DIR</span><span class="p">,</span>		<span class="cm">/* Directory error due to IIO access*/</span>
	<span class="n">BTEFAIL_POISON</span><span class="p">,</span>		<span class="cm">/* poison error on IO access (write to poison page) */</span>
	<span class="n">BTEFAIL_WERR</span><span class="p">,</span>		<span class="cm">/* Write error (ie WINV to a Read only line) */</span>
	<span class="n">BTEFAIL_ACCESS</span><span class="p">,</span>		<span class="cm">/* access error (protection violation) */</span>
	<span class="n">BTEFAIL_PWERR</span><span class="p">,</span>		<span class="cm">/* Partial Write Error */</span>
	<span class="n">BTEFAIL_PRERR</span><span class="p">,</span>		<span class="cm">/* Partial Read Error */</span>
	<span class="n">BTEFAIL_TOUT</span><span class="p">,</span>		<span class="cm">/* CRB Time out */</span>
	<span class="n">BTEFAIL_XTERR</span><span class="p">,</span>		<span class="cm">/* Incoming xtalk pkt had error bit */</span>
	<span class="n">BTEFAIL_NOTAVAIL</span><span class="p">,</span>	<span class="cm">/* BTE not available */</span>
<span class="p">}</span> <span class="n">bte_result_t</span><span class="p">;</span>

<span class="cp">#define BTEFAIL_SH2_RESP_SHORT	0x1	</span><span class="cm">/* bit 000001 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_RESP_LONG	0x2	</span><span class="cm">/* bit 000010 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_RESP_DSP	0x4	</span><span class="cm">/* bit 000100 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_RESP_ACCESS	0x8	</span><span class="cm">/* bit 001000 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_CRB_TO	0x10	</span><span class="cm">/* bit 010000 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_NACK_LIMIT	0x20	</span><span class="cm">/* bit 100000 */</span><span class="cp"></span>
<span class="cp">#define BTEFAIL_SH2_ALL		0x3F	</span><span class="cm">/* bit 111111 */</span><span class="cp"></span>

<span class="cp">#define	BTE_ERR_BITS	0x3FUL</span>
<span class="cp">#define	BTE_ERR_SHIFT	36</span>
<span class="cp">#define BTE_ERR_MASK	(BTE_ERR_BITS &lt;&lt; BTE_ERR_SHIFT)</span>

<span class="cp">#define BTE_ERROR_RETRY(value)						\</span>
<span class="cp">	(is_shub2() ? (value != BTEFAIL_SH2_CRB_TO)			\</span>
<span class="cp">		: (value != BTEFAIL_TOUT))</span>

<span class="cm">/*</span>
<span class="cm"> * On shub1 BTE_ERR_MASK will always be false, so no need for is_shub2()</span>
<span class="cm"> */</span>
<span class="cp">#define BTE_SHUB2_ERROR(_status)					\</span>
<span class="cp">	((_status &amp; BTE_ERR_MASK) 					\</span>
<span class="cp">	   ? (((_status &gt;&gt; BTE_ERR_SHIFT) &amp; BTE_ERR_BITS) | IBLS_ERROR) \</span>
<span class="cp">	   : _status)</span>

<span class="cp">#define BTE_GET_ERROR_STATUS(_status)					\</span>
<span class="cp">	(BTE_SHUB2_ERROR(_status) &amp; ~IBLS_ERROR)</span>

<span class="cp">#define BTE_VALID_SH2_ERROR(value)					\</span>
<span class="cp">	((value &gt;= BTEFAIL_SH2_RESP_SHORT) &amp;&amp; (value &lt;= BTEFAIL_SH2_ALL))</span>

<span class="cm">/*</span>
<span class="cm"> * Structure defining a bte.  An instance of this</span>
<span class="cm"> * structure is created in the nodepda for each</span>
<span class="cm"> * bte on that node (as defined by BTES_PER_NODE)</span>
<span class="cm"> * This structure contains everything necessary</span>
<span class="cm"> * to work with a BTE.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u64</span> <span class="n">notify</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">bte_base_addr</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">bte_source_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">bte_destination_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">bte_control_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">bte_notify_addr</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="n">cnodeid_t</span> <span class="n">bte_cnode</span><span class="p">;</span>	<span class="cm">/* cnode                            */</span>
	<span class="kt">int</span> <span class="n">bte_error_count</span><span class="p">;</span>	<span class="cm">/* Number of errors encountered     */</span>
	<span class="kt">int</span> <span class="n">bte_num</span><span class="p">;</span>		<span class="cm">/* 0 --&gt; BTE0, 1 --&gt; BTE1           */</span>
	<span class="kt">int</span> <span class="n">cleanup_active</span><span class="p">;</span>	<span class="cm">/* Interface is locked for cleanup  */</span>
	<span class="k">volatile</span> <span class="n">bte_result_t</span> <span class="n">bh_error</span><span class="p">;</span>	<span class="cm">/* error while processing   */</span>
	<span class="k">volatile</span> <span class="n">u64</span> <span class="o">*</span><span class="n">most_rcnt_na</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="o">*</span><span class="n">btes_to_try</span><span class="p">[</span><span class="n">MAX_BTES_PER_NODE</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Function prototypes (functions defined in bte.c, used elsewhere)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bte_result_t</span> <span class="n">bte_copy</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bte_result_t</span> <span class="n">bte_unaligned_copy</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bte_error_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#define bte_zero(dest, len, mode, notification) \</span>
<span class="cp">	bte_copy(0, dest, len, ((mode) | BTE_ZERO_FILL), notification)</span>

<span class="cm">/*</span>
<span class="cm"> * The following is the preferred way of calling bte_unaligned_copy</span>
<span class="cm"> * If the copy is fully cache line aligned, then bte_copy is</span>
<span class="cm"> * used instead.  Since bte_copy is inlined, this saves a call</span>
<span class="cm"> * stack.  NOTE: bte_copy is called synchronously and does block</span>
<span class="cm"> * until the transfer is complete.  In order to get the asynch</span>
<span class="cm"> * version of bte_copy, you must perform this check yourself.</span>
<span class="cm"> */</span>
<span class="cp">#define BTE_UNALIGNED_COPY(src, dest, len, mode)			\</span>
<span class="cp">	(((len &amp; (L1_CACHE_BYTES - 1)) ||				\</span>
<span class="cp">	  (src &amp; (L1_CACHE_BYTES - 1)) ||				\</span>
<span class="cp">	  (dest &amp; (L1_CACHE_BYTES - 1))) ?				\</span>
<span class="cp">	 bte_unaligned_copy(src, dest, len, mode) :			\</span>
<span class="cp">	 bte_copy(src, dest, len, mode, NULL))</span>


<span class="cp">#endif	</span><span class="cm">/* _ASM_IA64_SN_BTE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
