<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › sn › addrs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>addrs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1992-1999,2001-2005 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_IA64_SN_ADDRS_H</span>
<span class="cp">#define _ASM_IA64_SN_ADDRS_H</span>

<span class="cp">#include &lt;asm/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/sn/types.h&gt;</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pda.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *  Memory/SHUB Address Format:</span>
<span class="cm"> *  +-+---------+--+--------------+</span>
<span class="cm"> *  |0|  NASID  |AS| NodeOffset   |</span>
<span class="cm"> *  +-+---------+--+--------------+</span>
<span class="cm"> *</span>
<span class="cm"> *  NASID: (low NASID bit is 0) Memory and SHUB MMRs</span>
<span class="cm"> *   AS: 2-bit Address Space Identifier. Used only if low NASID bit is 0</span>
<span class="cm"> *     00: Local Resources and MMR space</span>
<span class="cm"> *           Top bit of NodeOffset</span>
<span class="cm"> *               0: Local resources space</span>
<span class="cm"> *                  node id:</span>
<span class="cm"> *                        0: IA64/NT compatibility space</span>
<span class="cm"> *                        2: Local MMR Space</span>
<span class="cm"> *                        4: Local memory, regardless of local node id</span>
<span class="cm"> *               1: Global MMR space</span>
<span class="cm"> *     01: GET space.</span>
<span class="cm"> *     10: AMO space.</span>
<span class="cm"> *     11: Cacheable memory space.</span>
<span class="cm"> *</span>
<span class="cm"> *   NodeOffset: byte offset</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  TIO address format:</span>
<span class="cm"> *  +-+----------+--+--------------+</span>
<span class="cm"> *  |0|  NASID   |AS| Nodeoffset   |</span>
<span class="cm"> *  +-+----------+--+--------------+</span>
<span class="cm"> *</span>
<span class="cm"> *  NASID: (low NASID bit is 1) TIO</span>
<span class="cm"> *   AS: 2-bit Chiplet Identifier</span>
<span class="cm"> *     00: TIO LB (Indicates TIO MMR access.)</span>
<span class="cm"> *     01: TIO ICE (indicates coretalk space access.)</span>
<span class="cm"> * </span>
<span class="cm"> *   NodeOffset: top bit must be set.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Note that in both of the above address formats, the low</span>
<span class="cm"> * NASID bit indicates if the reference is to the SHUB or TIO MMRs.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Define basic shift &amp; mask constants for manipulating NASIDs and AS values.</span>
<span class="cm"> */</span>
<span class="cp">#define NASID_BITMASK		(sn_hub_info-&gt;nasid_bitmask)</span>
<span class="cp">#define NASID_SHIFT		(sn_hub_info-&gt;nasid_shift)</span>
<span class="cp">#define AS_SHIFT		(sn_hub_info-&gt;as_shift)</span>
<span class="cp">#define AS_BITMASK		0x3UL</span>

<span class="cp">#define NASID_MASK              ((u64)NASID_BITMASK &lt;&lt; NASID_SHIFT)</span>
<span class="cp">#define AS_MASK			((u64)AS_BITMASK &lt;&lt; AS_SHIFT)</span>


<span class="cm">/*</span>
<span class="cm"> * AS values. These are the same on both SHUB1 &amp; SHUB2.</span>
<span class="cm"> */</span>
<span class="cp">#define AS_GET_VAL		1UL</span>
<span class="cp">#define AS_AMO_VAL		2UL</span>
<span class="cp">#define AS_CAC_VAL		3UL</span>
<span class="cp">#define AS_GET_SPACE		(AS_GET_VAL &lt;&lt; AS_SHIFT)</span>
<span class="cp">#define AS_AMO_SPACE		(AS_AMO_VAL &lt;&lt; AS_SHIFT)</span>
<span class="cp">#define AS_CAC_SPACE		(AS_CAC_VAL &lt;&lt; AS_SHIFT)</span>


<span class="cm">/* </span>
<span class="cm"> * Virtual Mode Local &amp; Global MMR space.  </span>
<span class="cm"> */</span>
<span class="cp">#define SH1_LOCAL_MMR_OFFSET	0x8000000000UL</span>
<span class="cp">#define SH2_LOCAL_MMR_OFFSET	0x0200000000UL</span>
<span class="cp">#define LOCAL_MMR_OFFSET	(is_shub2() ? SH2_LOCAL_MMR_OFFSET : SH1_LOCAL_MMR_OFFSET)</span>
<span class="cp">#define LOCAL_MMR_SPACE		(__IA64_UNCACHED_OFFSET | LOCAL_MMR_OFFSET)</span>
<span class="cp">#define LOCAL_PHYS_MMR_SPACE	(RGN_BASE(RGN_HPAGE) | LOCAL_MMR_OFFSET)</span>

<span class="cp">#define SH1_GLOBAL_MMR_OFFSET	0x0800000000UL</span>
<span class="cp">#define SH2_GLOBAL_MMR_OFFSET	0x0300000000UL</span>
<span class="cp">#define GLOBAL_MMR_OFFSET	(is_shub2() ? SH2_GLOBAL_MMR_OFFSET : SH1_GLOBAL_MMR_OFFSET)</span>
<span class="cp">#define GLOBAL_MMR_SPACE	(__IA64_UNCACHED_OFFSET | GLOBAL_MMR_OFFSET)</span>

<span class="cm">/*</span>
<span class="cm"> * Physical mode addresses</span>
<span class="cm"> */</span>
<span class="cp">#define GLOBAL_PHYS_MMR_SPACE	(RGN_BASE(RGN_HPAGE) | GLOBAL_MMR_OFFSET)</span>


<span class="cm">/*</span>
<span class="cm"> * Clear region &amp; AS bits.</span>
<span class="cm"> */</span>
<span class="cp">#define TO_PHYS_MASK		(~(RGN_BITS | AS_MASK))</span>


<span class="cm">/*</span>
<span class="cm"> * Misc NASID manipulation.</span>
<span class="cm"> */</span>
<span class="cp">#define NASID_SPACE(n)		((u64)(n) &lt;&lt; NASID_SHIFT)</span>
<span class="cp">#define REMOTE_ADDR(n,a)	(NASID_SPACE(n) | (a))</span>
<span class="cp">#define NODE_OFFSET(x)		((x) &amp; (NODE_ADDRSPACE_SIZE - 1))</span>
<span class="cp">#define NODE_ADDRSPACE_SIZE     (1UL &lt;&lt; AS_SHIFT)</span>
<span class="cp">#define NASID_GET(x)		(int) (((u64) (x) &gt;&gt; NASID_SHIFT) &amp; NASID_BITMASK)</span>
<span class="cp">#define LOCAL_MMR_ADDR(a)	(LOCAL_MMR_SPACE | (a))</span>
<span class="cp">#define GLOBAL_MMR_ADDR(n,a)	(GLOBAL_MMR_SPACE | REMOTE_ADDR(n,a))</span>
<span class="cp">#define GLOBAL_MMR_PHYS_ADDR(n,a) (GLOBAL_PHYS_MMR_SPACE | REMOTE_ADDR(n,a))</span>
<span class="cp">#define GLOBAL_CAC_ADDR(n,a)	(CAC_BASE | REMOTE_ADDR(n,a))</span>
<span class="cp">#define CHANGE_NASID(n,x)	((void *)(((u64)(x) &amp; ~NASID_MASK) | NASID_SPACE(n)))</span>
<span class="cp">#define IS_TIO_NASID(n)		((n) &amp; 1)</span>


<span class="cm">/* non-II mmr&#39;s start at top of big window space (4G) */</span>
<span class="cp">#define BWIN_TOP		0x0000000100000000UL</span>

<span class="cm">/*</span>
<span class="cm"> * general address defines</span>
<span class="cm"> */</span>
<span class="cp">#define CAC_BASE		(PAGE_OFFSET | AS_CAC_SPACE)</span>
<span class="cp">#define AMO_BASE		(__IA64_UNCACHED_OFFSET | AS_AMO_SPACE)</span>
<span class="cp">#define AMO_PHYS_BASE		(RGN_BASE(RGN_HPAGE) | AS_AMO_SPACE)</span>
<span class="cp">#define GET_BASE		(PAGE_OFFSET | AS_GET_SPACE)</span>

<span class="cm">/*</span>
<span class="cm"> * Convert Memory addresses between various addressing modes.</span>
<span class="cm"> */</span>
<span class="cp">#define TO_PHYS(x)		(TO_PHYS_MASK &amp; (x))</span>
<span class="cp">#define TO_CAC(x)		(CAC_BASE     | TO_PHYS(x))</span>
<span class="cp">#ifdef CONFIG_SGI_SN</span>
<span class="cp">#define TO_AMO(x)		(AMO_BASE     | TO_PHYS(x))</span>
<span class="cp">#define TO_GET(x)		(GET_BASE     | TO_PHYS(x))</span>
<span class="cp">#else</span>
<span class="cp">#define TO_AMO(x)		({ BUG(); x; })</span>
<span class="cp">#define TO_GET(x)		({ BUG(); x; })</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Covert from processor physical address to II/TIO physical address:</span>
<span class="cm"> *	II - squeeze out the AS bits</span>
<span class="cm"> *	TIO- requires a chiplet id in bits 38-39.  For DMA to memory,</span>
<span class="cm"> *           the chiplet id is zero.  If we implement TIO-TIO dma, we might need</span>
<span class="cm"> *           to insert a chiplet id into this macro.  However, it is our belief</span>
<span class="cm"> *           right now that this chiplet id will be ICE, which is also zero.</span>
<span class="cm"> */</span>
<span class="cp">#define SH1_TIO_PHYS_TO_DMA(x) 						\</span>
<span class="cp">	((((u64)(NASID_GET(x))) &lt;&lt; 40) | NODE_OFFSET(x))</span>

<span class="cp">#define SH2_NETWORK_BANK_OFFSET(x) 					\</span>
<span class="cp">        ((u64)(x) &amp; ((1UL &lt;&lt; (sn_hub_info-&gt;nasid_shift - 4)) -1))</span>

<span class="cp">#define SH2_NETWORK_BANK_SELECT(x) 					\</span>
<span class="cp">        ((((u64)(x) &amp; (0x3UL &lt;&lt; (sn_hub_info-&gt;nasid_shift - 4)))	\</span>
<span class="cp">        	&gt;&gt; (sn_hub_info-&gt;nasid_shift - 4)) &lt;&lt; 36)</span>

<span class="cp">#define SH2_NETWORK_ADDRESS(x) 						\</span>
<span class="cp">	(SH2_NETWORK_BANK_OFFSET(x) | SH2_NETWORK_BANK_SELECT(x))</span>

<span class="cp">#define SH2_TIO_PHYS_TO_DMA(x) 						\</span>
<span class="cp">        (((u64)(NASID_GET(x)) &lt;&lt; 40) | 	SH2_NETWORK_ADDRESS(x))</span>

<span class="cp">#define PHYS_TO_TIODMA(x)						\</span>
<span class="cp">	(is_shub1() ? SH1_TIO_PHYS_TO_DMA(x) : SH2_TIO_PHYS_TO_DMA(x))</span>

<span class="cp">#define PHYS_TO_DMA(x)							\</span>
<span class="cp">	((((u64)(x) &amp; NASID_MASK) &gt;&gt; 2) | NODE_OFFSET(x))</span>


<span class="cm">/*</span>
<span class="cm"> * Macros to test for address type.</span>
<span class="cm"> */</span>
<span class="cp">#define IS_AMO_ADDRESS(x)	(((u64)(x) &amp; (RGN_BITS | AS_MASK)) == AMO_BASE)</span>
<span class="cp">#define IS_AMO_PHYS_ADDRESS(x)	(((u64)(x) &amp; (RGN_BITS | AS_MASK)) == AMO_PHYS_BASE)</span>


<span class="cm">/*</span>
<span class="cm"> * The following definitions pertain to the IO special address</span>
<span class="cm"> * space.  They define the location of the big and little windows</span>
<span class="cm"> * of any given node.</span>
<span class="cm"> */</span>
<span class="cp">#define BWIN_SIZE_BITS			29	</span><span class="cm">/* big window size: 512M */</span><span class="cp"></span>
<span class="cp">#define TIO_BWIN_SIZE_BITS		30	</span><span class="cm">/* big window size: 1G */</span><span class="cp"></span>
<span class="cp">#define NODE_SWIN_BASE(n, w)		((w == 0) ? NODE_BWIN_BASE((n), SWIN0_BIGWIN) \</span>
<span class="cp">		: RAW_NODE_SWIN_BASE(n, w))</span>
<span class="cp">#define TIO_SWIN_BASE(n, w) 		(TIO_IO_BASE(n) + \</span>
<span class="cp">					    ((u64) (w) &lt;&lt; TIO_SWIN_SIZE_BITS))</span>
<span class="cp">#define NODE_IO_BASE(n)			(GLOBAL_MMR_SPACE | NASID_SPACE(n))</span>
<span class="cp">#define TIO_IO_BASE(n)                  (__IA64_UNCACHED_OFFSET | NASID_SPACE(n))</span>
<span class="cp">#define BWIN_SIZE			(1UL &lt;&lt; BWIN_SIZE_BITS)</span>
<span class="cp">#define NODE_BWIN_BASE0(n)		(NODE_IO_BASE(n) + BWIN_SIZE)</span>
<span class="cp">#define NODE_BWIN_BASE(n, w)		(NODE_BWIN_BASE0(n) + ((u64) (w) &lt;&lt; BWIN_SIZE_BITS))</span>
<span class="cp">#define RAW_NODE_SWIN_BASE(n, w)	(NODE_IO_BASE(n) + ((u64) (w) &lt;&lt; SWIN_SIZE_BITS))</span>
<span class="cp">#define BWIN_WIDGET_MASK		0x7</span>
<span class="cp">#define BWIN_WINDOWNUM(x)		(((x) &gt;&gt; BWIN_SIZE_BITS) &amp; BWIN_WIDGET_MASK)</span>
<span class="cp">#define SH1_IS_BIG_WINDOW_ADDR(x)	((x) &amp; BWIN_TOP)</span>

<span class="cp">#define TIO_BWIN_WINDOW_SELECT_MASK	0x7</span>
<span class="cp">#define TIO_BWIN_WINDOWNUM(x)		(((x) &gt;&gt; TIO_BWIN_SIZE_BITS) &amp; TIO_BWIN_WINDOW_SELECT_MASK)</span>

<span class="cp">#define TIO_HWIN_SHIFT_BITS		33</span>
<span class="cp">#define TIO_HWIN(x)			(NODE_OFFSET(x) &gt;&gt; TIO_HWIN_SHIFT_BITS)</span>

<span class="cm">/*</span>
<span class="cm"> * The following definitions pertain to the IO special address</span>
<span class="cm"> * space.  They define the location of the big and little windows</span>
<span class="cm"> * of any given node.</span>
<span class="cm"> */</span>

<span class="cp">#define SWIN_SIZE_BITS			24</span>
<span class="cp">#define	SWIN_WIDGET_MASK		0xF</span>

<span class="cp">#define TIO_SWIN_SIZE_BITS		28</span>
<span class="cp">#define TIO_SWIN_SIZE			(1UL &lt;&lt; TIO_SWIN_SIZE_BITS)</span>
<span class="cp">#define TIO_SWIN_WIDGET_MASK		0x3</span>

<span class="cm">/*</span>
<span class="cm"> * Convert smallwindow address to xtalk address.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;addr&#39; can be physical or virtual address, but will be converted</span>
<span class="cm"> * to Xtalk address in the range 0 -&gt; SWINZ_SIZEMASK</span>
<span class="cm"> */</span>
<span class="cp">#define	SWIN_WIDGETNUM(x)		(((x)  &gt;&gt; SWIN_SIZE_BITS) &amp; SWIN_WIDGET_MASK)</span>
<span class="cp">#define TIO_SWIN_WIDGETNUM(x)		(((x)  &gt;&gt; TIO_SWIN_SIZE_BITS) &amp; TIO_SWIN_WIDGET_MASK)</span>


<span class="cm">/*</span>
<span class="cm"> * The following macros produce the correct base virtual address for</span>
<span class="cm"> * the hub registers. The REMOTE_HUB_* macro produce</span>
<span class="cm"> * the address for the specified hub&#39;s registers.  The intent is</span>
<span class="cm"> * that the appropriate PI, MD, NI, or II register would be substituted</span>
<span class="cm"> * for x.</span>
<span class="cm"> *</span>
<span class="cm"> *   WARNING:</span>
<span class="cm"> *	When certain Hub chip workaround are defined, it&#39;s not sufficient</span>
<span class="cm"> *	to dereference the *_HUB_ADDR() macros.  You should instead use</span>
<span class="cm"> *	HUB_L() and HUB_S() if you must deal with pointers to hub registers.</span>
<span class="cm"> *	Otherwise, the recommended approach is to use *_HUB_L() and *_HUB_S().</span>
<span class="cm"> *	They&#39;re always safe.</span>
<span class="cm"> */</span>
<span class="cm">/* Shub1 TIO &amp; MMR addressing macros */</span>
<span class="cp">#define SH1_TIO_IOSPACE_ADDR(n,x)					\</span>
<span class="cp">	GLOBAL_MMR_ADDR(n,x)</span>

<span class="cp">#define SH1_REMOTE_BWIN_MMR(n,x)					\</span>
<span class="cp">	GLOBAL_MMR_ADDR(n,x)</span>

<span class="cp">#define SH1_REMOTE_SWIN_MMR(n,x)					\</span>
<span class="cp">	(NODE_SWIN_BASE(n,1) + 0x800000UL + (x))</span>

<span class="cp">#define SH1_REMOTE_MMR(n,x)						\</span>
<span class="cp">	(SH1_IS_BIG_WINDOW_ADDR(x) ? SH1_REMOTE_BWIN_MMR(n,x) :		\</span>
<span class="cp">	 	SH1_REMOTE_SWIN_MMR(n,x))</span>

<span class="cm">/* Shub1 TIO &amp; MMR addressing macros */</span>
<span class="cp">#define SH2_TIO_IOSPACE_ADDR(n,x)					\</span>
<span class="cp">	((__IA64_UNCACHED_OFFSET | REMOTE_ADDR(n,x) | 1UL &lt;&lt; (NASID_SHIFT - 2)))</span>

<span class="cp">#define SH2_REMOTE_MMR(n,x)						\</span>
<span class="cp">	GLOBAL_MMR_ADDR(n,x)</span>


<span class="cm">/* TIO &amp; MMR addressing macros that work on both shub1 &amp; shub2 */</span>
<span class="cp">#define TIO_IOSPACE_ADDR(n,x)						\</span>
<span class="cp">	((u64 *)(is_shub1() ? SH1_TIO_IOSPACE_ADDR(n,x) :		\</span>
<span class="cp">		 SH2_TIO_IOSPACE_ADDR(n,x)))</span>

<span class="cp">#define SH_REMOTE_MMR(n,x)						\</span>
<span class="cp">	(is_shub1() ? SH1_REMOTE_MMR(n,x) : SH2_REMOTE_MMR(n,x))</span>

<span class="cp">#define REMOTE_HUB_ADDR(n,x)						\</span>
<span class="cp">	(IS_TIO_NASID(n) ?  ((volatile u64*)TIO_IOSPACE_ADDR(n,x)) :	\</span>
<span class="cp">	 ((volatile u64*)SH_REMOTE_MMR(n,x)))</span>


<span class="cp">#define HUB_L(x)			(*((volatile typeof(*x) *)x))</span>
<span class="cp">#define	HUB_S(x,d)			(*((volatile typeof(*x) *)x) = (d))</span>

<span class="cp">#define REMOTE_HUB_L(n, a)		HUB_L(REMOTE_HUB_ADDR((n), (a)))</span>
<span class="cp">#define REMOTE_HUB_S(n, a, d)		HUB_S(REMOTE_HUB_ADDR((n), (a)), (d))</span>

<span class="cm">/*</span>
<span class="cm"> * Coretalk address breakdown</span>
<span class="cm"> */</span>
<span class="cp">#define CTALK_NASID_SHFT		40</span>
<span class="cp">#define CTALK_NASID_MASK		(0x3FFFULL &lt;&lt; CTALK_NASID_SHFT)</span>
<span class="cp">#define CTALK_CID_SHFT			38</span>
<span class="cp">#define CTALK_CID_MASK			(0x3ULL &lt;&lt; CTALK_CID_SHFT)</span>
<span class="cp">#define CTALK_NODE_OFFSET		0x3FFFFFFFFF</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_SN_ADDRS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
