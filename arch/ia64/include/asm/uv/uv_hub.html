<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › uv › uv_hub.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>uv_hub.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * SGI UV architectural definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ASM_IA64_UV_HUB_H__</span>
<span class="cp">#define __ASM_IA64_UV_HUB_H__</span>

<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/percpu.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Addressing Terminology</span>
<span class="cm"> *</span>
<span class="cm"> *	M       - The low M bits of a physical address represent the offset</span>
<span class="cm"> *		  into the blade local memory. RAM memory on a blade is physically</span>
<span class="cm"> *		  contiguous (although various IO spaces may punch holes in</span>
<span class="cm"> *		  it)..</span>
<span class="cm"> *</span>
<span class="cm"> * 	N	- Number of bits in the node portion of a socket physical</span>
<span class="cm"> * 		  address.</span>
<span class="cm"> *</span>
<span class="cm"> * 	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of</span>
<span class="cm"> * 	 	  routers always have low bit of 1, C/MBricks have low bit</span>
<span class="cm"> * 		  equal to 0. Most addressing macros that target UV hub chips</span>
<span class="cm"> * 		  right shift the NASID by 1 to exclude the always-zero bit.</span>
<span class="cm"> * 		  NASIDs contain up to 15 bits.</span>
<span class="cm"> *</span>
<span class="cm"> *	GNODE   - NASID right shifted by 1 bit. Most mmrs contain gnodes instead</span>
<span class="cm"> *		  of nasids.</span>
<span class="cm"> *</span>
<span class="cm"> * 	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant</span>
<span class="cm"> * 		  of the nasid for socket usage.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  NumaLink Global Physical Address Format:</span>
<span class="cm"> *  +--------------------------------+---------------------+</span>
<span class="cm"> *  |00..000|      GNODE             |      NodeOffset     |</span>
<span class="cm"> *  +--------------------------------+---------------------+</span>
<span class="cm"> *          |&lt;-------53 - M bits ---&gt;|&lt;--------M bits -----&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	M - number of node offset bits (35 .. 40)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Memory/UV-HUB Processor Socket Address Format:</span>
<span class="cm"> *  +----------------+---------------+---------------------+</span>
<span class="cm"> *  |00..000000000000|   PNODE       |      NodeOffset     |</span>
<span class="cm"> *  +----------------+---------------+---------------------+</span>
<span class="cm"> *                   &lt;--- N bits ---&gt;|&lt;--------M bits -----&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	M - number of node offset bits (35 .. 40)</span>
<span class="cm"> *	N - number of PNODE bits (0 .. 10)</span>
<span class="cm"> *</span>
<span class="cm"> *		Note: M + N cannot currently exceed 44 (x86_64) or 46 (IA64).</span>
<span class="cm"> *		The actual values are configuration dependent and are set at</span>
<span class="cm"> *		boot time. M &amp; N values are set by the hardware/BIOS at boot.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Maximum number of bricks in all partitions and in all coherency domains.</span>
<span class="cm"> * This is the total number of bricks accessible in the numalink fabric. It</span>
<span class="cm"> * includes all C &amp; M bricks. Routers are NOT included.</span>
<span class="cm"> *</span>
<span class="cm"> * This value is also the value of the maximum number of non-router NASIDs</span>
<span class="cm"> * in the numalink fabric.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: a brick may contain 1 or 2 OS nodes. Don&#39;t get these confused.</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_NUMALINK_BLADES	16384</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of C/Mbricks within a software SSI (hardware may support</span>
<span class="cm"> * more).</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_SSI_BLADES	1</span>

<span class="cm">/*</span>
<span class="cm"> * The largest possible NASID of a C or M brick (+ 2)</span>
<span class="cm"> */</span>
<span class="cp">#define UV_MAX_NASID_VALUE	(UV_MAX_NUMALINK_NODES * 2)</span>

<span class="cm">/*</span>
<span class="cm"> * The following defines attributes of the HUB chip. These attributes are</span>
<span class="cm"> * frequently referenced and are kept in the per-cpu data areas of each cpu.</span>
<span class="cm"> * They are kept together in a struct to minimize cache misses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uv_hub_info_s</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">global_mmr_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">gpa_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">gnode_upper</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lowmem_remap_top</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lowmem_remap_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">pnode_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">coherency_domain_number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">numa_blade_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">blade_processor_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">m_val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">n_val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">uv_hub_info_s</span><span class="p">,</span> <span class="n">__uv_hub_info</span><span class="p">);</span>
<span class="cp">#define uv_hub_info 		(&amp;__get_cpu_var(__uv_hub_info))</span>
<span class="cp">#define uv_cpu_hub_info(cpu)	(&amp;per_cpu(__uv_hub_info, cpu))</span>

<span class="cm">/*</span>
<span class="cm"> * Local &amp; Global MMR space macros.</span>
<span class="cm"> * 	Note: macros are intended to be used ONLY by inline functions</span>
<span class="cm"> * 	in this file - not by other kernel code.</span>
<span class="cm"> * 		n -  NASID (full 15-bit global nasid)</span>
<span class="cm"> * 		g -  GNODE (full 15-bit global nasid, right shifted 1)</span>
<span class="cm"> * 		p -  PNODE (local part of nsids, right shifted 1)</span>
<span class="cm"> */</span>
<span class="cp">#define UV_NASID_TO_PNODE(n)		(((n) &gt;&gt; 1) &amp; uv_hub_info-&gt;pnode_mask)</span>
<span class="cp">#define UV_PNODE_TO_NASID(p)		(((p) &lt;&lt; 1) | uv_hub_info-&gt;gnode_upper)</span>

<span class="cp">#define UV_LOCAL_MMR_BASE		0xf4000000UL</span>
<span class="cp">#define UV_GLOBAL_MMR32_BASE		0xf8000000UL</span>
<span class="cp">#define UV_GLOBAL_MMR64_BASE		(uv_hub_info-&gt;global_mmr_base)</span>

<span class="cp">#define UV_GLOBAL_MMR32_PNODE_SHIFT	15</span>
<span class="cp">#define UV_GLOBAL_MMR64_PNODE_SHIFT	26</span>

<span class="cp">#define UV_GLOBAL_MMR32_PNODE_BITS(p)	((p) &lt;&lt; (UV_GLOBAL_MMR32_PNODE_SHIFT))</span>

<span class="cp">#define UV_GLOBAL_MMR64_PNODE_BITS(p)					\</span>
<span class="cp">	((unsigned long)(p) &lt;&lt; UV_GLOBAL_MMR64_PNODE_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Macros for converting between kernel virtual addresses, socket local physical</span>
<span class="cm"> * addresses, and UV global physical addresses.</span>
<span class="cm"> * 	Note: use the standard __pa() &amp; __va() macros for converting</span>
<span class="cm"> * 	      between socket virtual and socket physical addresses.</span>
<span class="cm"> */</span>

<span class="cm">/* socket phys RAM --&gt; UV global physical address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_soc_phys_ram_to_gpa</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paddr</span> <span class="o">&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_top</span><span class="p">)</span>
		<span class="n">paddr</span> <span class="o">+=</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">lowmem_remap_base</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">paddr</span> <span class="o">|</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">gnode_upper</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* socket virtual --&gt; UV global physical address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_gpa</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">gnode_upper</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* socket virtual --&gt; UV global physical address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">uv_vgpa</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">uv_gpa</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* UV global physical address --&gt; socket virtual */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">uv_va</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">gpa</span> <span class="o">&amp;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">gpa_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pnode, offset --&gt; socket virtual */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">uv_pnode_offset_to_vaddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pnode</span> <span class="o">&lt;&lt;</span> <span class="n">uv_hub_info</span><span class="o">-&gt;</span><span class="n">m_val</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Access global MMRs using the low memory MMR32 space. This region supports</span>
<span class="cm"> * faster MMR access but not all MMRs are accessible in this space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">uv_global_mmr32_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_GLOBAL_MMR32_BASE</span> <span class="o">|</span>
		       <span class="n">UV_GLOBAL_MMR32_PNODE_BITS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_global_mmr32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">uv_global_mmr32_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_global_mmr32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">uv_global_mmr32_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access Global MMR space using the MMR space located at the top of physical</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">uv_global_mmr64_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_GLOBAL_MMR64_BASE</span> <span class="o">|</span>
		    <span class="n">UV_GLOBAL_MMR64_PNODE_BITS</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_global_mmr64</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_global_mmr64</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">uv_global_mmr64_address</span><span class="p">(</span><span class="n">pnode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access hub local MMRs. Faster than using global space but only local MMRs</span>
<span class="cm"> * are accessible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">uv_local_mmr_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">UV_LOCAL_MMR_BASE</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">uv_read_local_mmr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_write_local_mmr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">uv_local_mmr_address</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Structures and definitions for converting between cpu, node, pnode, and blade</span>
<span class="cm"> * numbers.</span>
<span class="cm"> */</span>

<span class="cm">/* Blade-local cpu number of current cpu. Numbered 0 .. &lt;# cpus on the blade&gt; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_processor_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Blade number of current cpu. Numnbered 0 .. &lt;#blades -1&gt; */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_numa_blade_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a cpu number to the the UV blade number */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_cpu_to_blade_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert linux node number to the UV blade number */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_node_to_blade_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a blade id to the PNODE of the blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine the number of possible cpus on a blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_nr_possible_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Determine the number of online cpus on a blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_blade_nr_online_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">num_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Convert a cpu id to the PNODE of the blade containing the cpu */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_cpu_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert a linux node number to the PNODE of the blade */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_node_to_pnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Maximum possible number of blades */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uv_num_possible_blades</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uv_hub_send_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">pnode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not currently needed on ia64 */</span>
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* __ASM_IA64_UV_HUB__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
