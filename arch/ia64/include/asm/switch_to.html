<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › switch_to.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>switch_to.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Low-level task switching. This is based on information published in</span>
<span class="cm"> * the Processor Abstraction Layer and the System Abstraction Layer</span>
<span class="cm"> * manual.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 Asit Mallick &lt;asit.k.mallick@intel.com&gt;</span>
<span class="cm"> * Copyright (C) 1999 Don Dugger &lt;don.dugger@intel.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_IA64_SWITCH_TO_H</span>
<span class="cp">#define _ASM_IA64_SWITCH_TO_H</span>

<span class="cp">#include &lt;linux/percpu.h&gt;</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Context switch from one thread to another.  If the two threads have</span>
<span class="cm"> * different address spaces, schedule() has already taken care of</span>
<span class="cm"> * switching to the new address space by calling switch_mm().</span>
<span class="cm"> *</span>
<span class="cm"> * Disabling access to the fph partition and the debug-register</span>
<span class="cm"> * context switch MUST be done before calling ia64_switch_to() since a</span>
<span class="cm"> * newly created thread returns directly to</span>
<span class="cm"> * ia64_ret_from_syscall_clear_r8.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ia64_switch_to</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">next_task</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_save_extra</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_load_extra</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_VIRT_CPU_ACCOUNTING</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_account_on_switch</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="cp"># define IA64_ACCOUNT_ON_SWITCH(p,n) ia64_account_on_switch(p,n)</span>
<span class="cp">#else</span>
<span class="cp"># define IA64_ACCOUNT_ON_SWITCH(p,n)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PERFMON</span>
  <span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pfm_syst_info</span><span class="p">);</span>
<span class="cp"># define PERFMON_IS_SYSWIDE() (__get_cpu_var(pfm_syst_info) &amp; 0x1)</span>
<span class="cp">#else</span>
<span class="cp"># define PERFMON_IS_SYSWIDE() (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define IA64_HAS_EXTRA_STATE(t)							\</span>
<span class="cp">	((t)-&gt;thread.flags &amp; (IA64_THREAD_DBG_VALID|IA64_THREAD_PM_VALID)	\</span>
<span class="cp">	 || PERFMON_IS_SYSWIDE())</span>

<span class="cp">#define __switch_to(prev,next,last) do {							 \</span>
<span class="cp">	IA64_ACCOUNT_ON_SWITCH(prev, next);							 \</span>
<span class="cp">	if (IA64_HAS_EXTRA_STATE(prev))								 \</span>
<span class="cp">		ia64_save_extra(prev);								 \</span>
<span class="cp">	if (IA64_HAS_EXTRA_STATE(next))								 \</span>
<span class="cp">		ia64_load_extra(next);								 \</span>
<span class="cp">	ia64_psr(task_pt_regs(next))-&gt;dfh = !ia64_is_local_fpu_owner(next);			 \</span>
<span class="cp">	(last) = ia64_switch_to((next));							 \</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * In the SMP case, we save the fph state when context-switching away from a thread that</span>
<span class="cm"> * modified fph.  This way, when the thread gets scheduled on another CPU, the CPU can</span>
<span class="cm"> * pick up the state from task-&gt;thread.fph, avoiding the complication of having to fetch</span>
<span class="cm"> * the latest fph state from another CPU.  In other words: eager save, lazy restore.</span>
<span class="cm"> */</span>
<span class="cp"># define switch_to(prev,next,last) do {						\</span>
<span class="cp">	if (ia64_psr(task_pt_regs(prev))-&gt;mfh &amp;&amp; ia64_is_local_fpu_owner(prev)) {				\</span>
<span class="cp">		ia64_psr(task_pt_regs(prev))-&gt;mfh = 0;			\</span>
<span class="cp">		(prev)-&gt;thread.flags |= IA64_THREAD_FPH_VALID;			\</span>
<span class="cp">		__ia64_save_fpu((prev)-&gt;thread.fph);				\</span>
<span class="cp">	}									\</span>
<span class="cp">	__switch_to(prev, next, last);						\</span>
<span class="cp">	</span><span class="cm">/* &quot;next&quot; in old context is &quot;current&quot; in new context */</span><span class="cp">			\</span>
<span class="cp">	if (unlikely((current-&gt;thread.flags &amp; IA64_THREAD_MIGRATION) &amp;&amp;	       \</span>
<span class="cp">		     (task_cpu(current) !=				       \</span>
<span class="cp">		      		      task_thread_info(current)-&gt;last_cpu))) { \</span>
<span class="cp">		platform_migrate(current);				       \</span>
<span class="cp">		task_thread_info(current)-&gt;last_cpu = task_cpu(current);       \</span>
<span class="cp">	}								       \</span>
<span class="cp">} while (0)</span>
<span class="cp">#else</span>
<span class="cp"># define switch_to(prev,next,last)	__switch_to(prev, next, last)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_SWITCH_TO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
