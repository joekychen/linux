<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › perfmon.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>perfmon.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001-2003 Hewlett-Packard Co</span>
<span class="cm"> *               Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _ASM_IA64_PERFMON_H</span>
<span class="cp">#define _ASM_IA64_PERFMON_H</span>

<span class="cm">/*</span>
<span class="cm"> * perfmon commands supported on all CPU models</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_WRITE_PMCS		0x01</span>
<span class="cp">#define PFM_WRITE_PMDS		0x02</span>
<span class="cp">#define PFM_READ_PMDS		0x03</span>
<span class="cp">#define PFM_STOP		0x04</span>
<span class="cp">#define PFM_START		0x05</span>
<span class="cp">#define PFM_ENABLE		0x06 </span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define PFM_DISABLE		0x07 </span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define PFM_CREATE_CONTEXT	0x08</span>
<span class="cp">#define PFM_DESTROY_CONTEXT	0x09 </span><span class="cm">/* obsolete use close() */</span><span class="cp"></span>
<span class="cp">#define PFM_RESTART		0x0a</span>
<span class="cp">#define PFM_PROTECT_CONTEXT	0x0b </span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define PFM_GET_FEATURES	0x0c</span>
<span class="cp">#define PFM_DEBUG		0x0d</span>
<span class="cp">#define PFM_UNPROTECT_CONTEXT	0x0e </span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define PFM_GET_PMC_RESET_VAL	0x0f</span>
<span class="cp">#define PFM_LOAD_CONTEXT	0x10</span>
<span class="cp">#define PFM_UNLOAD_CONTEXT	0x11</span>

<span class="cm">/*</span>
<span class="cm"> * PMU model specific commands (may not be supported on all PMU models)</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_WRITE_IBRS		0x20</span>
<span class="cp">#define PFM_WRITE_DBRS		0x21</span>

<span class="cm">/*</span>
<span class="cm"> * context flags</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_FL_NOTIFY_BLOCK    	 0x01	</span><span class="cm">/* block task on user level notifications */</span><span class="cp"></span>
<span class="cp">#define PFM_FL_SYSTEM_WIDE	 0x02	</span><span class="cm">/* create a system wide context */</span><span class="cp"></span>
<span class="cp">#define PFM_FL_OVFL_NO_MSG	 0x80   </span><span class="cm">/* do not post overflow/end messages for notification */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * event set flags</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_SETFL_EXCL_IDLE      0x01   </span><span class="cm">/* exclude idle task (syswide only) XXX: DO NOT USE YET */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PMC flags</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_REGFL_OVFL_NOTIFY	0x1	</span><span class="cm">/* send notification on overflow */</span><span class="cp"></span>
<span class="cp">#define PFM_REGFL_RANDOM	0x2	</span><span class="cm">/* randomize sampling interval   */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PMD/PMC/IBR/DBR return flags (ignored on input)</span>
<span class="cm"> *</span>
<span class="cm"> * Those flags are used on output and must be checked in case EAGAIN is returned</span>
<span class="cm"> * by any of the calls using a pfarg_reg_t or pfarg_dbreg_t structure.</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_REG_RETFL_NOTAVAIL	(1UL&lt;&lt;31) </span><span class="cm">/* set if register is implemented but not available */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_RETFL_EINVAL	(1UL&lt;&lt;30) </span><span class="cm">/* set if register entry is invalid */</span><span class="cp"></span>
<span class="cp">#define PFM_REG_RETFL_MASK	(PFM_REG_RETFL_NOTAVAIL|PFM_REG_RETFL_EINVAL)</span>

<span class="cp">#define PFM_REG_HAS_ERROR(flag)	(((flag) &amp; PFM_REG_RETFL_MASK) != 0)</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pfm_uuid_t</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* custom sampling buffer identifier type */</span>

<span class="cm">/*</span>
<span class="cm"> * Request structure used to define a context</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">pfm_uuid_t</span>     <span class="n">ctx_smpl_buf_id</span><span class="p">;</span>	 <span class="cm">/* which buffer format to use (if needed) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">ctx_flags</span><span class="p">;</span>	 <span class="cm">/* noblock/block */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctx_nextra_sets</span><span class="p">;</span>	 <span class="cm">/* number of extra event sets (you always get 1) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctx_reserved1</span><span class="p">;</span>	 <span class="cm">/* for future use */</span>
	<span class="kt">int</span>	       <span class="n">ctx_fd</span><span class="p">;</span>		 <span class="cm">/* return arg: unique identification for context */</span>
	<span class="kt">void</span>	       <span class="o">*</span><span class="n">ctx_smpl_vaddr</span><span class="p">;</span>	 <span class="cm">/* return arg: virtual address of sampling buffer, is used */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">ctx_reserved2</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span><span class="cm">/* for future use */</span>
<span class="p">}</span> <span class="n">pfarg_context_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Request structure used to write/read a PMC or PMD</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">reg_num</span><span class="p">;</span>	   <span class="cm">/* which register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">reg_set</span><span class="p">;</span>	   <span class="cm">/* event set for this register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">reg_reserved1</span><span class="p">;</span>	   <span class="cm">/* for future use */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_value</span><span class="p">;</span>	   <span class="cm">/* initial pmc/pmd value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_flags</span><span class="p">;</span>	   <span class="cm">/* input: pmc/pmd flags, return: reg error */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_long_reset</span><span class="p">;</span>	   <span class="cm">/* reset after buffer overflow notification */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_short_reset</span><span class="p">;</span>   <span class="cm">/* reset after counter overflow */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_reset_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* which other counters to reset on overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_random_seed</span><span class="p">;</span>   <span class="cm">/* seed value when randomization is used */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_random_mask</span><span class="p">;</span>   <span class="cm">/* bitmask used to limit random value */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">reg_last_reset_val</span><span class="p">;</span><span class="cm">/* return: PMD last reset value */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_smpl_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>  <span class="cm">/* which pmds are accessed when PMC overflows */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reg_smpl_eventid</span><span class="p">;</span>  <span class="cm">/* opaque sampling event identifier */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">reg_reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>   <span class="cm">/* for future use */</span>
<span class="p">}</span> <span class="n">pfarg_reg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">dbreg_num</span><span class="p">;</span>		<span class="cm">/* which debug register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">dbreg_set</span><span class="p">;</span>		<span class="cm">/* event set for this register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">dbreg_reserved1</span><span class="p">;</span>	<span class="cm">/* for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbreg_value</span><span class="p">;</span>		<span class="cm">/* value for debug register */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbreg_flags</span><span class="p">;</span>		<span class="cm">/* return: dbreg error */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dbreg_reserved2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* for future use */</span>
<span class="p">}</span> <span class="n">pfarg_dbreg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">ft_version</span><span class="p">;</span>	<span class="cm">/* perfmon: major [16-31], minor [0-15] */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">ft_reserved</span><span class="p">;</span>	<span class="cm">/* reserved for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">reserved</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* for future use */</span>
<span class="p">}</span> <span class="n">pfarg_features_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">pid_t</span>		<span class="n">load_pid</span><span class="p">;</span>	   <span class="cm">/* process to load the context into */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">load_set</span><span class="p">;</span>	   <span class="cm">/* first event set to load */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">load_reserved1</span><span class="p">;</span>	   <span class="cm">/* for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">load_reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* for future use */</span>
<span class="p">}</span> <span class="n">pfarg_load_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">msg_type</span><span class="p">;</span>		<span class="cm">/* generic message header */</span>
	<span class="kt">int</span>		<span class="n">msg_ctx_fd</span><span class="p">;</span>		<span class="cm">/* generic message header */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">msg_ovfl_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* which PMDs overflowed */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">msg_active_set</span><span class="p">;</span>		<span class="cm">/* active set at the time of overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">msg_reserved1</span><span class="p">;</span>		<span class="cm">/* for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">msg_reserved2</span><span class="p">;</span>		<span class="cm">/* for future use */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">msg_tstamp</span><span class="p">;</span>		<span class="cm">/* for perf tuning/debug */</span>
<span class="p">}</span> <span class="n">pfm_ovfl_msg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">msg_type</span><span class="p">;</span>		<span class="cm">/* generic message header */</span>
	<span class="kt">int</span>		<span class="n">msg_ctx_fd</span><span class="p">;</span>		<span class="cm">/* generic message header */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">msg_tstamp</span><span class="p">;</span>		<span class="cm">/* for perf tuning */</span>
<span class="p">}</span> <span class="n">pfm_end_msg_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">msg_type</span><span class="p">;</span>		<span class="cm">/* type of the message */</span>
	<span class="kt">int</span>		<span class="n">msg_ctx_fd</span><span class="p">;</span>		<span class="cm">/* unique identifier for the context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">msg_tstamp</span><span class="p">;</span>		<span class="cm">/* for perf tuning */</span>
<span class="p">}</span> <span class="n">pfm_gen_msg_t</span><span class="p">;</span>

<span class="cp">#define PFM_MSG_OVFL	1	</span><span class="cm">/* an overflow happened */</span><span class="cp"></span>
<span class="cp">#define PFM_MSG_END	2	</span><span class="cm">/* task to which context was attached ended */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="n">pfm_ovfl_msg_t</span>	<span class="n">pfm_ovfl_msg</span><span class="p">;</span>
	<span class="n">pfm_end_msg_t</span>	<span class="n">pfm_end_msg</span><span class="p">;</span>
	<span class="n">pfm_gen_msg_t</span>	<span class="n">pfm_gen_msg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pfm_msg_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Define the version numbers for both perfmon as a whole and the sampling buffer format.</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_VERSION_MAJ		 2U</span>
<span class="cp">#define PFM_VERSION_MIN		 0U</span>
<span class="cp">#define PFM_VERSION		 (((PFM_VERSION_MAJ&amp;0xffff)&lt;&lt;16)|(PFM_VERSION_MIN &amp; 0xffff))</span>
<span class="cp">#define PFM_VERSION_MAJOR(x)	 (((x)&gt;&gt;16) &amp; 0xffff)</span>
<span class="cp">#define PFM_VERSION_MINOR(x)	 ((x) &amp; 0xffff)</span>


<span class="cm">/*</span>
<span class="cm"> * miscellaneous architected definitions</span>
<span class="cm"> */</span>
<span class="cp">#define PMU_FIRST_COUNTER	4	</span><span class="cm">/* first counting monitor (PMC/PMD) */</span><span class="cp"></span>
<span class="cp">#define PMU_MAX_PMCS		256	</span><span class="cm">/* maximum architected number of PMC registers */</span><span class="cp"></span>
<span class="cp">#define PMU_MAX_PMDS		256	</span><span class="cm">/* maximum architected number of PMD registers */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">perfmonctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narg</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span> <span class="n">pfm_intr_handler_desc_t</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_save_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_load_regs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_exit_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">pfm_use_debug_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">pfm_release_debug_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_syst_wide_update_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_ctxswin</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_inherit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_init_percpu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pfm_handle_work</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">pfm_install_alt_pmu_interrupt</span><span class="p">(</span><span class="n">pfm_intr_handler_desc_t</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">pfm_remove_alt_pmu_interrupt</span><span class="p">(</span><span class="n">pfm_intr_handler_desc_t</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> * Reset PMD register flags</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_PMD_SHORT_RESET	0</span>
<span class="cp">#define PFM_PMD_LONG_RESET	1</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notify_user</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* notify user program of overflow */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset_ovfl_pmds</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* reset overflowed PMDs */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_task</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* block monitored task on kernel exit */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask_monitoring</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* mask monitors via PMCx.plm */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">28</span><span class="p">;</span>	<span class="cm">/* for future use */</span>
	<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pfm_ovfl_ctrl_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">ovfl_pmd</span><span class="p">;</span>			<span class="cm">/* index of overflowed PMD  */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">ovfl_notify</span><span class="p">;</span>			<span class="cm">/* =1 if monitor requested overflow notification */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">active_set</span><span class="p">;</span>			<span class="cm">/* event set active at the time of the overflow */</span>
	<span class="n">pfm_ovfl_ctrl_t</span> <span class="n">ovfl_ctrl</span><span class="p">;</span>			<span class="cm">/* return: perfmon controls to set by handler */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">pmd_last_reset</span><span class="p">;</span>			<span class="cm">/* last reset value of of the PMD */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">smpl_pmds</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>			<span class="cm">/* bitmask of other PMD of interest on overflow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">smpl_pmds_values</span><span class="p">[</span><span class="n">PMU_MAX_PMDS</span><span class="p">];</span> <span class="cm">/* values for the other PMDs of interest */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">pmd_value</span><span class="p">;</span>			<span class="cm">/* current 64-bit value of the PMD */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">pmd_eventid</span><span class="p">;</span>			<span class="cm">/* eventid associated with PMD */</span>
<span class="p">}</span> <span class="n">pfm_ovfl_arg_t</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">fmt_name</span><span class="p">;</span>
	<span class="n">pfm_uuid_t</span>	<span class="n">fmt_uuid</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">fmt_arg_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">fmt_flags</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_validate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_getsize</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> 		<span class="p">(</span><span class="o">*</span><span class="n">fmt_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">pfm_ovfl_arg_t</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stamp</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_restart</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_ovfl_ctrl_t</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_restart_active</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="n">pfm_ovfl_ctrl_t</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">fmt_exit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fmt_list</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pfm_buffer_fmt_t</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_register_buffer_fmt</span><span class="p">(</span><span class="n">pfm_buffer_fmt_t</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_unregister_buffer_fmt</span><span class="p">(</span><span class="n">pfm_uuid_t</span> <span class="n">uuid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * perfmon interface exported to modules</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_mod_read_pmds</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_mod_write_pmcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_mod_write_ibrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pfm_mod_write_dbrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nreq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * describe the content of the local_cpu_date-&gt;pfm_syst_info field</span>
<span class="cm"> */</span>
<span class="cp">#define PFM_CPUINFO_SYST_WIDE	0x1	</span><span class="cm">/* if set a system wide session exists */</span><span class="cp"></span>
<span class="cp">#define PFM_CPUINFO_DCR_PP	0x2	</span><span class="cm">/* if set the system wide session has started */</span><span class="cp"></span>
<span class="cp">#define PFM_CPUINFO_EXCL_IDLE	0x4	</span><span class="cm">/* the system wide session excludes the idle task */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * sysctl control structure. visible to sampling formats</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">debug</span><span class="p">;</span>		<span class="cm">/* turn on/off debugging via syslog */</span>
	<span class="kt">int</span>	<span class="n">debug_ovfl</span><span class="p">;</span>	<span class="cm">/* turn on/off debug printk in overflow handler */</span>
	<span class="kt">int</span>	<span class="n">fastctxsw</span><span class="p">;</span>	<span class="cm">/* turn on/off fast (unsecure) ctxsw */</span>
	<span class="kt">int</span>	<span class="n">expert_mode</span><span class="p">;</span>	<span class="cm">/* turn on/off value checking */</span>
<span class="p">}</span> <span class="n">pfm_sysctl_t</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pfm_sysctl_t</span> <span class="n">pfm_sysctl</span><span class="p">;</span>


<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_PERFMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
