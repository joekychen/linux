<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › xen › minstate.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>minstate.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifdef CONFIG_VIRT_CPU_ACCOUNTING</span>
<span class="cm">/* read ar.itc in advance, and use it before leaving bank 0 */</span>
<span class="cp">#define XEN_ACCOUNT_GET_STAMP		\</span>
<span class="cp">	MOV_FROM_ITC(pUStk, p6, r20, r2);</span>
<span class="cp">#else</span>
<span class="cp">#define XEN_ACCOUNT_GET_STAMP</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * DO_SAVE_MIN switches to the kernel stacks (if necessary) and saves</span>
<span class="cm"> * the minimum state necessary that allows us to turn psr.ic back</span>
<span class="cm"> * on.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumed state upon entry:</span>
<span class="cm"> *	psr.ic: off</span>
<span class="cm"> *	r31:	contains saved predicates (pr)</span>
<span class="cm"> *</span>
<span class="cm"> * Upon exit, the state is as follows:</span>
<span class="cm"> *	psr.ic: off</span>
<span class="cm"> *	 r2 = points to &amp;pt_regs.r16</span>
<span class="cm"> *	 r8 = contents of ar.ccv</span>
<span class="cm"> *	 r9 = contents of ar.csd</span>
<span class="cm"> *	r10 = contents of ar.ssd</span>
<span class="cm"> *	r11 = FPSR_DEFAULT</span>
<span class="cm"> *	r12 = kernel sp (kernel virtual address)</span>
<span class="cm"> *	r13 = points to current task_struct (kernel virtual address)</span>
<span class="cm"> *	p15 = TRUE if psr.i is set in cr.ipsr</span>
<span class="cm"> *	predicate registers (other than p2, p3, and p15), b6, r3, r14, r15:</span>
<span class="cm"> *		preserved</span>
<span class="cm"> * CONFIG_XEN note: p6/p7 are not preserved</span>
<span class="cm"> *</span>
<span class="cm"> * Note that psr.ic is NOT turned on by this macro.  This is so that</span>
<span class="cm"> * we can pass interruption state as arguments to a handler.</span>
<span class="cm"> */</span>
<span class="cp">#define XEN_DO_SAVE_MIN(__COVER,SAVE_IFS,EXTRA,WORKAROUND)					\</span>
<span class="cp">	mov r16=IA64_KR(CURRENT);	</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r27=ar.rsc;			</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r20=r1;			</span><span class="cm">/* A */</span><span class="cp">							\</span>
<span class="cp">	mov r25=ar.unat;		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	MOV_FROM_IPSR(p0,r29);		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	MOV_FROM_IIP(r28);		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r21=ar.fpsr;		</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	mov r26=ar.pfs;			</span><span class="cm">/* I */</span><span class="cp">							\</span>
<span class="cp">	__COVER;			</span><span class="cm">/* B;; (or nothing) */</span><span class="cp">					\</span>
<span class="cp">	adds r16=IA64_TASK_THREAD_ON_USTACK_OFFSET,r16;						\</span>
<span class="cp">	;;											\</span>
<span class="cp">	ld1 r17=[r16];				</span><span class="cm">/* load current-&gt;thread.on_ustack flag */</span><span class="cp">	\</span>
<span class="cp">	st1 [r16]=r0;				</span><span class="cm">/* clear current-&gt;thread.on_ustack flag */</span><span class="cp">	\</span>
<span class="cp">	adds r1=-IA64_TASK_THREAD_ON_USTACK_OFFSET,r16						\</span>
<span class="cp">	</span><span class="cm">/* switch from user to kernel RBS: */</span><span class="cp">							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	invala;				</span><span class="cm">/* M */</span><span class="cp">							\</span>
<span class="cp">	</span><span class="cm">/* SAVE_IFS;*/</span><span class="cp"> </span><span class="cm">/* see xen special handling below */</span><span class="cp">					\</span>
<span class="cp">	cmp.eq pKStk,pUStk=r0,r17;		</span><span class="cm">/* are we in kernel mode already? */</span><span class="cp">		\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov ar.rsc=0;		</span><span class="cm">/* set enforced lazy mode, pl 0, little-endian, loadrs=0 */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov.m r24=ar.rnat;									\</span>
<span class="cp">(pUStk)	addl r22=IA64_RBS_OFFSET,r1;			</span><span class="cm">/* compute base of RBS */</span><span class="cp">		\</span>
<span class="cp">(pKStk) mov r1=sp;					</span><span class="cm">/* get sp  */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk) lfetch.fault.excl.nt1 [r22];								\</span>
<span class="cp">(pUStk)	addl r1=IA64_STK_OFFSET-IA64_PT_REGS_SIZE,r1;	</span><span class="cm">/* compute base of memory stack */</span><span class="cp">	\</span>
<span class="cp">(pUStk)	mov r23=ar.bspstore;				</span><span class="cm">/* save ar.bspstore */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov ar.bspstore=r22;				</span><span class="cm">/* switch to kernel RBS */</span><span class="cp">		\</span>
<span class="cp">(pKStk) addl r1=-IA64_PT_REGS_SIZE,r1;			</span><span class="cm">/* if in kernel mode, use sp (r12) */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">(pUStk)	mov r18=ar.bsp;										\</span>
<span class="cp">(pUStk)	mov ar.rsc=0x3;		</span><span class="cm">/* set eager mode, pl 0, little-endian, loadrs=0 */</span><span class="cp">		\</span>
<span class="cp">	adds r17=2*L1_CACHE_BYTES,r1;		</span><span class="cm">/* really: biggest cache-line size */</span><span class="cp">		\</span>
<span class="cp">	adds r16=PT(CR_IPSR),r1;								\</span>
<span class="cp">	;;											\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17],L1_CACHE_BYTES;						\</span>
<span class="cp">	st8 [r16]=r29;		</span><span class="cm">/* save cr.ipsr */</span><span class="cp">						\</span>
<span class="cp">	;;											\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17];								\</span>
<span class="cp">	tbit.nz p15,p0=r29,IA64_PSR_I_BIT;							\</span>
<span class="cp">	mov r29=b0										\</span>
<span class="cp">	;;											\</span>
<span class="cp">	WORKAROUND;										\</span>
<span class="cp">	adds r16=PT(R8),r1;	</span><span class="cm">/* initialize first base pointer */</span><span class="cp">				\</span>
<span class="cp">	adds r17=PT(R9),r1;	</span><span class="cm">/* initialize second base pointer */</span><span class="cp">				\</span>
<span class="cp">(pKStk)	mov r18=r0;		</span><span class="cm">/* make sure r18 isn&#39;t NaT */</span><span class="cp">					\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r8,16;								\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r9,16;								\</span>
<span class="cp">        ;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r10,24;							\</span>
<span class="cp">	movl r8=XSI_PRECOVER_IFS;								\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r11,24;							\</span>
<span class="cp">        ;;											\</span>
<span class="cp">	</span><span class="cm">/* xen special handling for possibly lazy cover */</span><span class="cp">					\</span>
<span class="cp">	</span><span class="cm">/* SAVE_MIN case in dispatch_ia32_handler: mov r30=r0 */</span><span class="cp">				\</span>
<span class="cp">	ld8 r30=[r8];										\</span>
<span class="cp">(pUStk)	sub r18=r18,r22;	</span><span class="cm">/* r18=RSE.ndirty*8 */</span><span class="cp">						\</span>
<span class="cp">	st8 [r16]=r28,16;	</span><span class="cm">/* save cr.iip */</span><span class="cp">						\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r17]=r30,16;	</span><span class="cm">/* save cr.ifs */</span><span class="cp">						\</span>
<span class="cp">	mov r8=ar.ccv;										\</span>
<span class="cp">	mov r9=ar.csd;										\</span>
<span class="cp">	mov r10=ar.ssd;										\</span>
<span class="cp">	movl r11=FPSR_DEFAULT;   </span><span class="cm">/* L-unit */</span><span class="cp">							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r25,16;	</span><span class="cm">/* save ar.unat */</span><span class="cp">						\</span>
<span class="cp">	st8 [r17]=r26,16;	</span><span class="cm">/* save ar.pfs */</span><span class="cp">						\</span>
<span class="cp">	shl r18=r18,16;		</span><span class="cm">/* compute ar.rsc to be used for &quot;loadrs&quot; */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r27,16;	</span><span class="cm">/* save ar.rsc */</span><span class="cp">						\</span>
<span class="cp">(pUStk)	st8 [r17]=r24,16;	</span><span class="cm">/* save ar.rnat */</span><span class="cp">						\</span>
<span class="cp">(pKStk)	adds r17=16,r17;	</span><span class="cm">/* skip over ar_rnat field */</span><span class="cp">					\</span>
<span class="cp">	;;			</span><span class="cm">/* avoid RAW on r16 &amp; r17 */</span><span class="cp">					\</span>
<span class="cp">(pUStk)	st8 [r16]=r23,16;	</span><span class="cm">/* save ar.bspstore */</span><span class="cp">						\</span>
<span class="cp">	st8 [r17]=r31,16;	</span><span class="cm">/* save predicates */</span><span class="cp">						\</span>
<span class="cp">(pKStk)	adds r16=16,r16;	</span><span class="cm">/* skip over ar_bspstore field */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">	st8 [r16]=r29,16;	</span><span class="cm">/* save b0 */</span><span class="cp">							\</span>
<span class="cp">	st8 [r17]=r18,16;	</span><span class="cm">/* save ar.rsc value for &quot;loadrs&quot; */</span><span class="cp">				\</span>
<span class="cp">	cmp.eq pNonSys,pSys=r0,r0	</span><span class="cm">/* initialize pSys=0, pNonSys=1 */</span><span class="cp">			\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r20,16;	</span><span class="cm">/* save original r1 */</span><span class="cp">				\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r12,16;							\</span>
<span class="cp">	adds r12=-16,r1;	</span><span class="cm">/* switch to kernel memory stack (with 16 bytes of scratch) */</span><span class="cp">	\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r13,16;							\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r21,16;	</span><span class="cm">/* save ar.fpsr */</span><span class="cp">				\</span>
<span class="cp">	mov r13=IA64_KR(CURRENT);	</span><span class="cm">/* establish `current&#39; */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r15,16;							\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r14,16;							\</span>
<span class="cp">	;;											\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16]=r2,16;								\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17]=r3,16;								\</span>
<span class="cp">	XEN_ACCOUNT_GET_STAMP									\</span>
<span class="cp">	adds r2=IA64_PT_REGS_R16_OFFSET,r1;							\</span>
<span class="cp">	;;											\</span>
<span class="cp">	EXTRA;											\</span>
<span class="cp">	movl r1=__gp;		</span><span class="cm">/* establish kernel global pointer */</span><span class="cp">				\</span>
<span class="cp">	;;											\</span>
<span class="cp">	ACCOUNT_SYS_ENTER									\</span>
<span class="cp">	BSW_1(r3,r14);	</span><span class="cm">/* switch back to bank 1 (must be last in insn group) */</span><span class="cp">		\</span>
<span class="cp">	;;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
