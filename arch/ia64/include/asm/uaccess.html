<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › include › asm › uaccess.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uaccess.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _ASM_IA64_UACCESS_H</span>
<span class="cp">#define _ASM_IA64_UACCESS_H</span>

<span class="cm">/*</span>
<span class="cm"> * This file defines various macros to transfer memory areas across</span>
<span class="cm"> * the user/kernel boundary.  This needs to be done carefully because</span>
<span class="cm"> * this code is executed in kernel mode and uses user-specified</span>
<span class="cm"> * addresses.  Thus, we need to be careful not to let the user to</span>
<span class="cm"> * trick us into accessing kernel memory that would normally be</span>
<span class="cm"> * inaccessible.  This code is also fairly performance sensitive,</span>
<span class="cm"> * so we want to spend as little time doing safety checks as</span>
<span class="cm"> * possible.</span>
<span class="cm"> *</span>
<span class="cm"> * To make matters a bit more interesting, these macros sometimes also</span>
<span class="cm"> * called from within the kernel itself, in which case the address</span>
<span class="cm"> * validity check must be skipped.  The get_fs() macro tells us what</span>
<span class="cm"> * to do: if get_fs()==USER_DS, checking is performed, if</span>
<span class="cm"> * get_fs()==KERNEL_DS, checking is bypassed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that even if the memory area specified by the user is in a</span>
<span class="cm"> * valid address range, it is still possible that we&#39;ll get a page</span>
<span class="cm"> * fault while accessing it.  This is handled by filling out an</span>
<span class="cm"> * exception handler fixup entry for each instruction that has the</span>
<span class="cm"> * potential to fault.  When such a fault occurs, the page fault</span>
<span class="cm"> * handler checks to see whether the faulting instruction has a fixup</span>
<span class="cm"> * associated and, if so, sets r8 to -EFAULT and clears r9 to 0 and</span>
<span class="cm"> * then resumes execution at the continuation point.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on &lt;asm-alpha/uaccess.h&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998, 1999, 2001-2004 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/page-flags.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>

<span class="cp">#include &lt;asm/intrinsics.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * For historical reasons, the following macros are grossly misnamed:</span>
<span class="cm"> */</span>
<span class="cp">#define KERNEL_DS	((mm_segment_t) { ~0UL })		</span><span class="cm">/* cf. access_ok() */</span><span class="cp"></span>
<span class="cp">#define USER_DS		((mm_segment_t) { TASK_SIZE-1 })	</span><span class="cm">/* cf. access_ok() */</span><span class="cp"></span>

<span class="cp">#define VERIFY_READ	0</span>
<span class="cp">#define VERIFY_WRITE	1</span>

<span class="cp">#define get_ds()  (KERNEL_DS)</span>
<span class="cp">#define get_fs()  (current_thread_info()-&gt;addr_limit)</span>
<span class="cp">#define set_fs(x) (current_thread_info()-&gt;addr_limit = (x))</span>

<span class="cp">#define segment_eq(a, b)	((a).seg == (b).seg)</span>

<span class="cm">/*</span>
<span class="cm"> * When accessing user memory, we need to make sure the entire area really is in</span>
<span class="cm"> * user-level space.  In order to do this efficiently, we make sure that the page at</span>
<span class="cm"> * address TASK_SIZE is never valid.  We also need to make sure that the address doesn&#39;t</span>
<span class="cm"> * point inside the virtually mapped linear page table.</span>
<span class="cm"> */</span>
<span class="cp">#define __access_ok(addr, size, segment)						\</span>
<span class="cp">({											\</span>
<span class="cp">	__chk_user_ptr(addr);								\</span>
<span class="cp">	(likely((unsigned long) (addr) &lt;= (segment).seg)				\</span>
<span class="cp">	 &amp;&amp; ((segment).seg == KERNEL_DS.seg						\</span>
<span class="cp">	     || likely(REGION_OFFSET((unsigned long) (addr)) &lt; RGN_MAP_LIMIT)));	\</span>
<span class="cp">})</span>
<span class="cp">#define access_ok(type, addr, size)	__access_ok((addr), (size), get_fs())</span>

<span class="cm">/*</span>
<span class="cm"> * These are the main single-value transfer routines.  They automatically</span>
<span class="cm"> * use the right size if we just have the right pointer type.</span>
<span class="cm"> *</span>
<span class="cm"> * Careful to not</span>
<span class="cm"> * (a) re-use the arguments for side effects (sizeof/typeof is ok)</span>
<span class="cm"> * (b) require any knowledge of processes at this stage</span>
<span class="cm"> */</span>
<span class="cp">#define put_user(x, ptr)	__put_user_check((__typeof__(*(ptr))) (x), (ptr), sizeof(*(ptr)), get_fs())</span>
<span class="cp">#define get_user(x, ptr)	__get_user_check((x), (ptr), sizeof(*(ptr)), get_fs())</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;__xxx&quot; versions do not do address space checking, useful when</span>
<span class="cm"> * doing multiple accesses to the same area (the programmer has to do the</span>
<span class="cm"> * checks by hand with &quot;access_ok()&quot;)</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user(x, ptr)	__put_user_nocheck((__typeof__(*(ptr))) (x), (ptr), sizeof(*(ptr)))</span>
<span class="cp">#define __get_user(x, ptr)	__get_user_nocheck((x), (ptr), sizeof(*(ptr)))</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">__put_user_unaligned_unknown</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __put_user_unaligned(x, ptr)								\</span>
<span class="cp">({												\</span>
<span class="cp">	long __ret;										\</span>
<span class="cp">	switch (sizeof(*(ptr))) {								\</span>
<span class="cp">		case 1: __ret = __put_user((x), (ptr)); break;					\</span>
<span class="cp">		case 2: __ret = (__put_user((x), (u8 __user *)(ptr)))				\</span>
<span class="cp">			| (__put_user((x) &gt;&gt; 8, ((u8 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		case 4: __ret = (__put_user((x), (u16 __user *)(ptr)))				\</span>
<span class="cp">			| (__put_user((x) &gt;&gt; 16, ((u16 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		case 8: __ret = (__put_user((x), (u32 __user *)(ptr)))				\</span>
<span class="cp">			| (__put_user((x) &gt;&gt; 32, ((u32 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		default: __ret = __put_user_unaligned_unknown();				\</span>
<span class="cp">	}											\</span>
<span class="cp">	__ret;											\</span>
<span class="cp">})</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">__get_user_unaligned_unknown</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_unaligned(x, ptr)								\</span>
<span class="cp">({												\</span>
<span class="cp">	long __ret;										\</span>
<span class="cp">	switch (sizeof(*(ptr))) {								\</span>
<span class="cp">		case 1: __ret = __get_user((x), (ptr)); break;					\</span>
<span class="cp">		case 2: __ret = (__get_user((x), (u8 __user *)(ptr)))				\</span>
<span class="cp">			| (__get_user((x) &gt;&gt; 8, ((u8 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		case 4: __ret = (__get_user((x), (u16 __user *)(ptr)))				\</span>
<span class="cp">			| (__get_user((x) &gt;&gt; 16, ((u16 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		case 8: __ret = (__get_user((x), (u32 __user *)(ptr)))				\</span>
<span class="cp">			| (__get_user((x) &gt;&gt; 32, ((u32 __user *)(ptr) + 1))); break;		\</span>
<span class="cp">		default: __ret = __get_user_unaligned_unknown();				\</span>
<span class="cp">	}											\</span>
<span class="cp">	__ret;											\</span>
<span class="cp">})</span>

<span class="cp">#ifdef ASM_SUPPORTED</span>
  <span class="k">struct</span> <span class="n">__large_struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">};</span>
<span class="cp"># define __m(x) (*(struct __large_struct __user *)(x))</span>

<span class="cm">/* We need to declare the __ex_table section before we can use it in .xdata.  */</span>
<span class="n">asm</span> <span class="p">(</span><span class="s">&quot;.section </span><span class="se">\&quot;</span><span class="s">__ex_table</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;\n\t</span><span class="s">.previous&quot;</span><span class="p">);</span>

<span class="cp"># define __get_user_size(val, addr, n, err)							\</span>
<span class="cp">do {												\</span>
<span class="cp">	register long __gu_r8 asm (&quot;r8&quot;) = 0;							\</span>
<span class="cp">	register long __gu_r9 asm (&quot;r9&quot;);							\</span>
<span class="cp">	asm (&quot;\n[1:]\tld&quot;#n&quot; %0=%2%P2\t</span><span class="c1">// %0 and %1 get overwritten by exception handler\n&quot;	\</span>
	     <span class="s">&quot;</span><span class="se">\t</span><span class="s">.xdata4 </span><span class="se">\&quot;</span><span class="s">__ex_table</span><span class="se">\&quot;</span><span class="s">, 1b-., 1f-.+4</span><span class="se">\n</span><span class="s">&quot;</span>						\
	     <span class="s">&quot;[1:]&quot;</span>										\
	     <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">__gu_r9</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">__gu_r8</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">__m</span><span class="p">(</span><span class="n">addr</span><span class="p">)),</span> <span class="s">&quot;1&quot;</span><span class="p">(</span><span class="n">__gu_r8</span><span class="p">));</span>			\
	<span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">__gu_r8</span><span class="p">;</span>									\
	<span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="n">__gu_r9</span><span class="p">;</span>									\
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;__put_user_size()&quot; macro tells gcc it reads from memory instead of writing it.  This</span>
<span class="cm"> * is because they do not write to any memory gcc knows about, so there are no aliasing</span>
<span class="cm"> * issues.</span>
<span class="cm"> */</span>
<span class="cp"># define __put_user_size(val, addr, n, err)							\</span>
<span class="cp">do {												\</span>
<span class="cp">	register long __pu_r8 asm (&quot;r8&quot;) = 0;							\</span>
<span class="cp">	asm volatile (&quot;\n[1:]\tst&quot;#n&quot; %1=%r2%P1\t</span><span class="c1">// %0 gets overwritten by exception handler\n&quot;	\</span>
		      <span class="s">&quot;</span><span class="se">\t</span><span class="s">.xdata4 </span><span class="se">\&quot;</span><span class="s">__ex_table</span><span class="se">\&quot;</span><span class="s">, 1b-., 1f-.</span><span class="se">\n</span><span class="s">&quot;</span>					\
		      <span class="s">&quot;[1:]&quot;</span>									\
		      <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">__pu_r8</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">__m</span><span class="p">(</span><span class="n">addr</span><span class="p">)),</span> <span class="s">&quot;rO&quot;</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">__pu_r8</span><span class="p">));</span>		\
	<span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">__pu_r8</span><span class="p">;</span>									\
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="cp">#else </span><span class="cm">/* !ASM_SUPPORTED */</span><span class="cp"></span>
<span class="cp"># define RELOC_TYPE	2	</span><span class="cm">/* ip-rel */</span><span class="cp"></span>
<span class="cp"># define __get_user_size(val, addr, n, err)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	__ld_user(&quot;__ex_table&quot;, (unsigned long) addr, n, RELOC_TYPE);	\</span>
<span class="cp">	(err) = ia64_getreg(_IA64_REG_R8);				\</span>
<span class="cp">	(val) = ia64_getreg(_IA64_REG_R9);				\</span>
<span class="cp">} while (0)</span>
<span class="cp"># define __put_user_size(val, addr, n, err)							\</span>
<span class="cp">do {												\</span>
<span class="cp">	__st_user(&quot;__ex_table&quot;, (unsigned long) addr, n, RELOC_TYPE, (unsigned long) (val));	\</span>
<span class="cp">	(err) = ia64_getreg(_IA64_REG_R8);							\</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* !ASM_SUPPORTED */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__get_user_unknown</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluating arguments X, PTR, SIZE, and SEGMENT may involve subroutine-calls, which</span>
<span class="cm"> * could clobber r8 and r9 (among others).  Thus, be careful not to evaluate it while</span>
<span class="cm"> * using r8/r9.</span>
<span class="cm"> */</span>
<span class="cp">#define __do_get_user(check, x, ptr, size, segment)					\</span>
<span class="cp">({											\</span>
<span class="cp">	const __typeof__(*(ptr)) __user *__gu_ptr = (ptr);				\</span>
<span class="cp">	__typeof__ (size) __gu_size = (size);						\</span>
<span class="cp">	long __gu_err = -EFAULT;							\</span>
<span class="cp">	unsigned long __gu_val = 0;							\</span>
<span class="cp">	if (!check || __access_ok(__gu_ptr, size, segment))				\</span>
<span class="cp">		switch (__gu_size) {							\</span>
<span class="cp">		      case 1: __get_user_size(__gu_val, __gu_ptr, 1, __gu_err); break;	\</span>
<span class="cp">		      case 2: __get_user_size(__gu_val, __gu_ptr, 2, __gu_err); break;	\</span>
<span class="cp">		      case 4: __get_user_size(__gu_val, __gu_ptr, 4, __gu_err); break;	\</span>
<span class="cp">		      case 8: __get_user_size(__gu_val, __gu_ptr, 8, __gu_err); break;	\</span>
<span class="cp">		      default: __get_user_unknown(); break;				\</span>
<span class="cp">		}									\</span>
<span class="cp">	(x) = (__typeof__(*(__gu_ptr))) __gu_val;					\</span>
<span class="cp">	__gu_err;									\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_nocheck(x, ptr, size)	__do_get_user(0, x, ptr, size, KERNEL_DS)</span>
<span class="cp">#define __get_user_check(x, ptr, size, segment)	__do_get_user(1, x, ptr, size, segment)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_user_unknown</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluating arguments X, PTR, SIZE, and SEGMENT may involve subroutine-calls, which</span>
<span class="cm"> * could clobber r8 (among others).  Thus, be careful not to evaluate them while using r8.</span>
<span class="cm"> */</span>
<span class="cp">#define __do_put_user(check, x, ptr, size, segment)					\</span>
<span class="cp">({											\</span>
<span class="cp">	__typeof__ (x) __pu_x = (x);							\</span>
<span class="cp">	__typeof__ (*(ptr)) __user *__pu_ptr = (ptr);					\</span>
<span class="cp">	__typeof__ (size) __pu_size = (size);						\</span>
<span class="cp">	long __pu_err = -EFAULT;							\</span>
<span class="cp">											\</span>
<span class="cp">	if (!check || __access_ok(__pu_ptr, __pu_size, segment))			\</span>
<span class="cp">		switch (__pu_size) {							\</span>
<span class="cp">		      case 1: __put_user_size(__pu_x, __pu_ptr, 1, __pu_err); break;	\</span>
<span class="cp">		      case 2: __put_user_size(__pu_x, __pu_ptr, 2, __pu_err); break;	\</span>
<span class="cp">		      case 4: __put_user_size(__pu_x, __pu_ptr, 4, __pu_err); break;	\</span>
<span class="cp">		      case 8: __put_user_size(__pu_x, __pu_ptr, 8, __pu_err); break;	\</span>
<span class="cp">		      default: __put_user_unknown(); break;				\</span>
<span class="cp">		}									\</span>
<span class="cp">	__pu_err;									\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_nocheck(x, ptr, size)	__do_put_user(0, x, ptr, size, KERNEL_DS)</span>
<span class="cp">#define __put_user_check(x, ptr, size, segment)	__do_put_user(1, x, ptr, size, segment)</span>

<span class="cm">/*</span>
<span class="cm"> * Complex access routines</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__must_check</span> <span class="n">__copy_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_to_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">from</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_from_user</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_user</span><span class="p">((</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __copy_to_user_inatomic		__copy_to_user</span>
<span class="cp">#define __copy_from_user_inatomic	__copy_from_user</span>
<span class="cp">#define copy_to_user(to, from, n)							\</span>
<span class="cp">({											\</span>
<span class="cp">	void __user *__cu_to = (to);							\</span>
<span class="cp">	const void *__cu_from = (from);							\</span>
<span class="cp">	long __cu_len = (n);								\</span>
<span class="cp">											\</span>
<span class="cp">	if (__access_ok(__cu_to, __cu_len, get_fs()))					\</span>
<span class="cp">		__cu_len = __copy_user(__cu_to, (__force void __user *) __cu_from, __cu_len);	\</span>
<span class="cp">	__cu_len;									\</span>
<span class="cp">})</span>

<span class="cp">#define copy_from_user(to, from, n)							\</span>
<span class="cp">({											\</span>
<span class="cp">	void *__cu_to = (to);								\</span>
<span class="cp">	const void __user *__cu_from = (from);						\</span>
<span class="cp">	long __cu_len = (n);								\</span>
<span class="cp">											\</span>
<span class="cp">	__chk_user_ptr(__cu_from);							\</span>
<span class="cp">	if (__access_ok(__cu_from, __cu_len, get_fs()))					\</span>
<span class="cp">		__cu_len = __copy_user((__force void __user *) __cu_to, __cu_from, __cu_len);	\</span>
<span class="cp">	__cu_len;									\</span>
<span class="cp">})</span>

<span class="cp">#define __copy_in_user(to, from, size)	__copy_user((to), (from), (size))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_in_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">__copy_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__do_clear_user</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#define __clear_user(to, n)		__do_clear_user(to, n)</span>

<span class="cp">#define clear_user(to, n)					\</span>
<span class="cp">({								\</span>
<span class="cp">	unsigned long __cu_len = (n);				\</span>
<span class="cp">	if (__access_ok(to, __cu_len, get_fs()))		\</span>
<span class="cp">		__cu_len = __do_clear_user(to, __cu_len);	\</span>
<span class="cp">	__cu_len;						\</span>
<span class="cp">})</span>


<span class="cm">/*</span>
<span class="cm"> * Returns: -EFAULT if exception before terminator, N if the entire buffer filled, else</span>
<span class="cm"> * strlen.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">__must_check</span> <span class="n">__strncpy_from_user</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">to_len</span><span class="p">);</span>

<span class="cp">#define strncpy_from_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	const char __user * __sfu_from = (from);			\</span>
<span class="cp">	long __sfu_ret = -EFAULT;					\</span>
<span class="cp">	if (__access_ok(__sfu_from, 0, get_fs()))			\</span>
<span class="cp">		__sfu_ret = __strncpy_from_user((to), __sfu_from, (n));	\</span>
<span class="cp">	__sfu_ret;							\</span>
<span class="cp">})</span>

<span class="cm">/* Returns: 0 if bad, string length+1 (memory size) of string if ok */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__strlen_user</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define strlen_user(str)				\</span>
<span class="cp">({							\</span>
<span class="cp">	const char __user *__su_str = (str);		\</span>
<span class="cp">	unsigned long __su_ret = 0;			\</span>
<span class="cp">	if (__access_ok(__su_str, 0, get_fs()))		\</span>
<span class="cp">		__su_ret = __strlen_user(__su_str);	\</span>
<span class="cp">	__su_ret;					\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * Returns: 0 if exception before NUL or reaching the supplied limit</span>
<span class="cm"> * (N), a value greater than N if the limit would be exceeded, else</span>
<span class="cm"> * strlen.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__strnlen_user</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#define strnlen_user(str, len)					\</span>
<span class="cp">({								\</span>
<span class="cp">	const char __user *__su_str = (str);			\</span>
<span class="cp">	unsigned long __su_ret = 0;				\</span>
<span class="cp">	if (__access_ok(__su_str, 0, get_fs()))			\</span>
<span class="cp">		__su_ret = __strnlen_user(__su_str, len);	\</span>
<span class="cp">	__su_ret;						\</span>
<span class="cp">})</span>

<span class="cm">/* Generic code can&#39;t deal with the location-relative format that we use for compactness.  */</span>
<span class="cp">#define ARCH_HAS_SORT_EXTABLE</span>
<span class="cp">#define ARCH_HAS_SEARCH_EXTABLE</span>

<span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* location-relative address of insn this fixup is for */</span>
	<span class="kt">int</span> <span class="n">cont</span><span class="p">;</span>	<span class="cm">/* location-relative continuation addr.; if bit 2 is set, r9 is set to 0 */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_handle_exception</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">search_exception_tables</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ia64_done_with_exception</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">search_exception_tables</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">+</span> <span class="n">ia64_psr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_handle_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ARCH_HAS_TRANSLATE_MEM_PTR	1</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">xlate_dev_mem_ptr</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUncached</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a virtual cached kernel memory pointer to an uncached pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">xlate_dev_kmem_ptr</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUncached</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__pa</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_IA64_UACCESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
