<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › mm › discontig.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>discontig.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000, 2003 Silicon Graphics, Inc.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2001 Intel Corp.</span>
<span class="cm"> * Copyright (c) 2001 Tony Luck &lt;tony.luck@intel.com&gt;</span>
<span class="cm"> * Copyright (c) 2002 NEC Corp.</span>
<span class="cm"> * Copyright (c) 2002 Kimio Suganuma &lt;k-suganuma@da.jp.nec.com&gt;</span>
<span class="cm"> * Copyright (c) 2004 Silicon Graphics, Inc</span>
<span class="cm"> *	Russ Anderson &lt;rja@sgi.com&gt;</span>
<span class="cm"> *	Jesse Barnes &lt;jbarnes@sgi.com&gt;</span>
<span class="cm"> *	Jack Steiner &lt;steiner@sgi.com&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Platform initialization for Discontig Memory</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/meminit.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Track per-node information needed to setup the boot memory allocator, the</span>
<span class="cm"> * per-node areas, and the real VM.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">early_node_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_node_data</span> <span class="o">*</span><span class="n">node_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernode_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernode_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_physpages</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_dma_physpages</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">early_node_data</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="n">nodemask_t</span> <span class="n">memory_less_mask</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * To prevent cache aliasing effects, align per-node structures so that they</span>
<span class="cm"> * start at addresses that are strided by node number.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_NODE_ALIGN_OFFSET	(32 * 1024 * 1024)</span>
<span class="cp">#define NODEDATA_ALIGN(addr, node)						\</span>
<span class="cp">	((((addr) + 1024*1024-1) &amp; ~(1024*1024-1)) + 				\</span>
<span class="cp">	     (((node)*PERCPU_PAGE_SIZE) &amp; (MAX_NODE_ALIGN_OFFSET - 1)))</span>

<span class="cm">/**</span>
<span class="cm"> * build_node_maps - callback to setup bootmem structs for each node</span>
<span class="cm"> * @start: physical start of range</span>
<span class="cm"> * @len: length of range</span>
<span class="cm"> * @node: node where this range resides</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate a struct bootmem_data for each piece of memory that we wish to</span>
<span class="cm"> * treat as a virtually contiguous block (i.e. each node). Each such block</span>
<span class="cm"> * must start on an %IA64_GRANULE_SIZE boundary, so we round the address down</span>
<span class="cm"> * if necessary.  Any non-existent pages will simply be part of the virtual</span>
<span class="cm"> * memmap.  We also update min_low_pfn and max_low_pfn here as we receive</span>
<span class="cm"> * memory ranges from the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">build_node_maps</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spfn</span><span class="p">,</span> <span class="n">epfn</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="n">epfn</span> <span class="o">=</span> <span class="n">GRANULEROUNDUP</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">spfn</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">=</span> <span class="n">spfn</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">=</span> <span class="n">epfn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">spfn</span><span class="p">,</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">);</span>
		<span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">epfn</span><span class="p">,</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * early_nr_cpus_node - return number of cpus on a given node</span>
<span class="cm"> * @node: node to check</span>
<span class="cm"> *</span>
<span class="cm"> * Count the number of cpus on @node.  We can&#39;t use nr_cpus_node() yet because</span>
<span class="cm"> * acpi_boot_init() (which builds the node_to_cpu_mask array) hasn&#39;t been</span>
<span class="cm"> * called yet.  Note that node 0 will also count all non-existent cpus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">early_nr_cpus_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_early_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">)</span>
			<span class="n">n</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * compute_pernodesize - compute size of pernode data</span>
<span class="cm"> * @node: the node id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span> <span class="nf">compute_pernodesize</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernodesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpus</span><span class="p">;</span>

	<span class="n">cpus</span> <span class="o">=</span> <span class="n">early_nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">pernodesize</span> <span class="o">+=</span> <span class="n">PERCPU_PAGE_SIZE</span> <span class="o">*</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="n">pernodesize</span> <span class="o">+=</span> <span class="n">node</span> <span class="o">*</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>
	<span class="n">pernodesize</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">));</span>
	<span class="n">pernodesize</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_node_data</span><span class="p">));</span>
	<span class="n">pernodesize</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">));</span>
	<span class="n">pernodesize</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">pernodesize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pernodesize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * per_cpu_node_setup - setup per-cpu areas on each node</span>
<span class="cm"> * @cpu_data: per-cpu area on this node</span>
<span class="cm"> * @node: node to setup</span>
<span class="cm"> *</span>
<span class="cm"> * Copy the static per-cpu data into the region we just set aside and then</span>
<span class="cm"> * setup __per_cpu_offset for each CPU on this node.  Return a pointer to</span>
<span class="cm"> * the end of the area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">per_cpu_node_setup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cpu_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_early_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">__cpu0_per_cpu</span> <span class="o">:</span> <span class="n">__phys_per_cpu_start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">);</span>
		<span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">__per_cpu_start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * percpu area for cpu0 is moved from the __init area</span>
<span class="cm">		 * which is setup by head.S and used till this point.</span>
<span class="cm">		 * Update ar.k3.  This move is ensures that percpu</span>
<span class="cm">		 * area for cpu0 is on the correct node and its</span>
<span class="cm">		 * virtual address isn&#39;t insanely far from other</span>
<span class="cm">		 * percpu areas which is important for congruent</span>
<span class="cm">		 * percpu allocator.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ia64_set_kr</span><span class="p">(</span><span class="n">IA64_KR_PER_CPU_DATA</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_data</span> <span class="o">-</span>
				    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__per_cpu_start</span><span class="p">);</span>

		<span class="n">cpu_data</span> <span class="o">+=</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">cpu_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/**</span>
<span class="cm"> * setup_per_cpu_areas - setup percpu areas</span>
<span class="cm"> *</span>
<span class="cm"> * Arch code has already allocated and initialized percpu areas.  All</span>
<span class="cm"> * this function has to do is to teach the determined layout to the</span>
<span class="cm"> * dynamic percpu allocator, which happens to be more complex than</span>
<span class="cm"> * creating whole new ones using helpers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_per_cpu_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">gi</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">static_size</span><span class="p">,</span> <span class="n">reserved_size</span><span class="p">,</span> <span class="n">dyn_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">prev_node</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">nr_units</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">pcpu_alloc_alloc_info</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="n">nr_cpu_ids</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ai</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;failed to allocate pcpu_alloc_info&quot;</span><span class="p">);</span>
	<span class="n">cpu_map</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">;</span>

	<span class="cm">/* determine base */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">__per_cpu_start</span><span class="p">));</span>
	<span class="n">base_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__per_cpu_start</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* build cpu_map, units are grouped by node */</span>
	<span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">)</span>
				<span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">nr_units</span> <span class="o">=</span> <span class="n">unit</span><span class="p">;</span>

	<span class="cm">/* set basic parameters */</span>
	<span class="n">static_size</span> <span class="o">=</span> <span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="n">reserved_size</span> <span class="o">=</span> <span class="n">PERCPU_MODULE_RESERVE</span><span class="p">;</span>
	<span class="n">dyn_size</span> <span class="o">=</span> <span class="n">PERCPU_PAGE_SIZE</span> <span class="o">-</span> <span class="n">static_size</span> <span class="o">-</span> <span class="n">reserved_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dyn_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;percpu area overflow static=%zd reserved=%zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">static_size</span><span class="p">,</span> <span class="n">reserved_size</span><span class="p">);</span>

	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span>		<span class="o">=</span> <span class="n">static_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span>	<span class="o">=</span> <span class="n">reserved_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span>		<span class="o">=</span> <span class="n">dyn_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span>		<span class="o">=</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span>		<span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">alloc_size</span>		<span class="o">=</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPUs are put into groups according to node.  Walk cpu_map</span>
<span class="cm">	 * and create new groups at node boundaries.</span>
<span class="cm">	 */</span>
	<span class="n">prev_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">unit</span> <span class="o">&lt;</span> <span class="n">nr_units</span><span class="p">;</span> <span class="n">unit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">];</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">prev_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="o">++</span><span class="p">];</span>
		<span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">gi</span><span class="o">-&gt;</span><span class="n">base_offset</span>		<span class="o">=</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">base_offset</span><span class="p">;</span>
		<span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_setup_first_chunk</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;failed to setup percpu area (err=%d)&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">pcpu_free_alloc_info</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * fill_pernode - initialize pernode data.</span>
<span class="cm"> * @node: the node id.</span>
<span class="cm"> * @pernode: physical address of pernode data</span>
<span class="cm"> * @pernodesize: size of the pernode data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">fill_pernode</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernode</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernodesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpu_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpus</span> <span class="o">=</span> <span class="n">early_nr_cpus_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_addr</span> <span class="o">=</span> <span class="n">pernode</span><span class="p">;</span>
	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_size</span> <span class="o">=</span> <span class="n">pernodesize</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">pernode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pernodesize</span><span class="p">);</span>

	<span class="n">cpu_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pernode</span><span class="p">;</span>
	<span class="n">pernode</span> <span class="o">+=</span> <span class="n">PERCPU_PAGE_SIZE</span> <span class="o">*</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="n">pernode</span> <span class="o">+=</span> <span class="n">node</span> <span class="o">*</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>

	<span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">pernode</span><span class="p">);</span>
	<span class="n">pernode</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">));</span>

	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">node_data</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">pernode</span><span class="p">);</span>
	<span class="n">pernode</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_node_data</span><span class="p">));</span>

	<span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bdata</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>
	<span class="n">pernode</span> <span class="o">+=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pg_data_t</span><span class="p">));</span>

	<span class="n">cpu_data</span> <span class="o">=</span> <span class="n">per_cpu_node_setup</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_pernode_space - allocate memory for memory map and per-node structures</span>
<span class="cm"> * @start: physical start of range</span>
<span class="cm"> * @len: length of range</span>
<span class="cm"> * @node: node where this range resides</span>
<span class="cm"> *</span>
<span class="cm"> * This routine reserves space for the per-cpu data struct, the list of</span>
<span class="cm"> * pg_data_ts and the per-node data struct.  Each node will have something like</span>
<span class="cm"> * the following in the first chunk of addr. space large enough to hold it.</span>
<span class="cm"> *</span>
<span class="cm"> *    ________________________</span>
<span class="cm"> *   |                        |</span>
<span class="cm"> *   |~~~~~~~~~~~~~~~~~~~~~~~~| &lt;-- NODEDATA_ALIGN(start, node) for the first</span>
<span class="cm"> *   |    PERCPU_PAGE_SIZE *  |     start and length big enough</span>
<span class="cm"> *   |    cpus_on_this_node   | Node 0 will also have entries for all non-existent cpus.</span>
<span class="cm"> *   |------------------------|</span>
<span class="cm"> *   |   local pg_data_t *    |</span>
<span class="cm"> *   |------------------------|</span>
<span class="cm"> *   |  local ia64_node_data  |</span>
<span class="cm"> *   |------------------------|</span>
<span class="cm"> *   |          ???           |</span>
<span class="cm"> *   |________________________|</span>
<span class="cm"> *</span>
<span class="cm"> * Once this space has been set aside, the bootmem maps are initialized.  We</span>
<span class="cm"> * could probably move the allocation of the per-cpu and ia64_node_data space</span>
<span class="cm"> * outside of this function and use alloc_bootmem_node(), but doing it here</span>
<span class="cm"> * is straightforward and we get the alignments we want so...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_pernode_space</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spfn</span><span class="p">,</span> <span class="n">epfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernodesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pernode</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="n">spfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">epfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">-</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">mapsize</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure this memory falls within this node&#39;s usable memory</span>
<span class="cm">	 * since we may have thrown some away in build_maps().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spfn</span> <span class="o">&lt;</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">||</span> <span class="n">epfn</span> <span class="o">&gt;</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t setup this node&#39;s local space twice... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate total size needed, incl. what&#39;s necessary</span>
<span class="cm">	 * for good alignment and alias prevention.</span>
<span class="cm">	 */</span>
	<span class="n">pernodesize</span> <span class="o">=</span> <span class="n">compute_pernodesize</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">pernode</span> <span class="o">=</span> <span class="n">NODEDATA_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="cm">/* Is this range big enough for what we want to store here? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pernode</span> <span class="o">+</span> <span class="n">pernodesize</span> <span class="o">+</span> <span class="n">mapsize</span><span class="p">))</span>
		<span class="n">fill_pernode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pernode</span><span class="p">,</span> <span class="n">pernodesize</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_node_bootmem - free bootmem allocator memory for use</span>
<span class="cm"> * @start: physical start of range</span>
<span class="cm"> * @len: length of range</span>
<span class="cm"> * @node: node where this range resides</span>
<span class="cm"> *</span>
<span class="cm"> * Simply calls the bootmem allocator to free the specified ranged from</span>
<span class="cm"> * the given pg_data_t&#39;s bdata struct.  After this function has been called</span>
<span class="cm"> * for all the entries in the EFI memory map, the bootmem allocator will</span>
<span class="cm"> * be ready to service allocation requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">free_node_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_bootmem_node</span><span class="p">(</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_pernode_space - reserve memory for per-node space</span>
<span class="cm"> *</span>
<span class="cm"> * Reserve the space used by the bootmem maps &amp; per-node space in the boot</span>
<span class="cm"> * allocator so that when we actually create the real mem maps we don&#39;t</span>
<span class="cm"> * use their memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">reserve_pernode_space</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pdp</span> <span class="o">=</span> <span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">bdp</span> <span class="o">=</span> <span class="n">pdp</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">;</span>

		<span class="cm">/* First the bootmem_map itself */</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">-</span> <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">);</span>
		<span class="n">reserve_bootmem_node</span><span class="p">(</span><span class="n">pdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>

		<span class="cm">/* Now the per-node space */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_size</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_addr</span><span class="p">);</span>
		<span class="n">reserve_bootmem_node</span><span class="p">(</span><span class="n">pdp</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">BOOTMEM_DEFAULT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__meminit</span> <span class="nf">scatter_node_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pg_data_t</span> <span class="o">**</span><span class="n">dst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for_each_online_node() can&#39;t be used at here.</span>
<span class="cm">	 * node_online_map is not set for hot-added nodes at this time,</span>
<span class="cm">	 * because we are halfway through initialization of the new node&#39;s</span>
<span class="cm">	 * structures.  If for_each_online_node() is used, a new node&#39;s</span>
<span class="cm">	 * pg_data_ptrs will be not initialized. Instead of using it,</span>
<span class="cm">	 * pgdat_list[] is checked.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dst</span> <span class="o">=</span> <span class="n">LOCAL_DATA_ADDR</span><span class="p">(</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">pg_data_ptrs</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">pgdat_list</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgdat_list</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * initialize_pernode_data - fixup per-cpu &amp; per-node pointers</span>
<span class="cm"> *</span>
<span class="cm"> * Each node&#39;s per-node area has a copy of the global pg_data_t list, so</span>
<span class="cm"> * we copy that to each node here, as well as setting the per-cpu pointer</span>
<span class="cm"> * to the local node data structure.  The active_cpus field of the per-node</span>
<span class="cm"> * structure gets setup by the platform_cpu_init() function later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">initialize_pernode_data</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">scatter_node_data</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* Set the node_data pointer for each per-cpu struct */</span>
	<span class="n">for_each_possible_early_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">;</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">node_data</span> <span class="o">=</span>
			<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">node_data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="n">cpu0_cpu_info</span><span class="p">;</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node_cpuid</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">nid</span><span class="p">;</span>
		<span class="n">cpu0_cpu_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_ia64</span> <span class="o">*</span><span class="p">)(</span><span class="n">__phys_per_cpu_start</span> <span class="o">+</span>
			<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ia64_cpu_info</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">));</span>
		<span class="n">cpu0_cpu_info</span><span class="o">-&gt;</span><span class="n">node_data</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">node_data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memory_less_node_alloc - * attempt to allocate memory on the best NUMA slit</span>
<span class="cm"> * 	node but fall back to any other node when __alloc_bootmem_node fails</span>
<span class="cm"> *	for best.</span>
<span class="cm"> * @nid: node id</span>
<span class="cm"> * @pernodesize: size of this node&#39;s pernode data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="o">*</span><span class="nf">memory_less_node_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernodesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">best</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bestnode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">anynode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_distance</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">best</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">bestnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">anynode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bestnode</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">bestnode</span> <span class="o">=</span> <span class="n">anynode</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">bestnode</span><span class="p">],</span> <span class="n">pernodesize</span><span class="p">,</span>
		<span class="n">PERCPU_PAGE_SIZE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * memory_less_nodes - allocate and initialize CPU only nodes pernode</span>
<span class="cm"> *	information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">memory_less_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernodesize</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pernode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pernodesize</span> <span class="o">=</span> <span class="n">compute_pernodesize</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">pernode</span> <span class="o">=</span> <span class="n">memory_less_node_alloc</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pernodesize</span><span class="p">);</span>
		<span class="n">fill_pernode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pernode</span><span class="p">),</span> <span class="n">pernodesize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_memory - walk the EFI memory map and setup the bootmem allocator</span>
<span class="cm"> *</span>
<span class="cm"> * Called early in boot to setup the bootmem allocator, and to</span>
<span class="cm"> * allocate the per-cpu and per-node structures.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">find_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">reserve_memory</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;node info missing!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">node_set_online</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nodes_or</span><span class="p">(</span><span class="n">memory_less_mask</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">,</span> <span class="n">node_online_map</span><span class="p">);</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* These actually end up getting called by call_pernode_memory() */</span>
	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">filter_rsvd_memory</span><span class="p">,</span> <span class="n">build_node_maps</span><span class="p">);</span>
	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">filter_rsvd_memory</span><span class="p">,</span> <span class="n">find_pernode_space</span><span class="p">);</span>
	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">find_max_min_low_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">node_low_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node_clear</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">);</span>
			<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">min_pfn</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">filter_memory</span><span class="p">,</span> <span class="n">register_active_ranges</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the boot memory maps in reverse order since that&#39;s</span>
<span class="cm">	 * what the bootmem allocator expects</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">node</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">node</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pernode</span><span class="p">,</span> <span class="n">pernodesize</span><span class="p">,</span> <span class="n">map</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memory_less_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">bdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
		<span class="n">pernode</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_addr</span><span class="p">;</span>
		<span class="n">pernodesize</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">pernode_size</span><span class="p">;</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">pernode</span> <span class="o">+</span> <span class="n">pernodesize</span><span class="p">;</span>

		<span class="n">init_bootmem_node</span><span class="p">(</span><span class="n">pgdat_list</span><span class="p">[</span><span class="n">node</span><span class="p">],</span>
				  <span class="n">map</span><span class="o">&gt;&gt;</span><span class="n">PAGE_SHIFT</span><span class="p">,</span>
				  <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">,</span>
				  <span class="n">bdp</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">filter_rsvd_memory</span><span class="p">,</span> <span class="n">free_node_bootmem</span><span class="p">);</span>

	<span class="n">reserve_pernode_space</span><span class="p">();</span>
	<span class="n">memory_less_nodes</span><span class="p">();</span>
	<span class="n">initialize_pernode_data</span><span class="p">();</span>

	<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>

	<span class="n">find_initrd</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/**</span>
<span class="cm"> * per_cpu_init - setup per-cpu variables</span>
<span class="cm"> *</span>
<span class="cm"> * find_pernode_space() does most of this already, we just need to set</span>
<span class="cm"> * local_per_cpu_offset</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="o">*</span><span class="nf">per_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_possible_early_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">local_per_cpu_offset</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__per_cpu_start</span> <span class="o">+</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * show_mem - give short summary of memory stats</span>
<span class="cm"> *</span>
<span class="cm"> * Shows a simple page count of reserved and used pages in the system.</span>
<span class="cm"> * For discontig machines, it does this on a per-pgdat basis.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">show_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">filter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">total_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Mem-info:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Node memory in pages:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skip_free_areas_node</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">nid</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pgdat_resize_lock</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">present</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_present_pages</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">MAX_ORDER_NR_PAGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">vmemmap_find_next_valid_pfn</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">reserved</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">cached</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">shared</span> <span class="o">+=</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pgdat_resize_unlock</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">total_present</span> <span class="o">+=</span> <span class="n">present</span><span class="p">;</span>
		<span class="n">total_reserved</span> <span class="o">+=</span> <span class="n">reserved</span><span class="p">;</span>
		<span class="n">total_cached</span> <span class="o">+=</span> <span class="n">cached</span><span class="p">;</span>
		<span class="n">total_shared</span> <span class="o">+=</span> <span class="n">shared</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Node %4d:  RAM: %11ld, rsvd: %8d, &quot;</span>
		       <span class="s">&quot;shrd: %10d, swpd: %10d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
		       <span class="n">present</span><span class="p">,</span> <span class="n">reserved</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">cached</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%ld pages of RAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_present</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d reserved pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_reserved</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d pages shared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_shared</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d pages swap cached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_cached</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Total of %ld pages in page table cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">quicklist_total_size</span><span class="p">());</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d free buffer pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_free_buffer_pages</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * call_pernode_memory - use SRAT to call callback functions with node info</span>
<span class="cm"> * @start: physical start of range</span>
<span class="cm"> * @len: length of range</span>
<span class="cm"> * @arg: function to call for each range</span>
<span class="cm"> *</span>
<span class="cm"> * efi_memmap_walk() knows nothing about layout of memory across nodes. Find</span>
<span class="cm"> * out to which node a block of memory belongs.  Ignore memory that we cannot</span>
<span class="cm"> * identify, and split blocks that run across multiple nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Take this opportunity to round the start address up and the end address</span>
<span class="cm"> * down to page boundaries.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">call_pernode_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rs</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">func</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_node_memblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No SRAT table, so assume one node (node 0) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_node_memblks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_paddr</span><span class="p">);</span>
		<span class="n">re</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_paddr</span> <span class="o">+</span>
			 <span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rs</span> <span class="o">&lt;</span> <span class="n">re</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">rs</span><span class="p">,</span> <span class="n">re</span> <span class="o">-</span> <span class="n">rs</span><span class="p">,</span> <span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">re</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * count_node_pages - callback to build per-node memory info structures</span>
<span class="cm"> * @start: physical start of range</span>
<span class="cm"> * @len: length of range</span>
<span class="cm"> * @node: node where this range resides</span>
<span class="cm"> *</span>
<span class="cm"> * Each node has it&#39;s own number of physical pages, DMAable pages, start, and</span>
<span class="cm"> * end page frame number.  This routine will be called by call_pernode_memory()</span>
<span class="cm"> * for each piece of usable memory and will setup these values for each node.</span>
<span class="cm"> * Very similar to build_maps().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">count_node_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">num_physpages</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">))</span>
		<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">num_dma_physpages</span> <span class="o">+=</span>
			<span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">))</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span><span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">GRANULEROUNDUP</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">max_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">max_pfn</span><span class="p">,</span>
				     <span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">min_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">min_pfn</span><span class="p">,</span>
				     <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * paging_init - setup page tables</span>
<span class="cm"> *</span>
<span class="cm"> * paging_init() sets up the page tables for each node of the system and frees</span>
<span class="cm"> * the bootmem allocator memory for general use.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_dma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>

	<span class="n">max_dma</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">MAX_DMA_ADDRESS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">filter_rsvd_memory</span><span class="p">,</span> <span class="n">count_node_pages</span><span class="p">);</span>

	<span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="n">MAX_NUMNODES</span><span class="p">);</span>
	<span class="n">sparse_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
	<span class="n">VMALLOC_END</span> <span class="o">-=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">,</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">)</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">));</span>
	<span class="n">vmem_map</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="n">VMALLOC_END</span><span class="p">;</span>
	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">create_mem_map_page_table</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Virtual mem_map starts at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vmem_map</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_physpages</span> <span class="o">+=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">num_physpages</span><span class="p">;</span>
		<span class="n">pfn_offset</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">min_pfn</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
		<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_mem_map</span> <span class="o">=</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="n">pfn_offset</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">max_pfn</span> <span class="o">&gt;</span> <span class="n">max_pfn</span><span class="p">)</span>
			<span class="n">max_pfn</span> <span class="o">=</span> <span class="n">mem_data</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">max_pfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dma</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>
	<span class="n">free_area_init_nodes</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">);</span>

	<span class="n">zero_page_memmap_ptr</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">empty_zero_page</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="n">pg_data_t</span> <span class="o">*</span><span class="nf">arch_alloc_nodedata</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">compute_pernodesize</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_free_nodedata</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_refresh_nodedata</span><span class="p">(</span><span class="kt">int</span> <span class="n">update_node</span><span class="p">,</span> <span class="n">pg_data_t</span> <span class="o">*</span><span class="n">update_pgdat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgdat_list</span><span class="p">[</span><span class="n">update_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_pgdat</span><span class="p">;</span>
	<span class="n">scatter_node_data</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">vmemmap_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_page</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmemmap_populate_basepages</span><span class="p">(</span><span class="n">start_page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
