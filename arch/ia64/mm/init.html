<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › mm › init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Initialize MMU support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/patch.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/mca.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_tlb_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">MAX_DMA_ADDRESS</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="mh">0x100000000UL</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">VMALLOC_END</span> <span class="o">=</span> <span class="n">VMALLOC_END_INIT</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">VMALLOC_END</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">vmem_map</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmem_map</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">zero_page_memmap_ptr</span><span class="p">;</span>	<span class="cm">/* map entry for zero page */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">zero_page_memmap_ptr</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">__ia64_sync_icache_dcache</span> <span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>				<span class="cm">/* i-cache is already coherent with d-cache */</span>

	<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">)));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>	<span class="cm">/* mark page as clean */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Since DMA is i-cache coherent, any (complete) pages that were written via</span>
<span class="cm"> * DMA can be marked as &quot;clean&quot; so that lazy_mmu_prot_update() doesn&#39;t have to</span>
<span class="cm"> * flush them when they get mapped into an executable vm-area.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">dma_mark_clean</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg_addr</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">pg_addr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pg_addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pg_addr</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pg_addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ia64_set_rbs_bot</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span> <span class="o">=</span> <span class="n">rlimit_max</span><span class="p">(</span><span class="n">RLIMIT_STACK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stack_size</span> <span class="o">&gt;</span> <span class="n">MAX_USER_STACK_SIZE</span><span class="p">)</span>
		<span class="n">stack_size</span> <span class="o">=</span> <span class="n">MAX_USER_STACK_SIZE</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">rbs_bot</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">-</span> <span class="n">stack_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This performs some platform-dependent address space initialization.</span>
<span class="cm"> * On IA-64, we want to setup the VM area for the register backing</span>
<span class="cm"> * store (which grows upwards) and install the gateway page which is</span>
<span class="cm"> * used for signal trampolines, etc.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">ia64_init_addr_space</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">ia64_set_rbs_bot</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re out of memory and kmem_cache_alloc() returns NULL, we simply ignore</span>
<span class="cm">	 * the problem.  When the process attempts to write to the register backing store</span>
<span class="cm">	 * for the first time, it will get a SEGFAULT in this case.</span>
<span class="cm">	 */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">rbs_bot</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">VM_DATA_DEFAULT_FLAGS</span><span class="o">|</span><span class="n">VM_GROWSUP</span><span class="o">|</span><span class="n">VM_ACCOUNT</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insert_vm_struct</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* map NaT-page at address zero to speed up speculative dereferencing of NULL: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">MMAP_PAGE_ZERO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">PAGE_READONLY</span><span class="p">)</span> <span class="o">|</span> <span class="n">_PAGE_MA_NAT</span><span class="p">);</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_RESERVED</span><span class="p">;</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">insert_vm_struct</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
				<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">free_initmem</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia64_imva</span><span class="p">(</span><span class="n">__init_begin</span><span class="p">);</span>
	<span class="n">eaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia64_imva</span><span class="p">(</span><span class="n">__init_end</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">eaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="o">++</span><span class="n">totalram_pages</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Freeing unused kernel memory: %ldkB freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">__init_end</span> <span class="o">-</span> <span class="n">__init_begin</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">free_initrd_mem</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * EFI uses 4KB pages while the kernel can use 4KB or bigger.</span>
<span class="cm">	 * Thus EFI and the kernel may have different page sizes. It is</span>
<span class="cm">	 * therefore possible to have the initrd share the same page as</span>
<span class="cm">	 * the end of the kernel (given current setup).</span>
<span class="cm">	 *</span>
<span class="cm">	 * To avoid freeing/using the wrong page (kernel sized) we:</span>
<span class="cm">	 *	- align up the beginning of initrd</span>
<span class="cm">	 *	- align down the end of initrd</span>
<span class="cm">	 *</span>
<span class="cm">	 *  |             |</span>
<span class="cm">	 *  |=============| a000</span>
<span class="cm">	 *  |             |</span>
<span class="cm">	 *  |             |</span>
<span class="cm">	 *  |             | 9000</span>
<span class="cm">	 *  |/////////////|</span>
<span class="cm">	 *  |/////////////|</span>
<span class="cm">	 *  |=============| 8000</span>
<span class="cm">	 *  |///INITRD////|</span>
<span class="cm">	 *  |/////////////|</span>
<span class="cm">	 *  |/////////////| 7000</span>
<span class="cm">	 *  |             |</span>
<span class="cm">	 *  |KKKKKKKKKKKKK|</span>
<span class="cm">	 *  |=============| 6000</span>
<span class="cm">	 *  |KKKKKKKKKKKKK|</span>
<span class="cm">	 *  |KKKKKKKKKKKKK|</span>
<span class="cm">	 *  K=kernel using 8KB pages</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this example, we must free page 8000 ONLY. So we must align up</span>
<span class="cm">	 * initrd_start and keep initrd_end as is.</span>
<span class="cm">	 */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Freeing initrd memory: %ldkB freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="o">++</span><span class="n">totalram_pages</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This installs a clean page in the kernel&#39;s page table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">put_kernel_page</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">pgprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;put_kernel_page: page at 0x%p not in reserved memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>		<span class="cm">/* note: this is NOT pgd_offset()! */</span>

	<span class="p">{</span>
		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pgprot</span><span class="p">));</span>
	<span class="p">}</span>
  <span class="nl">out:</span>
	<span class="cm">/* no need for flush_tlb */</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">setup_gate</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">gate_section</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map the gate page twice: once read-only to export the ELF</span>
<span class="cm">	 * headers etc. and once execute-only page to enable</span>
<span class="cm">	 * privilege-promotion via &quot;epc&quot;:</span>
<span class="cm">	 */</span>
	<span class="n">gate_section</span> <span class="o">=</span> <span class="n">paravirt_get_gate_section</span><span class="p">();</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">gate_section</span><span class="p">));</span>
	<span class="n">put_kernel_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GATE_ADDR</span><span class="p">,</span> <span class="n">PAGE_READONLY</span><span class="p">);</span>
<span class="cp">#ifdef HAVE_BUGGY_SEGREL</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ia64_imva</span><span class="p">(</span><span class="n">gate_section</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
	<span class="n">put_kernel_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GATE_ADDR</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_GATE</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">put_kernel_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GATE_ADDR</span> <span class="o">+</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_GATE</span><span class="p">);</span>
	<span class="cm">/* Fill in the holes (if any) with read-only zero pages: */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">GATE_ADDR</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		     <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">GATE_ADDR</span> <span class="o">+</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">;</span>
		     <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">put_kernel_page</span><span class="p">(</span><span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span>
					<span class="n">PAGE_READONLY</span><span class="p">);</span>
			<span class="n">put_kernel_page</span><span class="p">(</span><span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PERCPU_PAGE_SIZE</span><span class="p">,</span>
					<span class="n">PAGE_READONLY</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ia64_patch_gate</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">ia64_mmu_init</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">my_cpu_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pta</span><span class="p">,</span> <span class="n">impl_va_bits</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="n">tlb_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DISABLE_VHPT</span>
<span class="cp">#	define VHPT_ENABLE_BIT	0</span>
<span class="cp">#else</span>
<span class="cp">#	define VHPT_ENABLE_BIT	1</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the virtually mapped linear page table (VMLPT) overlaps with a mapped</span>
<span class="cm">	 * address space.  The IA-64 architecture guarantees that at least 50 bits of</span>
<span class="cm">	 * virtual address space are implemented but if we pick a large enough page size</span>
<span class="cm">	 * (e.g., 64KB), the mapped address space is big enough that it will overlap with</span>
<span class="cm">	 * VMLPT.  I assume that once we run on machines big enough to warrant 64KB pages,</span>
<span class="cm">	 * IMPL_VA_MSB will be significantly bigger, so this is unlikely to become a</span>
<span class="cm">	 * problem in practice.  Alternatively, we could truncate the top of the mapped</span>
<span class="cm">	 * address space to not permit mappings that would overlap with the VMLPT.</span>
<span class="cm">	 * --davidm 00/12/06</span>
<span class="cm">	 */</span>
<span class="cp">#	define pte_bits			3</span>
<span class="cp">#	define mapped_space_bits	(3*(PAGE_SHIFT - pte_bits) + PAGE_SHIFT)</span>
	<span class="cm">/*</span>
<span class="cm">	 * The virtual page table has to cover the entire implemented address space within</span>
<span class="cm">	 * a region even though not all of this space may be mappable.  The reason for</span>
<span class="cm">	 * this is that the Access bit and Dirty bit fault handlers perform</span>
<span class="cm">	 * non-speculative accesses to the virtual page table, so the address range of the</span>
<span class="cm">	 * virtual page table itself needs to be covered by virtual page table.</span>
<span class="cm">	 */</span>
<span class="cp">#	define vmlpt_bits		(impl_va_bits - PAGE_SHIFT + pte_bits)</span>
<span class="cp">#	define POW2(n)			(1ULL &lt;&lt; (n))</span>

	<span class="n">impl_va_bits</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">unimpl_va_mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">7UL</span> <span class="o">&lt;&lt;</span> <span class="mi">61</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">impl_va_bits</span> <span class="o">&lt;</span> <span class="mi">51</span> <span class="o">||</span> <span class="n">impl_va_bits</span> <span class="o">&gt;</span> <span class="mi">61</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;CPU has bogus IMPL_VA_MSB value of %lu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">impl_va_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * mapped_space_bits - PAGE_SHIFT is the total number of ptes we need,</span>
<span class="cm">	 * which must fit into &quot;vmlpt_bits - pte_bits&quot; slots. Second half of</span>
<span class="cm">	 * the test makes sure that our mapped space doesn&#39;t overlap the</span>
<span class="cm">	 * unimplemented hole in the middle of the region.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mapped_space_bits</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span> <span class="o">&gt;</span> <span class="n">vmlpt_bits</span> <span class="o">-</span> <span class="n">pte_bits</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">mapped_space_bits</span> <span class="o">&gt;</span> <span class="n">impl_va_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot build a big enough virtual-linear page table&quot;</span>
		      <span class="s">&quot; to cover mapped address space.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot; Try using a smaller page size.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


	<span class="cm">/* place the VMLPT at the end of each page-table mapped region: */</span>
	<span class="n">pta</span> <span class="o">=</span> <span class="n">POW2</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span> <span class="o">-</span> <span class="n">POW2</span><span class="p">(</span><span class="n">vmlpt_bits</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the (virtually mapped linear) page table address.  Bit</span>
<span class="cm">	 * 8 selects between the short and long format, bits 2-7 the</span>
<span class="cm">	 * size of the table, and bit 0 whether the VHPT walker is</span>
<span class="cm">	 * enabled.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_set_pta</span><span class="p">(</span><span class="n">pta</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vmlpt_bits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">VHPT_ENABLE_BIT</span><span class="p">);</span>

	<span class="n">ia64_tlb_init</span><span class="p">();</span>

<span class="cp">#ifdef	CONFIG_HUGETLB_PAGE</span>
	<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">HPAGE_REGION_BASE</span><span class="p">,</span> <span class="n">HPAGE_SHIFT</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ia64_srlz_d</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_VIRTUAL_MEM_MAP</span>
<span class="kt">int</span> <span class="nf">vmemmap_find_next_valid_pfn</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_address</span><span class="p">,</span> <span class="n">hole_next_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stop_address</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">end_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">vmem_map</span><span class="p">[</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
	<span class="n">end_address</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">end_address</span><span class="p">);</span>

	<span class="n">stop_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">vmem_map</span><span class="p">[</span>
		<span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">];</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
		<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">end_address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">end_address</span> <span class="o">+=</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">end_address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">end_address</span> <span class="o">+=</span> <span class="n">PUD_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">end_address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">end_address</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">end_address</span><span class="p">);</span>
<span class="nl">retry_pte:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">end_address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">end_address</span> <span class="o">&lt;</span> <span class="n">stop_address</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">end_address</span> <span class="o">!=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">end_address</span><span class="p">,</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">PMD_SHIFT</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">retry_pte</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Found next valid vmem_map page */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">end_address</span> <span class="o">&lt;</span> <span class="n">stop_address</span><span class="p">);</span>

	<span class="n">end_address</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end_address</span><span class="p">,</span> <span class="n">stop_address</span><span class="p">);</span>
	<span class="n">end_address</span> <span class="o">=</span> <span class="n">end_address</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hole_next_pfn</span> <span class="o">=</span> <span class="n">end_address</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hole_next_pfn</span> <span class="o">-</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">create_mem_map_page_table</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">start_page</span><span class="p">,</span> <span class="n">end_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">map_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="n">map_start</span> <span class="o">=</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">map_end</span>   <span class="o">=</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">start_page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map_start</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">end_page</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map_end</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">paddr_to_nid</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="n">start_page</span><span class="p">;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">end_page</span><span class="p">;</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
			<span class="n">pgd_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">alloc_bootmem_pages_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
			<span class="n">pud_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">alloc_bootmem_pages_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
			<span class="n">pmd_populate_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">alloc_bootmem_pages_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">pfn_pte</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">alloc_bootmem_pages_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					     <span class="n">PAGE_KERNEL</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">memmap_init_callback_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__meminit</span>
<span class="nf">virtual_memmap_init</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memmap_init_callback_data</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">map_start</span><span class="p">,</span> <span class="o">*</span><span class="n">map_end</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">memmap_init_callback_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">map_start</span> <span class="o">=</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">map_end</span>   <span class="o">=</span> <span class="n">vmem_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_start</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="n">map_start</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_end</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
		<span class="n">map_end</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to initialize &quot;out of bounds&quot; struct page elements that fit completely</span>
<span class="cm">	 * on the same pages that were allocated for the &quot;in bounds&quot; elements because they</span>
<span class="cm">	 * may be referenced later (and found to be &quot;reserved&quot;).</span>
<span class="cm">	 */</span>
	<span class="n">map_start</span> <span class="o">-=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map_start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">map_end</span> <span class="o">+=</span> <span class="p">((</span><span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map_end</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map_end</span><span class="p">)</span>
		    <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_start</span> <span class="o">&lt;</span> <span class="n">map_end</span><span class="p">)</span>
		<span class="n">memmap_init_zone</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">map_end</span> <span class="o">-</span> <span class="n">map_start</span><span class="p">),</span>
				 <span class="n">args</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">map_start</span><span class="p">),</span>
				 <span class="n">MEMMAP_EARLY</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__meminit</span>
<span class="nf">memmap_init</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmem_map</span><span class="p">)</span>
		<span class="n">memmap_init_zone</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">MEMMAP_EARLY</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">memmap_init_callback_data</span> <span class="n">args</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">);</span>
		<span class="n">args</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="p">;</span>

		<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">virtual_memmap_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ia64_pfn_valid</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>

	<span class="k">return</span>     <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">pg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">((((</span><span class="n">u64</span><span class="p">)</span><span class="n">pg</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)(</span><span class="n">pg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ia64_pfn_valid</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_largest_hole</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">max_gap</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">static</span> <span class="n">u64</span> <span class="n">last_end</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>

	<span class="cm">/* NOTE: this algorithm assumes efi memmap table is ordered */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">max_gap</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">last_end</span><span class="p">))</span>
		<span class="o">*</span><span class="n">max_gap</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">last_end</span><span class="p">;</span>
	<span class="n">last_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_VIRTUAL_MEM_MAP */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">register_active_ranges</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">memblock_add_node</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">count_reserved_pages</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span>
			<span class="o">++</span><span class="n">num_reserved</span><span class="p">;</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">+=</span> <span class="n">num_reserved</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">find_max_min_low_pfn</span> <span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_start</span><span class="p">,</span> <span class="n">pfn_end</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">pfn_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pfn_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">pfn_start</span> <span class="o">=</span> <span class="n">GRANULEROUNDDOWN</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pfn_end</span> <span class="o">=</span> <span class="n">GRANULEROUNDUP</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_low_pfn</span><span class="p">,</span> <span class="n">pfn_start</span><span class="p">);</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">,</span> <span class="n">pfn_end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Boot command-line option &quot;nolwsys&quot; can be used to disable the use of any light-weight</span>
<span class="cm"> * system call handler.  When this option is in effect, all fsyscalls will end up bubbling</span>
<span class="cm"> * down into the kernel and calling the normal (heavy-weight) syscall handler.  This is</span>
<span class="cm"> * useful for performance testing, but conceivably could also come in handy for debugging</span>
<span class="cm"> * purposes.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nolwsys</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">nolwsys_setup</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nolwsys</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nolwsys&quot;</span><span class="p">,</span> <span class="n">nolwsys_setup</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">mem_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">reserved_pages</span><span class="p">,</span> <span class="n">codesize</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">initsize</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PTRS_PER_PGD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PTRS_PER_PTE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="cm">/*</span>
<span class="cm">	 * This needs to be called _after_ the command line has been parsed but _before_</span>
<span class="cm">	 * any drivers that may need the PCI DMA interface are initialized or bootmem has</span>
<span class="cm">	 * been freed.</span>
<span class="cm">	 */</span>
	<span class="n">platform_dma_init</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FLATMEM</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mem_map</span><span class="p">);</span>
	<span class="n">max_mapnr</span> <span class="o">=</span> <span class="n">max_low_pfn</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">high_memory</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">max_low_pfn</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">for_each_online_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">)</span>
			<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>

	<span class="n">reserved_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">efi_memmap_walk</span><span class="p">(</span><span class="n">count_reserved_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reserved_pages</span><span class="p">);</span>

	<span class="n">codesize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_stext</span><span class="p">;</span>
	<span class="n">datasize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_edata</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span><span class="p">;</span>
	<span class="n">initsize</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__init_end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__init_begin</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Memory: %luk/%luk available (%luk code, %luk reserved, &quot;</span>
	       <span class="s">&quot;%luk data, %luk init)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_free_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">),</span>
	       <span class="n">num_physpages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">),</span> <span class="n">codesize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
	       <span class="n">reserved_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">),</span> <span class="n">datasize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">initsize</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * For fsyscall entrpoints with no light-weight handler, use the ordinary</span>
<span class="cm">	 * (heavy-weight) handler, but mark it by setting bit 0, so the fsyscall entry</span>
<span class="cm">	 * code can tell them apart.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_syscalls</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">NR_syscalls</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">fsyscall_table</span> <span class="o">=</span> <span class="n">paravirt_get_fsyscall_table</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsyscall_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">nolwsys</span><span class="p">)</span>
			<span class="n">fsyscall_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">setup_gate</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="kt">int</span> <span class="nf">arch_add_memory</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

	<span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">ZONE_NORMAL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Problem encountered in __add_pages() as ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span>  <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Even when CONFIG_IA32_SUPPORT is not enabled it is</span>
<span class="cm"> * useful to have the Linux/x86 domain registered to</span>
<span class="cm"> * avoid an attempted module load when emulators call</span>
<span class="cm"> * personality(PER_LINUX32). This saves several milliseconds</span>
<span class="cm"> * on each such call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">exec_domain</span> <span class="n">ia32_exec_domain</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">per_linux32_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Linux/x86&quot;</span><span class="p">;</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">pers_low</span> <span class="o">=</span> <span class="n">PER_LINUX32</span><span class="p">;</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">pers_high</span> <span class="o">=</span> <span class="n">PER_LINUX32</span><span class="p">;</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">signal_map</span> <span class="o">=</span> <span class="n">default_exec_domain</span><span class="p">.</span><span class="n">signal_map</span><span class="p">;</span>
	<span class="n">ia32_exec_domain</span><span class="p">.</span><span class="n">signal_invmap</span> <span class="o">=</span> <span class="n">default_exec_domain</span><span class="p">.</span><span class="n">signal_invmap</span><span class="p">;</span>
	<span class="n">register_exec_domain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ia32_exec_domain</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">per_linux32_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
