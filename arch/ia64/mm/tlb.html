<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › mm › tlb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tlb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * TLB support routines.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998-2001, 2003 Hewlett-Packard Co</span>
<span class="cm"> *	David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 08/02/00 A. Mallick &lt;asit.k.mallick@intel.com&gt;</span>
<span class="cm"> *		Modified RID allocation for SMP</span>
<span class="cm"> *          Goutham Rao &lt;goutham.rao@intel.com&gt;</span>
<span class="cm"> *              IPI based ptc implementation and A-step IPI implementation.</span>
<span class="cm"> * Rohit Seth &lt;rohit.seth@intel.com&gt;</span>
<span class="cm"> * Ken Chen &lt;kenneth.w.chen@intel.com&gt;</span>
<span class="cm"> * Christophe de Dinechin &lt;ddd@hp.com&gt;: Avoid ptc.e on memory allocation</span>
<span class="cm"> * Copyright (C) 2007 Intel Corp</span>
<span class="cm"> *	Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="cm"> *	Add multiple ptc.g/ptc.ga instruction support in global tlb purge.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/pal.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask of supported purge page-sizes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_bits</span><span class="p">;</span>	<span class="cm">/* log2 of largest supported purge page-size */</span>
<span class="p">}</span> <span class="n">purge</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ia64_ctx</span> <span class="n">ia64_ctx</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span>	<span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_ctx</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span>
<span class="p">};</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">ia64_need_tlb_flush</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">ia64_tr_num</span><span class="p">);</span>  <span class="cm">/*Number of TR slots in current processor*/</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">ia64_tr_used</span><span class="p">);</span> <span class="cm">/*Max Slot number used by kernel*/</span>

<span class="k">struct</span> <span class="n">ia64_tr_entry</span> <span class="o">*</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Initializes the ia64_ctx.bitmap array based on max_ctx+1.</span>
<span class="cm"> * Called after cpu_init() has setup ia64_ctx.max_ctx based on</span>
<span class="cm"> * maximum RID that is supported by boot CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">mmu_context_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">((</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">flushmap</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">((</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Acquire the ia64_ctx.lock before calling this function!</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">wrap_mmu_context</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flush_bit</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_bit</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">flushmap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">flush_bit</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="cm">/* use offset at 300 to skip daemons */</span>
	<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">bitmap</span><span class="p">,</span>
				<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
	<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">ia64_ctx</span><span class="p">.</span><span class="n">bitmap</span><span class="p">,</span>
				<span class="n">ia64_ctx</span><span class="p">.</span><span class="n">max_ctx</span><span class="p">,</span> <span class="n">ia64_ctx</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * can&#39;t call flush_tlb_all() here because of race condition</span>
<span class="cm">	 * with O(1) scheduler [EF]</span>
<span class="cm">	 */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span> <span class="cm">/* prevent preemption/migration */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_need_tlb_flush</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="n">local_flush_tlb_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implement &quot;spinaphores&quot; ... like counting semaphores, but they</span>
<span class="cm"> * spin instead of sleeping.  If there are ever any other users for</span>
<span class="cm"> * this primitive it can be moved up to a spinaphore.h header.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spinaphore</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ticket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">serve</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spinaphore_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinaphore</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">ticket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">serve</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">down_spin</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinaphore</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ia64_fetchadd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">,</span> <span class="n">acq</span><span class="p">),</span> <span class="n">serve</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">serve</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ia64_invala</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;ld8.c.nc %0=[%1]&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">serve</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">serve</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">serve</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">up_spin</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinaphore</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_fetchadd</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">serve</span><span class="p">,</span> <span class="n">rel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spinaphore</span> <span class="n">ptcg_sem</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">nptcg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">toolatetochangeptcgsem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel parameter &quot;nptcg=&quot; overrides max number of concurrent global TLB</span>
<span class="cm"> * purges which is reported from either PAL or SAL PALO.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t have sanity checking for nptcg value. It&#39;s the user&#39;s responsibility</span>
<span class="cm"> * for valid nptcg value on the platform. Otherwise, kernel may hang in some</span>
<span class="cm"> * cases.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">set_nptcg</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">setup_ptcg_sem</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NPTCG_FROM_KERNEL_PARAMETER</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nptcg=&quot;</span><span class="p">,</span> <span class="n">set_nptcg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of simultaneous ptc.g purges in the system can</span>
<span class="cm"> * be defined by PAL_VM_SUMMARY (in which case we should take</span>
<span class="cm"> * the smallest value for any cpu in the system) or by the PAL</span>
<span class="cm"> * override table (in which case we should ignore the value from</span>
<span class="cm"> * PAL_VM_SUMMARY).</span>
<span class="cm"> *</span>
<span class="cm"> * Kernel parameter &quot;nptcg=&quot; overrides maximum number of simultanesous ptc.g</span>
<span class="cm"> * purges defined in either PAL_VM_SUMMARY or PAL override table. In this case,</span>
<span class="cm"> * we should ignore the value from either PAL_VM_SUMMARY or PAL override table.</span>
<span class="cm"> *</span>
<span class="cm"> * Complicating the logic here is the fact that num_possible_cpus()</span>
<span class="cm"> * isn&#39;t fully setup until we start bringing cpus online.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">setup_ptcg_sem</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_purges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nptcg_from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">kp_override</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">palo_override</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">firstcpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">toolatetochangeptcgsem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nptcg_from</span> <span class="o">==</span> <span class="n">NPTCG_FROM_PAL</span> <span class="o">&amp;&amp;</span> <span class="n">max_purges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nptcg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">max_purges</span> <span class="o">&lt;</span> <span class="n">nptcg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nptcg_from</span> <span class="o">==</span> <span class="n">NPTCG_FROM_KERNEL_PARAMETER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kp_override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nptcg</span> <span class="o">=</span> <span class="n">max_purges</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">resetsema</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kp_override</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nptcg</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nptcg_from</span> <span class="o">==</span> <span class="n">NPTCG_FROM_PALO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">palo_override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* In PALO max_purges == 0 really means it! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_purges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Whoa! Platform does not support global TLB purges.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nptcg</span> <span class="o">=</span> <span class="n">max_purges</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nptcg</span> <span class="o">==</span> <span class="n">PALO_MAX_TLB_PURGES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">resetsema</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">palo_override</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nptcg</span> <span class="o">!=</span> <span class="n">PALO_MAX_TLB_PURGES</span><span class="p">)</span>
			<span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nptcg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In PAL_VM_SUMMARY max_purges == 0 actually means 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_purges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">max_purges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firstcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nptcg</span> <span class="o">=</span> <span class="n">max_purges</span><span class="p">;</span>
		<span class="n">firstcpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_purges</span> <span class="o">&lt;</span> <span class="n">nptcg</span><span class="p">)</span>
		<span class="n">nptcg</span> <span class="o">=</span> <span class="n">max_purges</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nptcg</span> <span class="o">==</span> <span class="n">PAL_MAX_PURGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">need_ptcg_sem</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nptcg</span><span class="p">);</span>

<span class="nl">resetsema:</span>
	<span class="n">spinaphore_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptcg_sem</span><span class="p">,</span> <span class="n">max_purges</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">ia64_global_tlb_purge</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>

	<span class="n">toolatetochangeptcgsem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">active_mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Restore region IDs for mm */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">active_mm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">activate_context</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">flush_tlb_all</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_ptcg_sem</span><span class="p">)</span>
		<span class="n">down_spin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptcg_sem</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Flush ALAT entries also.</span>
<span class="cm">		 */</span>
		<span class="n">ia64_ptcga</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_ptcg_sem</span><span class="p">)</span>
		<span class="n">up_spin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptcg_sem</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">active_mm</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">activate_context</span><span class="p">(</span><span class="n">active_mm</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">local_flush_tlb_all</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">count0</span><span class="p">,</span> <span class="n">count1</span><span class="p">,</span> <span class="n">stride0</span><span class="p">,</span> <span class="n">stride1</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span>    <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_base</span><span class="p">;</span>
	<span class="n">count0</span>  <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">count1</span>  <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">stride0</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">stride1</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count0</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_ptce</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">stride1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">stride0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>			<span class="cm">/* srlz.i implies srlz.d */</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">flush_tlb_range</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbits</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">nbits</span> <span class="o">=</span> <span class="n">ia64_fls</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mh">0xfff</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">purge</span><span class="p">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;</span> <span class="n">purge</span><span class="p">.</span><span class="n">max_bits</span><span class="p">))</span>
		<span class="o">++</span><span class="n">nbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&gt;</span> <span class="n">purge</span><span class="p">.</span><span class="n">max_bits</span><span class="p">)</span>
		<span class="n">nbits</span> <span class="o">=</span> <span class="n">purge</span><span class="p">.</span><span class="n">max_bits</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">||</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">platform_global_tlb_purge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ia64_ptcl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">nbits</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">));</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>			<span class="cm">/* srlz.i implies srlz.d */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_tlb_range</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">ia64_tlb_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ptce_info_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ptce_info</span><span class="p">);</span> <span class="cm">/* GCC be quiet */</span>
	<span class="n">u64</span> <span class="n">tr_pgbits</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">pal_vm_info_1_u_t</span> <span class="n">vm_info_1</span><span class="p">;</span>
	<span class="n">pal_vm_info_2_u_t</span> <span class="n">vm_info_2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_vm_page_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tr_pgbits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">purge</span><span class="p">.</span><span class="n">mask</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PAL_VM_PAGE_SIZE failed with status=%ld; &quot;</span>
		       <span class="s">&quot;defaulting to architected purge page-sizes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">purge</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mh">0x115557000UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">purge</span><span class="p">.</span><span class="n">max_bits</span> <span class="o">=</span> <span class="n">ia64_fls</span><span class="p">(</span><span class="n">purge</span><span class="p">.</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">ia64_get_ptce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptce_info</span><span class="p">);</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_base</span> <span class="o">=</span> <span class="n">ptce_info</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce_info</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce_info</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce_info</span><span class="p">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce_info</span><span class="p">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">local_flush_tlb_all</span><span class="p">();</span>	<span class="cm">/* nuke left overs from bootstrapping... */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_vm_summary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_info_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_info_2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ia64_pal_vm_summary=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">vm_info_1</span><span class="p">.</span><span class="n">pal_vm_info_1_s</span><span class="p">.</span><span class="n">max_itr_entry</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="p">(</span><span class="n">vm_info_1</span><span class="p">.</span><span class="n">pal_vm_info_1_s</span><span class="p">.</span><span class="n">max_dtr_entry</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
				<span class="n">vm_info_1</span><span class="p">.</span><span class="n">pal_vm_info_1_s</span><span class="p">.</span><span class="n">max_dtr_entry</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">IA64_TR_ALLOC_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">justonce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">IA64_TR_ALLOC_MAX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">justonce</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">justonce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;TR register number exceeds &quot;</span>
			       <span class="s">&quot;IA64_TR_ALLOC_MAX!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_tr_overlap</span>
<span class="cm"> *</span>
<span class="cm"> * Check overlap with inserted TRs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_tr_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ia64_tr_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="n">va</span><span class="p">,</span> <span class="n">u64</span> <span class="n">log_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tr_log_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tr_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">va_rr</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">va_rid</span> <span class="o">=</span> <span class="n">RR_TO_RID</span><span class="p">(</span><span class="n">va_rr</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">va_end</span> <span class="o">=</span> <span class="n">va</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">log_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">va_rid</span> <span class="o">!=</span> <span class="n">RR_TO_RID</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tr_log_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">tr_end</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tr_log_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;</span> <span class="n">tr_end</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span> <span class="o">&gt;</span> <span class="n">va_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_insert_tr in virtual mode. Allocate a TR slot</span>
<span class="cm"> *</span>
<span class="cm"> * target_mask : 0x1 : itr, 0x2 : dtr, 0x3 : idtr</span>
<span class="cm"> *</span>
<span class="cm"> * va 	: virtual address.</span>
<span class="cm"> * pte 	: pte entries inserted.</span>
<span class="cm"> * log_size: range to be covered.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:  &lt;0 :  error No.</span>
<span class="cm"> *</span>
<span class="cm"> *		  &gt;=0 : slot number allocated for TR.</span>
<span class="cm"> * Must be called with preemption disabled.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ia64_itr_entry</span><span class="p">(</span><span class="n">u64</span> <span class="n">target_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">va</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pte</span><span class="p">,</span> <span class="n">u64</span> <span class="n">log_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_tr_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">*</span>
				<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_tr_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*Check overlap with existing TR entries*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IA64_TR_ALLOC_BASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
								<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_tr_overlap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">log_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Overlapped Entry&quot;</span>
						<span class="s">&quot;Inserted for TR Reigster!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IA64_TR_ALLOC_BASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
								<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_tr_overlap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">log_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Overlapped Entry&quot;</span>
						<span class="s">&quot;Inserted for TR Reigster!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">IA64_TR_ALLOC_BASE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/*Record tr info for mca hander use!*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">psr</span> <span class="o">=</span> <span class="n">ia64_clear_ic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_itr</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">log_size</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">=</span> <span class="n">log_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_itr</span><span class="p">(</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">log_size</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span> <span class="o">=</span> <span class="n">log_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">rr</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ia64_set_psr</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ia64_itr_entry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ia64_purge_tr</span>
<span class="cm"> *</span>
<span class="cm"> * target_mask: 0x1: purge itr, 0x2 : purge dtr, 0x3 purge idtr.</span>
<span class="cm"> * slot: slot number to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with preemption disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ia64_ptr_entry</span><span class="p">(</span><span class="n">u64</span> <span class="n">target_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_tr_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">IA64_TR_ALLOC_BASE</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_num</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">slot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span><span class="o">&amp;</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_tr_overlap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ia64_ptr</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">);</span>
			<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target_mask</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">+</span> <span class="n">slot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_tr_overlap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ia64_ptr</span><span class="p">(</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ifa</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">itir</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">);</span>
			<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IA64_TR_ALLOC_BASE</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">ia64_idtrs</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span> <span class="n">IA64_TR_ALLOC_MAX</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_tr_used</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ia64_ptr_entry</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
