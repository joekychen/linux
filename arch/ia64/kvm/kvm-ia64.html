<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kvm › kvm-ia64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kvm-ia64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kvm_ia64.c: Basic KVM suppport On Itanium series processors</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 	Copyright (C) 2007, Intel Corporation.</span>
<span class="cm"> *  	Xiantao Zhang  (xiantao.zhang@intel.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &lt;linux/kvm.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/iommu.h&gt;</span>
<span class="cp">#include &lt;linux/intel-iommu.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/gcc_intrin.h&gt;</span>
<span class="cp">#include &lt;asm/pal.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/elf.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/clksupport.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shub_mmr.h&gt;</span>

<span class="cp">#include &quot;misc.h&quot;</span>
<span class="cp">#include &quot;vti.h&quot;</span>
<span class="cp">#include &quot;iodev.h&quot;</span>
<span class="cp">#include &quot;ioapic.h&quot;</span>
<span class="cp">#include &quot;lapic.h&quot;</span>
<span class="cp">#include &quot;irq.h&quot;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_vmm_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_vsa_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_vm_buffer</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_vm_buffer_size</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kvm_vmm_gp</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">vp_env_info</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_vmm_info</span> <span class="o">*</span><span class="n">kvm_vmm_info</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">,</span> <span class="n">last_vcpu</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kvm_stats_debugfs_item</span> <span class="n">debugfs_entries</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kvm_get_itc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">is_sn2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rtc_time</span><span class="p">();</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_AR_ITC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_flush_icache</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">32</span><span class="p">);</span> <span class="n">l</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">ia64_fc</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="p">));</span>

	<span class="n">ia64_sync_i</span><span class="p">();</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_flush_tlb_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">count0</span><span class="p">,</span> <span class="n">count1</span><span class="p">,</span> <span class="n">stride0</span><span class="p">,</span> <span class="n">stride1</span><span class="p">,</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">addr</span>    <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_base</span><span class="p">;</span>
	<span class="n">count0</span>  <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">count1</span>  <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">stride0</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">stride1</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count0</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ia64_ptce</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">stride1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">stride0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>			<span class="cm">/* srlz.i implies srlz.d */</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">ia64_pal_vp_create</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">host_iva</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">opt_handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_pal_retval</span> <span class="n">iprv</span><span class="p">;</span>

	<span class="n">PAL_CALL_STK</span><span class="p">(</span><span class="n">iprv</span><span class="p">,</span> <span class="n">PAL_VP_CREATE</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vpd</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">host_iva</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">opt_handler</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">iprv</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>  <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">vp_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_arch_hardware_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>  <span class="n">status</span><span class="p">;</span>
	<span class="kt">long</span>  <span class="n">tmp_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">saved_psr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">),</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">saved_psr</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">ia64_itr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">KVM_VMM_BASE</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">KVM_VMM_SHIFT</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">saved_psr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_vp_init_env</span><span class="p">(</span><span class="n">kvm_vsa_base</span> <span class="o">?</span>
				<span class="n">VP_INIT_ENV</span> <span class="o">:</span> <span class="n">VP_INIT_ENV_INITALIZE</span><span class="p">,</span>
			<span class="n">__pa</span><span class="p">(</span><span class="n">kvm_vm_buffer</span><span class="p">),</span> <span class="n">KVM_VM_BUFFER_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_lock</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;kvm: Failed to Enable VT Support!!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vsa_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_vsa_base</span> <span class="o">=</span> <span class="n">tmp_base</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="s">&quot;kvm: kvm_vsa_base:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kvm_vsa_base</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp_lock</span><span class="p">);</span>
	<span class="n">ia64_ptr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_hardware_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">garbage</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">saved_psr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_iva</span> <span class="o">=</span> <span class="n">ia64_getreg</span><span class="p">(</span><span class="n">_IA64_REG_CR_IVA</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">),</span>
				<span class="n">PAGE_KERNEL</span><span class="p">));</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">saved_psr</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">ia64_itr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">KVM_VMM_BASE</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">KVM_VMM_SHIFT</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">saved_psr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_pal_vp_exit_env</span><span class="p">(</span><span class="n">host_iva</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Failed to disable VT support! :%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
	<span class="n">ia64_ptr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_check_processor_compat</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rtn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">rtn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_dev_ioctl_check_extension</span><span class="p">(</span><span class="kt">long</span> <span class="n">ext</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_CAP_IRQCHIP</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_MP_STATE</span>:
	<span class="k">case</span> <span class="n">KVM_CAP_IRQ_INJECT_STATUS</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_COALESCED_MMIO</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">KVM_COALESCED_MMIO_PAGE_OFFSET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_CAP_IOMMU</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">iommu_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vm_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_req</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_io_device</span> <span class="o">*</span><span class="n">mmio_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_vcpu_ioreq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOAPIC_DEFAULT_BASE_ADDRESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">mmio</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_fragments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span> <span class="o">=</span> <span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">is_write</span> <span class="o">=</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmio_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_MMIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">mmio:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_io_bus_read</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_MMIO_BUS</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				    <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_io_bus_write</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_MMIO_BUS</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				     <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: No iodevice found! addr:%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_IORESP_READY</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_pal_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">exit_ctl_data</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_exit_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_PAL_CALL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kvm_pal_emul</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_run</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_sal_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">exit_ctl_data</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_exit_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">==</span> <span class="n">EXIT_REASON_SAL_CALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_sal_emul</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__apic_accept_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">irr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">irq_new_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm_vcpu_kick</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  offset: address offset to IPI space.</span>
<span class="cm"> *  value:  deliver value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vcpu_deliver_ipi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">dm</span><span class="p">,</span>
				<span class="kt">uint64_t</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SAPIC_FIXED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAPIC_NMI</span>:
		<span class="n">vector</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAPIC_EXTINT</span>:
		<span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAPIC_INIT</span>:
	<span class="k">case</span> <span class="n">SAPIC_PMI</span>:
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: Unimplemented Deliver reserved IPI!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__apic_accept_irq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">lid_to_vcpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ia64_lid</span> <span class="n">lid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>

	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lid</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">VCPU_LID</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lid</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">lid</span><span class="p">.</span><span class="n">eid</span> <span class="o">==</span> <span class="n">eid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">vcpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ipi</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">exit_ctl_data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_exit_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">target_vcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ia64_ipi_a</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ipi_data</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ia64_ipi_d</span> <span class="n">data</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ipi_data</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>

	<span class="n">target_vcpu</span> <span class="o">=</span> <span class="n">lid_to_vcpu</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">eid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_vcpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">handle_vm_error</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_run</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target_vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">launched</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">vcpu_regs</span><span class="p">(</span><span class="n">target_vcpu</span><span class="p">);</span>

		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rdv_sal_data</span><span class="p">.</span><span class="n">boot_ip</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">rdv_sal_data</span><span class="p">.</span><span class="n">boot_gp</span><span class="p">;</span>

		<span class="n">target_vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target_vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target_vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vcpu_deliver_ipi</span><span class="p">(</span><span class="n">target_vcpu</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">dm</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">vector</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_vcpu</span> <span class="o">!=</span> <span class="n">vcpu</span><span class="p">)</span>
			<span class="n">kvm_vcpu_kick</span><span class="p">(</span><span class="n">target_vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">call_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_ptc_g</span> <span class="n">ptc_g_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vcpu_global_purge</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">call_data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">call_data</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_PTC_G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptc_g_count</span> <span class="o">&lt;</span> <span class="n">MAX_PTC_G_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptc_g_data</span><span class="p">[</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptc_g_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">p</span><span class="o">-&gt;</span><span class="n">ptc_g_data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_PTC_G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptc_g_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_global_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">exit_ctl_data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_exit_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">call_data</span> <span class="n">call_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpui</span><span class="p">;</span>

	<span class="n">call_data</span><span class="p">.</span><span class="n">ptc_g_data</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ptc_g_data</span><span class="p">;</span>

	<span class="n">kvm_for_each_vcpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">vcpui</span><span class="p">,</span> <span class="n">kvm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpui</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span> <span class="o">||</span>
				<span class="n">vcpu</span> <span class="o">==</span> <span class="n">vcpui</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpui</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpui</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vcpui</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">call_data</span><span class="p">.</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">vcpui</span><span class="p">;</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">vcpui</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
					<span class="n">vcpu_global_purge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;kvm: Uninit vcpu received ipi!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_switch_rr6</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_sn2_setup_mappings</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">,</span> <span class="n">rtc_phys_addr</span><span class="p">,</span> <span class="n">map_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">map_addr</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">KVM_VMM_SHIFT</span><span class="p">);</span>
	<span class="n">rtc_phys_addr</span> <span class="o">=</span> <span class="n">LOCAL_MMR_OFFSET</span> <span class="o">|</span> <span class="n">SH_RTC</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">rtc_phys_addr</span><span class="p">,</span> <span class="n">PAGE_KERNEL_UC</span><span class="p">));</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">ia64_itr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">map_addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sn_rtc_tr_slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Mayday mayday! RTC mapping failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ktime_t</span> <span class="n">kt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">itc_diff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vcpu_now_itc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">p_ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cyc_per_usec</span> <span class="o">=</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">cyc_per_usec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">vcpu_now_itc</span> <span class="o">=</span> <span class="n">kvm_get_itc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">+</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itc_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">vcpu_now_itc</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">itm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">itc_diff</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">itm</span> <span class="o">-</span> <span class="n">vcpu_now_itc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">itc_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">itc_diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">itc_diff</span><span class="p">;</span>

		<span class="n">expires</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">itc_diff</span><span class="p">,</span> <span class="n">cyc_per_usec</span><span class="p">);</span>
		<span class="n">kt</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">expires</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ht_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hrtimer_start</span><span class="p">(</span><span class="n">p_ht</span><span class="p">,</span> <span class="n">kt</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_HALTED</span><span class="p">;</span>
		<span class="n">kvm_vcpu_block</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="n">p_ht</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ht_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_UNHALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_HALTED</span><span class="p">)</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">!=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: Unsupported userspace halt!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vm_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_SHUTDOWN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_external_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_vcpu_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;VMM: %s&quot;</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">log_buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kvm_vti_exit_handlers</span><span class="p">[])(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VM_PANIC</span><span class="p">]</span>              <span class="o">=</span> <span class="n">handle_vm_error</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_MMIO_INSTRUCTION</span><span class="p">]</span>      <span class="o">=</span> <span class="n">handle_mmio</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_PAL_CALL</span><span class="p">]</span>              <span class="o">=</span> <span class="n">handle_pal_call</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_SAL_CALL</span><span class="p">]</span>              <span class="o">=</span> <span class="n">handle_sal_call</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_SWITCH_RR6</span><span class="p">]</span>            <span class="o">=</span> <span class="n">handle_switch_rr6</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_VM_DESTROY</span><span class="p">]</span>            <span class="o">=</span> <span class="n">handle_vm_shutdown</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_EXTERNAL_INTERRUPT</span><span class="p">]</span>    <span class="o">=</span> <span class="n">handle_external_interrupt</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_IPI</span><span class="p">]</span>		    <span class="o">=</span> <span class="n">handle_ipi</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_PTC_G</span><span class="p">]</span>		    <span class="o">=</span> <span class="n">handle_global_purge</span><span class="p">,</span>
	<span class="p">[</span><span class="n">EXIT_REASON_DEBUG</span><span class="p">]</span>		    <span class="o">=</span> <span class="n">handle_vcpu_debug</span><span class="p">,</span>

<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kvm_vti_max_exit_handlers</span> <span class="o">=</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">kvm_vti_exit_handlers</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kvm_vti_exit_handlers</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">kvm_get_exit_reason</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">exit_ctl_data</span> <span class="o">*</span><span class="n">p_exit_data</span><span class="p">;</span>

	<span class="n">p_exit_data</span> <span class="o">=</span> <span class="n">kvm_get_exit_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p_exit_data</span><span class="o">-&gt;</span><span class="n">exit_reason</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The guest has exited.  See if we can fix it or if we need userspace</span>
<span class="cm"> * assistance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_handle_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">exit_reason</span> <span class="o">=</span> <span class="n">kvm_get_exit_reason</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_exit</span> <span class="o">=</span> <span class="n">exit_reason</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exit_reason</span> <span class="o">&lt;</span> <span class="n">kvm_vti_max_exit_handlers</span>
			<span class="o">&amp;&amp;</span> <span class="n">kvm_vti_exit_handlers</span><span class="p">[</span><span class="n">exit_reason</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">kvm_vti_exit_handlers</span><span class="p">[</span><span class="n">exit_reason</span><span class="p">](</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_run</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_UNKNOWN</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hardware_exit_reason</span> <span class="o">=</span> <span class="n">exit_reason</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vti_set_rr6</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rr6</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">RR6</span><span class="p">,</span> <span class="n">rr6</span><span class="p">);</span>
	<span class="n">ia64_srlz_i</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_insert_vmm_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*Insert a pair of tr to map vmm*/</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">),</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">ia64_itr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">KVM_VMM_BASE</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">KVM_VMM_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_tr_slot</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/*Insert a pairt of tr to map data of vm*/</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">mk_pte_phys</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_base</span><span class="p">),</span> <span class="n">PAGE_KERNEL</span><span class="p">));</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">ia64_itr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">KVM_VM_DATA_BASE</span><span class="p">,</span>
					<span class="n">pte</span><span class="p">,</span> <span class="n">KVM_VM_DATA_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_tr_slot</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">is_sn2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_sn2_setup_mappings</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_purge_vmm_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="n">ia64_ptr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_tr_slot</span><span class="p">);</span>
	<span class="n">ia64_ptr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_tr_slot</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_IA64_SGI_SN2) || defined(CONFIG_IA64_GENERIC)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">is_sn2</span><span class="p">)</span>
		<span class="n">ia64_ptr_entry</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">sn_rtc_tr_slot</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vcpu_pre_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_run_cpu</span> <span class="o">!=</span> <span class="n">cpu</span> <span class="o">||</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">last_vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">last_vcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_run_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">kvm_flush_tlb_all</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_rr6</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">RR6</span><span class="p">);</span>
	<span class="n">vti_set_rr6</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_rr</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_insert_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_vcpu_post_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_purge_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vti_set_rr6</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">host_rr6</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vcpu_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">context</span> <span class="o">*</span><span class="n">host_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">guest_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_INTR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="cm">/*Get host and guest context with guest address space.*/</span>
	<span class="n">host_ctx</span> <span class="o">=</span> <span class="n">kvm_get_host_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">guest_ctx</span> <span class="o">=</span> <span class="n">kvm_get_guest_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_KICK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_pre_transition</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">vcpu_run_fail</span><span class="p">;</span>

	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IN_GUEST_MODE</span><span class="p">;</span>
	<span class="n">kvm_guest_enter</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transition to the guest</span>
<span class="cm">	 */</span>
	<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">tramp_entry</span><span class="p">(</span><span class="n">host_ctx</span><span class="p">,</span> <span class="n">guest_ctx</span><span class="p">);</span>

	<span class="n">kvm_vcpu_post_transition</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">launched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_KICK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must have an instruction between local_irq_enable() and</span>
<span class="cm">	 * kvm_guest_exit(), so the timer interrupt isn&#39;t delayed by</span>
<span class="cm">	 * the interrupt shadow.  The stat.exits increment will do nicely.</span>
<span class="cm">	 * But we need to prevent reordering, hence this barrier():</span>
<span class="cm">	 */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="n">kvm_guest_exit</span><span class="p">();</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">OUTSIDE_GUEST_MODE</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_handle_exit</span><span class="p">(</span><span class="n">kvm_run</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_resched</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="nl">vcpu_run_fail:</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">exit_reason</span> <span class="o">=</span> <span class="n">KVM_EXIT_FAIL_ENTRY</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_set_mmio_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmio_req</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kvm_get_vcpu_ioreq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_is_write</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmio_data</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_IORESP_READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_run</span> <span class="o">*</span><span class="n">kvm_run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">sigsaved</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_vcpu_block</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">KVM_REQ_UNHALT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmio_data</span><span class="p">,</span> <span class="n">kvm_run</span><span class="o">-&gt;</span><span class="n">mmio</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">kvm_set_mmio_data</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_read_completed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mmio_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__vcpu_run</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">kvm_run</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">sigset_active</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="nf">kvm_arch_alloc_vm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="kt">uint64_t</span>  <span class="n">vm_base</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">KVM_VM_STRUCT_SIZE</span><span class="p">);</span>

	<span class="n">vm_base</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">KVM_VM_DATA_SIZE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_base</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vm_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KVM_VM_DATA_SIZE</span><span class="p">);</span>
	<span class="n">kvm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="p">)(</span><span class="n">vm_base</span> <span class="o">+</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vm_data</span><span class="p">,</span> <span class="n">kvm_vm_struct</span><span class="p">));</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_base</span> <span class="o">=</span> <span class="n">vm_base</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: vm&#39;s data area:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vm_base</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_ia64_io_range</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kvm_ia64_io_range</span> <span class="n">io_ranges</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">VGA_IO_START</span><span class="p">,</span> <span class="n">VGA_IO_SIZE</span><span class="p">,</span> <span class="n">GPFN_FRAME_BUFFER</span><span class="p">},</span>
	<span class="p">{</span><span class="n">MMIO_START</span><span class="p">,</span> <span class="n">MMIO_SIZE</span><span class="p">,</span> <span class="n">GPFN_LOW_MMIO</span><span class="p">},</span>
	<span class="p">{</span><span class="n">LEGACY_IO_START</span><span class="p">,</span> <span class="n">LEGACY_IO_SIZE</span><span class="p">,</span> <span class="n">GPFN_LEGACY_IO</span><span class="p">},</span>
	<span class="p">{</span><span class="n">IO_SAPIC_START</span><span class="p">,</span> <span class="n">IO_SAPIC_SIZE</span><span class="p">,</span> <span class="n">GPFN_IOSAPIC</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PIB_START</span><span class="p">,</span> <span class="n">PIB_SIZE</span><span class="p">,</span> <span class="n">GPFN_PIB</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_build_io_pmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Mark I/O ranges */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">io_ranges</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_io_range</span><span class="p">));</span>
							<span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">io_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">&lt;</span> <span class="n">io_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">io_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
				<span class="n">j</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">kvm_set_pmt_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					<span class="n">io_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*Use unused rids to virtualize guest rid.*/</span>
<span class="cp">#define GUEST_PHYSICAL_RR0	0x1739</span>
<span class="cp">#define GUEST_PHYSICAL_RR4	0x2739</span>
<span class="cp">#define VMM_INIT_RR		0x1660</span>

<span class="kt">int</span> <span class="nf">kvm_arch_init_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kvm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">is_sn2</span> <span class="o">=</span> <span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">);</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr0</span> <span class="o">=</span> <span class="n">GUEST_PHYSICAL_RR0</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr4</span> <span class="o">=</span> <span class="n">GUEST_PHYSICAL_RR4</span><span class="p">;</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_init_rr</span> <span class="o">=</span> <span class="n">VMM_INIT_RR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *Fill P2M entries for MMIO/IO ranges</span>
<span class="cm">	 */</span>
	<span class="n">kvm_build_io_pmt</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">assigned_dev_head</span><span class="p">);</span>

	<span class="cm">/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_USERSPACE_IRQ_SOURCE_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">irq_sources_bitmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_irqchip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_IOAPIC</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_get_ioapic</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ioapic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_vm_ioctl_set_irqchip</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_IRQCHIP_IOAPIC</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_set_ioapic</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ioapic</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RESTORE_REGS(_x) vcpu-&gt;arch._x = regs-&gt;_x</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vgr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vgr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vbgr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vbgr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vcr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vcr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vhpi</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vhpi</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vnat</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vnat</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vbnat</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vbnat</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vpsr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vpsr</span><span class="p">;</span>

	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vpr</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vpr</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">saved_guest</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">context</span><span class="p">));</span>

	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">mp_state</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">vmm_rr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itrs</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">itrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">NITRS</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtrs</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dtrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">NDTRS</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">itr_regions</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">dtr_regions</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">tc_regions</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">irq_check</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">itc_check</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">timer_check</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">last_itc</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vrr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">vrr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ibr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ibr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dbr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">dbr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">insvc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">insvc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">xtp</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">metaphysical_rr0</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">metaphysical_rr4</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">metaphysical_saved_rr0</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">metaphysical_saved_rr4</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">fp_psr</span><span class="p">);</span>
	<span class="n">RESTORE_REGS</span><span class="p">(</span><span class="n">saved_gp</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">irq_new_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itc_offset</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">saved_itc</span> <span class="o">-</span> <span class="n">kvm_get_itc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">KVM_REQ_RESUME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">kvm_arch_vm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_SET_MEMORY_REGION</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_memory_region</span> <span class="n">kvm_mem</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="n">kvm_userspace_mem</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_mem</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">kvm_mem</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">kvm_mem</span><span class="p">.</span><span class="n">slot</span><span class="p">;</span>
		<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">kvm_mem</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">guest_phys_addr</span> <span class="o">=</span>
					<span class="n">kvm_mem</span><span class="p">.</span><span class="n">guest_phys_addr</span><span class="p">;</span>
		<span class="n">kvm_userspace_mem</span><span class="p">.</span><span class="n">memory_size</span> <span class="o">=</span> <span class="n">kvm_mem</span><span class="p">.</span><span class="n">memory_size</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_memory_region</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">kvm_userspace_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_CREATE_IRQCHIP</span>:
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_ioapic_init</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_setup_default_irq_routing</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
			<span class="n">kvm_ioapic_destroy</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KVM_IRQ_LINE_STATUS</span>:
	<span class="k">case</span> <span class="n">KVM_IRQ_LINE</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_irq_level</span> <span class="n">irq_event</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_event</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">irq_event</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">kvm_set_irq</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">KVM_USERSPACE_IRQ_SOURCE_ID</span><span class="p">,</span>
				    <span class="n">irq_event</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_event</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span> <span class="o">==</span> <span class="n">KVM_IRQ_LINE_STATUS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">irq_event</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_event</span><span class="p">,</span>
							<span class="k">sizeof</span> <span class="n">irq_event</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_GET_IRQCHIP</span>: <span class="p">{</span>
		<span class="cm">/* 0: PIC master, 1: PIC slave, 2: IOAPIC */</span>
		<span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="n">chip</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">chip</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_get_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">chip</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_SET_IRQCHIP</span>: <span class="p">{</span>
		<span class="cm">/* 0: PIC master, 1: PIC slave, 2: IOAPIC */</span>
		<span class="k">struct</span> <span class="n">kvm_irqchip</span> <span class="n">chip</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">chip</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">kvm</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vm_ioctl_set_irqchip</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_sregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_sregs</span> <span class="o">*</span><span class="n">sregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_translate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_translation</span> <span class="o">*</span><span class="n">tr</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_alloc_vmm_area</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vmm_base</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">kvm_vm_buffer_size</span> <span class="o">&lt;</span> <span class="n">KVM_VM_BUFFER_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_vmm_base</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
				<span class="n">get_order</span><span class="p">(</span><span class="n">KVM_VMM_SIZE</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vmm_base</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KVM_VMM_SIZE</span><span class="p">);</span>
		<span class="n">kvm_vm_buffer</span> <span class="o">=</span> <span class="n">kvm_vmm_base</span> <span class="o">+</span> <span class="n">VMM_SIZE</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm:VMM&#39;s Base Addr:0x%lx, vm_buffer:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="n">kvm_vm_buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_free_vmm_area</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*Zero this area before free to avoid bits leak!!*/</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KVM_VMM_SIZE</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">KVM_VMM_SIZE</span><span class="p">));</span>
		<span class="n">kvm_vmm_base</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kvm_vm_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kvm_vsa_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vti_init_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cpuid3_t</span> <span class="n">cpuid3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vpd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vpd</span><span class="p">);</span>

	<span class="cm">/* CPUID init */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vcpuid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia64_get_cpuid</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="cm">/* Limit the CPUID number to 5 */</span>
	<span class="n">cpuid3</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vcpuid</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">cpuid3</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* 5 - 1 */</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vcpuid</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuid3</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/*Set vac and vdc fields*/</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_from_int_cr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_to_int_cr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_from_psr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_from_cpuid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_cover</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_bsw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vac</span><span class="p">.</span><span class="n">a_int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vdc</span><span class="p">.</span><span class="n">d_vmsw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*Set virtual buffer*/</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">virt_env_vaddr</span> <span class="o">=</span> <span class="n">KVM_VM_BUFFER_BASE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vti_create_vp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">vmm_ivt</span><span class="p">;</span>

	<span class="n">vmm_ivt</span> <span class="o">=</span> <span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_ivt</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;kvm: vcpu:%p,ivt: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="n">vmm_ivt</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ia64_pal_vp_create</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">vpd</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">vmm_ivt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: ia64_pal_vp_create failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_ptce_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ia64_ptce_info_t</span> <span class="n">ptce</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="n">ia64_get_ptce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptce</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptce_base</span> <span class="o">=</span> <span class="n">ptce</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptce_count</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce</span><span class="p">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ptce_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptce</span><span class="p">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_migrate_hlt_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">p_ht</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_cancel</span><span class="p">(</span><span class="n">p_ht</span><span class="p">))</span>
		<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="n">p_ht</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">hlt_timer_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">vcpu</span>  <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">,</span> <span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">!=</span> <span class="n">KVM_MP_STATE_HALTED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_fired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PALE_RESET_ENTRY    0x80000000ffffffb0UL</span>

<span class="n">bool</span> <span class="nf">kvm_vcpu_compatible</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">itc_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">vcpu_regs</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">union</span> <span class="n">context</span> <span class="o">*</span><span class="n">p_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vmm_vcpu</span> <span class="o">=</span> <span class="n">to_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*Init vcpu context for first run.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vmm_vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vmm_vcpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vcpu_is_bsp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">;</span>

		<span class="cm">/*Set entry address for first run.*/</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cr_iip</span> <span class="o">=</span> <span class="n">PALE_RESET_ENTRY</span><span class="p">;</span>

		<span class="cm">/*Initialize itc offset for vcpus*/</span>
		<span class="n">itc_offset</span> <span class="o">=</span> <span class="mi">0UL</span> <span class="o">-</span> <span class="n">kvm_get_itc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vcpu</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itc_offset</span> <span class="o">=</span> <span class="n">itc_offset</span><span class="p">;</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_itc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_lapic</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">vcpu</span><span class="p">;</span>

	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">gr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">gr</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vmm_vcpu</span> <span class="o">+</span> <span class="n">KVM_STK_OFFSET</span><span class="p">);</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">gr</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmm_vcpu</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">psr</span> <span class="o">=</span> <span class="mh">0x1008522000UL</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="n">FPSR_DEFAULT</span><span class="p">;</span> <span class="cm">/*fpsr*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">caller_unat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">pr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="cm">/*unat*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="cm">/*rnat*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmm_vcpu</span> <span class="o">+</span>
				<span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">)</span><span class="o">+</span><span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">15</span><span class="p">);</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">ar</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="cm">/*pfs*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x7e04UL</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_ivt</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">cr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3c</span><span class="p">;</span>

	<span class="cm">/*Initialize region register*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">rr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>

	<span class="cm">/*Initialize branch register 0*/</span>
	<span class="n">p_ctx</span><span class="o">-&gt;</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_entry</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_rr</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vmm_init_rr</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr0</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr0</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr4</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">metaphysical_rr4</span><span class="p">;</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hlt_timer_fn</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">last_run_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="p">)</span><span class="n">VPD_BASE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vsa_base</span> <span class="o">=</span> <span class="n">kvm_vsa_base</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">__gp</span> <span class="o">=</span> <span class="n">kvm_vmm_gp</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dirty_log_lock_pa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dirty_log_lock</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vhpt</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span> <span class="o">*</span><span class="p">)</span><span class="n">VHPT_BASE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vtlb</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span> <span class="o">*</span><span class="p">)</span><span class="n">VTLB_BASE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">);</span>
	<span class="n">init_ptce_info</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vti_vcpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_insert_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_vcpu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">vti_init_vpd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: vpd init error!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">uninit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">vti_create_vp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">uninit</span><span class="p">;</span>

	<span class="n">kvm_purge_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">uninit:</span>
	<span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="nf">kvm_arch_vcpu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_base</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">VCPU_STRUCT_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">KVM_MAX_VCPUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: Can&#39;t configure vcpus &gt; %ld&quot;</span><span class="p">,</span>
				<span class="n">KVM_MAX_VCPUS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;kvm: Create vcpu[%d] error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">)(</span><span class="n">vm_base</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vm_data</span><span class="p">,</span>
					<span class="n">vcpu_data</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">vcpu_struct</span><span class="p">));</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">kvm</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vti_vcpu_setup</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: vcpu_setup error!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vcpu</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_fpu</span> <span class="o">*</span><span class="n">fpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_guest_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_guest_debug</span> <span class="o">*</span><span class="n">dbg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_free_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_base</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vm_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KVM_VM_DATA_SIZE</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">(</span><span class="n">vm_base</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">KVM_VM_DATA_SIZE</span><span class="p">));</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_release_vm_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_gfn</span><span class="p">;</span>

	<span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="n">kvm_for_each_memslot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base_gfn</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="n">put_page</span><span class="p">((</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_sync_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_destroy_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_iommu_unmap_guest</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="cp">#ifdef  KVM_CAP_DEVICE_ASSIGNMENT</span>
	<span class="n">kvm_free_all_assigned_devices</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vioapic</span><span class="p">);</span>
	<span class="n">kvm_release_vm_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ht_active</span><span class="p">)</span>
			<span class="n">kvm_migrate_hlt_timer</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define SAVE_REGS(_x) 	regs-&gt;_x = vcpu-&gt;arch._x</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vcpu_load</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vgr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vgr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vbgr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vbgr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vcr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vcr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vhpi</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vhpi</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vnat</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vnat</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vbnat</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vbnat</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vpsr</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vpsr</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">vpr</span> <span class="o">=</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">vpr</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">saved_guest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">guest</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">context</span><span class="p">));</span>

	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">mp_state</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">vmm_rr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">itrs</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">NITRS</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dtrs</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dtrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">thash_data</span><span class="p">)</span> <span class="o">*</span> <span class="n">NDTRS</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">itr_regions</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">dtr_regions</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">tc_regions</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">irq_check</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">itc_check</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">timer_check</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">last_itc</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">vrr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vrr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ibr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">ibr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">dbr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dbr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">insvc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">insvc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">saved_itc</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">itc_offset</span> <span class="o">+</span> <span class="n">kvm_get_itc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">xtp</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">metaphysical_rr0</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">metaphysical_rr4</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">metaphysical_saved_rr0</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">metaphysical_saved_rr4</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">fp_psr</span><span class="p">);</span>
	<span class="n">SAVE_REGS</span><span class="p">(</span><span class="n">saved_gp</span><span class="p">);</span>

	<span class="n">vcpu_put</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">vcpu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">),</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span><span class="p">));</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exit_data</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="p">)</span><span class="n">stack</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">exit_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">hlt_timer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">long</span> <span class="nf">kvm_arch_vcpu_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVM_IA64_VCPU_GET_STACK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_stack</span><span class="p">;</span>
	        <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">first_p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_stack</span><span class="p">,</span> <span class="n">first_p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">user_stack</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;KVM_IA64_VCPU_GET_STACK: &quot;</span>
			       <span class="s">&quot;Illegal user destination address for stack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_get_stack</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">stack</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_stack</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVM_IA64_VCPU_SET_STACK</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_stack</span><span class="p">;</span>
	        <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">first_p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_stack</span><span class="p">,</span> <span class="n">first_p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">user_stack</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;KVM_IA64_VCPU_SET_STACK: &quot;</span>
			       <span class="s">&quot;Illegal user address for stack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">user_stack</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_ia64_vcpu_stack</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_ioctl_set_stack</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">stack</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_free_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">free</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">dont</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_create_memslot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_prepare_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npages</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_gfn</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">npages</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">KVM_MAX_MEM_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">gfn_to_pfn</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">base_gfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kvm_set_pmt_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">base_gfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
				<span class="n">_PAGE_AR_RWX</span> <span class="o">|</span> <span class="n">_PAGE_MA_WB</span><span class="p">);</span>
			<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kvm_set_pmt_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">base_gfn</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">GPFN_PHYS_MMIO</span> <span class="o">|</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
					<span class="n">_PAGE_MA_UC</span><span class="p">);</span>
			<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_commit_memory_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_userspace_memory_region</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="n">old</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">user_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_flush_shadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">kvm_arch_dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_vcpu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vti_cpu_has_kvm_support</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>  <span class="n">avail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">control</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ia64_pal_proc_get_features</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">avail</span> <span class="o">&amp;</span> <span class="n">PAL_PROC_VM_BIT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Hardware Supports VT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ia64_pal_vp_env_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_vm_buffer_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vp_env_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: VM Buffer Size:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kvm_vm_buffer_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vp_env_info</span> <span class="o">&amp;</span> <span class="n">VP_OPCODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;kvm: No opcode ability on hardware, &quot;</span>
				<span class="s">&quot;vm_env_info:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vp_env_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * On SN2, the ITC isn&#39;t stable, so copy in fast path code to use the</span>
<span class="cm"> * SN2 RTC, replacing the ITC based default verion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_patch_vmm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vmm_info</span> <span class="o">*</span><span class="n">vmm_info</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_ar</span><span class="p">,</span> <span class="n">new_ar_sn2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">module_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">;</span>

	<span class="n">new_ar</span> <span class="o">=</span> <span class="n">kvm_vmm_base</span> <span class="o">+</span> <span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">patch_mov_ar</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">new_ar_sn2</span> <span class="o">=</span> <span class="n">kvm_vmm_base</span> <span class="o">+</span> <span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">patch_mov_ar_sn2</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;kvm: Patching ITC emulation to use SGI SN2 RTC &quot;</span>
	       <span class="s">&quot;as source</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the SN2 version of mov_ar into place. They are both</span>
<span class="cm">	 * the same size, so 6 bundles is sufficient (6 * 0x10).</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">new_ar</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">new_ar_sn2</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_relocate_vmm</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vmm_info</span> <span class="o">*</span><span class="n">vmm_info</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmm_size</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmm_offset</span><span class="p">,</span> <span class="n">func_offset</span><span class="p">,</span> <span class="n">fdesc_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdesc</span> <span class="o">*</span><span class="n">p_fdesc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">module</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vmm_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;kvm: kvm area hasn&#39;t been initialized yet!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*Calculate new position of relocated vmm module.*/</span>
	<span class="n">module_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">module_core</span><span class="p">;</span>
	<span class="n">vmm_size</span> <span class="o">=</span> <span class="n">module</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vmm_size</span> <span class="o">&gt;</span> <span class="n">KVM_VMM_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">module_base</span><span class="p">,</span> <span class="n">vmm_size</span><span class="p">);</span>
	<span class="n">kvm_patch_vmm</span><span class="p">(</span><span class="n">vmm_info</span><span class="p">,</span> <span class="n">module</span><span class="p">);</span>
	<span class="n">kvm_flush_icache</span><span class="p">(</span><span class="n">kvm_vmm_base</span><span class="p">,</span> <span class="n">vmm_size</span><span class="p">);</span>

	<span class="cm">/*Recalculate kvm_vmm_info based on new VMM*/</span>
	<span class="n">vmm_offset</span> <span class="o">=</span> <span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_ivt</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_ivt</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="n">vmm_offset</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Relocated VMM&#39;s IVT Base Addr:%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_ivt</span><span class="p">);</span>

	<span class="n">fdesc_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_entry</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_vmm_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">KVM_VMM_BASE</span> <span class="o">+</span>
							<span class="n">fdesc_offset</span><span class="p">);</span>
	<span class="n">func_offset</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_entry</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">p_fdesc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fdesc</span> <span class="o">*</span><span class="p">)(</span><span class="n">kvm_vmm_base</span> <span class="o">+</span> <span class="n">fdesc_offset</span><span class="p">);</span>
	<span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="n">func_offset</span><span class="p">;</span>
	<span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span><span class="o">+</span><span class="p">(</span><span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Relocated VMM&#39;s Init Entry Addr:%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">KVM_VMM_BASE</span><span class="o">+</span><span class="n">func_offset</span><span class="p">);</span>

	<span class="n">fdesc_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">tramp_entry</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">tramp_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">kvm_tramp_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">KVM_VMM_BASE</span> <span class="o">+</span>
			<span class="n">fdesc_offset</span><span class="p">);</span>
	<span class="n">func_offset</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">tramp_entry</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">;</span>
	<span class="n">p_fdesc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fdesc</span> <span class="o">*</span><span class="p">)(</span><span class="n">kvm_vmm_base</span> <span class="o">+</span> <span class="n">fdesc_offset</span><span class="p">);</span>
	<span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="n">func_offset</span><span class="p">;</span>
	<span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">=</span> <span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">gp</span> <span class="o">-</span> <span class="n">module_base</span><span class="p">);</span>

	<span class="n">kvm_vmm_gp</span> <span class="o">=</span> <span class="n">p_fdesc</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Relocated VMM&#39;s Entry IP:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">kvm_vmm_info</span><span class="o">-&gt;</span><span class="n">vmm_entry</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="s">&quot;kvm: Relocated VMM&#39;s Trampoline Entry IP:0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">KVM_VMM_BASE</span> <span class="o">+</span> <span class="n">func_offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_vmm_info</span> <span class="o">*</span><span class="n">vmm_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vmm_info</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vti_cpu_has_kvm_support</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: No Hardware Virtualization Support!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_vmm_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kvm: Already loaded VMM module!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">kvm_vmm_info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vmm_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_vmm_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_alloc_vmm_area</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_free0</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_relocate_vmm</span><span class="p">(</span><span class="n">vmm_info</span><span class="p">,</span> <span class="n">vmm_info</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free1:</span>
	<span class="n">kvm_free_vmm_area</span><span class="p">();</span>
<span class="nl">out_free0:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm_vmm_info</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_free_vmm_area</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kvm_vmm_info</span><span class="p">);</span>
	<span class="n">kvm_vmm_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_ia64_sync_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dirty_bitmap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vm_base</span> <span class="o">+</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vm_data</span><span class="p">,</span> <span class="n">kvm_mem_dirty_log</span><span class="p">));</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dirty_log_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
		<span class="n">dirty_bitmap</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">dirty_log_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_vm_ioctl_get_dirty_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kvm_dirty_log</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">KVM_MEMORY_SLOTS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memslot</span> <span class="o">=</span> <span class="n">id_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">memslots</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kvm_ia64_sync_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">memslot</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_get_dirty_log</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_dirty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If nothing is dirty, don&#39;t bother messing with page tables. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">kvm_dirty_bitmap_bytes</span><span class="p">(</span><span class="n">memslot</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">slots_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_hardware_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_arch_hardware_unsetup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_apic_set_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_lapic_irq</span> <span class="o">*</span><span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__apic_accept_irq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_apic_match_physical_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">apic</span><span class="p">,</span> <span class="n">u16</span> <span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span> <span class="o">==</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_apic_match_logical_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">apic</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mda</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_apic_compare_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu1</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xtp</span> <span class="o">-</span> <span class="n">vcpu2</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">xtp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_apic_match_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">short_hand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_lapic</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apic</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dest_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">kvm_apic_match_physical_addr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">kvm_apic_match_logical_addr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_highest_bits</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">dat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>  <span class="n">bits</span><span class="p">,</span> <span class="n">bitnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* loop for all 256 bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bitnum</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">+</span> <span class="n">bitnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_highest_pending_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">vpd</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span> <span class="n">to_host</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">vpd</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">irr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">NMI_VECTOR</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NMI_VECTOR</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">irr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">ExtINT_VECTOR</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ExtINT_VECTOR</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">find_highest_bits</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">irr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_cpu_has_pending_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">timer_fired</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_RUNNABLE</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">kvm_highest_pending_irq</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_should_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">KVM_REQ_KICK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">requests</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_get_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mp_state</span><span class="o">-&gt;</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vcpu_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">psr</span><span class="p">;</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_insert_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">psr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">launched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kvm_arch_vcpu_uninit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_arch_vcpu_init</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">kvm_purge_vmm_mapping</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_arch_vcpu_ioctl_set_mpstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mp_state</span> <span class="o">*</span><span class="n">mp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">=</span> <span class="n">mp_state</span><span class="o">-&gt;</span><span class="n">mp_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mp_state</span> <span class="o">==</span> <span class="n">KVM_MP_STATE_UNINITIALIZED</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu_reset</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
