<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › kvm › kvm_minstate.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kvm_minstate.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  kvm_minstate.h: min save macros</span>
<span class="cm"> *  Copyright (c) 2007, Intel Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *  Xuefei Xu (Anthony Xu) (Anthony.xu@intel.com)</span>
<span class="cm"> *  Xiantao Zhang (xiantao.zhang@intel.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;asm/asmmacro.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/kregs.h&gt;</span>
<span class="cp">#include &lt;asm/kvm_host.h&gt;</span>

<span class="cp">#include &quot;asm-offsets.h&quot;</span>

<span class="cp">#define KVM_MINSTATE_START_SAVE_MIN	     					\</span>
<span class="cp">	mov ar.rsc = 0;</span><span class="cm">/* set enforced lazy mode, pl 0, little-endian, loadrs=0 */</span><span class="cp">\</span>
<span class="cp">	;;									\</span>
<span class="cp">	mov.m r28 = ar.rnat;                                  			\</span>
<span class="cp">	addl r22 = VMM_RBS_OFFSET,r1;            </span><span class="cm">/* compute base of RBS */</span><span class="cp">	\</span>
<span class="cp">	;;									\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r22];						\</span>
<span class="cp">	addl r1 = KVM_STK_OFFSET-VMM_PT_REGS_SIZE, r1;  \</span>
<span class="cp">	mov r23 = ar.bspstore;			</span><span class="cm">/* save ar.bspstore */</span><span class="cp">          \</span>
<span class="cp">	;;									\</span>
<span class="cp">	mov ar.bspstore = r22;				</span><span class="cm">/* switch to kernel RBS */</span><span class="cp">\</span>
<span class="cp">	;;									\</span>
<span class="cp">	mov r18 = ar.bsp;							\</span>
<span class="cp">	mov ar.rsc = 0x3;     </span><span class="cm">/* set eager mode, pl 0, little-endian, loadrs=0 */</span><span class="cp"></span>



<span class="cp">#define KVM_MINSTATE_END_SAVE_MIN						\</span>
<span class="cp">	bsw.1;          </span><span class="cm">/* switch back to bank 1 (must be last in insn group) */</span><span class="cp">\</span>
<span class="cp">	;;</span>


<span class="cp">#define PAL_VSA_SYNC_READ						\</span>
<span class="cp">	</span><span class="cm">/* begin to call pal vps sync_read */</span><span class="cp">				\</span>
<span class="cp">{.mii;									\</span>
<span class="cp">	add r25 = VMM_VPD_BASE_OFFSET, r21;				\</span>
<span class="cp">	nop 0x0;							\</span>
<span class="cp">	mov r24=ip;							\</span>
<span class="cp">	;;								\</span>
<span class="cp">}									\</span>
<span class="cp">{.mmb									\</span>
<span class="cp">	add r24=0x20, r24;						\</span>
<span class="cp">	ld8 r25 = [r25];      </span><span class="cm">/* read vpd base */</span><span class="cp">			\</span>
<span class="cp">	br.cond.sptk kvm_vps_sync_read;		</span><span class="cm">/*call the service*/</span><span class="cp">	\</span>
<span class="cp">	;;								\</span>
<span class="cp">};									\</span>


<span class="cp">#define KVM_MINSTATE_GET_CURRENT(reg)   mov reg=r21</span>

<span class="cm">/*</span>
<span class="cm"> * KVM_DO_SAVE_MIN switches to the kernel stacks (if necessary) and saves</span>
<span class="cm"> * the minimum state necessary that allows us to turn psr.ic back</span>
<span class="cm"> * on.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumed state upon entry:</span>
<span class="cm"> *  psr.ic: off</span>
<span class="cm"> *  r31:	contains saved predicates (pr)</span>
<span class="cm"> *</span>
<span class="cm"> * Upon exit, the state is as follows:</span>
<span class="cm"> *  psr.ic: off</span>
<span class="cm"> *   r2 = points to &amp;pt_regs.r16</span>
<span class="cm"> *   r8 = contents of ar.ccv</span>
<span class="cm"> *   r9 = contents of ar.csd</span>
<span class="cm"> *  r10 = contents of ar.ssd</span>
<span class="cm"> *  r11 = FPSR_DEFAULT</span>
<span class="cm"> *  r12 = kernel sp (kernel virtual address)</span>
<span class="cm"> *  r13 = points to current task_struct (kernel virtual address)</span>
<span class="cm"> *  p15 = TRUE if psr.i is set in cr.ipsr</span>
<span class="cm"> *  predicate registers (other than p2, p3, and p15), b6, r3, r14, r15:</span>
<span class="cm"> *	  preserved</span>
<span class="cm"> *</span>
<span class="cm"> * Note that psr.ic is NOT turned on by this macro.  This is so that</span>
<span class="cm"> * we can pass interruption state as arguments to a handler.</span>
<span class="cm"> */</span>


<span class="cp">#define PT(f) (VMM_PT_REGS_##f##_OFFSET)</span>

<span class="cp">#define KVM_DO_SAVE_MIN(COVER,SAVE_IFS,EXTRA)			\</span>
<span class="cp">	KVM_MINSTATE_GET_CURRENT(r16);  </span><span class="cm">/* M (or M;;I) */</span><span class="cp">	\</span>
<span class="cp">	mov r27 = ar.rsc;         </span><span class="cm">/* M */</span><span class="cp">			\</span>
<span class="cp">	mov r20 = r1;         </span><span class="cm">/* A */</span><span class="cp">				\</span>
<span class="cp">	mov r25 = ar.unat;        </span><span class="cm">/* M */</span><span class="cp">			\</span>
<span class="cp">	mov r29 = cr.ipsr;        </span><span class="cm">/* M */</span><span class="cp">			\</span>
<span class="cp">	mov r26 = ar.pfs;         </span><span class="cm">/* I */</span><span class="cp">			\</span>
<span class="cp">	mov r18 = cr.isr;         				\</span>
<span class="cp">	COVER;              </span><span class="cm">/* B;; (or nothing) */</span><span class="cp">		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	tbit.z p0,p15 = r29,IA64_PSR_I_BIT;			\</span>
<span class="cp">	mov r1 = r16;						\</span>
<span class="cm">/*	mov r21=r16;	*/</span><span class="cp">					\</span>
<span class="cp">	</span><span class="cm">/* switch from user to kernel RBS: */</span><span class="cp">			\</span>
<span class="cp">	;;							\</span>
<span class="cp">	invala;             </span><span class="cm">/* M */</span><span class="cp">				\</span>
<span class="cp">	SAVE_IFS;						\</span>
<span class="cp">	;;							\</span>
<span class="cp">	KVM_MINSTATE_START_SAVE_MIN				\</span>
<span class="cp">	adds r17 = 2*L1_CACHE_BYTES,r1;</span><span class="cm">/* cache-line size */</span><span class="cp">	\</span>
<span class="cp">	adds r16 = PT(CR_IPSR),r1;				\</span>
<span class="cp">	;;							\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17],L1_CACHE_BYTES;		\</span>
<span class="cp">	st8 [r16] = r29;      </span><span class="cm">/* save cr.ipsr */</span><span class="cp">		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	lfetch.fault.excl.nt1 [r17];				\</span>
<span class="cp">	tbit.nz p15,p0 = r29,IA64_PSR_I_BIT;			\</span>
<span class="cp">	mov r29 = b0						\</span>
<span class="cp">	;;							\</span>
<span class="cp">	adds r16 = PT(R8),r1; </span><span class="cm">/* initialize first base pointer */</span><span class="cp">\</span>
<span class="cp">	adds r17 = PT(R9),r1; </span><span class="cm">/* initialize second base pointer */</span><span class="cp">\</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r8,16;			\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r9,16;			\</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r10,24;			\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r11,24;			\</span>
<span class="cp">	;;							\</span>
<span class="cp">	mov r9 = cr.iip;         </span><span class="cm">/* M */</span><span class="cp">			\</span>
<span class="cp">	mov r10 = ar.fpsr;        </span><span class="cm">/* M */</span><span class="cp">			\</span>
<span class="cp">	;;							\</span>
<span class="cp">	st8 [r16] = r9,16;    </span><span class="cm">/* save cr.iip */</span><span class="cp">			\</span>
<span class="cp">	st8 [r17] = r30,16;   </span><span class="cm">/* save cr.ifs */</span><span class="cp">			\</span>
<span class="cp">	sub r18 = r18,r22;    </span><span class="cm">/* r18=RSE.ndirty*8 */</span><span class="cp">		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	st8 [r16] = r25,16;   </span><span class="cm">/* save ar.unat */</span><span class="cp">		\</span>
<span class="cp">	st8 [r17] = r26,16;    </span><span class="cm">/* save ar.pfs */</span><span class="cp">		\</span>
<span class="cp">	shl r18 = r18,16;     </span><span class="cm">/* calu ar.rsc used for &quot;loadrs&quot; */</span><span class="cp">\</span>
<span class="cp">	;;							\</span>
<span class="cp">	st8 [r16] = r27,16;   </span><span class="cm">/* save ar.rsc */</span><span class="cp">			\</span>
<span class="cp">	st8 [r17] = r28,16;   </span><span class="cm">/* save ar.rnat */</span><span class="cp">		\</span>
<span class="cp">	;;          </span><span class="cm">/* avoid RAW on r16 &amp; r17 */</span><span class="cp">		\</span>
<span class="cp">	st8 [r16] = r23,16;   </span><span class="cm">/* save ar.bspstore */</span><span class="cp">		\</span>
<span class="cp">	st8 [r17] = r31,16;   </span><span class="cm">/* save predicates */</span><span class="cp">		\</span>
<span class="cp">	;;							\</span>
<span class="cp">	st8 [r16] = r29,16;   </span><span class="cm">/* save b0 */</span><span class="cp">			\</span>
<span class="cp">	st8 [r17] = r18,16;   </span><span class="cm">/* save ar.rsc value for &quot;loadrs&quot; */</span><span class="cp">\</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r20,16;</span><span class="cm">/* save original r1 */</span><span class="cp">  \</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r12,16;			\</span>
<span class="cp">	adds r12 = -16,r1;    </span><span class="cm">/* switch to kernel memory stack */</span><span class="cp">  \</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r13,16;			\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r10,16;	</span><span class="cm">/* save ar.fpsr */</span><span class="cp">\</span>
<span class="cp">	mov r13 = r21;   </span><span class="cm">/* establish `current&#39; */</span><span class="cp">		\</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r15,16;			\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r14,16;			\</span>
<span class="cp">	;;							\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r16] = r2,16;			\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r17] = r3,16;			\</span>
<span class="cp">	adds r2 = VMM_PT_REGS_R16_OFFSET,r1;			\</span>
<span class="cp">	 ;;							\</span>
<span class="cp">	adds r16 = VMM_VCPU_IIPA_OFFSET,r13;			\</span>
<span class="cp">	adds r17 = VMM_VCPU_ISR_OFFSET,r13;			\</span>
<span class="cp">	mov r26 = cr.iipa;					\</span>
<span class="cp">	mov r27 = cr.isr;					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	st8 [r16] = r26;					\</span>
<span class="cp">	st8 [r17] = r27;					\</span>
<span class="cp">	;;							\</span>
<span class="cp">	EXTRA;							\</span>
<span class="cp">	mov r8 = ar.ccv;					\</span>
<span class="cp">	mov r9 = ar.csd;					\</span>
<span class="cp">	mov r10 = ar.ssd;					\</span>
<span class="cp">	movl r11 = FPSR_DEFAULT;   </span><span class="cm">/* L-unit */</span><span class="cp">			\</span>
<span class="cp">	adds r17 = VMM_VCPU_GP_OFFSET,r13;			\</span>
<span class="cp">	;;							\</span>
<span class="cp">	ld8 r1 = [r17];</span><span class="cm">/* establish kernel global pointer */</span><span class="cp">	\</span>
<span class="cp">	;;							\</span>
<span class="cp">	PAL_VSA_SYNC_READ					\</span>
<span class="cp">	KVM_MINSTATE_END_SAVE_MIN</span>

<span class="cm">/*</span>
<span class="cm"> * SAVE_REST saves the remainder of pt_regs (with psr.ic on).</span>
<span class="cm"> *</span>
<span class="cm"> * Assumed state upon entry:</span>
<span class="cm"> *  psr.ic: on</span>
<span class="cm"> *  r2: points to &amp;pt_regs.f6</span>
<span class="cm"> *  r3: points to &amp;pt_regs.f7</span>
<span class="cm"> *  r8: contents of ar.ccv</span>
<span class="cm"> *  r9: contents of ar.csd</span>
<span class="cm"> *  r10:	contents of ar.ssd</span>
<span class="cm"> *  r11:	FPSR_DEFAULT</span>
<span class="cm"> *</span>
<span class="cm"> * Registers r14 and r15 are guaranteed not to be touched by SAVE_REST.</span>
<span class="cm"> */</span>
<span class="cp">#define KVM_SAVE_REST				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r16,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r17,16;	\</span>
<span class="cp">	;;				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r18,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r19,16;	\</span>
<span class="cp">	;;				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r20,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r21,16;	\</span>
<span class="cp">	mov r18=b6;			\</span>
<span class="cp">	;;				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r22,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r23,16;	\</span>
<span class="cp">	mov r19 = b7;				\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r24,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r25,16;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r26,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r27,16;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r28,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r29,16;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r30,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r31,32;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov ar.fpsr = r11;			\</span>
<span class="cp">	st8 [r2] = r8,8;			\</span>
<span class="cp">	adds r24 = PT(B6)-PT(F7),r3;		\</span>
<span class="cp">	adds r25 = PT(B7)-PT(F7),r3;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r24] = r18,16;       </span><span class="cm">/* b6 */</span><span class="cp">	\</span>
<span class="cp">	st8 [r25] = r19,16;       </span><span class="cm">/* b7 */</span><span class="cp">	\</span>
<span class="cp">	adds r2 = PT(R4)-PT(F6),r2;		\</span>
<span class="cp">	adds r3 = PT(R5)-PT(F7),r3;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r24] = r9;	</span><span class="cm">/* ar.csd */</span><span class="cp">		\</span>
<span class="cp">	st8 [r25] = r10;	</span><span class="cm">/* ar.ssd */</span><span class="cp">	\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov r18 = ar.unat;			\</span>
<span class="cp">	adds r19 = PT(EML_UNAT)-PT(R4),r2;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r19] = r18; </span><span class="cm">/* eml_unat */</span><span class="cp"> 	\</span>


<span class="cp">#define KVM_SAVE_EXTRA				\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r4,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r5,16;	\</span>
<span class="cp">	;;					\</span>
<span class="cp">.mem.offset 0,0; st8.spill [r2] = r6,16;	\</span>
<span class="cp">.mem.offset 8,0; st8.spill [r3] = r7;		\</span>
<span class="cp">	;;					\</span>
<span class="cp">	mov r26 = ar.unat;			\</span>
<span class="cp">	;;					\</span>
<span class="cp">	st8 [r2] = r26;</span><span class="cm">/* eml_unat */</span><span class="cp"> 		\</span>

<span class="cp">#define KVM_SAVE_MIN_WITH_COVER		KVM_DO_SAVE_MIN(cover, mov r30 = cr.ifs,)</span>
<span class="cp">#define KVM_SAVE_MIN_WITH_COVER_R19	KVM_DO_SAVE_MIN(cover, mov r30 = cr.ifs, mov r15 = r19)</span>
<span class="cp">#define KVM_SAVE_MIN			KVM_DO_SAVE_MIN(     , mov r30 = r0, )</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
