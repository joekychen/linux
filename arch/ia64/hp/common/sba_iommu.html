<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › hp › common › sba_iommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sba_iommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">**  IA64 System Bus Adapter (SBA) I/O MMU manager</span>
<span class="cm">**</span>
<span class="cm">**	(c) Copyright 2002-2005 Alex Williamson</span>
<span class="cm">**	(c) Copyright 2002-2003 Grant Grundler</span>
<span class="cm">**	(c) Copyright 2002-2005 Hewlett-Packard Company</span>
<span class="cm">**</span>
<span class="cm">**	Portions (c) 2000 Grant Grundler (from parisc I/O MMU code)</span>
<span class="cm">**	Portions (c) 1999 Dave S. Miller (from sparc64 I/O MMU code)</span>
<span class="cm">**</span>
<span class="cm">**	This program is free software; you can redistribute it and/or modify</span>
<span class="cm">**	it under the terms of the GNU General Public License as published by</span>
<span class="cm">**      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">**      (at your option) any later version.</span>
<span class="cm">**</span>
<span class="cm">**</span>
<span class="cm">** This module initializes the IOC (I/O Controller) found on HP</span>
<span class="cm">** McKinley machines and their successors.</span>
<span class="cm">**</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;         </span><span class="cm">/* hweight64() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/iommu-helper.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;asm/delay.h&gt;		</span><span class="cm">/* ia64_get_itc() */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;		</span><span class="cm">/* PAGE_OFFSET */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="cp">#include &lt;asm/acpi-ext.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">swiotlb_late_init_with_default_size</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cp">#define PFX &quot;IOC: &quot;</span>

<span class="cm">/*</span>
<span class="cm">** Enabling timing search of the pdir resource map.  Output in /proc.</span>
<span class="cm">** Disabled by default to optimize performance.</span>
<span class="cm">*/</span>
<span class="cp">#undef PDIR_SEARCH_TIMING</span>

<span class="cm">/*</span>
<span class="cm">** This option allows cards capable of 64bit DMA to bypass the IOMMU.  If</span>
<span class="cm">** not defined, all DMA will be 32bit and go through the TLB.</span>
<span class="cm">** There&#39;s potentially a conflict in the bio merge code with us</span>
<span class="cm">** advertising an iommu, but then bypassing it.  Since I/O MMU bypassing</span>
<span class="cm">** appears to give more performance than bio-level virtual merging, we&#39;ll</span>
<span class="cm">** do the former for now.  NOTE: BYPASS_SG also needs to be undef&#39;d to</span>
<span class="cm">** completely restrict DMA to the IOMMU.</span>
<span class="cm">*/</span>
<span class="cp">#define ALLOW_IOV_BYPASS</span>

<span class="cm">/*</span>
<span class="cm">** This option specifically allows/disallows bypassing scatterlists with</span>
<span class="cm">** multiple entries.  Coalescing these entries can allow better DMA streaming</span>
<span class="cm">** and in some cases shows better performance than entirely bypassing the</span>
<span class="cm">** IOMMU.  Performance increase on the order of 1-2% sequential output/input</span>
<span class="cm">** using bonnie++ on a RAID0 MD device (sym2 &amp; mpt).</span>
<span class="cm">*/</span>
<span class="cp">#undef ALLOW_IOV_BYPASS_SG</span>

<span class="cm">/*</span>
<span class="cm">** If a device prefetches beyond the end of a valid pdir entry, it will cause</span>
<span class="cm">** a hard failure, ie. MCA.  Version 3.0 and later of the zx1 LBA should</span>
<span class="cm">** disconnect on 4k boundaries and prevent such issues.  If the device is</span>
<span class="cm">** particularly aggressive, this option will keep the entire pdir valid such</span>
<span class="cm">** that prefetching will hit a valid address.  This could severely impact</span>
<span class="cm">** error containment, and is therefore off by default.  The page that is</span>
<span class="cm">** used for spill-over is poisoned, so that should help debugging somewhat.</span>
<span class="cm">*/</span>
<span class="cp">#undef FULL_VALID_PDIR</span>

<span class="cp">#define ENABLE_MARK_CLEAN</span>

<span class="cm">/*</span>
<span class="cm">** The number of debug flags is a clue - this code is fragile.  NOTE: since</span>
<span class="cm">** tightening the use of res_lock the resource bitmap and actual pdir are no</span>
<span class="cm">** longer guaranteed to stay in sync.  The sanity checking code isn&#39;t going to</span>
<span class="cm">** like that.</span>
<span class="cm">*/</span>
<span class="cp">#undef DEBUG_SBA_INIT</span>
<span class="cp">#undef DEBUG_SBA_RUN</span>
<span class="cp">#undef DEBUG_SBA_RUN_SG</span>
<span class="cp">#undef DEBUG_SBA_RESOURCE</span>
<span class="cp">#undef ASSERT_PDIR_SANITY</span>
<span class="cp">#undef DEBUG_LARGE_SG_ENTRIES</span>
<span class="cp">#undef DEBUG_BYPASS</span>

<span class="cp">#if defined(FULL_VALID_PDIR) &amp;&amp; defined(ASSERT_PDIR_SANITY)</span>
<span class="cp">#error FULL_VALID_PDIR and ASSERT_PDIR_SANITY are mutually exclusive</span>
<span class="cp">#endif</span>

<span class="cp">#define SBA_INLINE	__inline__</span>
<span class="cm">/* #define SBA_INLINE */</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>
<span class="cp">#define DBG_INIT(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_INIT(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_SBA_RUN</span>
<span class="cp">#define DBG_RUN(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_SBA_RUN_SG</span>
<span class="cp">#define DBG_RUN_SG(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RUN_SG(x...)</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef DEBUG_SBA_RESOURCE</span>
<span class="cp">#define DBG_RES(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_RES(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_BYPASS</span>
<span class="cp">#define DBG_BYPASS(x...)	printk(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DBG_BYPASS(x...)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
<span class="cp">#define ASSERT(expr) \</span>
<span class="cp">        if(!(expr)) { \</span>
<span class="cp">                printk( &quot;\n&quot; __FILE__ &quot;:%d: Assertion &quot; #expr &quot; failed!\n&quot;,__LINE__); \</span>
<span class="cp">                panic(#expr); \</span>
<span class="cp">        }</span>
<span class="cp">#else</span>
<span class="cp">#define ASSERT(expr)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">** The number of pdir entries to &quot;free&quot; before issuing</span>
<span class="cm">** a read to PCOM register to flush out PCOM writes.</span>
<span class="cm">** Interacts with allocation granularity (ie 4 or 8 entries</span>
<span class="cm">** allocated and free&#39;d/purged at a time might make this</span>
<span class="cm">** less interesting).</span>
<span class="cm">*/</span>
<span class="cp">#define DELAYED_RESOURCE_CNT	64</span>

<span class="cp">#define PCI_DEVICE_ID_HP_SX2000_IOC	0x12ec</span>

<span class="cp">#define ZX1_IOC_ID	((PCI_DEVICE_ID_HP_ZX1_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)</span>
<span class="cp">#define ZX2_IOC_ID	((PCI_DEVICE_ID_HP_ZX2_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)</span>
<span class="cp">#define REO_IOC_ID	((PCI_DEVICE_ID_HP_REO_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)</span>
<span class="cp">#define SX1000_IOC_ID	((PCI_DEVICE_ID_HP_SX1000_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)</span>
<span class="cp">#define SX2000_IOC_ID	((PCI_DEVICE_ID_HP_SX2000_IOC &lt;&lt; 16) | PCI_VENDOR_ID_HP)</span>

<span class="cp">#define ZX1_IOC_OFFSET	0x1000	</span><span class="cm">/* ACPI reports SBA, we want IOC */</span><span class="cp"></span>

<span class="cp">#define IOC_FUNC_ID	0x000</span>
<span class="cp">#define IOC_FCLASS	0x008	</span><span class="cm">/* function class, bist, header, rev... */</span><span class="cp"></span>
<span class="cp">#define IOC_IBASE	0x300	</span><span class="cm">/* IO TLB */</span><span class="cp"></span>
<span class="cp">#define IOC_IMASK	0x308</span>
<span class="cp">#define IOC_PCOM	0x310</span>
<span class="cp">#define IOC_TCNFG	0x318</span>
<span class="cp">#define IOC_PDIR_BASE	0x320</span>

<span class="cp">#define IOC_ROPE0_CFG	0x500</span>
<span class="cp">#define   IOC_ROPE_AO	  0x10	</span><span class="cm">/* Allow &quot;Relaxed Ordering&quot; */</span><span class="cp"></span>


<span class="cm">/* AGP GART driver looks for this */</span>
<span class="cp">#define ZX1_SBA_IOMMU_COOKIE	0x0000badbadc0ffeeUL</span>

<span class="cm">/*</span>
<span class="cm">** The zx1 IOC supports 4/8/16/64KB page sizes (see TCNFG register)</span>
<span class="cm">**</span>
<span class="cm">** Some IOCs (sx1000) can run at the above pages sizes, but are</span>
<span class="cm">** really only supported using the IOC at a 4k page size.</span>
<span class="cm">**</span>
<span class="cm">** iovp_size could only be greater than PAGE_SIZE if we are</span>
<span class="cm">** confident the drivers really only touch the next physical</span>
<span class="cm">** page iff that driver instance owns it.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp_size</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp_shift</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp_mask</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ioc</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">ioc_hpa</span><span class="p">;</span>	<span class="cm">/* I/O MMU base address */</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">res_map</span><span class="p">;</span>	<span class="cm">/* resource map, bit == pdir entry */</span>
	<span class="n">u64</span>		<span class="o">*</span><span class="n">pdir_base</span><span class="p">;</span>	<span class="cm">/* physical base address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ibase</span><span class="p">;</span>		<span class="cm">/* pdir IOV Space base */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">imask</span><span class="p">;</span>		<span class="cm">/* pdir IOV Space mask */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">res_hint</span><span class="p">;</span>	<span class="cm">/* next avail IOVP - circular search */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">res_lock</span><span class="p">;</span>	<span class="cm">/* protects the resource bitmap, but must be held when */</span>
					<span class="cm">/* clearing pdir to prevent races with allocations. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">res_bitshift</span><span class="p">;</span>	<span class="cm">/* from the RIGHT! */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">res_size</span><span class="p">;</span>	<span class="cm">/* size of resource map in bytes */</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">node</span><span class="p">;</span>		<span class="cm">/* node where this IOC lives */</span>
<span class="cp">#endif</span>
<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="n">spinlock_t</span>	<span class="n">saved_lock</span><span class="p">;</span>	<span class="cm">/* may want to try to get this on a separate cacheline */</span>
					<span class="cm">/* than res_lock for bigger systems. */</span>
	<span class="kt">int</span>		<span class="n">saved_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sba_dma_pair</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span>	<span class="n">iova</span><span class="p">;</span>
		<span class="kt">size_t</span>		<span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">saved</span><span class="p">[</span><span class="n">DELAYED_RESOURCE_CNT</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef PDIR_SEARCH_TIMING</span>
<span class="cp">#define SBA_SEARCH_SAMPLE	0x100</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_search</span><span class="p">[</span><span class="n">SBA_SEARCH_SAMPLE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_idx</span><span class="p">;</span>	<span class="cm">/* current index into avg_search */</span>
<span class="cp">#endif</span>

	<span class="cm">/* Stuff we don&#39;t need in performance path */</span>
	<span class="k">struct</span> <span class="n">ioc</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="cm">/* list of IOC&#39;s in system */</span>
	<span class="n">acpi_handle</span>	<span class="n">handle</span><span class="p">;</span>		<span class="cm">/* for multiple IOC&#39;s */</span>
	<span class="k">const</span> <span class="kt">char</span> 	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">func_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rev</span><span class="p">;</span>		<span class="cm">/* HW revision of chip */</span>
	<span class="n">u32</span>		<span class="n">iov_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pdir_size</span><span class="p">;</span>	<span class="cm">/* in bytes, determined by IOV Space size */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">sac_only_dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc_list</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">reserve_sba_gart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span> <span class="n">sba_mark_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="p">,</span> <span class="n">dma_addr_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span> <span class="n">sba_free_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="p">,</span> <span class="n">dma_addr_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cp">#define sba_sg_address(sg)	sg_virt((sg))</span>

<span class="cp">#ifdef FULL_VALID_PDIR</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">prefetch_spill_page</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp"># define GET_IOC(dev)	(((dev)-&gt;bus == &amp;pci_bus_type)						\</span>
<span class="cp">			 ? ((struct ioc *) PCI_CONTROLLER(to_pci_dev(dev))-&gt;iommu) : NULL)</span>
<span class="cp">#else</span>
<span class="cp"># define GET_IOC(dev)	NULL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">** DMA_CHUNK_SIZE is used by the SCSI mid-layer to break up</span>
<span class="cm">** (or rather not merge) DMAs into manageable chunks.</span>
<span class="cm">** On parisc, this is more of the software/tuning constraint</span>
<span class="cm">** rather than the HW. I/O MMU allocation algorithms can be</span>
<span class="cm">** faster with smaller sizes (to some degree).</span>
<span class="cm">*/</span>
<span class="cp">#define DMA_CHUNK_SIZE  (BITS_PER_LONG*iovp_size)</span>

<span class="cp">#define ROUNDUP(x,y) ((x + ((y)-1)) &amp; ~((y)-1))</span>

<span class="cm">/************************************</span>
<span class="cm">** SBA register read and write support</span>
<span class="cm">**</span>
<span class="cm">** BE WARNED: register writes are posted.</span>
<span class="cm">**  (ie follow writes which must reach HW with a read)</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="cp">#define READ_REG(addr)       __raw_readq(addr)</span>
<span class="cp">#define WRITE_REG(val, addr) __raw_writeq(val, addr)</span>

<span class="cp">#ifdef DEBUG_SBA_INIT</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dump_tlb - debugging only - print IOMMU operating parameters</span>
<span class="cm"> * @hpa: base address of the IOMMU</span>
<span class="cm"> *</span>
<span class="cm"> * Print the size/location of the IO MMU PDIR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_tlb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hpa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IO TLB at 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hpa</span><span class="p">);</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_IBASE    : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_IBASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_IMASK    : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_IMASK</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_TCNFG    : %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_TCNFG</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;IOC_PDIR_BASE: %016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">hpa</span><span class="o">+</span><span class="n">IOC_PDIR_BASE</span><span class="p">));</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>

<span class="cm">/**</span>
<span class="cm"> * sba_dump_pdir_entry - debugging only - print one IOMMU PDIR entry</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @msg: text to print ont the output line.</span>
<span class="cm"> * @pide: pdir index.</span>
<span class="cm"> *</span>
<span class="cm"> * Print one entry of the IO MMU PDIR in human readable form.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_pdir_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">uint</span> <span class="n">pide</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* start printing from lowest pde in rval */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span>  <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[(</span><span class="n">pide</span> <span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
	<span class="n">uint</span> <span class="n">rcnt</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SBA: %s rp %p bit %d rval 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">msg</span><span class="p">,</span> <span class="n">rptr</span><span class="p">,</span> <span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">rptr</span><span class="p">);</span>

	<span class="n">rcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rcnt</span> <span class="o">&lt;</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s %2d %p %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">rcnt</span> <span class="o">==</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		       <span class="o">?</span> <span class="s">&quot;    --&gt;&quot;</span> <span class="o">:</span> <span class="s">&quot;       &quot;</span><span class="p">,</span>
		       <span class="n">rcnt</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">);</span>
		<span class="n">rcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_check_pdir - debugging only - consistency checker</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @msg: text to print ont the output line.</span>
<span class="cm"> *</span>
<span class="cm"> * Verify the resource map and pdir state is consistent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_check_pdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">rptr_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">]);</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">rptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>	<span class="cm">/* resource map ptr */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">;</span>	<span class="cm">/* pdir ptr */</span>
	<span class="n">uint</span> <span class="n">pide</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rptr</span> <span class="o">&lt;</span> <span class="n">rptr_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">rval</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rcnt</span><span class="p">;</span> <span class="cm">/* number of bits we might check */</span>

		<span class="n">rval</span> <span class="o">=</span> <span class="o">*</span><span class="n">rptr</span><span class="p">;</span>
		<span class="n">rcnt</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">rcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Get last byte and highest bit from that */</span>
			<span class="n">u32</span> <span class="n">pde</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)((</span><span class="o">*</span><span class="n">pptr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">63</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">^</span> <span class="n">pde</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				** BUMMER!  -- res_map != pdir --</span>
<span class="cm">				** Dump rval and matching pdir entries</span>
<span class="cm">				*/</span>
				<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">pide</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">rcnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">rval</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* try the next bit */</span>
			<span class="n">pptr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pide</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rptr</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* look at next word of res_map */</span>
	<span class="p">}</span>
	<span class="cm">/* It&#39;d be nice if we always got here :^) */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_dump_sg - debugging only - print Scatter-Gather list</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @startsg: head of the SG list</span>
<span class="cm"> * @nents: number of entries in SG list</span>
<span class="cm"> *</span>
<span class="cm"> * print the SG list so we can verify it&#39;s correct by hand.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_dump_sg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">startsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nents</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %d : DMA %08lx/%05x CPU %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span>
		       <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">,</span>
		       <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">));</span>
		<span class="n">startsg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_check_sg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">startsg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">the_sg</span> <span class="o">=</span> <span class="n">startsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">the_nents</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">the_nents</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sba_sg_address</span><span class="p">(</span><span class="n">the_sg</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0UL</span><span class="p">)</span>
			<span class="n">sba_dump_sg</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">startsg</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
		<span class="n">the_sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">the_sg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ASSERT_PDIR_SANITY */</span><span class="cp"></span>




<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   I/O Pdir Resource Management</span>
<span class="cm">*</span>
<span class="cm">*   Bits set in the resource map are in use.</span>
<span class="cm">*   Each bit can represent a number of pages.</span>
<span class="cm">*   LSbs represent lower addresses (IOVA&#39;s).</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>
<span class="cp">#define PAGES_PER_RANGE 1	</span><span class="cm">/* could increase this to 4 or 8 if needed */</span><span class="cp"></span>

<span class="cm">/* Convert from IOVP to IOVA and vice versa. */</span>
<span class="cp">#define SBA_IOVA(ioc,iovp,offset) ((ioc-&gt;ibase) | (iovp) | (offset))</span>
<span class="cp">#define SBA_IOVP(ioc,iova) ((iova) &amp; ~(ioc-&gt;ibase))</span>

<span class="cp">#define PDIR_ENTRY_SIZE	sizeof(u64)</span>

<span class="cp">#define PDIR_INDEX(iovp)   ((iovp)&gt;&gt;iovp_shift)</span>

<span class="cp">#define RESMAP_MASK(n)    ~(~0UL &lt;&lt; (n))</span>
<span class="cp">#define RESMAP_IDX_MASK   (sizeof(unsigned long) - 1)</span>


<span class="cm">/**</span>
<span class="cm"> * For most cases the normal get_order is sufficient, however it limits us</span>
<span class="cm"> * to PAGE_SIZE being the minimum mapping alignment and TC flush granularity.</span>
<span class="cm"> * It only incurs about 1 clock cycle to use this one with the static variable</span>
<span class="cm"> * and makes the code more intuitive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">int</span>
<span class="nf">get_iovp_order</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">ia64_getf_exp</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="n">iovp_shift</span> <span class="o">-</span> <span class="mh">0xffff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ptr_to_pide</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitshiftcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res_ptr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">bitshiftcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_search_bitmap - find free space in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @bits_wanted: number of entries we need.</span>
<span class="cm"> * @use_hint: use res_hint to indicate where to start looking</span>
<span class="cm"> *</span>
<span class="cm"> * Find consecutive free bits in resource bitmap.</span>
<span class="cm"> * Each bit represents one entry in the IO Pdir.</span>
<span class="cm"> * Cool perf optimization: search for log2(size) bits at a time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">sba_search_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits_wanted</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">]);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pide</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">,</span> <span class="n">tpide</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boundary_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">res_end</span><span class="p">);</span>

	<span class="n">boundary_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">boundary_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">boundary_size</span><span class="p">,</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">iovp_shift</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">);</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">&gt;&gt;</span> <span class="n">iovp_shift</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Allow caller to force a search through the entire resource space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">use_hint</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res_ptr</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * N.B.  REO/Grande defect AR2305 can cause TLB fetch timeouts</span>
<span class="cm">	 * if a TLB entry is purged while in use.  sba_mark_invalid()</span>
<span class="cm">	 * purges IOTLB entries in power-of-two sizes, so we also</span>
<span class="cm">	 * allocate IOVA space in power-of-two sizes.</span>
<span class="cm">	 */</span>
	<span class="n">bits_wanted</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">get_iovp_order</span><span class="p">(</span><span class="n">bits_wanted</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bits_wanted</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitshiftcnt</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(;</span> <span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">res_end</span> <span class="p">;</span> <span class="n">res_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">*</span><span class="n">res_ptr</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bitshiftcnt</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>
				<span class="o">*</span><span class="n">res_ptr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bitshiftcnt</span><span class="p">);</span>
				<span class="n">pide</span> <span class="o">=</span> <span class="n">ptr_to_pide</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="n">bitshiftcnt</span><span class="p">);</span>
				<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="n">bitshiftcnt</span> <span class="o">+</span> <span class="n">bits_wanted</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>

	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bits_wanted</span> <span class="o">&lt;=</span> <span class="n">BITS_PER_LONG</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** Search the resource bit map on well-aligned values.</span>
<span class="cm">		** &quot;o&quot; is the alignment.</span>
<span class="cm">		** We need the alignment to invalidate I/O TLB using</span>
<span class="cm">		** SBA HW features in the unmap path.</span>
<span class="cm">		*/</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">get_iovp_order</span><span class="p">(</span><span class="n">bits_wanted</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">);</span>
		<span class="n">uint</span> <span class="n">bitshiftcnt</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="n">base_mask</span><span class="p">;</span>

		<span class="n">base_mask</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_wanted</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">base_mask</span> <span class="o">&lt;&lt;</span> <span class="n">bitshiftcnt</span><span class="p">;</span>

		<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s() o %ld %p&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(;</span> <span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">res_end</span> <span class="p">;</span> <span class="n">res_ptr</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span> 
			<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;    %p %lx %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">mask</span> <span class="p">;</span> <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="n">o</span><span class="p">,</span> <span class="n">bitshiftcnt</span> <span class="o">+=</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tpide</span> <span class="o">=</span> <span class="n">ptr_to_pide</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="n">bitshiftcnt</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_is_span_boundary</span><span class="p">(</span><span class="n">tpide</span><span class="p">,</span> <span class="n">bits_wanted</span><span class="p">,</span>
							     <span class="n">shift</span><span class="p">,</span>
							     <span class="n">boundary_size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="p">((</span><span class="o">*</span><span class="n">res_ptr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">res_ptr</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>     <span class="cm">/* mark resources busy! */</span>
					<span class="n">pide</span> <span class="o">=</span> <span class="n">tpide</span><span class="p">;</span>
					<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="n">bitshiftcnt</span> <span class="o">+</span> <span class="n">bits_wanted</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">bitshiftcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">base_mask</span><span class="p">;</span>

		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">qwords</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">qwords</span> <span class="o">=</span> <span class="n">bits_wanted</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* /64 */</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">bits_wanted</span> <span class="o">-</span> <span class="p">(</span><span class="n">qwords</span> <span class="o">*</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">res_end</span> <span class="o">-</span> <span class="n">qwords</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">res_ptr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">res_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tpide</span> <span class="o">=</span> <span class="n">ptr_to_pide</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iommu_is_span_boundary</span><span class="p">(</span><span class="n">tpide</span><span class="p">,</span> <span class="n">bits_wanted</span><span class="p">,</span>
						     <span class="n">shift</span><span class="p">,</span> <span class="n">boundary_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next_ptr</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qwords</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">res_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">next_ptr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;&amp;</span> <span class="n">res_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">__ffs</span><span class="p">(</span><span class="n">res_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Found it, mark it */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qwords</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">res_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
			<span class="n">res_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>

			<span class="n">pide</span> <span class="o">=</span> <span class="n">tpide</span><span class="p">;</span>
			<span class="n">res_ptr</span> <span class="o">+=</span> <span class="n">qwords</span><span class="p">;</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found_it</span><span class="p">;</span>
<span class="nl">next_ptr:</span>
			<span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">not_found:</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">);</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pide</span><span class="p">);</span>

<span class="nl">found_it:</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="n">res_ptr</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pide</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_alloc_range - find free bits and mark them in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @size: number of bytes to create a mapping for</span>
<span class="cm"> *</span>
<span class="cm"> * Given a size, find consecutive unmarked and then mark those bits in the</span>
<span class="cm"> * resource bit map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sba_alloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">iovp_shift</span><span class="p">;</span>
<span class="cp">#ifdef PDIR_SEARCH_TIMING</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itc_start</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pide</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">pages_needed</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">));</span>

<span class="cp">#ifdef PDIR_SEARCH_TIMING</span>
	<span class="n">itc_start</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	** &quot;seek and ye shall find&quot;...praying never hurts either...</span>
<span class="cm">	*/</span>
	<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_search_bitmap</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pide</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_search_bitmap</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pide</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			** With delayed resource freeing, we can give this one more shot.  We&#39;re</span>
<span class="cm">			** getting close to being in trouble here, so do what we can to make this</span>
<span class="cm">			** one count.</span>
<span class="cm">			*/</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">sba_dma_pair</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">;</span>

				<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sba_mark_invalid</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
					<span class="n">sba_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
					<span class="n">d</span><span class="o">--</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>	<span class="cm">/* flush purges */</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_search_bitmap</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pide</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: I/O MMU @ %p is&quot;</span>
				       <span class="s">&quot;out of mapping resources, %u %u %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">,</span>
				       <span class="n">pages_needed</span><span class="p">,</span> <span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: I/O MMU @ %p is&quot;</span>
			       <span class="s">&quot;out of mapping resources, %u %u %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">,</span>
			       <span class="n">pages_needed</span><span class="p">,</span> <span class="n">dma_get_seg_boundary</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef PDIR_SEARCH_TIMING</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">-</span> <span class="n">itc_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">pages_needed</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_idx</span> <span class="o">&amp;=</span> <span class="n">SBA_SEARCH_SAMPLE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">prefetchw</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span><span class="p">]));</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="cm">/* verify the first enable bit is clear */</span>
	<span class="k">if</span><span class="p">(</span><span class="mh">0x00</span> <span class="o">!=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)[</span><span class="n">pide</span><span class="o">*</span><span class="n">PDIR_ENTRY_SIZE</span> <span class="o">+</span> <span class="mi">7</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="s">&quot;sba_search_bitmap() botched it?&quot;</span><span class="p">,</span> <span class="n">pide</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s(%x) %d -&gt; %lx hint %x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pages_needed</span><span class="p">,</span> <span class="n">pide</span><span class="p">,</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">),</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_bitshift</span> <span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">pide</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_free_range - unmark bits in IO PDIR resource bitmap</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @iova: IO virtual address which was previously allocated.</span>
<span class="cm"> * @size: number of bytes to create a mapping for</span>
<span class="cm"> *</span>
<span class="cm"> * clear bits in the ioc&#39;s resource map</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span>
<span class="nf">sba_free_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iovp</span> <span class="o">=</span> <span class="n">SBA_IOVP</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pide</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ridx</span> <span class="o">=</span> <span class="n">pide</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* convert bit to byte address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">ioc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ridx</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RESMAP_IDX_MASK</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">bits_not_wanted</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">iovp_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span><span class="p">;</span>

	<span class="cm">/* Round up to power-of-two size: see AR2305 note above */</span>
	<span class="n">bits_not_wanted</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">get_iovp_order</span><span class="p">(</span><span class="n">bits_not_wanted</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">bits_not_wanted</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">res_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bits_not_wanted</span> <span class="o">&gt;</span> <span class="n">BITS_PER_LONG</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* these mappings start 64bit aligned */</span>
			<span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
			<span class="n">bits_not_wanted</span> <span class="o">-=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">pide</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="cm">/* 3-bits &quot;bit&quot; address plus 2 (or 3) bits for &quot;byte&quot; == bit in word */</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">RESMAP_MASK</span><span class="p">(</span><span class="n">bits_not_wanted</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">bits_not_wanted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">DBG_RES</span><span class="p">(</span><span class="s">&quot;%s( ,%x,%x) %x/%lx %x %p %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			        <span class="n">bits_not_wanted</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pide</span><span class="p">,</span> <span class="n">res_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>

			<span class="n">ASSERT</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">bits_not_wanted</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="o">*</span><span class="n">res_ptr</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="p">);</span> <span class="cm">/* verify same bits are set */</span>
			<span class="o">*</span><span class="n">res_ptr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">m</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   &quot;Dynamic DMA Mapping&quot; support (aka &quot;Coherent I/O&quot;)</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * sba_io_pdir_entry - fill in one IO PDIR entry</span>
<span class="cm"> * @pdir_ptr:  pointer to IO PDIR entry</span>
<span class="cm"> * @vba: Virtual CPU address of buffer to map</span>
<span class="cm"> *</span>
<span class="cm"> * SBA Mapping Routine</span>
<span class="cm"> *</span>
<span class="cm"> * Given a virtual address (vba, arg1) sba_io_pdir_entry()</span>
<span class="cm"> * loads the I/O PDIR entry pointed to by pdir_ptr (arg0).</span>
<span class="cm"> * Each IO Pdir entry consists of 8 bytes as shown below</span>
<span class="cm"> * (LSB == bit 0):</span>
<span class="cm"> *</span>
<span class="cm"> *  63                    40                                 11    7        0</span>
<span class="cm"> * +-+---------------------+----------------------------------+----+--------+</span>
<span class="cm"> * |V|        U            |            PPN[39:12]            | U  |   FF   |</span>
<span class="cm"> * +-+---------------------+----------------------------------+----+--------+</span>
<span class="cm"> *</span>
<span class="cm"> *  V  == Valid Bit</span>
<span class="cm"> *  U  == Unused</span>
<span class="cm"> * PPN == Physical Page Number</span>
<span class="cm"> *</span>
<span class="cm"> * The physical address fields are filled with the results of virt_to_phys()</span>
<span class="cm"> * on the vba.</span>
<span class="cm"> */</span>

<span class="cp">#if 1</span>
<span class="cp">#define sba_io_pdir_entry(pdir_ptr, vba) *pdir_ptr = ((vba &amp; ~0xE000000000000FFFULL)	\</span>
<span class="cp">						      | 0x8000000000000000ULL)</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="n">SBA_INLINE</span>
<span class="nf">sba_io_pdir_entry</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">pdir_ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pdir_ptr</span> <span class="o">=</span> <span class="p">((</span><span class="n">vba</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xE000000000000FFFULL</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000000000FFULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ENABLE_MARK_CLEAN</span>
<span class="cm">/**</span>
<span class="cm"> * Since DMA is i-cache coherent, any (complete) pages that were written via</span>
<span class="cm"> * DMA can be marked as &quot;clean&quot; so that lazy_mmu_prot_update() doesn&#39;t have to</span>
<span class="cm"> * flush them when they get mapped into an executable vm-area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mark_clean</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg_addr</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">pg_addr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pg_addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pg_addr</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_arch_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pg_addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * sba_mark_invalid - invalidate one or more IO PDIR entries</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @iova:  IO Virtual Address mapped earlier</span>
<span class="cm"> * @byte_cnt:  number of bytes this mapping covers.</span>
<span class="cm"> *</span>
<span class="cm"> * Marking the IO PDIR entry(ies) as Invalid and invalidate</span>
<span class="cm"> * corresponding IO TLB entry. The PCOM (Purge Command Register)</span>
<span class="cm"> * is to purge stale entries in the IO TLB when unmapping entries.</span>
<span class="cm"> *</span>
<span class="cm"> * The PCOM register supports purging of multiple pages, with a minium</span>
<span class="cm"> * of 1 page and a maximum of 2GB. Hardware requires the address be</span>
<span class="cm"> * aligned to the size of the range being purged. The size of the range</span>
<span class="cm"> * must be a power of 2. The &quot;Cool perf optimization&quot; in the</span>
<span class="cm"> * allocation routine helps keep that true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span>
<span class="nf">sba_mark_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">SBA_IOVP</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="n">iova</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">);</span>

	<span class="cm">/* Must be non-zero and rounded up */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">));</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="cm">/* Assert first pdir entry is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">60</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sba_dump_pdir_entry</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;sba_mark_invalid()&quot;</span><span class="p">,</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&lt;=</span> <span class="n">iovp_size</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

		<span class="n">iovp</span> <span class="o">|=</span> <span class="n">iovp_shift</span><span class="p">;</span>     <span class="cm">/* set &quot;size&quot; field for PCOM */</span>

<span class="cp">#ifndef FULL_VALID_PDIR</span>
		<span class="cm">/*</span>
<span class="cm">		** clear I/O PDIR entry &quot;valid&quot; bit</span>
<span class="cm">		** Do NOT clear the rest - save it for debugging.</span>
<span class="cm">		** We should only clear bits that have previously</span>
<span class="cm">		** been enabled.</span>
<span class="cm">		*/</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x80000000000000FFULL</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="cm">/*</span>
<span class="cm">  		** If we want to maintain the PDIR as valid, put in</span>
<span class="cm">		** the spill page so devices prefetching won&#39;t</span>
<span class="cm">		** cause a hard fail.</span>
<span class="cm">		*/</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80000000000000FFULL</span> <span class="o">|</span> <span class="n">prefetch_spill_page</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">t</span> <span class="o">=</span> <span class="n">get_iovp_order</span><span class="p">(</span><span class="n">byte_cnt</span><span class="p">)</span> <span class="o">+</span> <span class="n">iovp_shift</span><span class="p">;</span>

		<span class="n">iovp</span> <span class="o">|=</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">);</span>   <span class="cm">/* 2GB! Max value of &quot;size&quot; field */</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* verify this pdir entry is enabled */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span>  <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">);</span>
<span class="cp">#ifndef FULL_VALID_PDIR</span>
			<span class="cm">/* clear I/O Pdir entry &quot;valid&quot; bit first */</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x80000000000000FFULL</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80000000000000FFULL</span> <span class="o">|</span> <span class="n">prefetch_spill_page</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">off</span><span class="o">++</span><span class="p">;</span>
			<span class="n">byte_cnt</span> <span class="o">-=</span> <span class="n">iovp_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">byte_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">iovp</span> <span class="o">|</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_map_single_attrs - map one buffer and return IOVA for DMA</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @addr:  driver buffer to map.</span>
<span class="cm"> * @size:  number of bytes to map in driver buffer.</span>
<span class="cm"> * @dir:  R/W or both.</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">sba_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">poff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">poff</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">iovp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdir_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pide</span><span class="p">;</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ALLOW_IOV_BYPASS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_addr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ALLOW_IOV_BYPASS</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm"> 	** Check if the PCI device can DMA to ptr... if so, just return ptr</span>
<span class="cm"> 	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">pci_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm"> 		** Device is bit capable of DMA&#39;ing to the buffer...</span>
<span class="cm">		** just return the PCI address of ptr</span>
<span class="cm"> 		*/</span>
		<span class="n">DBG_BYPASS</span><span class="p">(</span><span class="s">&quot;sba_map_single_attrs() bypass mask/addr: &quot;</span>
			   <span class="s">&quot;0x%lx/0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">,</span> <span class="n">pci_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pci_addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">);</span>

	<span class="cm">/* save offset bits */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">;</span>

	<span class="cm">/* round up to nearest iovp_size */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iovp_mask</span><span class="p">;</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_map_single_attrs()&quot;</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Sanity check failed&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">pide</span> <span class="o">=</span> <span class="n">sba_alloc_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pide</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="n">pide</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">;</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() 0x%p -&gt; 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">iovp</span> <span class="o">|</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">pdir_start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span><span class="p">]);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">pdir_start</span><span class="p">)[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* verify availability */</span>
		<span class="n">sba_io_pdir_entry</span><span class="p">(</span><span class="n">pdir_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

		<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;     pdir 0x%p %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdir_start</span><span class="p">,</span> <span class="o">*</span><span class="n">pdir_start</span><span class="p">);</span>

		<span class="n">addr</span> <span class="o">+=</span> <span class="n">iovp_size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">iovp_size</span><span class="p">;</span>
		<span class="n">pdir_start</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* force pdir update */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/* form complete address */</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_map_single_attrs()&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">SBA_IOVA</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">sba_map_single_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sba_map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef ENABLE_MARK_CLEAN</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">void</span>
<span class="nf">sba_mark_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">iovp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">SBA_IOVP</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="n">iova</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="n">off</span> <span class="o">=</span> <span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">iovp</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">iovp_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">&amp;</span>
		                    <span class="o">~</span><span class="mh">0xE000000000000FFFULL</span><span class="p">);</span>
		<span class="n">mark_clean</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">&amp;</span>
			                    <span class="o">~</span><span class="mh">0xE000000000000FFFULL</span><span class="p">);</span>
			<span class="n">mark_clean</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">iovp_size</span><span class="p">));</span>
			<span class="n">off</span><span class="o">++</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">iovp_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * sba_unmap_single_attrs - unmap one IOVA and free resources</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @iova:  IOVA of driver buffer previously mapped.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @dir:  R/W or both.</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sba_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="k">struct</span> <span class="n">sba_dma_pair</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

<span class="cp">#ifdef ALLOW_IOV_BYPASS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">iova</span> <span class="o">&amp;</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		** Address does not fall w/in IOVA, must be bypassing</span>
<span class="cm">		*/</span>
		<span class="n">DBG_BYPASS</span><span class="p">(</span><span class="s">&quot;sba_unmap_single_attrs() bypass addr: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">iova</span><span class="p">);</span>

<span class="cp">#ifdef ENABLE_MARK_CLEAN</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mark_clean</span><span class="p">(</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">iova</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">iova</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">;</span>

	<span class="n">DBG_RUN</span><span class="p">(</span><span class="s">&quot;%s() iovp 0x%lx/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">iova</span> <span class="o">^=</span> <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* clear offset bits */</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">iovp_size</span><span class="p">);</span>

<span class="cp">#ifdef ENABLE_MARK_CLEAN</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
		<span class="n">sba_mark_clean</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">]);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span> <span class="o">=</span> <span class="n">iova</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">DELAYED_RESOURCE_CNT</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sba_mark_invalid</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">sba_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">iova</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">d</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>	<span class="cm">/* flush purges */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* DELAYED_RESOURCE_CNT == 0 */</span><span class="cp"></span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_mark_invalid</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">sba_free_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="o">+</span><span class="n">IOC_PCOM</span><span class="p">);</span>	<span class="cm">/* flush purges */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DELAYED_RESOURCE_CNT == 0 */</span><span class="cp"></span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sba_unmap_single_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">iova</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sba_unmap_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">iova</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_alloc_coherent - allocate/map shared mem for DMA</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @dma_handle:  IOVA of new buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">sba_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span>
		   <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span> <span class="o">?</span>
		                        <span class="n">numa_node_id</span><span class="p">()</span> <span class="o">:</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		                        <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="cp">#ifdef ALLOW_IOV_BYPASS</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm"> 	** Check if the PCI device can DMA to ptr... if so, just return ptr</span>
<span class="cm"> 	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="o">*</span><span class="n">dma_handle</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG_BYPASS</span><span class="p">(</span><span class="s">&quot;sba_alloc_coherent() bypass mask/addr: 0x%lx/0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">dev</span><span class="o">-&gt;</span><span class="n">coherent_dma_mask</span><span class="p">,</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * If device can&#39;t bypass or bypass is disabled, pass the 32bit fake</span>
<span class="cm">	 * device to map single to get an iova mapping.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">sba_map_single_attrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sac_only_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
					   <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sba_free_coherent - free/unmap shared mem for DMA</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @size:  number of bytes mapped in driver buffer.</span>
<span class="cm"> * @vaddr:  virtual address IOVA of &quot;consistent&quot; buffer.</span>
<span class="cm"> * @dma_handler:  IO virtual address of &quot;consistent&quot; buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sba_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
			      <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sba_unmap_single_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** Since 0 is a valid pdir_base index value, can&#39;t use that</span>
<span class="cm">** to determine if a value is valid or not. Use a flag to indicate</span>
<span class="cm">** the SG list entry contains a valid pdir index.</span>
<span class="cm">*/</span>
<span class="cp">#define PIDE_FLAG 0x1UL</span>

<span class="cp">#ifdef DEBUG_LARGE_SG_ENTRIES</span>
<span class="kt">int</span> <span class="n">dump_run_sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * sba_fill_pdir - write allocated SG entries into IO PDIR</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @startsg:  list of IOVA/size pairs</span>
<span class="cm"> * @nents: number of entries in startsg list</span>
<span class="cm"> *</span>
<span class="cm"> * Take preprocessed SG list and write corresponding entries</span>
<span class="cm"> * in the IO PDIR.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">int</span>
<span class="nf">sba_fill_pdir</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">startsg</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dma_sg</span> <span class="o">=</span> <span class="n">startsg</span><span class="p">;</span>	<span class="cm">/* pointer to current DMA */</span>
	<span class="kt">int</span> <span class="n">n_mappings</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pdirp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nents</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>     <span class="n">cnt</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">;</span>
		<span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_LARGE_SG_ENTRIES</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dump_run_sg</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2d : %08lx/%05x %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nents</span><span class="p">,</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span>
				<span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot; %d : %08lx/%05x %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nents</span><span class="p">,</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span>
				<span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		** Look for the start of a new DMA stream</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">&amp;</span> <span class="n">PIDE_FLAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">pide</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PIDE_FLAG</span><span class="p">;</span>
			<span class="n">dma_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pide</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">;</span>
			<span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n_mappings</span><span class="p">)</span>
				<span class="n">dma_sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">dma_sg</span><span class="p">);</span>
			<span class="n">dma_sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">pide</span> <span class="o">|</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">;</span>
			<span class="n">pdirp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="n">pide</span> <span class="o">&gt;&gt;</span> <span class="n">iovp_shift</span><span class="p">]);</span>
			<span class="n">n_mappings</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		** Look for a VCONTIG chunk</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">pdirp</span><span class="p">);</span>

			<span class="cm">/* Since multiple Vcontig blocks could make up</span>
<span class="cm">			** one DMA stream, *add* cnt to dma_len.</span>
<span class="cm">			*/</span>
			<span class="n">dma_sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="n">dma_offset</span><span class="p">;</span>
			<span class="n">dma_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* only want offset on first chunk */</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">iovp_size</span><span class="p">);</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">sba_io_pdir_entry</span><span class="p">(</span><span class="n">pdirp</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
				<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">iovp_size</span><span class="p">;</span>
				<span class="n">cnt</span> <span class="o">-=</span> <span class="n">iovp_size</span><span class="p">;</span>
				<span class="n">pdirp</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">startsg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* force pdir update */</span>
	<span class="n">wmb</span><span class="p">();</span>

<span class="cp">#ifdef DEBUG_LARGE_SG_ENTRIES</span>
	<span class="n">dump_run_sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span><span class="p">(</span><span class="n">n_mappings</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">** Two address ranges are DMA contiguous *iff* &quot;end of prev&quot; and</span>
<span class="cm">** &quot;start of next&quot; are both on an IOV page boundary.</span>
<span class="cm">**</span>
<span class="cm">** (shift left is a quick trick to mask off upper bits)</span>
<span class="cm">*/</span>
<span class="cp">#define DMA_CONTIG(__X, __Y) \</span>
<span class="cp">	(((((unsigned long) __X) | ((unsigned long) __Y)) &lt;&lt; (BITS_PER_LONG - iovp_shift)) == 0UL)</span>


<span class="cm">/**</span>
<span class="cm"> * sba_coalesce_chunks - preprocess the SG list</span>
<span class="cm"> * @ioc: IO MMU structure which owns the pdir we are interested in.</span>
<span class="cm"> * @startsg:  list of IOVA/size pairs</span>
<span class="cm"> * @nents: number of entries in startsg list</span>
<span class="cm"> *</span>
<span class="cm"> * First pass is to walk the SG list and determine where the breaks are</span>
<span class="cm"> * in the DMA stream. Allocates PDIR entries but does not fill them.</span>
<span class="cm"> * Returns the number of DMA chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * Doing the fill separate from the coalescing/allocation keeps the</span>
<span class="cm"> * code simpler. Future enhancement could make one pass through</span>
<span class="cm"> * the sglist do both.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">SBA_INLINE</span> <span class="kt">int</span>
<span class="nf">sba_coalesce_chunks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">startsg</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">vcontig_sg</span><span class="p">;</span>    <span class="cm">/* VCONTIG chunk head */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vcontig_len</span><span class="p">;</span>         <span class="cm">/* len of VCONTIG chunk */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vcontig_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dma_sg</span><span class="p">;</span>        <span class="cm">/* next DMA stream head */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_offset</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">;</span> <span class="cm">/* start/len of DMA stream */</span>
	<span class="kt">int</span> <span class="n">n_mappings</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_seg_size</span> <span class="o">=</span> <span class="n">dma_get_max_seg_size</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		** Prepare for first/next DMA stream</span>
<span class="cm">		*/</span>
		<span class="n">dma_sg</span> <span class="o">=</span> <span class="n">vcontig_sg</span> <span class="o">=</span> <span class="n">startsg</span><span class="p">;</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="n">vcontig_len</span> <span class="o">=</span> <span class="n">vcontig_end</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">vcontig_end</span> <span class="o">+=</span>  <span class="n">vaddr</span><span class="p">;</span>
		<span class="n">dma_offset</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">;</span>

		<span class="cm">/* PARANOID: clear entries */</span>
		<span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		** This loop terminates one iteration &quot;early&quot; since</span>
<span class="cm">		** it&#39;s always looking one &quot;ahead&quot;.</span>
<span class="cm">		*/</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">nents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>	<span class="cm">/* tmp */</span>

			<span class="n">startsg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>

			<span class="cm">/* PARANOID */</span>
			<span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* catch brokenness in SCSI layer */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			** First make sure current dma stream won&#39;t</span>
<span class="cm">			** exceed DMA_CHUNK_SIZE if we coalesce the</span>
<span class="cm">			** next entry.</span>
<span class="cm">			*/</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">dma_len</span> <span class="o">+</span> <span class="n">dma_offset</span> <span class="o">+</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iovp_mask</span><span class="p">)</span>
			    <span class="o">&gt;</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dma_len</span> <span class="o">+</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">max_seg_size</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			** Then look for virtually contiguous blocks.</span>
<span class="cm">			**</span>
<span class="cm">			** append the next transaction?</span>
<span class="cm">			*/</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">startsg</span><span class="p">);</span>
			<span class="k">if</span>  <span class="p">(</span><span class="n">vcontig_end</span> <span class="o">==</span> <span class="n">vaddr</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">vcontig_len</span> <span class="o">+=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
				<span class="n">vcontig_end</span> <span class="o">+=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
				<span class="n">dma_len</span>     <span class="o">+=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

<span class="cp">#ifdef DEBUG_LARGE_SG_ENTRIES</span>
			<span class="n">dump_run_sg</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcontig_len</span> <span class="o">&gt;</span> <span class="n">iovp_size</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="cm">/*</span>
<span class="cm">			** Not virtually contiguous.</span>
<span class="cm">			** Terminate prev chunk.</span>
<span class="cm">			** Start a new chunk.</span>
<span class="cm">			**</span>
<span class="cm">			** Once we start a new VCONTIG chunk, dma_offset</span>
<span class="cm">			** can&#39;t change. And we need the offset from the first</span>
<span class="cm">			** chunk - not the last one. Ergo Successive chunks</span>
<span class="cm">			** must start on page boundaries and dove tail</span>
<span class="cm">			** with it&#39;s predecessor.</span>
<span class="cm">			*/</span>
			<span class="n">vcontig_sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">vcontig_len</span><span class="p">;</span>

			<span class="n">vcontig_sg</span> <span class="o">=</span> <span class="n">startsg</span><span class="p">;</span>
			<span class="n">vcontig_len</span> <span class="o">=</span> <span class="n">startsg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			** 3) do the entries end/start on page boundaries?</span>
<span class="cm">			**    Don&#39;t update vcontig_end until we&#39;ve checked.</span>
<span class="cm">			*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DMA_CONTIG</span><span class="p">(</span><span class="n">vcontig_end</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">vcontig_end</span> <span class="o">=</span> <span class="n">vcontig_len</span> <span class="o">+</span> <span class="n">vaddr</span><span class="p">;</span>
				<span class="n">dma_len</span> <span class="o">+=</span> <span class="n">vcontig_len</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		** End of DMA Stream</span>
<span class="cm">		** Terminate last VCONTIG block.</span>
<span class="cm">		** Allocate space for DMA stream.</span>
<span class="cm">		*/</span>
		<span class="n">vcontig_sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">vcontig_len</span><span class="p">;</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_len</span> <span class="o">+</span> <span class="n">dma_offset</span> <span class="o">+</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iovp_mask</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dma_len</span> <span class="o">&lt;=</span> <span class="n">DMA_CHUNK_SIZE</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">sba_alloc_range</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)(</span><span class="n">PIDE_FLAG</span> <span class="o">|</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">)</span>
						   <span class="o">|</span> <span class="n">dma_offset</span><span class="p">);</span>
		<span class="n">n_mappings</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n_mappings</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sba_unmap_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * sba_map_sg - map Scatter/Gather list</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @sglist:  array of buffer/length pairs</span>
<span class="cm"> * @nents:  number of entries in list</span>
<span class="cm"> * @dir:  R/W or both.</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_map_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">coalesced</span><span class="p">,</span> <span class="n">filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef ALLOW_IOV_BYPASS_SG</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

<span class="cp">#ifdef ALLOW_IOV_BYPASS_SG</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">filled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">sba_sg_address</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">filled</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Fast path single entry scatterlists. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">sba_map_single_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_map_sg_attrs()&quot;</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">sba_dump_sg</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Check before sba_map_sg_attrs()&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">prefetch</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** First coalesce the chunks and allocate I/O pdir space</span>
<span class="cm">	**</span>
<span class="cm">	** If this is one DMA stream, we can properly map using the</span>
<span class="cm">	** correct virtual address associated with each DMA page.</span>
<span class="cm">	** w/o this association, we wouldn&#39;t have coherent DMA!</span>
<span class="cm">	** Access to the virtual address is what forces a two pass algorithm.</span>
<span class="cm">	*/</span>
	<span class="n">coalesced</span> <span class="o">=</span> <span class="n">sba_coalesce_chunks</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">coalesced</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sba_unmap_sg_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	** Program the I/O Pdir</span>
<span class="cm">	**</span>
<span class="cm">	** map the virtual addresses to the I/O Pdir</span>
<span class="cm">	** o dma_address will contain the pdir index</span>
<span class="cm">	** o dma_len will contain the number of bytes to map</span>
<span class="cm">	** o address contains the virtual address.</span>
<span class="cm">	*/</span>
	<span class="n">filled</span> <span class="o">=</span> <span class="n">sba_fill_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_map_sg_attrs()&quot;</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">sba_dump_sg</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">sglist</span><span class="p">,</span> <span class="n">nents</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Check after sba_map_sg_attrs()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">coalesced</span> <span class="o">==</span> <span class="n">filled</span><span class="p">);</span>
	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE %d mappings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">filled</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">filled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sba_unmap_sg_attrs - unmap Scatter/Gather list</span>
<span class="cm"> * @dev: instance of PCI owned by the driver that&#39;s asking.</span>
<span class="cm"> * @sglist:  array of buffer/length pairs</span>
<span class="cm"> * @nents:  number of entries in list</span>
<span class="cm"> * @dir:  R/W or both.</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/DMA-API-HOWTO.txt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sba_unmap_sg_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() START %d entries,  %p,%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">sba_sg_address</span><span class="p">(</span><span class="n">sglist</span><span class="p">),</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">ioc</span> <span class="o">=</span> <span class="n">GET_IOC</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check before sba_unmap_sg_attrs()&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nents</span> <span class="o">&amp;&amp;</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">sba_unmap_single_attrs</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span>
				       <span class="n">sglist</span><span class="o">-&gt;</span><span class="n">dma_length</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
		<span class="n">sglist</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sglist</span><span class="p">);</span>
		<span class="n">nents</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DBG_RUN_SG</span><span class="p">(</span><span class="s">&quot;%s() DONE (nents %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>  <span class="n">nents</span><span class="p">);</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sba_check_pdir</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span><span class="s">&quot;Check after sba_unmap_sg_attrs()&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="cm">/**************************************************************</span>
<span class="cm">*</span>
<span class="cm">*   Initialization and claim</span>
<span class="cm">*</span>
<span class="cm">***************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ioc_iova_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tcnfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agp_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef FULL_VALID_PDIR</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	** Firmware programs the base and size of a &quot;safe IOVA space&quot;</span>
<span class="cm">	** (one that doesn&#39;t overlap memory or LMMIO space) in the</span>
<span class="cm">	** IBASE and IMASK registers.</span>
<span class="cm">	*/</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IBASE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1UL</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IMASK</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xFFFFFFFF00000000UL</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span> <span class="o">=</span> <span class="o">~</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() hpa %p IOV base 0x%lx mask 0x%lx (%dMB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">imask</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">iovp_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span>  <span class="mi">4</span><span class="o">*</span><span class="mi">1024</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span>  <span class="mi">8</span><span class="o">*</span><span class="mi">1024</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span>: <span class="n">tcnfg</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Unsupported IOTLB page size %ldK&quot;</span><span class="p">,</span>
				<span class="n">iovp_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">tcnfg</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_TCNFG</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span> <span class="o">/</span> <span class="n">iovp_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">PDIR_ENTRY_SIZE</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
						   <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Couldn&#39;t allocate I/O Page Table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() IOV page size %ldK pdir %p size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">iovp_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">);</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">),</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PDIR_BASE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** If an AGP device is present, only use half of the IOV space</span>
<span class="cm">	** for PCI DMA.  Unfortunately we can&#39;t know ahead of time</span>
<span class="cm">	** whether GART support will actually be used, for now we</span>
<span class="cm">	** can just key on an AGP device found in the system.</span>
<span class="cm">	** We program the next pdir index after we stop w/ a key for</span>
<span class="cm">	** the GART code to handshake on.</span>
<span class="cm">	*/</span>
	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>	
		<span class="n">agp_found</span> <span class="o">|=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">PCI_CAP_ID_AGP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">agp_found</span> <span class="o">&amp;&amp;</span> <span class="n">reserve_sba_gart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span> <span class="s">&quot;reserving %dMb of IOVA space at 0x%lx for agpgart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span><span class="o">/</span><span class="mi">2</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">+</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)[</span><span class="n">PDIR_INDEX</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ZX1_SBA_IOMMU_COOKIE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef FULL_VALID_PDIR</span>
	<span class="cm">/*</span>
<span class="cm">  	** Check to see if the spill page has been allocated, we don&#39;t need more than</span>
<span class="cm">	** one across multiple SBAs.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prefetch_spill_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">spill_poison</span> <span class="o">=</span> <span class="s">&quot;SBAIOMMU POISON&quot;</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">poison_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">poison_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">iovp_size</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Couldn&#39;t allocate PDIR spill page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">poison_addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">poison_addr</span> <span class="o">&lt;</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">iovp_size</span><span class="p">;</span> <span class="n">poison_addr</span> <span class="o">+=</span> <span class="n">poison_size</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">poison_addr</span><span class="p">,</span> <span class="n">spill_poison</span><span class="p">,</span> <span class="n">poison_size</span><span class="p">);</span>

		<span class="n">prefetch_spill_page</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() prefetch spill addr: 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">prefetch_spill_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">  	** Set all the PDIR entries valid w/ the spill page as the target</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="n">PDIR_ENTRY_SIZE</span><span class="p">)</span> <span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80000000000000FF</span> <span class="o">|</span> <span class="n">prefetch_spill_page</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Clear I/O TLB of any possible entries */</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_iovp_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">iovp_shift</span><span class="p">),</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PCOM</span><span class="p">);</span>
	<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_PCOM</span><span class="p">);</span>

	<span class="cm">/* Enable IOVA translation */</span>
	<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IBASE</span><span class="p">);</span>
	<span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_IBASE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ioc_resource_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_lock</span><span class="p">);</span>
<span class="cp">#if DELAYED_RESOURCE_CNT &gt; 0</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">saved_lock</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* resource map size dictated by pdir_size */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="n">PDIR_ENTRY_SIZE</span><span class="p">;</span> <span class="cm">/* entries */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* convert bit count to byte count */</span>
	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() res_size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
						 <span class="n">get_order</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Couldn&#39;t allocate resource map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">);</span>
	<span class="cm">/* next available IOVP - circular search */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_hint</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>

<span class="cp">#ifdef ASSERT_PDIR_SANITY</span>
	<span class="cm">/* Mark first bit busy - ie no IOVA 0 */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x8000000000000000ULL</span> <span class="o">|</span> <span class="n">ZX1_SBA_IOMMU_COOKIE</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef FULL_VALID_PDIR</span>
	<span class="cm">/* Mark the last resource used so we don&#39;t prefetch beyond IOVA space */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">[</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80UL</span><span class="p">;</span> <span class="cm">/* res_map is chars */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_base</span><span class="p">[(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">/</span> <span class="n">PDIR_ENTRY_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80000000000000FF</span>
							      <span class="o">|</span> <span class="n">prefetch_spill_page</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s() res_map %x %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		 <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ioc_sac_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">sac</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pci_alloc_coherent() must return a DMA address which is</span>
<span class="cm">	 * SAC (single address cycle) addressable, so allocate a</span>
<span class="cm">	 * pseudo-device to enforce that.</span>
<span class="cm">	 */</span>
	<span class="n">sac</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sac</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sac</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Couldn&#39;t allocate struct pci_dev&quot;</span><span class="p">);</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">controller</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">controller</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;Couldn&#39;t allocate struct pci_controller&quot;</span><span class="p">);</span>

	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">=</span> <span class="n">controller</span><span class="p">;</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFUL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">sac</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">sac_only_dev</span> <span class="o">=</span> <span class="n">sac</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ioc_zx1_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rope_config</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;IOC 2.0 or later required for IOMMU support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* 38 bit memory controller + extra bit for range displaced by MMIO */</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">39</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	** Clear ROPE(N)_CONFIG AO bit.</span>
<span class="cm">	** Disables &quot;NT Ordering&quot; (~= !&quot;Relaxed Ordering&quot;)</span>
<span class="cm">	** Overrides bit 1 in DMA Hint Sets.</span>
<span class="cm">	** Improves netperf UDP_STREAM by ~10% for tg3 on bcm5701.</span>
<span class="cm">	*/</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span> <span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rope_config</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_ROPE0_CFG</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rope_config</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IOC_ROPE_AO</span><span class="p">;</span>
		<span class="n">WRITE_REG</span><span class="p">(</span><span class="n">rope_config</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_ROPE0_CFG</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">initfunc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ioc_iommu</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">func_id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">initfunc</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc_iommu</span> <span class="n">ioc_iommu_info</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">ZX1_IOC_ID</span><span class="p">,</span> <span class="s">&quot;zx1&quot;</span><span class="p">,</span> <span class="n">ioc_zx1_init</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ZX2_IOC_ID</span><span class="p">,</span> <span class="s">&quot;zx2&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SX1000_IOC_ID</span><span class="p">,</span> <span class="s">&quot;sx1000&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SX2000_IOC_ID</span><span class="p">,</span> <span class="s">&quot;sx2000&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">ioc_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hpa</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc_iommu</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ioc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span>
	<span class="n">ioc_list</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">hpa</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">func_id</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_FUNC_ID</span><span class="p">);</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">=</span> <span class="n">READ_REG</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioc_hpa</span> <span class="o">+</span> <span class="n">IOC_FCLASS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFUL</span><span class="p">;</span>
	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFFFFFFFFFUL</span><span class="p">;</span>	<span class="cm">/* conservative */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">info</span> <span class="o">=</span> <span class="n">ioc_iommu_info</span><span class="p">;</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="n">ioc_iommu_info</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ioc_iommu_info</span><span class="p">);</span> <span class="n">info</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">func_id</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">func_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
				<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)(</span><span class="n">ioc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iovp_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">iovp_shift</span><span class="p">);</span>
	<span class="n">iovp_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">iovp_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">DBG_INIT</span><span class="p">(</span><span class="s">&quot;%s: PAGE_SIZE %ldK, iovp_size %ldK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">iovp_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
			<span class="n">sprintf</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Unknown (%04x:%04x)&quot;</span><span class="p">,</span>
				<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">func_id</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">,</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">func_id</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioc_iova_init</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="n">ioc_resource_init</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="n">ioc_sac_init</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="o">~</span><span class="n">iovp_mask</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ia64_max_iommu_merge_mask</span><span class="p">)</span>
		<span class="n">ia64_max_iommu_merge_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">iovp_mask</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PFX</span>
		<span class="s">&quot;%s %d.%d HPA 0x%lx IOVA space %dMb at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span>
		<span class="n">hpa</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">iov_size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ibase</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ioc</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**   SBA initialization code (HW and SW)</span>
<span class="cm">**</span>
<span class="cm">**   o identify SBA chip itself</span>
<span class="cm">**   o FIXME: initialize DMA hints for reasonable defaults</span>
<span class="cm">**</span>
<span class="cm">**************************************************************************/</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ioc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span> <span class="n">ioc</span><span class="p">;</span> <span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ioc</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ioc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ioc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ioc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">res_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Hewlett Packard %s IOC rev %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">),</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">!=</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;NUMA node       : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;IOVA size       : %ld MB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">iovp_size</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;IOVA page size  : %ld kb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iovp_size</span><span class="o">/</span><span class="mi">1024</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">res_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">res_ptr</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">+=</span> <span class="n">hweight64</span><span class="p">(</span><span class="o">*</span><span class="n">res_ptr</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PDIR size       : %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">pdir_size</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PDIR used       : %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>

<span class="cp">#ifdef PDIR_SEARCH_TIMING</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SBA_SEARCH_SAMPLE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avg</span> <span class="o">+=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="n">min</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">avg_search</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">avg</span> <span class="o">/=</span> <span class="n">SBA_SEARCH_SAMPLE</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Bitmap search   : %ld/%ld/%ld (min/avg/max CPU Cycles/IOVA page)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		           <span class="n">min</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef ALLOW_IOV_BYPASS</span>
	 <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;IOVA bypass disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">ioc_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ioc_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">ioc_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">ioc_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">ioc_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ioc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ioc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">ioc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">ioc_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;bus/mckinley&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">proc_create</span><span class="p">(</span><span class="n">ioc_list</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioc_fops</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sba_connect_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">,</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">PFX</span> <span class="s">&quot;no sysdata on bus %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">acpi_handle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The IOC scope encloses PCI root bridges in the ACPI</span>
<span class="cm">	 * namespace, so work our way out until we find an IOC we</span>
<span class="cm">	 * claimed previously.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_list</span><span class="p">;</span> <span class="n">ioc</span><span class="p">;</span> <span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">==</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iommu</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_parent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No IOC for PCI Bus %04x:%02x in ACPI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">sba_map_ioc_to_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">,</span> <span class="n">acpi_handle</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pxm</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>

	<span class="n">pxm</span> <span class="o">=</span> <span class="n">acpi_get_pxm</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pxm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">pxm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ioc</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define sba_map_ioc_to_node(ioc, handle)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">acpi_sba_ioc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hpa</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_device_info</span> <span class="o">*</span><span class="n">adi</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">hp_acpi_csr_space</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_object_info</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For HWP0001, only SBA appears in ACPI namespace.  It encloses the PCI</span>
<span class="cm">	 * root bridges, and its CSR space includes the IOC function.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="s">&quot;HWP0001&quot;</span><span class="p">,</span> <span class="n">adi</span><span class="o">-&gt;</span><span class="n">hardware_id</span><span class="p">.</span><span class="n">string</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa</span> <span class="o">+=</span> <span class="n">ZX1_IOC_OFFSET</span><span class="p">;</span>
		<span class="cm">/* zx1 based systems default to kernel page size iommu pages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iovp_shift</span><span class="p">)</span>
			<span class="n">iovp_shift</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * default anything not caught above or specified on cmdline to 4k</span>
<span class="cm">	 * iommu page size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iovp_shift</span><span class="p">)</span>
		<span class="n">iovp_shift</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">ioc_init</span><span class="p">(</span><span class="n">hpa</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* setup NUMA node association */</span>
	<span class="n">sba_map_ioc_to_node</span><span class="p">(</span><span class="n">ioc</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">acpi_device_id</span> <span class="n">hp_ioc_iommu_device_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;HWP0001&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;HWP0004&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">acpi_driver</span> <span class="n">acpi_sba_ioc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;IOC IOMMU Driver&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ids</span>		<span class="o">=</span> <span class="n">hp_ioc_iommu_device_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">add</span>	<span class="o">=</span> <span class="n">acpi_sba_ioc_add</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">swiotlb_dma_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">sba_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;hpzx1&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;hpzx1_swiotlb&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_IA64_GENERIC)</span>
	<span class="cm">/* If we are booting a kdump kernel, the sba_iommu will</span>
<span class="cm">	 * cause devices that were not shutdown properly to MCA</span>
<span class="cm">	 * as soon as they are turned back on.  Our only option for</span>
<span class="cm">	 * a successful kdump kernel boot is to use the swiotlb.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_kdump_kernel</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">swiotlb_dma_ops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swiotlb_late_init_with_default_size</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to initialize software I/O TLB:&quot;</span>
				  <span class="s">&quot; Try machvec=dig boot option&quot;</span><span class="p">);</span>
		<span class="n">machvec_init</span><span class="p">(</span><span class="s">&quot;dig&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">acpi_bus_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acpi_sba_ioc_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc_list</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IA64_GENERIC</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we didn&#39;t find something sba_iommu can claim, we</span>
<span class="cm">		 * need to setup the swiotlb and switch to the dig machvec.</span>
<span class="cm">		 */</span>
		<span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">swiotlb_dma_ops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swiotlb_late_init_with_default_size</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to find SBA IOMMU or initialize &quot;</span>
			      <span class="s">&quot;software I/O TLB: Try machvec=dig boot option&quot;</span><span class="p">);</span>
		<span class="n">machvec_init</span><span class="p">(</span><span class="s">&quot;dig&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to find SBA IOMMU: Try a generic or DIG kernel&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_HP_ZX1_SWIOTLB)</span>
	<span class="cm">/*</span>
<span class="cm">	 * hpzx1_swiotlb needs to have a fairly small swiotlb bounce</span>
<span class="cm">	 * buffer setup to support devices with smaller DMA masks than</span>
<span class="cm">	 * sba_iommu can handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;hpzx1_swiotlb&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">extern</span> <span class="kt">void</span> <span class="n">hwsw_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

		<span class="n">hwsw_init</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">pci_find_next_bus</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">sba_connect_bus</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">ioc_proc_init</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">sba_init</span><span class="p">);</span> <span class="cm">/* must be initialized after ACPI etc., but before any drivers... */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">nosbagart</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reserve_sba_gart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_dma_supported</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* make sure it&#39;s at least 32bit capable */</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFUL</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFFFFFFFFUL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sba_dma_mapping_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nosbagart&quot;</span><span class="p">,</span> <span class="n">nosbagart</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">sba_page_override</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size</span><span class="p">;</span>

	<span class="n">page_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">page_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">4096</span>:
		<span class="k">case</span> <span class="mi">8192</span>:
		<span class="k">case</span> <span class="mi">16384</span>:
		<span class="k">case</span> <span class="mi">65536</span>:
			<span class="n">iovp_shift</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">page_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: unknown/unsupported iommu page size %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">page_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;sbapagesize=&quot;</span><span class="p">,</span><span class="n">sba_page_override</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">sba_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>			<span class="o">=</span> <span class="n">sba_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>			<span class="o">=</span> <span class="n">sba_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>		<span class="o">=</span> <span class="n">sba_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>		<span class="o">=</span> <span class="n">sba_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>			<span class="o">=</span> <span class="n">sba_map_sg_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>		<span class="o">=</span> <span class="n">sba_unmap_sg_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_cpu</span>	<span class="o">=</span> <span class="n">machvec_dma_sync_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_cpu</span>	<span class="o">=</span> <span class="n">machvec_dma_sync_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_device</span>	<span class="o">=</span> <span class="n">machvec_dma_sync_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_device</span>	<span class="o">=</span> <span class="n">machvec_dma_sync_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_supported</span>		<span class="o">=</span> <span class="n">sba_dma_supported</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mapping_error</span>		<span class="o">=</span> <span class="n">sba_dma_mapping_error</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">sba_dma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sba_dma_ops</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
