<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › hp › sim › simeth.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>simeth.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Simulated Ethernet Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2001, 2003 Hewlett-Packard Co</span>
<span class="cm"> *	Stephane Eranian &lt;eranian@hpl.hp.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/hpsim.h&gt;</span>

<span class="cp">#include &quot;hpsim_ssc.h&quot;</span>

<span class="cp">#define SIMETH_RECV_MAX	10</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum possible received frame for Ethernet.</span>
<span class="cm"> * We preallocate an sk_buff of that size to avoid costly</span>
<span class="cm"> * memcpy for temporary buffer into sk_buff. We do basically</span>
<span class="cm"> * what&#39;s done in other drivers, like eepro with a ring.</span>
<span class="cm"> * The difference is, of course, that we don&#39;t have real DMA !!!</span>
<span class="cm"> */</span>
<span class="cp">#define SIMETH_FRAME_SIZE	ETH_FRAME_LEN</span>


<span class="cp">#define NETWORK_INTR			8</span>

<span class="k">struct</span> <span class="n">simeth_local</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">simfd</span><span class="p">;</span>	 <span class="cm">/* descriptor in the simulator */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_probe1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">simeth_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">simeth_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_device_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">simeth_version</span><span class="o">=</span><span class="s">&quot;0.3&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This variable is used to establish a mapping between the Linux/ia64 kernel</span>
<span class="cm"> * and the host linux kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * As of today, we support only one card, even though most of the code</span>
<span class="cm"> * is ready for many more. The mapping is then:</span>
<span class="cm"> *	linux/ia64 -&gt; linux/x86</span>
<span class="cm"> * 	   eth0    -&gt; eth1</span>
<span class="cm"> *</span>
<span class="cm"> * In the future, we some string operations, we could easily support up</span>
<span class="cm"> * to 10 cards (0-9).</span>
<span class="cm"> *</span>
<span class="cm"> * The default mapping can be changed on the kernel command line by</span>
<span class="cm"> * specifying simeth=ethX (or whatever string you want).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">simeth_device</span><span class="o">=</span><span class="s">&quot;eth0&quot;</span><span class="p">;</span>	 <span class="cm">/* default host interface to use */</span>



<span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">card_count</span><span class="p">;</span> <span class="cm">/* how many cards &quot;found&quot; so far */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">simeth_debug</span><span class="p">;</span>		<span class="cm">/* set to 1 to get debug information */</span>

<span class="cm">/*</span>
<span class="cm"> * Used to catch IFF_UP &amp; IFF_DOWN events</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">simeth_dev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">simeth_device_event</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Function used when using a kernel command line option.</span>
<span class="cm"> *</span>
<span class="cm"> * Format: simeth=interface_name (like eth0)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">simeth_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">simeth_device</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;simeth=&quot;</span><span class="p">,</span> <span class="n">simeth_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function used to probe for simeth devices when not installed</span>
<span class="cm"> * as a loadable module</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">simeth_probe</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;simeth: v%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">simeth_version</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">simeth_probe1</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simeth_dev_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">netdev_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ether</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ia64_ssc</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ether</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">SSC_NETDEV_PROBE</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">netdev_attach</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this puts the host interface in the right mode (start interrupting) */</span>
	<span class="k">return</span> <span class="n">ia64_ssc</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ipaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">SSC_NETDEV_ATTACH</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">netdev_detach</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * inactivate the host interface (don&#39;t interrupt anymore) */</span>
	<span class="k">return</span> <span class="n">ia64_ssc</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">SSC_NETDEV_DETACH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">netdev_send</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ia64_ssc</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SSC_NETDEV_SEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">netdev_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ia64_ssc</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SSC_NETDEV_RECV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">simeth_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">simeth_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">simeth_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">simeth_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">simeth_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">set_multicast_list</span><span class="p">,</span> <span class="cm">/* not yet used */</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function shared with module code, so cannot be in init section</span>
<span class="cm"> *</span>
<span class="cm"> * So far this function &quot;detects&quot; only one card (test_&amp;_set) but could</span>
<span class="cm"> * be extended easily.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> * 	- -ENODEV is no device found</span>
<span class="cm"> *	- -ENOMEM is no more memory</span>
<span class="cm"> *	- 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_probe1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">simeth_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Fix me</span>
<span class="cm">	 * let&#39;s support just one card for now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check with the simulator for the device</span>
<span class="cm">	 */</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">netdev_probe</span><span class="p">(</span><span class="n">simeth_device</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">simeth_local</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">));</span>

	<span class="n">local</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* keep track of underlying file descriptor */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simeth_netdev_ops</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * attach the interrupt in the simulator, this does enable interrupts</span>
<span class="cm">	 * until a netdev_attach() is called</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">hpsim_get_irq</span><span class="p">(</span><span class="n">NETWORK_INTR</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: out of interrupt vectors!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: hosteth=%s simfd=%d, HwAddr=%pm, IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">simeth_device</span><span class="p">,</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * actually binds the device to an interrupt vector</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">simeth_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;simeth&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;simeth: unable to get IRQ %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* copied from lapbether.c */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">dev_is_ethdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="p">(</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_ETHER</span> <span class="o">&amp;&amp;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;dummy&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handler for IFF_UP or IFF_DOWN</span>
<span class="cm"> *</span>
<span class="cm"> * The reason for that is that we don&#39;t want to be interrupted when the</span>
<span class="cm"> * interface is down. There is no way to unconnect in the simualtor. Instead</span>
<span class="cm"> * we use this function to shutdown packet processing in the frame filter</span>
<span class="cm"> * in the simulator. Thus no interrupts are generated</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * That&#39;s also the place where we pass the IP address of this device to the</span>
<span class="cm"> * simulator so that that we can start filtering packets for it</span>
<span class="cm"> *</span>
<span class="cm"> * There may be a better way of doing this, but I don&#39;t know which yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_device_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">simeth_local</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">**</span><span class="n">ifap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="n">ifa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">dev</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;simeth_device_event dev=0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">event</span> <span class="o">!=</span> <span class="n">NETDEV_UP</span> <span class="o">&amp;&amp;</span> <span class="n">event</span> <span class="o">!=</span> <span class="n">NETDEV_DOWN</span> <span class="p">)</span> <span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether or not it&#39;s for an ethernet device</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX Fixme: This works only as long as we support one</span>
<span class="cm">	 * type of ethernet device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">dev_is_ethdev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">in_dev</span><span class="o">=</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ip_ptr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ifap</span><span class="o">=&amp;</span><span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">ifa_list</span><span class="p">;</span> <span class="p">(</span><span class="n">ifa</span><span class="o">=*</span><span class="n">ifap</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ifap</span><span class="o">=&amp;</span><span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_next</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_label</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">ifa</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;simeth_open: can&#39;t find device %s&#39;s ifa</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;simeth_device_event: %s ipaddr=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_local</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX Fix me</span>
<span class="cm">	 * if the device was up, and we&#39;re simply reconfiguring it, not sure</span>
<span class="cm">	 * we get DOWN then UP.</span>
<span class="cm">	 */</span>

	<span class="n">local</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* now do it for real */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_UP</span> <span class="o">?</span>
		<span class="n">netdev_attach</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_local</span><span class="p">))</span><span class="o">:</span>
		<span class="n">netdev_detach</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;simeth: netdev_attach/detach: event=%s -&gt;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_UP</span> <span class="o">?</span> <span class="s">&quot;attach&quot;</span><span class="o">:</span><span class="s">&quot;detach&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Only used for debug</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">frame_print</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: (%d) %02x&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;:%02x&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %2x&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;:%02x&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; [%02x%02x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">frame</span><span class="p">[</span><span class="mi">13</span><span class="p">]);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">14</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">10</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function used to transmit of frame, very last one on the path before</span>
<span class="cm"> * going to the simulator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">simeth_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* ensure we have at least ETH_ZLEN bytes (min frame size) */</span>
<span class="c">	unsigned int length = ETH_ZLEN &lt; skb-&gt;len ? skb-&gt;len : ETH_ZLEN;</span>
<span class="c">	/* Where do the extra padding bytes comes from inthe skbuff ? */</span>
<span class="cp">#else</span>
	<span class="cm">/* the real driver in the host system is going to take care of that</span>
<span class="cm">	 * or maybe it&#39;s the NIC itself.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">simeth_debug</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="n">frame_print</span><span class="p">(</span><span class="s">&quot;simeth_tx&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">netdev_send</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we are synchronous on write, so we don&#39;t simulate a</span>
<span class="cm">	 * trasnmit complete interrupt, thus we don&#39;t need to arm a tx</span>
<span class="cm">	 */</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span>
<span class="nf">make_new_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The +2 is used to make sure that the IP header is nicely</span>
<span class="cm">	 * aligned (on 4byte boundary I assume 14+2=16)</span>
<span class="cm">	 */</span>
	<span class="n">nskb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">SIMETH_FRAME_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">nskb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: memory squeeze. dropping packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Align IP on 16 byte boundaries */</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span><span class="n">SIMETH_FRAME_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nskb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called from interrupt handler to process a received frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">simeth_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">simeth_local</span>	<span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rcv_count</span> <span class="o">=</span> <span class="n">SIMETH_RECV_MAX</span><span class="p">;</span>

	<span class="n">local</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * the loop concept has been borrowed from other drivers</span>
<span class="cm">	 * looks to me like it&#39;s a throttling thing to avoid pushing to many</span>
<span class="cm">	 * packets at one time into the stack. Making sure we can process them</span>
<span class="cm">	 * upstream and make forward progress overall</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">skb</span><span class="o">=</span><span class="n">make_new_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: memory squeeze. dropping packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read only one frame at a time</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">netdev_read</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">simfd</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">SIMETH_FRAME_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">simeth_debug</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: count=%d netdev_read=0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">SIMETH_RECV_MAX</span><span class="o">-</span><span class="n">rcv_count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/*</span>
<span class="c">		 * XXX Fix me</span>
<span class="c">		 * Should really do a csum+copy here</span>
<span class="c">		 */</span>
<span class="c">		skb_copy_to_linear_data(skb, frame, len);</span>
<span class="cp">#endif</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">simeth_debug</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="p">)</span> <span class="n">frame_print</span><span class="p">(</span><span class="s">&quot;simeth_rx&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * push the packet up &amp; trigger software interrupt</span>
<span class="cm">		 */</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="o">--</span><span class="n">rcv_count</span> <span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* 0 = nothing left to read, otherwise, we can try again */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler (Yes, we can do it too !!!)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">simeth_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * very simple loop because we get interrupts only when receiving</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">simeth_rx</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span>
<span class="nf">simeth_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">simeth_local</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fake multicast ability */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: set_multicast_list called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">simeth_probe</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
