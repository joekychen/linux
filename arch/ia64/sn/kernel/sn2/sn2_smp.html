<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › kernel › sn2 › sn2_smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sn2_smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SN2 Platform specific SMP Support</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000-2006 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_cpuid.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shub_mmr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/nodepda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/rw_mmr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_feature_sets.h&gt;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span><span class="p">,</span> <span class="n">ptcstats</span><span class="p">);</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span><span class="p">,</span> <span class="n">ptcstats</span><span class="p">);</span>

<span class="k">static</span>  <span class="n">__cacheline_aligned</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sn2_global_ptc_lock</span><span class="p">);</span>

<span class="cm">/* 0 = old algorithm (no IPI flushes), 1 = ipi deadlock flush, 2 = ipi instead of SHUB ptc, &gt;2 = always ipi */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sn2_flush_opt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">sn2_ptc_deadlock_recovery_core</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			       <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			       <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span>
<span class="n">sn2_ptc_deadlock_recovery</span><span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Note: some is the following is captured here to make degugging easier</span>
<span class="cm"> * (the macros make more sense if you see the debug patch - not posted)</span>
<span class="cm"> */</span>
<span class="cp">#define sn2_ptctest	0</span>
<span class="cp">#define local_node_uses_ptc_ga(sh1)	((sh1) ? 1 : 0)</span>
<span class="cp">#define max_active_pio(sh1)		((sh1) ? 32 : 7)</span>
<span class="cp">#define reset_max_active_on_deadlock()	1</span>
<span class="cp">#define PTC_LOCK(sh1)			((sh1) ? &amp;sn2_global_ptc_lock : &amp;sn_nodepda-&gt;ptc_lock)</span>

<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptc_l</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">change_rid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_ptc_flushes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nodes_flushed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadlocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadlocks2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_itc_clocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_itc_clocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_itc_clocks_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_ptc_flushes_not_my_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_ipi_flushes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shub_ipi_flushes_itc_clocks</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define sn2_ptctest	0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">wait_piowc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">piows</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zeroval</span><span class="p">,</span> <span class="n">ws</span><span class="p">;</span>

	<span class="n">piows</span> <span class="o">=</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_addr</span><span class="p">;</span>
	<span class="n">zeroval</span> <span class="o">=</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_val</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(((</span><span class="n">ws</span> <span class="o">=</span> <span class="o">*</span><span class="n">piows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SH_PIO_WRITE_STATUS_PENDING_WRITE_COUNT_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zeroval</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&amp;</span> <span class="n">SH_PIO_WRITE_STATUS_WRITE_DEADLOCK_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_migrate - SN-specific task migration actions</span>
<span class="cm"> * @task: Task being migrated to new CPU</span>
<span class="cm"> *</span>
<span class="cm"> * SN2 PIO writes from separate CPUs are not guaranteed to arrive in order.</span>
<span class="cm"> * Context switching user threads which have memory-mapped MMIO may cause</span>
<span class="cm"> * PIOs to issue from separate CPUs, thus the PIO writes must be drained</span>
<span class="cm"> * from the previous CPU&#39;s Shub before execution resumes on the new CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sn_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pda_t</span> <span class="o">*</span><span class="n">last_pda</span> <span class="o">=</span> <span class="n">pdacpu</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_cpu</span><span class="p">);</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">adr</span> <span class="o">=</span> <span class="n">last_pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">last_pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_val</span><span class="p">;</span>

	<span class="cm">/* Drain PIO writes from old CPU&#39;s Shub */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="o">*</span><span class="n">adr</span> <span class="o">&amp;</span> <span class="n">SH_PIO_WRITE_STATUS_PENDING_WRITE_COUNT_MASK</span><span class="p">)</span>
			<span class="o">!=</span> <span class="n">val</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_tlb_migrate_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* flush_tlb_mm is inefficient if more than 1 users of mm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn2_ipi_flush_all_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itc</span><span class="p">;</span>

	<span class="n">itc</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
	<span class="n">smp_flush_tlb_cpumask</span><span class="p">(</span><span class="o">*</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
	<span class="n">itc</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">-</span> <span class="n">itc</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_ipi_flushes_itc_clocks</span> <span class="o">+=</span> <span class="n">itc</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_ipi_flushes</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn2_global_tlb_purge - globally purge translation cache of virtual address range</span>
<span class="cm"> * @mm: mm_struct containing virtual address range</span>
<span class="cm"> * @start: start of virtual address range</span>
<span class="cm"> * @end: end of virtual address range</span>
<span class="cm"> * @nbits: specifies number of bytes to purge per instruction (num = 1&lt;&lt;(nbits &amp; 0xfc))</span>
<span class="cm"> *</span>
<span class="cm"> * Purges the translation caches of all processors of the given virtual address</span>
<span class="cm"> * range.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> * 	- cpu_vm_mask is a bit mask that indicates which cpus have loaded the context.</span>
<span class="cm"> * 	- cpu_vm_mask is converted into a nodemask of the nodes containing the</span>
<span class="cm"> * 	  cpus in cpu_vm_mask.</span>
<span class="cm"> *	- if only one bit is set in cpu_vm_mask &amp; it is the current cpu &amp; the</span>
<span class="cm"> *	  process is purging its own virtual address range, then only the</span>
<span class="cm"> *	  local TLB needs to be flushed. This flushing can be done using</span>
<span class="cm"> *	  ptc.l. This is the common case &amp; avoids the global spinlock.</span>
<span class="cm"> *	- if multiple cpus have loaded the context, then flushing has to be</span>
<span class="cm"> *	  done with ptc.g/MMRs under protection of the global ptc_lock.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">sn2_global_tlb_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ibegin</span><span class="p">,</span> <span class="n">shub1</span><span class="p">,</span> <span class="n">cnode</span><span class="p">,</span> <span class="n">mynasid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">lcpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mymm</span> <span class="o">=</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">&amp;&amp;</span> <span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">use_cpu_ptcga</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptc0</span><span class="p">,</span> <span class="o">*</span><span class="n">ptc1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itc</span><span class="p">,</span> <span class="n">itc2</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rr_value</span><span class="p">,</span> <span class="n">old_rr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">nasids</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">],</span> <span class="n">nix</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="n">nodes_flushed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">,</span> <span class="n">max_active</span><span class="p">,</span> <span class="n">deadlock</span><span class="p">,</span> <span class="n">flush_opt</span> <span class="o">=</span> <span class="n">sn2_flush_opt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_opt</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn2_ipi_flush_all_tlb</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">nodes_flushed</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="n">node_set</span><span class="p">(</span><span class="n">cnode</span><span class="p">,</span> <span class="n">nodes_flushed</span><span class="p">);</span>
		<span class="n">lcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">lcpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">mymm</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ia64_ptcl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">ia64_srlz_i</span><span class="p">();</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">ptc_l</span><span class="o">++</span><span class="p">;</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mymm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">change_rid</span><span class="o">++</span><span class="p">;</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_opt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn2_ipi_flush_all_tlb</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">itc</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
	<span class="n">nix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">cnode</span><span class="p">,</span> <span class="n">nodes_flushed</span><span class="p">)</span>
		<span class="n">nasids</span><span class="p">[</span><span class="n">nix</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnodeid_to_nasid</span><span class="p">(</span><span class="n">cnode</span><span class="p">);</span>

	<span class="n">rr_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">REGION_NUMBER</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="n">shub1</span> <span class="o">=</span> <span class="n">is_shub1</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shub1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH1_PTC_0_A_SHFT</span><span class="p">)</span> <span class="o">|</span>
		    	<span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="n">SH1_PTC_0_PS_SHFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">rr_value</span> <span class="o">&lt;&lt;</span> <span class="n">SH1_PTC_0_RID_SHFT</span><span class="p">)</span> <span class="o">|</span>
		    	<span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH1_PTC_0_START_SHFT</span><span class="p">);</span>
		<span class="n">ptc0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_PHYS_ADDR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SH1_PTC_0</span><span class="p">);</span>
		<span class="n">ptc1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_PHYS_ADDR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SH1_PTC_1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH2_PTC_A_SHFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="n">SH2_PTC_PS_SHFT</span><span class="p">)</span> <span class="o">|</span>
		    	<span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH2_PTC_START_SHFT</span><span class="p">);</span>
		<span class="n">ptc0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_PHYS_ADDR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SH2_PTC</span> <span class="o">+</span> 
			<span class="p">(</span><span class="n">rr_value</span> <span class="o">&lt;&lt;</span> <span class="n">SH2_PTC_RID_SHFT</span><span class="p">));</span>
		<span class="n">ptc1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	

	<span class="n">mynasid</span> <span class="o">=</span> <span class="n">get_nasid</span><span class="p">();</span>
	<span class="n">use_cpu_ptcga</span> <span class="o">=</span> <span class="n">local_node_uses_ptc_ga</span><span class="p">(</span><span class="n">shub1</span><span class="p">);</span>
	<span class="n">max_active</span> <span class="o">=</span> <span class="n">max_active_pio</span><span class="p">(</span><span class="n">shub1</span><span class="p">);</span>

	<span class="n">itc</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">PTC_LOCK</span><span class="p">(</span><span class="n">shub1</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">itc2</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">();</span>

	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">lock_itc_clocks</span> <span class="o">+=</span> <span class="n">itc2</span> <span class="o">-</span> <span class="n">itc</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_ptc_flushes</span><span class="o">++</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">nodes_flushed</span> <span class="o">+=</span> <span class="n">nix</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mymm</span><span class="p">)</span>
		 <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_ptc_flushes_not_my_mm</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_cpu_ptcga</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mymm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_rr</span> <span class="o">=</span> <span class="n">ia64_get_rr</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">old_rr</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rr_value</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">wait_piowc</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shub1</span><span class="p">)</span>
			<span class="n">data1</span> <span class="o">=</span> <span class="n">start</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH1_PTC_1_START_SHFT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">data0</span> <span class="o">=</span> <span class="p">(</span><span class="n">data0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SH2_PTC_ADDR_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">SH2_PTC_ADDR_MASK</span><span class="p">);</span>
		<span class="n">deadlock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ibegin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nix</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nasid</span> <span class="o">=</span> <span class="n">nasids</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">use_cpu_ptcga</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">nasid</span> <span class="o">==</span> <span class="n">mynasid</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ia64_ptcga</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">ia64_srlz_i</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ptc0</span> <span class="o">=</span> <span class="n">CHANGE_NASID</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">ptc0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ptc1</span><span class="p">)</span>
					<span class="n">ptc1</span> <span class="o">=</span> <span class="n">CHANGE_NASID</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">ptc1</span><span class="p">);</span>
				<span class="n">pio_atomic_phys_write_mmrs</span><span class="p">(</span><span class="n">ptc0</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">ptc1</span><span class="p">,</span> <span class="n">data1</span><span class="p">);</span>
				<span class="n">active</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="n">max_active</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">nix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">deadlock</span> <span class="o">=</span> <span class="n">wait_piowc</span><span class="p">()))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">flush_opt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
					<span class="n">sn2_ptc_deadlock_recovery</span><span class="p">(</span><span class="n">nasids</span><span class="p">,</span> <span class="n">ibegin</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mynasid</span><span class="p">,</span> <span class="n">ptc0</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">ptc1</span><span class="p">,</span> <span class="n">data1</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">reset_max_active_on_deadlock</span><span class="p">())</span>
						<span class="n">max_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ibegin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">nbits</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">itc2</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">-</span> <span class="n">itc2</span><span class="p">;</span>
	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_itc_clocks</span> <span class="o">+=</span> <span class="n">itc2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">itc2</span> <span class="o">&gt;</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_itc_clocks_max</span><span class="p">)</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">shub_itc_clocks_max</span> <span class="o">=</span> <span class="n">itc2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_rr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ia64_set_rr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">old_rr</span><span class="p">);</span>
		<span class="n">ia64_srlz_d</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">PTC_LOCK</span><span class="p">(</span><span class="n">shub1</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_opt</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">deadlock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">deadlocks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sn2_ipi_flush_all_tlb</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn2_ptc_deadlock_recovery</span>
<span class="cm"> *</span>
<span class="cm"> * Recover from PTC deadlocks conditions. Recovery requires stepping thru each </span>
<span class="cm"> * TLB flush transaction.  The recovery sequence is somewhat tricky &amp; is</span>
<span class="cm"> * coded in assembly language.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">sn2_ptc_deadlock_recovery</span><span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="n">nasids</span><span class="p">,</span> <span class="kt">short</span> <span class="n">ib</span><span class="p">,</span> <span class="kt">short</span> <span class="n">ie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mynasid</span><span class="p">,</span>
			  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptc0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data0</span><span class="p">,</span>
			  <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptc1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">piows</span><span class="p">,</span> <span class="n">zeroval</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">deadlocks</span><span class="o">++</span><span class="p">;</span>

	<span class="n">piows</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_addr</span><span class="p">;</span>
	<span class="n">zeroval</span> <span class="o">=</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_val</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ib</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ie</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nasid</span> <span class="o">=</span> <span class="n">nasids</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_node_uses_ptc_ga</span><span class="p">(</span><span class="n">is_shub1</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nasid</span> <span class="o">==</span> <span class="n">mynasid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ptc0</span> <span class="o">=</span> <span class="n">CHANGE_NASID</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">ptc0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptc1</span><span class="p">)</span>
			<span class="n">ptc1</span> <span class="o">=</span> <span class="n">CHANGE_NASID</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">ptc1</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">sn2_ptc_deadlock_recovery_core</span><span class="p">(</span><span class="n">ptc0</span><span class="p">,</span> <span class="n">data0</span><span class="p">,</span> <span class="n">ptc1</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">piows</span><span class="p">,</span> <span class="n">zeroval</span><span class="p">);</span>
		<span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">).</span><span class="n">deadlocks2</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_send_IPI_phys - send an IPI to a Nasid and slice</span>
<span class="cm"> * @nasid: nasid to receive the interrupt (may be outside partition)</span>
<span class="cm"> * @physid: physical cpuid to receive the interrupt.</span>
<span class="cm"> * @vector: command to send</span>
<span class="cm"> * @delivery_mode: delivery mechanism</span>
<span class="cm"> *</span>
<span class="cm"> * Sends an IPI (interprocessor interrupt) to the processor specified by</span>
<span class="cm"> * @physid</span>
<span class="cm"> *</span>
<span class="cm"> * @delivery_mode can be one of the following</span>
<span class="cm"> *</span>
<span class="cm"> * %IA64_IPI_DM_INT - pend an interrupt</span>
<span class="cm"> * %IA64_IPI_DM_PMI - pend a PMI</span>
<span class="cm"> * %IA64_IPI_DM_NMI - pend an NMI</span>
<span class="cm"> * %IA64_IPI_DM_INIT - pend an INIT interrupt</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sn_send_IPI_phys</span><span class="p">(</span><span class="kt">int</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">long</span> <span class="n">physid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delivery_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_PHYS_ADDR</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">SH_IPI_INT</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SH_IPI_INT_SEND_SHFT</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">(</span><span class="n">physid</span> <span class="o">&lt;&lt;</span> <span class="n">SH_IPI_INT_PID_SHFT</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">delivery_mode</span> <span class="o">&lt;&lt;</span> <span class="n">SH_IPI_INT_TYPE_SHFT</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">vector</span> <span class="o">&lt;&lt;</span> <span class="n">SH_IPI_INT_IDX_SHFT</span><span class="p">)</span> <span class="o">|</span>
	    <span class="p">(</span><span class="mh">0x000feeUL</span> <span class="o">&lt;&lt;</span> <span class="n">SH_IPI_INT_BASE_SHFT</span><span class="p">);</span>

	<span class="n">mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_shub_wars_1_1</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn2_global_ptc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pio_phys_write_mmr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_shub_wars_1_1</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">wait_piowc</span><span class="p">();</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn2_global_ptc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_send_IPI_phys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sn2_send_IPI - send an IPI to a processor</span>
<span class="cm"> * @cpuid: target of the IPI</span>
<span class="cm"> * @vector: command to send</span>
<span class="cm"> * @delivery_mode: delivery mechanism</span>
<span class="cm"> * @redirect: redirect the IPI?</span>
<span class="cm"> *</span>
<span class="cm"> * Sends an IPI (InterProcessor Interrupt) to the processor specified by</span>
<span class="cm"> * @cpuid.  @vector specifies the command to send, while @delivery_mode can </span>
<span class="cm"> * be one of the following</span>
<span class="cm"> *</span>
<span class="cm"> * %IA64_IPI_DM_INT - pend an interrupt</span>
<span class="cm"> * %IA64_IPI_DM_PMI - pend a PMI</span>
<span class="cm"> * %IA64_IPI_DM_NMI - pend an NMI</span>
<span class="cm"> * %IA64_IPI_DM_INIT - pend an INIT interrupt</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sn2_send_IPI</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpuid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delivery_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">redirect</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">physid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nasid</span><span class="p">;</span>

	<span class="n">physid</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>
	<span class="n">nasid</span> <span class="o">=</span> <span class="n">cpuid_to_nasid</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="cm">/* the following is used only when starting cpus at boot time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nasid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">ia64_sn_get_sapic_info</span><span class="p">(</span><span class="n">physid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nasid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">sn_send_IPI_phys</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">physid</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">delivery_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cm">/**</span>
<span class="cm"> * sn_cpu_disable_allowed - Determine if a CPU can be disabled.</span>
<span class="cm"> * @cpu - CPU that is requested to be disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * CPU disable is only allowed on SHub2 systems running with a PROM</span>
<span class="cm"> * that supports CPU disable. It is not permitted to disable the boot processor.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">sn_cpu_disable_allowed</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub2</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">sn_prom_feature_available</span><span class="p">(</span><span class="n">PRF_CPU_DISABLE_SUPPORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			      <span class="s">&quot;Disabling the boot processor is not allowed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;CPU disable is not supported on this system.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="cp">#define PTC_BASENAME	&quot;sgi_sn/ptc_statistics&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sn2_ptc_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sn2_ptc_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn2_ptc_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn2_ptc_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ptc_stats</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			   <span class="s">&quot;# cpu ptc_l newrid ptc_flushes nodes_flushed deadlocks lock_nsec shub_nsec shub_nsec_max not_my_mm deadlock2 ipi_fluches ipi_nsec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;# ptctest %d, flushopt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sn2_ptctest</span><span class="p">,</span> <span class="n">sn2_flush_opt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;cpu %d %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">ptc_l</span><span class="p">,</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">change_rid</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_ptc_flushes</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">nodes_flushed</span><span class="p">,</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">deadlocks</span><span class="p">,</span>
				<span class="mi">1000</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">lock_itc_clocks</span> <span class="o">/</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">cyc_per_usec</span><span class="p">,</span>
				<span class="mi">1000</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_itc_clocks</span> <span class="o">/</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">cyc_per_usec</span><span class="p">,</span>
				<span class="mi">1000</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_itc_clocks_max</span> <span class="o">/</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">cyc_per_usec</span><span class="p">,</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_ptc_flushes_not_my_mm</span><span class="p">,</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">deadlocks2</span><span class="p">,</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_ipi_flushes</span><span class="p">,</span>
				<span class="mi">1000</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">shub_ipi_flushes_itc_clocks</span> <span class="o">/</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">ia64_cpu_info</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">cyc_per_usec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sn2_ptc_proc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">optstr</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">optstr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">optstr</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">optstr</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">sn2_flush_opt</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">optstr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">ptcstats</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ptc_stats</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">sn2_ptc_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">sn2_ptc_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sn2_ptc_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">sn2_ptc_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">sn2_ptc_seq_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn2_ptc_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn2_ptc_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_sn2_ptc_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sn2_ptc_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sn2_ptc_proc_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_sn2_ptc</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sn2_ptc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">proc_sn2_ptc</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="n">PTC_BASENAME</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
				   <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_sn2_ptc_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_sn2_ptc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to create %s proc entry&quot;</span><span class="p">,</span> <span class="n">PTC_BASENAME</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn2_global_ptc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sn2_ptc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">PTC_BASENAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sn2_ptc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sn2_ptc_exit</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
