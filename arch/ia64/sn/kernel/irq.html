<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › kernel › irq.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>irq.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Platform dependent support for SGI SN</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2008 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;</span>
<span class="cp">#include &lt;asm/sn/intr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibr_provider.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibus_provider_defs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcidev.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shub_mmr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_feature_sets.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">register_intr_pda</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">unregister_intr_pda</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sn_ioif_inited</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="o">**</span><span class="n">sn_irq_lh</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sn_irq_info_lock</span><span class="p">);</span> <span class="cm">/* non-IRQ lock */</span>

<span class="n">u64</span> <span class="nf">sn_intr_alloc</span><span class="p">(</span><span class="n">nasid_t</span> <span class="n">local_nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local_widget</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">req_irq</span><span class="p">,</span> <span class="n">nasid_t</span> <span class="n">req_nasid</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">req_slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_INTERRUPT</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SAL_INTR_ALLOC</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_nasid</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_widget</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">),</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">req_irq</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">req_nasid</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">req_slice</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_intr_free</span><span class="p">(</span><span class="n">nasid_t</span> <span class="n">local_nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local_widget</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_INTERRUPT</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SAL_INTR_FREE</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_nasid</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_widget</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">sn_intr_redirect</span><span class="p">(</span><span class="n">nasid_t</span> <span class="n">local_nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local_widget</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">,</span>
		      <span class="n">nasid_t</span> <span class="n">req_nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req_slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_INTERRUPT</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SAL_INTR_REDIRECT</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_nasid</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">local_widget</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">req_nasid</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">req_slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sn_startup_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_shutdown_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ia64_mca_register_cpev</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">local_vector_to_irq</span><span class="p">(</span><span class="n">IA64_CPE_VECTOR</span><span class="p">))</span>
		<span class="n">ia64_mca_register_cpev</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">local_vector_to_irq</span><span class="p">(</span><span class="n">IA64_CPE_VECTOR</span><span class="p">))</span>
		<span class="n">ia64_mca_register_cpev</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_ack_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">event_occurred</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">event_occurred</span> <span class="o">=</span> <span class="n">HUB_L</span><span class="p">((</span><span class="n">u64</span><span class="o">*</span><span class="p">)</span><span class="n">LOCAL_MMR_ADDR</span><span class="p">(</span><span class="n">SH_EVENT_OCCURRED</span><span class="p">));</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">event_occurred</span> <span class="o">&amp;</span> <span class="n">SH_ALL_INT_MASK</span><span class="p">;</span>
	<span class="n">HUB_S</span><span class="p">((</span><span class="n">u64</span><span class="o">*</span><span class="p">)</span><span class="n">LOCAL_MMR_ADDR</span><span class="p">(</span><span class="n">SH_EVENT_OCCURRED_ALIAS</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pda</span><span class="o">-&gt;</span><span class="n">sn_in_service_ivecs</span><span class="p">);</span>

	<span class="n">irq_move_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="nf">sn_retarget_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">,</span>
				       <span class="n">nasid_t</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpuid</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpuphys</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int64_t</span> <span class="n">bridge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">local_widget</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">nasid_t</span> <span class="n">local_nasid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">new_irq_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">pci_provider</span><span class="p">;</span>

	<span class="n">bridge</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bridge</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* irq is not a device interrupt */</span>
	<span class="p">}</span>

	<span class="n">local_nasid</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local_nasid</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">local_widget</span> <span class="o">=</span> <span class="n">TIO_SWIN_WIDGETNUM</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">local_widget</span> <span class="o">=</span> <span class="n">SWIN_WIDGETNUM</span><span class="p">(</span><span class="n">bridge</span><span class="p">);</span>
	<span class="n">vector</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">;</span>

	<span class="cm">/* Make use of SAL_INTR_REDIRECT if PROM supports it */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sn_intr_redirect</span><span class="p">(</span><span class="n">local_nasid</span><span class="p">,</span> <span class="n">local_widget</span><span class="p">,</span> <span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_irq_info</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PROM does not support SAL_INTR_REDIRECT, or it failed.</span>
<span class="cm">	 * Revert to old method.</span>
<span class="cm">	 */</span>
	<span class="n">new_irq_info</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span><span class="p">),</span>
			       <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_irq_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Free the old PROM new_irq_info structure */</span>
	<span class="n">sn_intr_free</span><span class="p">(</span><span class="n">local_nasid</span><span class="p">,</span> <span class="n">local_widget</span><span class="p">,</span> <span class="n">new_irq_info</span><span class="p">);</span>
	<span class="n">unregister_intr_pda</span><span class="p">(</span><span class="n">new_irq_info</span><span class="p">);</span>

	<span class="cm">/* allocate a new PROM new_irq_info struct */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">sn_intr_alloc</span><span class="p">(</span><span class="n">local_nasid</span><span class="p">,</span> <span class="n">local_widget</span><span class="p">,</span>
			       <span class="n">new_irq_info</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span>
			       <span class="n">nasid</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>

	<span class="cm">/* SAL call failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_irq_info</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_intr_pda</span><span class="p">(</span><span class="n">new_irq_info</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>
	<span class="n">list_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>


<span class="nl">finish_up:</span>
	<span class="cm">/* Update kernels new_irq_info with new target info */</span>
	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">nasid_slice_to_cpuid</span><span class="p">(</span><span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">irq_nasid</span><span class="p">,</span>
				     <span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">irq_slice</span><span class="p">);</span>
	<span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">;</span>

	<span class="n">pci_provider</span> <span class="o">=</span> <span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge_type</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this represents a line interrupt, target it.  If it&#39;s</span>
<span class="cm">	 * an msi (irq_int_bit &lt; 0), it&#39;s already targeted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pci_provider</span> <span class="o">&amp;&amp;</span> <span class="n">pci_provider</span><span class="o">-&gt;</span><span class="n">target_interrupt</span><span class="p">)</span>
		<span class="p">(</span><span class="n">pci_provider</span><span class="o">-&gt;</span><span class="n">target_interrupt</span><span class="p">)(</span><span class="n">new_irq_info</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">cpuphys</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>
	<span class="n">set_irq_affinity_info</span><span class="p">((</span><span class="n">vector</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span> <span class="n">cpuphys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">new_irq_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_set_affinity_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="o">*</span><span class="n">sn_irq_info_safe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">nasid_t</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slice</span><span class="p">;</span>

	<span class="n">nasid</span> <span class="o">=</span> <span class="n">cpuid_to_nasid</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
	<span class="n">slice</span> <span class="o">=</span> <span class="n">cpuid_to_slice</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">sn_irq_info_safe</span><span class="p">,</span>
				 <span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">irq</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sn_retarget_vector</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="nf">sn_set_err_irq_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/*</span>
<span class="cm">         * On systems which support CPU disabling (SHub2), all error interrupts</span>
<span class="cm">         * are targeted at the boot CPU.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_shub2</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">sn_prom_feature_available</span><span class="p">(</span><span class="n">PRF_CPU_DISABLE_SUPPORT</span><span class="p">))</span>
                <span class="n">set_irq_affinity_info</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="nf">sn_set_err_irq_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_mask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_unmask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">irq_type_sn</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;SN hub&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_startup</span>		<span class="o">=</span> <span class="n">sn_startup_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_shutdown</span>		<span class="o">=</span> <span class="n">sn_shutdown_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_enable</span>		<span class="o">=</span> <span class="n">sn_enable_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_disable</span>		<span class="o">=</span> <span class="n">sn_disable_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">sn_ack_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">sn_mask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">sn_unmask_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">sn_set_affinity_irq</span>
<span class="p">};</span>

<span class="n">ia64_vector</span> <span class="nf">sn_irq_to_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">IA64_NUM_VECTORS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ia64_vector</span><span class="p">)</span><span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sn_local_vector_to_irq</span><span class="p">(</span><span class="n">u8</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">CPU_VECTOR_TO_IRQ</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">vector</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_irq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ia64_first_device_vector</span> <span class="o">=</span> <span class="n">IA64_SN2_FIRST_DEVICE_VECTOR</span><span class="p">;</span>
	<span class="n">ia64_last_device_vector</span> <span class="o">=</span> <span class="n">IA64_SN2_LAST_DEVICE_VECTOR</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_get_chip</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">no_irq_chip</span><span class="p">)</span>
			<span class="n">irq_set_chip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_type_sn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">register_intr_pda</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span> <span class="o">&lt;</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">&gt;</span> <span class="n">irq</span><span class="p">)</span>
		<span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_intr_pda</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">tmp_irq_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">foundmatch</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span> <span class="o">==</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">foundmatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		     <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">foundmatch</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_irq_info</span><span class="p">,</span>
						<span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">foundmatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">==</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">foundmatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">foundmatch</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_irq_info</span><span class="p">,</span>
						<span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">foundmatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pdacpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">NR_IRQS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_irq_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nasid_t</span> <span class="n">nasid</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_slice</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">nasid_slice_to_cpuid</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">slice</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpuphys</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_cpuid</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_pciioinfo</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/* link it into the sn_irq[irq] list */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">]);</span>
	<span class="n">reserve_irq_vector</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>

	<span class="n">register_intr_pda</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">cpuphys</span> <span class="o">=</span> <span class="n">cpu_physical_id</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">set_irq_affinity_info</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">,</span> <span class="n">cpuphys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Affinity was set by the PROM, prevent it from</span>
<span class="cm">	 * being reset by the request_irq() path.</span>
<span class="cm">	 */</span>
	<span class="n">irqd_mark_affinity_was_set</span><span class="p">(</span><span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_irq_unfixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">;</span>

	<span class="cm">/* Only cleanup IRQ stuff if this device has a host bus context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SN_PCIDEV_BUSSOFT</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sn_irq_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdi_sn_irq_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_irq_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unregister_intr_pda</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_irq_info_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">]))</span>
		<span class="n">free_irq_vector</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">sn_call_force_intr_provider</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">pci_provider</span><span class="p">;</span>

	<span class="n">pci_provider</span> <span class="o">=</span> <span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge_type</span><span class="p">];</span>

	<span class="cm">/* Don&#39;t force an interrupt if the irq has been disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqd_irq_disabled</span><span class="p">(</span><span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pci_provider</span> <span class="o">&amp;&amp;</span> <span class="n">pci_provider</span><span class="o">-&gt;</span><span class="n">force_interrupt</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">pci_provider</span><span class="o">-&gt;</span><span class="n">force_interrupt</span><span class="p">)(</span><span class="n">sn_irq_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for lost interrupts.  If the PIC int_status reg. says that</span>
<span class="cm"> * an interrupt has been sent, but not handled, and the interrupt</span>
<span class="cm"> * is not pending in either the cpu irr regs or in the soft irr regs,</span>
<span class="cm"> * and the interrupt is not in service, then the interrupt may have</span>
<span class="cm"> * been lost.  Force an interrupt on that pin.  It is possible that</span>
<span class="cm"> * the interrupt is in flight, so we may generate a spurious interrupt,</span>
<span class="cm"> * but we should never miss a real lost interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_check_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">regval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcibus_info</span> <span class="o">*</span><span class="n">pcibus_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bridge types attached to TIO (anything but PIC) do not need this WAR</span>
<span class="cm">	 * since they do not target Shub II interrupt registers.  If that</span>
<span class="cm">	 * ever changes, this check needs to accommodate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge_type</span> <span class="o">!=</span> <span class="n">PCIIO_ASIC_TYPE_PIC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pcidev_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_pciioinfo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcidev_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pcibus_info</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">pcibus_info</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_host_pcidev_info</span><span class="o">-&gt;</span>
	    <span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">regval</span> <span class="o">=</span> <span class="n">pcireg_intr_status_get</span><span class="p">(</span><span class="n">pcibus_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_get_irr</span><span class="p">(</span><span class="n">irq_to_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">sn_in_service_ivecs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">regval</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span> <span class="o">&amp;</span> <span class="n">regval</span> <span class="o">&amp;</span>
			    <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_last_intr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span> <span class="o">&amp;</span> <span class="n">regval</span><span class="p">);</span>
				<span class="n">sn_call_force_intr_provider</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_last_intr</span> <span class="o">=</span> <span class="n">regval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_lb_int_war_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_ioif_inited</span> <span class="o">||</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">sn_first_irq</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pda</span><span class="o">-&gt;</span><span class="n">sn_last_irq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">,</span> <span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sn_check_intr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sn_irq_info</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sn_irq_lh_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sn_irq_lh</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">NR_IRQS</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_irq_lh</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SN PCI INIT: Failed to allocate memory for PCI init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_IRQS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SN PCI INIT: Failed IRQ memory allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">sn_irq_lh</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
