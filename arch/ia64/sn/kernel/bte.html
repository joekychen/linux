<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › kernel › bte.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>bte.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2007 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/sn/nodepda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_cpuid.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shubio.h&gt;</span>
<span class="cp">#include &lt;asm/nodedata.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>

<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/sn/bte.h&gt;</span>

<span class="cp">#ifndef L1_CACHE_MASK</span>
<span class="cp">#define L1_CACHE_MASK (L1_CACHE_BYTES - 1)</span>
<span class="cp">#endif</span>

<span class="cm">/* two interfaces on two btes */</span>
<span class="cp">#define MAX_INTERFACES_TO_TRY		4</span>
<span class="cp">#define MAX_NODES_TO_TRY		2</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="o">*</span><span class="nf">bte_if_on_node</span><span class="p">(</span><span class="n">nasid_t</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nodepda_t</span> <span class="o">*</span><span class="n">tmp_nodepda</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tmp_nodepda</span> <span class="o">=</span> <span class="n">NODEPDA</span><span class="p">(</span><span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tmp_nodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">interface</span><span class="p">];</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bte_start_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="o">*</span><span class="n">bte</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub2</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">BTE_CTRL_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="p">(</span><span class="n">IBLS_BUSY</span> <span class="o">|</span> <span class="p">((</span><span class="n">len</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BTE_LNSTAT_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">BTE_CTRL_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> * Block Transfer Engine copy related functions.</span>
<span class="cm"> *</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * bte_copy(src, dest, len, mode, notification)</span>
<span class="cm"> *</span>
<span class="cm"> * Use the block transfer engine to move kernel memory from src to dest</span>
<span class="cm"> * using the assigned mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   src - physical address of the transfer source.</span>
<span class="cm"> *   dest - physical address of the transfer destination.</span>
<span class="cm"> *   len - number of bytes to transfer from source to dest.</span>
<span class="cm"> *   mode - hardware defined.  See reference information</span>
<span class="cm"> *          for IBCT0/1 in the SHUB Programmers Reference</span>
<span class="cm"> *   notification - kernel virtual address of the notification cache</span>
<span class="cm"> *                  line.  If NULL, the default is used and</span>
<span class="cm"> *                  the bte_copy is synchronous.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  This function requires src, dest, and len to</span>
<span class="cm"> * be cacheline aligned.</span>
<span class="cm"> */</span>
<span class="n">bte_result_t</span> <span class="nf">bte_copy</span><span class="p">(</span><span class="n">u64</span> <span class="n">src</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dest</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">notification</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">transfer_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transfer_stat</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">notif_phys_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bteinfo_s</span> <span class="o">*</span><span class="n">bte</span><span class="p">;</span>
	<span class="n">bte_result_t</span> <span class="n">bte_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">itc_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nasid_to_try</span><span class="p">[</span><span class="n">MAX_NODES_TO_TRY</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">my_nasid</span> <span class="o">=</span> <span class="n">cpuid_to_nasid</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="kt">int</span> <span class="n">bte_if_index</span><span class="p">,</span> <span class="n">nasid_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bte_first</span><span class="p">,</span> <span class="n">btes_per_node</span> <span class="o">=</span> <span class="n">BTES_PER_NODE</span><span class="p">;</span>

	<span class="n">BTE_PRINTK</span><span class="p">((</span><span class="s">&quot;bte_copy(0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">notification</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BTE_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">src</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BTE_MAX_XFER</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with interface corresponding to cpu number</span>
<span class="cm">	 */</span>
	<span class="n">bte_first</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">()</span> <span class="o">%</span> <span class="n">btes_per_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">BTE_USE_DEST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* try remote then local */</span>
		<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">BTE_USE_ANY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_nasid</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* try local then remote */</span>
		<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_nasid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">BTE_USE_ANY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nasid_to_try</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">retry_bteop:</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>

		<span class="n">bte_if_index</span> <span class="o">=</span> <span class="n">bte_first</span><span class="p">;</span>
		<span class="n">nasid_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Attempt to lock one of the BTE interfaces. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">nasid_index</span> <span class="o">&lt;</span> <span class="n">MAX_NODES_TO_TRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bte</span> <span class="o">=</span> <span class="n">bte_if_on_node</span><span class="p">(</span><span class="n">nasid_to_try</span><span class="p">[</span><span class="n">nasid_index</span><span class="p">],</span><span class="n">bte_if_index</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nasid_index</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">&amp;</span> <span class="n">BTE_WORD_AVAILABLE</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">BTE_LNSTAT_LOAD</span><span class="p">(</span><span class="n">bte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BTE_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Got the lock but BTE still busy */</span>
					<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* we got the lock and it&#39;s not busy */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">bte_if_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">bte_if_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">btes_per_node</span><span class="p">;</span> <span class="cm">/* Next interface */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bte_if_index</span> <span class="o">==</span> <span class="n">bte_first</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We&#39;ve tried all interfaces on this node</span>
<span class="cm">				 */</span>
				<span class="n">nasid_index</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bte</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">irq_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">BTE_WACQUIRE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">BTEFAIL_NOTAVAIL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notification</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* User does not want to be notified. */</span>
		<span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">=</span> <span class="n">notification</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate the number of cache lines to transfer. */</span>
	<span class="n">transfer_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">L1_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BTE_LEN_MASK</span><span class="p">);</span>

	<span class="cm">/* Initialize the notification to a known value. */</span>
	<span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">=</span> <span class="n">BTE_WORD_BUSY</span><span class="p">;</span>
	<span class="n">notif_phys_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span><span class="p">;</span>

	<span class="cm">/* Set the source and destination registers */</span>
	<span class="n">BTE_PRINTKV</span><span class="p">((</span><span class="s">&quot;IBSA = 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">));</span>
	<span class="n">BTE_SRC_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
	<span class="n">BTE_PRINTKV</span><span class="p">((</span><span class="s">&quot;IBDA = 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">));</span>
	<span class="n">BTE_DEST_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

	<span class="cm">/* Set the notification register */</span>
	<span class="n">BTE_PRINTKV</span><span class="p">((</span><span class="s">&quot;IBNA = 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">notif_phys_addr</span><span class="p">));</span>
	<span class="n">BTE_NOTIF_STORE</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">notif_phys_addr</span><span class="p">);</span>

	<span class="cm">/* Initiate the transfer */</span>
	<span class="n">BTE_PRINTK</span><span class="p">((</span><span class="s">&quot;IBCT = 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">BTE_VALID_MODE</span><span class="p">(</span><span class="n">mode</span><span class="p">)));</span>
	<span class="n">bte_start_transfer</span><span class="p">(</span><span class="n">bte</span><span class="p">,</span> <span class="n">transfer_size</span><span class="p">,</span> <span class="n">BTE_VALID_MODE</span><span class="p">(</span><span class="n">mode</span><span class="p">));</span>

	<span class="n">itc_end</span> <span class="o">=</span> <span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="mi">40000000</span> <span class="o">*</span> <span class="n">local_cpu_data</span><span class="o">-&gt;</span><span class="n">cyc_per_usec</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notification</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BTE_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">transfer_stat</span> <span class="o">=</span> <span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTE_WORD_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_get_itc</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">itc_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BTE_PRINTK</span><span class="p">((</span><span class="s">&quot;BTE timeout nasid 0x%x bte%d IBLS = 0x%lx na 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">NASID_GET</span><span class="p">(</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">bte_base_addr</span><span class="p">),</span> <span class="n">bte</span><span class="o">-&gt;</span><span class="n">bte_num</span><span class="p">,</span>
				<span class="n">BTE_LNSTAT_LOAD</span><span class="p">(</span><span class="n">bte</span><span class="p">),</span> <span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span><span class="p">)</span> <span class="p">);</span>
			<span class="n">bte</span><span class="o">-&gt;</span><span class="n">bte_error_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bte</span><span class="o">-&gt;</span><span class="n">bh_error</span> <span class="o">=</span> <span class="n">IBLS_ERROR</span><span class="p">;</span>
			<span class="n">bte_error_handler</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">NODEPDA</span><span class="p">(</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">bte_cnode</span><span class="p">));</span>
			<span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">=</span> <span class="n">BTE_WORD_AVAILABLE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry_bteop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BTE_PRINTKV</span><span class="p">((</span><span class="s">&quot; Delay Done.  IBLS = 0x%lx, most_rcnt_na = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">BTE_LNSTAT_LOAD</span><span class="p">(</span><span class="n">bte</span><span class="p">),</span> <span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transfer_stat</span> <span class="o">&amp;</span> <span class="n">IBLS_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bte_status</span> <span class="o">=</span> <span class="n">BTE_GET_ERROR_STATUS</span><span class="p">(</span><span class="n">transfer_stat</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bte_status</span> <span class="o">=</span> <span class="n">BTE_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span> <span class="o">=</span> <span class="n">BTE_WORD_AVAILABLE</span><span class="p">;</span>

	<span class="n">BTE_PRINTK</span><span class="p">((</span><span class="s">&quot;Returning status is 0x%lx and most_rcnt_na is 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">BTE_LNSTAT_LOAD</span><span class="p">(</span><span class="n">bte</span><span class="p">),</span> <span class="o">*</span><span class="n">bte</span><span class="o">-&gt;</span><span class="n">most_rcnt_na</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">bte_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bte_copy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * bte_unaligned_copy(src, dest, len, mode)</span>
<span class="cm"> *</span>
<span class="cm"> * use the block transfer engine to move kernel</span>
<span class="cm"> * memory from src to dest using the assigned mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *   src - physical address of the transfer source.</span>
<span class="cm"> *   dest - physical address of the transfer destination.</span>
<span class="cm"> *   len - number of bytes to transfer from source to dest.</span>
<span class="cm"> *   mode - hardware defined.  See reference information</span>
<span class="cm"> *          for IBCT0/1 in the SGI documentation.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: If the source, dest, and len are all cache line aligned,</span>
<span class="cm"> * then it would be _FAR_ preferable to use bte_copy instead.</span>
<span class="cm"> */</span>
<span class="n">bte_result_t</span> <span class="nf">bte_unaligned_copy</span><span class="p">(</span><span class="n">u64</span> <span class="n">src</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dest</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">destFirstCacheOffset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">headBteSource</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">headBteLen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">headBcopySrcOffset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">headBcopyDest</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">headBcopyLen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">footBteSource</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">footBteLen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">footBcopyDest</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">footBcopyLen</span><span class="p">;</span>
	<span class="n">bte_result_t</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bteBlock</span><span class="p">,</span> <span class="o">*</span><span class="n">bteBlock_unaligned</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BTE_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* temporary buffer used during unaligned transfers */</span>
	<span class="n">bteBlock_unaligned</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">L1_CACHE_BYTES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bteBlock_unaligned</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">BTEFAIL_NOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bteBlock</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">L1_CACHE_ALIGN</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">bteBlock_unaligned</span><span class="p">);</span>

	<span class="n">headBcopySrcOffset</span> <span class="o">=</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">;</span>
	<span class="n">destFirstCacheOffset</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, the transfer is broken into</span>
<span class="cm">	 * (up to) three sections.  The first section is</span>
<span class="cm">	 * from the start address to the first physical</span>
<span class="cm">	 * cache line, the second is from the first physical</span>
<span class="cm">	 * cache line to the last complete cache line,</span>
<span class="cm">	 * and the third is from the last cache line to the</span>
<span class="cm">	 * end of the buffer.  The first and third sections</span>
<span class="cm">	 * are handled by bte copying into a temporary buffer</span>
<span class="cm">	 * and then bcopy&#39;ing the necessary section into the</span>
<span class="cm">	 * final location.  The middle section is handled with</span>
<span class="cm">	 * a standard bte copy.</span>
<span class="cm">	 *</span>
<span class="cm">	 * One nasty exception to the above rule is when the</span>
<span class="cm">	 * source and destination are not symmetrically</span>
<span class="cm">	 * mis-aligned.  If the source offset from the first</span>
<span class="cm">	 * cache line is different from the destination offset,</span>
<span class="cm">	 * we make the first section be the entire transfer</span>
<span class="cm">	 * and the bcopy the entire block into place.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">headBcopySrcOffset</span> <span class="o">==</span> <span class="n">destFirstCacheOffset</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Both the source and destination are the same</span>
<span class="cm">		 * distance from a cache line boundary so we can</span>
<span class="cm">		 * use the bte to transfer the bulk of the</span>
<span class="cm">		 * data.</span>
<span class="cm">		 */</span>
		<span class="n">headBteSource</span> <span class="o">=</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">L1_CACHE_MASK</span><span class="p">;</span>
		<span class="n">headBcopyDest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">headBcopySrcOffset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">headBcopyLen</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span>
			     <span class="p">(</span><span class="n">L1_CACHE_BYTES</span> <span class="o">-</span>
			      <span class="n">headBcopySrcOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">L1_CACHE_BYTES</span>
			     <span class="o">-</span> <span class="n">headBcopySrcOffset</span> <span class="o">:</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">headBteLen</span> <span class="o">=</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">headBcopyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">headBteLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">headBcopyLen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">footBcopyLen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">headBcopyLen</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">;</span>
			<span class="n">footBteLen</span> <span class="o">=</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>

			<span class="n">footBteSource</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">footBcopyLen</span><span class="p">;</span>
			<span class="n">footBcopyDest</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">footBcopyLen</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">footBcopyDest</span> <span class="o">==</span> <span class="p">(</span><span class="n">headBcopyDest</span> <span class="o">+</span> <span class="n">headBcopyLen</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We have two contiguous bcopy</span>
<span class="cm">				 * blocks.  Merge them.</span>
<span class="cm">				 */</span>
				<span class="n">headBcopyLen</span> <span class="o">+=</span> <span class="n">footBcopyLen</span><span class="p">;</span>
				<span class="n">headBteLen</span> <span class="o">+=</span> <span class="n">footBteLen</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">footBcopyLen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="n">bte_copy</span><span class="p">(</span><span class="n">footBteSource</span><span class="p">,</span>
					      <span class="n">ia64_tpa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bteBlock</span><span class="p">),</span>
					      <span class="n">footBteLen</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="n">BTE_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">bteBlock_unaligned</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">footBcopyDest</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bteBlock</span><span class="p">,</span> <span class="n">footBcopyLen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">footBcopyLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">footBteLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">headBcopyLen</span> <span class="o">+</span> <span class="n">footBcopyLen</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* now transfer the middle. */</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">bte_copy</span><span class="p">((</span><span class="n">src</span> <span class="o">+</span> <span class="n">headBcopyLen</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">dest</span> <span class="o">+</span>
				       <span class="n">headBcopyLen</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">headBcopyLen</span> <span class="o">-</span>
				       <span class="n">footBcopyLen</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="n">BTE_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">bteBlock_unaligned</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * The transfer is not symmetric, we will</span>
<span class="cm">		 * allocate a buffer large enough for all the</span>
<span class="cm">		 * data, bte_copy into that buffer and then</span>
<span class="cm">		 * bcopy to the destination.</span>
<span class="cm">		 */</span>

		<span class="n">headBcopySrcOffset</span> <span class="o">=</span> <span class="n">src</span> <span class="o">&amp;</span> <span class="n">L1_CACHE_MASK</span><span class="p">;</span>
		<span class="n">headBcopyDest</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
		<span class="n">headBcopyLen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">headBteSource</span> <span class="o">=</span> <span class="n">src</span> <span class="o">-</span> <span class="n">headBcopySrcOffset</span><span class="p">;</span>
		<span class="cm">/* Add the leading and trailing bytes from source */</span>
		<span class="n">headBteLen</span> <span class="o">=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">headBcopySrcOffset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">headBcopyLen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">bte_copy</span><span class="p">(</span><span class="n">headBteSource</span><span class="p">,</span>
			      <span class="n">ia64_tpa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bteBlock</span><span class="p">),</span> <span class="n">headBteLen</span><span class="p">,</span>
			      <span class="n">mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="n">BTE_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bteBlock_unaligned</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">headBcopyDest</span><span class="p">),</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bteBlock</span> <span class="o">+</span>
					     <span class="n">headBcopySrcOffset</span><span class="p">),</span> <span class="n">headBcopyLen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bteBlock_unaligned</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BTE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bte_unaligned_copy</span><span class="p">);</span>

<span class="cm">/************************************************************************</span>
<span class="cm"> * Block Transfer Engine initialization functions.</span>
<span class="cm"> *</span>
<span class="cm"> ***********************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * bte_init_node(nodepda, cnode)</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the nodepda structure with BTE base addresses and</span>
<span class="cm"> * spinlocks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bte_init_node</span><span class="p">(</span><span class="n">nodepda_t</span> <span class="o">*</span> <span class="n">mynodepda</span><span class="p">,</span> <span class="n">cnodeid_t</span> <span class="n">cnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Indicate that all the block transfer engines on this node</span>
<span class="cm">	 * are available.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate one bte_recover_t structure per node.  It holds</span>
<span class="cm">	 * the recovery lock for node.  All the bte interface structures</span>
<span class="cm">	 * will point at this one bte_recover structure to get the lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_recovery_lock</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_recovery_timer</span><span class="p">);</span>
	<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_recovery_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">bte_error_handler</span><span class="p">;</span>
	<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_recovery_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mynodepda</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTES_PER_NODE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>

		<span class="cm">/* Which link status register should we use? */</span>
		<span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">REMOTE_HUB_ADDR</span><span class="p">(</span><span class="n">cnodeid_to_nasid</span><span class="p">(</span><span class="n">cnode</span><span class="p">),</span> <span class="n">BTE_BASE_ADDR</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_base_addr</span> <span class="o">=</span> <span class="n">base_addr</span><span class="p">;</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_source_addr</span> <span class="o">=</span> <span class="n">BTE_SOURCE_ADDR</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_destination_addr</span> <span class="o">=</span> <span class="n">BTE_DEST_ADDR</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_control_addr</span> <span class="o">=</span> <span class="n">BTE_CTRL_ADDR</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_notify_addr</span> <span class="o">=</span> <span class="n">BTE_NOTIF_ADDR</span><span class="p">(</span><span class="n">base_addr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize the notification and spinlock</span>
<span class="cm">		 * so the first transfer can occur.</span>
<span class="cm">		 */</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">most_rcnt_na</span> <span class="o">=</span>
		    <span class="o">&amp;</span><span class="p">(</span><span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify</span><span class="p">);</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify</span> <span class="o">=</span> <span class="n">BTE_WORD_AVAILABLE</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_cnode</span> <span class="o">=</span> <span class="n">cnode</span><span class="p">;</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_error_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bte_num</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cleanup_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mynodepda</span><span class="o">-&gt;</span><span class="n">bte_if</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
