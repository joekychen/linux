<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › kernel › io_common.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io_common.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/sn/types.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_feature_sets.h&gt;</span>
<span class="cp">#include &lt;asm/sn/geo.h&gt;</span>
<span class="cp">#include &lt;asm/sn/io.h&gt;</span>
<span class="cp">#include &lt;asm/sn/l1.h&gt;</span>
<span class="cp">#include &lt;asm/sn/module.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibr_provider.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibus_provider_defs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcidev.h&gt;</span>
<span class="cp">#include &lt;asm/sn/simulator.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/tioca_provider.h&gt;</span>
<span class="cp">#include &lt;asm/sn/tioce_provider.h&gt;</span>
<span class="cp">#include &quot;xtalk/hubdev.h&quot;</span>
<span class="cp">#include &quot;xtalk/xwidgetdev.h&quot;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn2/sn_hwperf.h&gt;</span>
<span class="cp">#include &lt;asm/sn/acpi.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sn_init_cpei_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">register_sn_procfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sn_io_acpi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sn_io_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">sn_sysdata_list</span><span class="p">;</span>

<span class="cm">/* sysdata list struct */</span>
<span class="k">struct</span> <span class="n">sysdata_el</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sysdata</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">sn_ioif_inited</span><span class="p">;</span>		<span class="cm">/* SN I/O infrastructure initialized? */</span>

<span class="kt">int</span> <span class="n">sn_acpi_rev</span><span class="p">;</span>		<span class="cm">/* SN ACPI revision */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sn_acpi_rev</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">PCIIO_ASIC_MAX_TYPES</span><span class="p">];</span>	<span class="cm">/* indexed by asic type */</span>

<span class="cm">/*</span>
<span class="cm"> * Hooks and struct for unsupported pci providers</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">dma_addr_t</span>
<span class="nf">sn_default_pci_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_default_pci_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">sn_default_pci_bus_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">soft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="n">sn_pci_default_provider</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_map</span> <span class="o">=</span> <span class="n">sn_default_pci_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_map_consistent</span> <span class="o">=</span> <span class="n">sn_default_pci_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_unmap</span> <span class="o">=</span> <span class="n">sn_default_pci_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_fixup</span> <span class="o">=</span> <span class="n">sn_default_pci_bus_fixup</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve the DMA Flush List given nasid, widget, and device.</span>
<span class="cm"> * This list is needed to implement the WAR - Flush DMA data on PIO Reads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span>
<span class="nf">sal_get_device_dmaflush_list</span><span class="p">(</span><span class="n">u64</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">widget_num</span><span class="p">,</span> <span class="n">u64</span> <span class="n">device_num</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_GET_DEVICE_DMAFLUSH_LIST</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">nasid</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">widget_num</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">device_num</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified</span>
<span class="cm"> *			  device.</span>
<span class="cm"> */</span>
<span class="kr">inline</span> <span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span>
<span class="nf">sn_pcidev_info_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pcidev</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="p">(</span><span class="n">SN_PLATFORM_DATA</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcidev_info</span><span class="p">),</span> <span class="n">pdi_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">pdi_linux_pcidev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pcidev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Older PROM flush WAR</span>
<span class="cm"> *</span>
<span class="cm"> * 01/16/06 -- This war will be in place until a new official PROM is released.</span>
<span class="cm"> * Additionally note that the struct sn_flush_device_war also has to be</span>
<span class="cm"> * removed from arch/ia64/sn/include/xtalk/hubdev.h</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">s64</span> <span class="nf">sn_device_fixup_war</span><span class="p">(</span><span class="n">u64</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">widget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sn_flush_device_common</span> <span class="o">*</span><span class="n">common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_flush_device_war</span> <span class="o">*</span><span class="n">war_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_flush_device_war</span> <span class="o">*</span><span class="n">dev_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">isrv</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;PROM version &lt; 4.50 -- implementing old PROM flush WAR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">war_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">DEV_PER_WIDGET</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">war_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">war_list</span><span class="p">);</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">isrv</span><span class="p">,</span> <span class="n">SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST</span><span class="p">,</span>
			<span class="n">nasid</span><span class="p">,</span> <span class="n">widget</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">war_list</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sn_device_fixup_war failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ia64_sal_strerror</span><span class="p">(</span><span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">));</span>

	<span class="n">dev_entry</span> <span class="o">=</span> <span class="n">war_list</span> <span class="o">+</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">common</span><span class="p">,</span><span class="n">dev_entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">common</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">war_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">isrv</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn_common_hubdev_init() - This routine is called to initialize the HUB data</span>
<span class="cm"> *			     structure for each node in the system.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span>
<span class="nf">sn_common_hubdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="n">hubdev</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">sn_flush_device_kernel</span> <span class="o">*</span><span class="n">sn_flush_device_kernel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_flush_device_kernel</span> <span class="o">*</span><span class="n">dev_entry</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">widget</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Attach the error interrupt handlers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_nasid</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>	<span class="cm">/* If TIO */</span>
		<span class="n">ice_error_init</span><span class="p">(</span><span class="n">hubdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hub_error_init</span><span class="p">(</span><span class="n">hubdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">widget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">widget</span> <span class="o">&lt;=</span> <span class="n">HUB_WIDGET_ID_MAX</span><span class="p">;</span> <span class="n">widget</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_xwidget_info</span><span class="p">[</span><span class="n">widget</span><span class="p">].</span><span class="n">xwi_hubinfo</span> <span class="o">=</span> <span class="n">hubdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_flush_nasid_list</span><span class="p">.</span><span class="n">widget_p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">HUB_WIDGET_ID_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_flush_device_kernel</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_flush_nasid_list</span><span class="p">.</span><span class="n">widget_p</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_flush_nasid_list</span><span class="p">.</span><span class="n">widget_p</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">widget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">widget</span> <span class="o">&lt;=</span> <span class="n">HUB_WIDGET_ID_MAX</span><span class="p">;</span> <span class="n">widget</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">DEV_PER_WIDGET</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_flush_device_kernel</span><span class="p">);</span>
		<span class="n">sn_flush_device_kernel</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sn_flush_device_kernel</span><span class="p">);</span>

		<span class="n">dev_entry</span> <span class="o">=</span> <span class="n">sn_flush_device_kernel</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">device</span> <span class="o">&lt;</span> <span class="n">DEV_PER_WIDGET</span><span class="p">;</span>
		     <span class="n">device</span><span class="o">++</span><span class="p">,</span> <span class="n">dev_entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_flush_device_common</span><span class="p">);</span>
			<span class="n">dev_entry</span><span class="o">-&gt;</span><span class="n">common</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_entry</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sn_prom_feature_available</span><span class="p">(</span><span class="n">PRF_DEVICE_FLUSH_LIST</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">sal_get_device_dmaflush_list</span><span class="p">(</span>
					     <span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_nasid</span><span class="p">,</span> <span class="n">widget</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">dev_entry</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">sn_device_fixup_war</span><span class="p">(</span><span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_nasid</span><span class="p">,</span>
							     <span class="n">widget</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
							     <span class="n">dev_entry</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SALRET_OK</span><span class="p">)</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SAL call failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">ia64_sal_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>

			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_entry</span><span class="o">-&gt;</span><span class="n">sfdl_flush_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sn_flush_device_kernel</span><span class="p">)</span>
			<span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_flush_nasid_list</span><span class="p">.</span><span class="n">widget_p</span><span class="p">[</span><span class="n">widget</span><span class="p">]</span> <span class="o">=</span>
							 <span class="n">sn_flush_device_kernel</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_pci_unfixup_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_pci_dev</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">host_pci_dev</span><span class="p">;</span>

	<span class="n">sn_irq_unfixup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">host_pci_dev</span><span class="p">);</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn_pci_fixup_slot()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sn_pci_fixup_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">segment</span> <span class="o">=</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">host_pci_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_pci_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus_no</span><span class="p">,</span> <span class="n">devfn</span><span class="p">;</span>

	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="cm">/* for the sysdata pointer */</span>

	<span class="cm">/* Add pcidev_info to list in pci_controller.platform_data */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_list</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="p">(</span><span class="n">SN_PLATFORM_DATA</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcidev_info</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Using the PROMs values for the PCI host bus, get the Linux</span>
<span class="cm">	 * PCI host_pci_dev struct and set up host bus linkages</span>
<span class="cm"> 	 */</span>

	<span class="n">bus_no</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_slot_host_handle</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">devfn</span> <span class="o">=</span> <span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_slot_host_handle</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
 	<span class="n">host_pci_bus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">bus_no</span><span class="p">);</span>
 	<span class="n">host_pci_dev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">host_pci_bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>

	<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">host_pci_dev</span> <span class="o">=</span> <span class="n">host_pci_dev</span><span class="p">;</span>
	<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_linux_pcidev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_host_pcidev_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">host_pci_dev</span><span class="p">);</span>
	<span class="n">bs</span> <span class="o">=</span> <span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span> <span class="o">=</span> <span class="n">bs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span> <span class="o">&amp;&amp;</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">&lt;</span> <span class="n">PCIIO_ASIC_MAX_TYPES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">=</span> <span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sn_pci_default_provider</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only set up IRQ stuff if this device has a host bus context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span> <span class="o">&amp;&amp;</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_sn_irq_info</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">;</span>
		<span class="n">sn_irq_fixup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sn_irq_info</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_sn_irq_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn_common_bus_fixup - Perform platform specific bus fixup.</span>
<span class="cm"> *			 Execute the ASIC specific fixup routine</span>
<span class="cm"> *			 for this bus.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">sn_common_bus_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">prom_bussoft_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="n">hubdev_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">provider_soft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_platform_data</span> <span class="o">*</span><span class="n">sn_platform_data</span><span class="p">;</span>

	<span class="n">controller</span> <span class="o">=</span> <span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Per-provider fixup.  Copies the bus soft structure from prom</span>
<span class="cm">	 * to local area and links SN_PCIBUS_BUSSOFT().</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prom_bussoft_ptr</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">&gt;=</span> <span class="n">PCIIO_ASIC_MAX_TYPES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sn_common_bus_fixup: Unsupported asic type, %d&quot;</span><span class="p">,</span>
		       <span class="n">prom_bussoft_ptr</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prom_bussoft_ptr</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">==</span> <span class="n">PCIIO_ASIC_TYPE_PPB</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* no further fixup necessary */</span>

	<span class="n">provider</span> <span class="o">=</span> <span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">prom_bussoft_ptr</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">provider</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sn_common_bus_fixup: No provider registered for this asic type, %d&quot;</span><span class="p">,</span>
		      <span class="n">prom_bussoft_ptr</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">provider</span><span class="o">-&gt;</span><span class="n">bus_fixup</span><span class="p">)</span>
		<span class="n">provider_soft</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">provider</span><span class="o">-&gt;</span><span class="n">bus_fixup</span><span class="p">)</span> <span class="p">(</span><span class="n">prom_bussoft_ptr</span><span class="p">,</span>
				 <span class="n">controller</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">provider_soft</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generic bus fixup goes here.  Don&#39;t reference prom_bussoft_ptr</span>
<span class="cm">	 * after this point.</span>
<span class="cm">	 */</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_platform_data</span><span class="p">),</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">platform_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sn_platform_data</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">sn_platform_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">controller</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">sn_platform_data</span><span class="o">-&gt;</span><span class="n">provider_soft</span> <span class="o">=</span> <span class="n">provider_soft</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sn_platform_data</span> <span class="o">*</span><span class="p">)</span>
			 <span class="n">controller</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcidev_info</span><span class="p">);</span>
	<span class="n">nasid</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_base</span><span class="p">);</span>
	<span class="n">cnode</span> <span class="o">=</span> <span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>
	<span class="n">hubdev_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">NODEPDA</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdinfo</span><span class="p">);</span>
	<span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_xwidget_info</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="p">(</span><span class="n">hubdev_info</span><span class="o">-&gt;</span><span class="n">hdi_xwidget_info</span><span class="p">[</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_xid</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the node information we obtained during the fixup phase is</span>
<span class="cm">	 * invalid then set controller-&gt;node to -1 (undetermined)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">controller</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">num_online_nodes</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Device ASIC=%u XID=%u PBUSNUM=%u &quot;</span>
		       <span class="s">&quot;L_IO=%llx L_MEM=%llx BASE=%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_xid</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_persist_busnum</span><span class="p">,</span>
		       <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_legacy_io</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_legacy_mem</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bs_base</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;on node %d but only %d nodes online.&quot;</span>
		       <span class="s">&quot;Association set to undetermined.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">controller</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">num_online_nodes</span><span class="p">());</span>
		<span class="n">controller</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_bus_store_sysdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysdata_el</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

	<span class="n">element</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysdata_el</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: out of memory!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">element</span><span class="o">-&gt;</span><span class="n">sysdata</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_sysdata_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_bus_free_sysdata</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysdata_el</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_sysdata_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">element</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sysdata_el</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="p">)</span>
			     <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">sysdata</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">pdi_list</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">sysdata</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hubdev_init_node() - Creates the HUB data structure and link them to it&#39;s</span>
<span class="cm"> *			own NODE specific data area.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">hubdev_init_node</span><span class="p">(</span><span class="n">nodepda_t</span> <span class="o">*</span> <span class="n">npda</span><span class="p">,</span> <span class="n">cnodeid_t</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="n">hubdev_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pg</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hubdev_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="n">num_online_nodes</span><span class="p">())</span>	<span class="cm">/* Headless/memless IO nodes */</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pg</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">hubdev_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_bootmem_node</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">npda</span><span class="o">-&gt;</span><span class="n">pdinfo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hubdev_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">geoid_t</span>
<span class="nf">cnodeid_get_geoid</span><span class="p">(</span><span class="n">cnodeid_t</span> <span class="n">cnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="n">hubdev</span><span class="p">;</span>

	<span class="n">hubdev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hubdev_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">NODEPDA</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdinfo</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hubdev</span><span class="o">-&gt;</span><span class="n">hdi_geoid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sn_generate_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nasid_t</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="n">cnodeid_t</span> <span class="n">cnode</span><span class="p">;</span>
	<span class="n">geoid_t</span> <span class="n">geoid</span><span class="p">;</span>
	<span class="n">moduleid_t</span> <span class="n">moduleid</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">bricktype</span><span class="p">;</span>

	<span class="n">nasid</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">pci_bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_base</span><span class="p">);</span>
	<span class="n">cnode</span> <span class="o">=</span> <span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>
	<span class="n">geoid</span> <span class="o">=</span> <span class="n">cnodeid_get_geoid</span><span class="p">(</span><span class="n">cnode</span><span class="p">);</span>
	<span class="n">moduleid</span> <span class="o">=</span> <span class="n">geo_module</span><span class="p">(</span><span class="n">geoid</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s">&quot;module_%c%c%c%c%.2d&quot;</span><span class="p">,</span>
		<span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="n">RACK_GET_CLASS</span><span class="p">(</span><span class="n">MODULE_GET_RACK</span><span class="p">(</span><span class="n">moduleid</span><span class="p">)),</span>
		<span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="n">RACK_GET_GROUP</span><span class="p">(</span><span class="n">MODULE_GET_RACK</span><span class="p">(</span><span class="n">moduleid</span><span class="p">)),</span>
		<span class="sc">&#39;0&#39;</span><span class="o">+</span><span class="n">RACK_GET_NUM</span><span class="p">(</span><span class="n">MODULE_GET_RACK</span><span class="p">(</span><span class="n">moduleid</span><span class="p">)),</span>
		<span class="n">MODULE_GET_BTCHAR</span><span class="p">(</span><span class="n">moduleid</span><span class="p">),</span> <span class="n">MODULE_GET_BPOS</span><span class="p">(</span><span class="n">moduleid</span><span class="p">));</span>

	<span class="cm">/* Tollhouse requires slot id to be displayed */</span>
	<span class="n">bricktype</span> <span class="o">=</span> <span class="n">MODULE_GET_BTYPE</span><span class="p">(</span><span class="n">moduleid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bricktype</span> <span class="o">==</span> <span class="n">L1_BRICKTYPE_191010</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bricktype</span> <span class="o">==</span> <span class="n">L1_BRICKTYPE_1932</span><span class="p">))</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="s">&quot;^%d&quot;</span><span class="p">,</span>
						<span class="n">geo_slot</span><span class="p">(</span><span class="n">geoid</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">sn_pci_fixup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SN_ACPI_BASE_SUPPORT</span><span class="p">())</span>
		<span class="n">sn_acpi_bus_fixup</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sn_bus_fixup</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sn_io_early_init - Perform early IO (and some non-IO) initialization.</span>
<span class="cm"> *		      In particular, setup the sn_pci_provider[] array.</span>
<span class="cm"> *		      This needs to be done prior to any bus scanning</span>
<span class="cm"> *		      (acpi_scan_init()) in the ACPI case, as the SN</span>
<span class="cm"> *		      bus fixup code will reference the array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">sn_io_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_RUNNING_ON_FAKE_PROM</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we set the acpi revision to that of the DSDT table OEM rev. */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">acpi_get_table</span><span class="p">(</span><span class="n">ACPI_SIG_DSDT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">header</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">sn_acpi_rev</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">oem_revision</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * prime sn_pci_provider[].  Individual provider init routines will</span>
<span class="cm">	 * override their respective default entries.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PCIIO_ASIC_MAX_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sn_pci_default_provider</span><span class="p">;</span>

	<span class="n">pcibr_init_provider</span><span class="p">();</span>
	<span class="n">tioca_init_provider</span><span class="p">();</span>
	<span class="n">tioce_init_provider</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is needed to avoid bounce limit checks in the blk layer</span>
<span class="cm">	 */</span>
	<span class="n">ia64_max_iommu_merge_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">sn_irq_lh_init</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sn_sysdata_list</span><span class="p">);</span>
	<span class="n">sn_init_cpei_timer</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">register_sn_procfs</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_get_table</span><span class="p">(</span><span class="n">ACPI_SIG_DSDT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ACPI  DSDT OEM Rev 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">header</span><span class="o">-&gt;</span><span class="n">oem_revision</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SN_ACPI_BASE_SUPPORT</span><span class="p">())</span>
		<span class="n">sn_io_acpi_init</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">sn_io_init</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arch_initcall</span><span class="p">(</span><span class="n">sn_io_early_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * sn_io_late_init() - Perform any final platform specific IO initialization.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">sn_io_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">bussoft</span><span class="p">;</span>
	<span class="n">cnodeid_t</span> <span class="n">cnode</span><span class="p">;</span>
	<span class="n">nasid_t</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="n">cnodeid_t</span> <span class="n">near_cnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_RUNNING_ON_FAKE_PROM</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup closest node in pci_controller-&gt;node for</span>
<span class="cm">	 * PIC, TIOCP, TIOCE (TIOCA does it during bus fixup using</span>
<span class="cm">	 * info from the PROM).</span>
<span class="cm">	 */</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pci_find_next_bus</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bussoft</span> <span class="o">=</span> <span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">nasid</span> <span class="o">=</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">bussoft</span><span class="o">-&gt;</span><span class="n">bs_base</span><span class="p">);</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bussoft</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">==</span> <span class="n">PCIIO_ASIC_TYPE_TIOCP</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">bussoft</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">==</span> <span class="n">PCIIO_ASIC_TYPE_TIOCE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">bussoft</span><span class="o">-&gt;</span><span class="n">bs_asic_type</span> <span class="o">==</span> <span class="n">PCIIO_ASIC_TYPE_PIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* PCI Bridge: find nearest node with CPUs */</span>
			<span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">sn_hwperf_get_nearest_node</span><span class="p">(</span><span class="n">cnode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">near_cnode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">near_cnode</span> <span class="o">=</span> <span class="p">(</span><span class="n">cnodeid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* use any node */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sn_io_late_init: failed &quot;</span>
				       <span class="s">&quot;to find near node with CPUs for &quot;</span>
				       <span class="s">&quot;node %d, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnode</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">PCI_CONTROLLER</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">near_cnode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sn_ioif_inited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* SN I/O infrastructure now initialized */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fs_initcall</span><span class="p">(</span><span class="n">sn_io_late_init</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_pci_unfixup_slot</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_bus_store_sysdata</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_bus_free_sysdata</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_generate_path</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
