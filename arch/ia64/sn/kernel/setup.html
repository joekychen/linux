<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › kernel › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999,2001-2006 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/screen_info.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/root_dev.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/sal.h&gt;</span>
<span class="cp">#include &lt;asm/machvec.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/vga.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sn/arch.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/nodepda.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_cpuid.h&gt;</span>
<span class="cp">#include &lt;asm/sn/simulator.h&gt;</span>
<span class="cp">#include &lt;asm/sn/leds.h&gt;</span>
<span class="cp">#include &lt;asm/sn/bte.h&gt;</span>
<span class="cp">#include &lt;asm/sn/shub_mmr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/clksupport.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/geo.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_feature_sets.h&gt;</span>
<span class="cp">#include &quot;xtalk/xwidgetdev.h&quot;</span>
<span class="cp">#include &quot;xtalk/hubdev.h&quot;</span>
<span class="cp">#include &lt;asm/sn/klconfig.h&gt;</span>


<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">pda_s</span><span class="p">,</span> <span class="n">pda_percpu</span><span class="p">);</span>

<span class="cp">#define MAX_PHYS_MEMORY		(1UL &lt;&lt; IA64_MAX_PHYS_BITS)	</span><span class="cm">/* Max physical address supported */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">bte_init_node</span><span class="p">(</span><span class="n">nodepda_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">cnodeid_t</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sn_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_time_offset</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ia64_mark_idle</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">snidle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sn_rtc_cycles_per_second</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_rtc_cycles_per_second</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_hub_info_s</span><span class="p">,</span> <span class="n">__sn_hub_info</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">__sn_hub_info</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">short</span><span class="p">,</span> <span class="n">__sn_cnodeid_to_nasid</span><span class="p">[</span><span class="n">MAX_COMPACT_NODES</span><span class="p">]);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">__sn_cnodeid_to_nasid</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">nodepda_s</span> <span class="o">*</span><span class="p">,</span> <span class="n">__sn_nodepda</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">__sn_nodepda</span><span class="p">);</span>

<span class="kt">char</span> <span class="n">sn_system_serial_number_string</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_system_serial_number_string</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">sn_partition_serial_number</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_partition_serial_number</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">sn_partition_id</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_partition_id</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">sn_system_size</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_system_size</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">sn_sharing_domain_size</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_sharing_domain_size</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">sn_coherency_id</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_coherency_id</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">sn_region_size</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_region_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sn_prom_type</span><span class="p">;</span>	<span class="cm">/* 0=hardware, 1=medusa/realprom, 2=medusa/fakeprom */</span>

<span class="kt">short</span> <span class="n">physical_node_map</span><span class="p">[</span><span class="n">MAX_NUMALINK_NODES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sn_prom_features</span><span class="p">[</span><span class="n">MAX_PROM_FEATURE_SETS</span><span class="p">];</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">physical_node_map</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">num_cnodes</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sn_init_pdas</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">build_cnode_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="n">nodepda_t</span> <span class="o">*</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">MAX_COMPACT_NODES</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * The format of &quot;screen_info&quot; is strange, and due to early i386-setup</span>
<span class="cm"> * code. This is just enough to make the console code think we&#39;re on a</span>
<span class="cm"> * VGA color display.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">screen_info</span> <span class="n">sn_screen_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">orig_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_mode</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_cols</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_ega_bx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_lines</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_isVGA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">orig_video_points</span> <span class="o">=</span> <span class="mi">16</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This routine can only be used during init, since</span>
<span class="cm"> * smp_boot_data is an init data structure.</span>
<span class="cm"> * We have to use smp_boot_data.cpu_phys_id to find</span>
<span class="cm"> * the physical id of the processor because the normal</span>
<span class="cm"> * cpu_physical_id() relies on data structures that</span>
<span class="cm"> * may not be initialized yet.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pxm_to_nasid</span><span class="p">(</span><span class="kt">int</span> <span class="n">pxm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">pxm_to_node</span><span class="p">(</span><span class="n">pxm</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_node_memblks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">NASID_GET</span><span class="p">(</span><span class="n">node_memblk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_paddr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * early_sn_setup - early setup routine for SN platforms</span>
<span class="cm"> *</span>
<span class="cm"> * Sets up an initial console to aid debugging.  Intended primarily</span>
<span class="cm"> * for bringup.  See start_kernel() in init/main.c.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_sn_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">efi_system_table_t</span> <span class="o">*</span><span class="n">efi_systab</span><span class="p">;</span>
	<span class="n">efi_config_table_t</span> <span class="o">*</span><span class="n">config_tables</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_systab</span> <span class="o">*</span><span class="n">sal_systab</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_desc_entry_point</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Parse enough of the SAL tables to locate the SAL entry point. Since, console</span>
<span class="cm">	 * IO on SN2 is done via SAL calls, early_printk won&#39;t work without this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code duplicates some of the ACPI table parsing that is in efi.c &amp; sal.c.</span>
<span class="cm">	 * Any changes to those file may have to be made here as well.</span>
<span class="cm">	 */</span>
	<span class="n">efi_systab</span> <span class="o">=</span> <span class="p">(</span><span class="n">efi_system_table_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">ia64_boot_param</span><span class="o">-&gt;</span><span class="n">efi_systab</span><span class="p">);</span>
	<span class="n">config_tables</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">efi_systab</span><span class="o">-&gt;</span><span class="n">tables</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efi_systab</span><span class="o">-&gt;</span><span class="n">nr_tables</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">efi_guidcmp</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">guid</span><span class="p">,</span> <span class="n">SAL_SYSTEM_TABLE_GUID</span><span class="p">)</span> <span class="o">==</span>
		    <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sal_systab</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">config_tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">sal_systab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sal_systab</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">SAL_DESC_ENTRY_POINT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ep</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ia64_sal_desc_entry_point</span>
					      <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
					<span class="n">ia64_sal_handler_init</span><span class="p">(</span><span class="n">__va</span>
							      <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">sal_proc</span><span class="p">),</span>
							      <span class="n">__va</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">gp</span><span class="p">));</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">SAL_DESC_SIZE</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Uh-oh, SAL not available?? */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;failed to find SAL entry point</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">platform_intr_list</span><span class="p">[];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinitdata</span> <span class="n">shub_1_1_found</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * sn_check_for_wars</span>
<span class="cm"> *</span>
<span class="cm"> * Set flag for enabling shub specific wars</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">is_shub_1_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">nasid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub2</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">REMOTE_HUB_L</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">SH1_SHUB_ID</span><span class="p">);</span>
	<span class="n">rev</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">SH1_SHUB_ID_REVISION_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SH1_SHUB_ID_REVISION_SHFT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rev</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">sn_check_for_wars</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub2</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* none yet */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_shub_1_1</span><span class="p">(</span><span class="n">cnodeid_to_nasid</span><span class="p">(</span><span class="n">cnode</span><span class="p">)))</span>
				<span class="n">shub_1_1_found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the EFI PCDP table (if it exists) for an acceptable VGA console</span>
<span class="cm"> * output device.  If one exists, pick it and set sn_legacy_{io,mem} to</span>
<span class="cm"> * reflect the bus offsets needed to address it.</span>
<span class="cm"> *</span>
<span class="cm"> * Since pcdp support in SN is not supported in the 2.4 kernel (or at least</span>
<span class="cm"> * the one lbs is based on) just declare the needed structs here.</span>
<span class="cm"> *</span>
<span class="cm"> * Reference spec http://www.dig64.org/specifications/DIG64_PCDPv20.pdf</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if no acceptable vga is found, !0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  This stuff is duped here because Altix requires the PCDP to</span>
<span class="cm"> * locate a usable VGA device due to lack of proper ACPI support.  Structures</span>
<span class="cm"> * could be used from drivers/firmware/pcdp.h, but it was decided that moving</span>
<span class="cm"> * this file to a more public location just for Altix use was undesirable.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">hcdp_uart_desc</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">pad</span><span class="p">[</span><span class="mi">45</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pcdp</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">signature</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* should be &#39;HCDP&#39; */</span>
	<span class="n">u32</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">rev</span><span class="p">;</span>		<span class="cm">/* should be &gt;=3 for pcdp, &lt;3 for hcdp */</span>
	<span class="n">u8</span>	<span class="n">sum</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">oem_id</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">u64</span>	<span class="n">oem_tableid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">oem_rev</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">creator_id</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">creator_rev</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">num_type0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hcdp_uart_desc</span> <span class="n">uart</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* num_type0 of these */</span>
	<span class="cm">/* pcdp descriptors follow */</span>
<span class="p">}</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">pcdp_device_desc</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">primary</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">index</span><span class="p">;</span>
	<span class="cm">/* interconnect specific structure follows */</span>
	<span class="cm">/* device specific structure follows that */</span>
<span class="p">}</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">pcdp_interface_pci</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">type</span><span class="p">;</span>		<span class="cm">/* 1 == pci */</span>
	<span class="n">u8</span>	<span class="n">reserved</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">segment</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">bus</span><span class="p">;</span>
	<span class="n">u8</span> 	<span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">fun</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">devid</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">vendid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">acpi_interrupt</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">mmio_tra</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">ioport_tra</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">translation</span><span class="p">;</span>
<span class="p">}</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">pcdp_vga_device</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">num_eas_desc</span><span class="p">;</span>
	<span class="cm">/* ACPI Extended Address Space Desc follows */</span>
<span class="p">}</span>  <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* from pcdp_device_desc.primary */</span>
<span class="cp">#define PCDP_PRIMARY_CONSOLE	0x01</span>

<span class="cm">/* from pcdp_device_desc.type */</span>
<span class="cp">#define PCDP_CONSOLE_INOUT	0x0</span>
<span class="cp">#define PCDP_CONSOLE_DEBUG	0x1</span>
<span class="cp">#define PCDP_CONSOLE_OUT	0x2</span>
<span class="cp">#define PCDP_CONSOLE_IN		0x3</span>
<span class="cp">#define PCDP_CONSOLE_TYPE_VGA	0x8</span>

<span class="cp">#define PCDP_CONSOLE_VGA	(PCDP_CONSOLE_TYPE_VGA | PCDP_CONSOLE_OUT)</span>

<span class="cm">/* from pcdp_interface_pci.type */</span>
<span class="cp">#define PCDP_IF_PCI		1</span>

<span class="cm">/* from pcdp_interface_pci.translation */</span>
<span class="cp">#define PCDP_PCI_TRANS_IOPORT	0x02</span>
<span class="cp">#define PCDP_PCI_TRANS_MMIO	0x01</span>

<span class="cp">#if defined(CONFIG_VT) &amp;&amp; defined(CONFIG_VGA_CONSOLE)</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_scan_pcdp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcdp</span> <span class="o">*</span><span class="n">pcdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcdp_device_desc</span> <span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcdp_interface_pci</span> <span class="n">if_pci</span><span class="p">;</span>
	<span class="k">extern</span> <span class="k">struct</span> <span class="n">efi</span> <span class="n">efi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">hcdp</span> <span class="o">==</span> <span class="n">EFI_INVALID_TABLE_ADDR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no hcdp/pcdp table */</span>

	<span class="n">pcdp</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">efi</span><span class="p">.</span><span class="n">hcdp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdp</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* only support PCDP (rev &gt;= 3) */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pcdp</span><span class="o">-&gt;</span><span class="n">uart</span><span class="p">[</span><span class="n">pcdp</span><span class="o">-&gt;</span><span class="n">num_type0</span><span class="p">];</span>
	     <span class="n">bp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">pcdp</span> <span class="o">+</span> <span class="n">pcdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	     <span class="n">bp</span> <span class="o">+=</span> <span class="n">device</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">device</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">device</span><span class="p">.</span><span class="n">primary</span> <span class="o">&amp;</span> <span class="n">PCDP_PRIMARY_CONSOLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* not primary console */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PCDP_CONSOLE_VGA</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* not VGA descriptor */</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">if_pci</span><span class="p">,</span> <span class="n">bp</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">if_pci</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">if_pci</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PCDP_IF_PCI</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* not PCI interconnect */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">if_pci</span><span class="p">.</span><span class="n">translation</span> <span class="o">&amp;</span> <span class="n">PCDP_PCI_TRANS_IOPORT</span><span class="p">)</span>
			<span class="n">vga_console_iobase</span> <span class="o">=</span> <span class="n">if_pci</span><span class="p">.</span><span class="n">ioport_tra</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">if_pci</span><span class="p">.</span><span class="n">translation</span> <span class="o">&amp;</span> <span class="n">PCDP_PCI_TRANS_MMIO</span><span class="p">)</span>
			<span class="n">vga_console_membase</span> <span class="o">=</span>
				<span class="n">if_pci</span><span class="p">.</span><span class="n">mmio_tra</span> <span class="o">|</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span> <span class="cm">/* once we find the primary, we&#39;re done */</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sn2_rtc_initial</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * sn_setup - SN platform setup routine</span>
<span class="cm"> * @cmdline_p: kernel command line</span>
<span class="cm"> *</span>
<span class="cm"> * Handles platform setup for SN machines.  This includes determining</span>
<span class="cm"> * the RTC frequency (via a SAL call), initializing secondary CPUs, and</span>
<span class="cm"> * setting up per-node data areas.  The console is also initialized here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sn_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">ticks_per_sec</span><span class="p">,</span> <span class="n">drift</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">version</span> <span class="o">=</span> <span class="n">sn_sal_rev</span><span class="p">();</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">sn_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

	<span class="n">sn2_rtc_initial</span> <span class="o">=</span> <span class="n">rtc_time</span><span class="p">();</span>
	<span class="n">ia64_sn_plat_set_error_handling_features</span><span class="p">();</span>	<span class="c1">// obsolete</span>
	<span class="n">ia64_sn_set_os_feature</span><span class="p">(</span><span class="n">OSF_MCA_SLV_TO_OS_INIT_SLV</span><span class="p">);</span>
	<span class="n">ia64_sn_set_os_feature</span><span class="p">(</span><span class="n">OSF_FEAT_LOG_SBES</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: The calls to notify the PROM of ACPI and PCI Segment</span>
<span class="cm">	 *	 support must be done prior to acpi_load_tables(), as</span>
<span class="cm">	 *	 an ACPI capable PROM will rebuild the DSDT as result</span>
<span class="cm">	 *	 of the call.</span>
<span class="cm">	 */</span>
	<span class="n">ia64_sn_set_os_feature</span><span class="p">(</span><span class="n">OSF_PCISEGMENT_ENABLE</span><span class="p">);</span>
	<span class="n">ia64_sn_set_os_feature</span><span class="p">(</span><span class="n">OSF_ACPI_ENABLE</span><span class="p">);</span>

	<span class="cm">/* Load the new DSDT and SSDT tables into the global table list. */</span>
	<span class="n">acpi_table_init</span><span class="p">();</span>

<span class="cp">#if defined(CONFIG_VT) &amp;&amp; defined(CONFIG_VGA_CONSOLE)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Handle SN vga console.</span>
<span class="cm">	 *</span>
<span class="cm">	 * SN systems do not have enough ACPI table information</span>
<span class="cm">	 * being passed from prom to identify VGA adapters and the legacy</span>
<span class="cm">	 * addresses to access them.  Until that is done, SN systems rely</span>
<span class="cm">	 * on the PCDP table to identify the primary VGA console if one</span>
<span class="cm">	 * exists.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, kernel PCDP support is optional, and even if it is built</span>
<span class="cm">	 * into the kernel, it will not be used if the boot cmdline contains</span>
<span class="cm">	 * console= directives.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, to work around this mess, we duplicate some of the PCDP code</span>
<span class="cm">	 * here so that the primary VGA console (as defined by PCDP) will</span>
<span class="cm">	 * work on SN systems even if a different console (e.g. serial) is</span>
<span class="cm">	 * selected on the boot line (or CONFIG_EFI_PCDP is off).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">vga_console_membase</span><span class="p">)</span>
		<span class="n">sn_scan_pcdp</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Setup legacy IO space.</span>
<span class="cm">	 *	vga_console_iobase maps to PCI IO Space address 0 on the</span>
<span class="cm">	 * 	bus containing the VGA console.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vga_console_iobase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mmio_base</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">vga_console_iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">io_space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sparse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vga_console_membase</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* usable vga ... make tty0 the preferred default console */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="o">*</span><span class="n">cmdline_p</span><span class="p">,</span> <span class="s">&quot;console=&quot;</span><span class="p">))</span>
			<span class="n">add_preferred_console</span><span class="p">(</span><span class="s">&quot;tty&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SGI: Disabling VGA console</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="o">*</span><span class="n">cmdline_p</span><span class="p">,</span> <span class="s">&quot;console=&quot;</span><span class="p">))</span>
			<span class="n">add_preferred_console</span><span class="p">(</span><span class="s">&quot;ttySG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DUMMY_CONSOLE</span>
		<span class="n">conswitchp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy_con</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">conswitchp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_DUMMY_CONSOLE */</span><span class="cp"></span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* def(CONFIG_VT) &amp;&amp; def(CONFIG_VGA_CONSOLE) */</span><span class="cp"></span>

	<span class="n">MAX_DMA_ADDRESS</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span> <span class="o">+</span> <span class="n">MAX_PHYS_MEMORY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the tables for managing cnodes.</span>
<span class="cm">	 */</span>
	<span class="n">build_cnode_tables</span><span class="p">();</span>

	<span class="n">status</span> <span class="o">=</span>
	    <span class="n">ia64_sal_freq_base</span><span class="p">(</span><span class="n">SAL_FREQ_BASE_REALTIME_CLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ticks_per_sec</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">drift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ticks_per_sec</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;unable to determine platform RTC clock frequency, guessing.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* PROM gives wrong value for clock freq. so guess */</span>
		<span class="n">sn_rtc_cycles_per_second</span> <span class="o">=</span> <span class="mi">1000000000000UL</span> <span class="o">/</span> <span class="mi">30000UL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sn_rtc_cycles_per_second</span> <span class="o">=</span> <span class="n">ticks_per_sec</span><span class="p">;</span>

	<span class="n">platform_intr_list</span><span class="p">[</span><span class="n">ACPI_INTERRUPT_CPEI</span><span class="p">]</span> <span class="o">=</span> <span class="n">IA64_CPE_VECTOR</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SGI SAL version %x.%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we set the default root device to /dev/hda</span>
<span class="cm">	 * to make simulation easy</span>
<span class="cm">	 */</span>
	<span class="n">ROOT_DEV</span> <span class="o">=</span> <span class="n">Root_HDA1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create the PDAs and NODEPDAs for all the cpus.</span>
<span class="cm">	 */</span>
	<span class="n">sn_init_pdas</span><span class="p">(</span><span class="n">cmdline_p</span><span class="p">);</span>

	<span class="n">ia64_mark_idle</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">snidle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For the bootcpu, we do this here. All other cpus will make the</span>
<span class="cm">	 * call as part of cpu_init in slave cpu initialization.</span>
<span class="cm">	 */</span>
	<span class="n">sn_cpu_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">init_smp_config</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">screen_info</span> <span class="o">=</span> <span class="n">sn_screen_info</span><span class="p">;</span>

	<span class="n">sn_timer_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * set pm_power_off to a SAL call to allow</span>
<span class="cm">	 * sn machines to power off. The SAL call can be replaced</span>
<span class="cm">	 * by an ACPI interface call when ACPI is fully implemented</span>
<span class="cm">	 * for sn.</span>
<span class="cm">	 */</span>
	<span class="n">pm_power_off</span> <span class="o">=</span> <span class="n">ia64_sn_power_down</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IA64_THREAD_MIGRATION</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_init_pdas - setup node data areas</span>
<span class="cm"> *</span>
<span class="cm"> * One time setup for Node Data Area.  Called by sn_setup().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sn_init_pdas</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cnodeid_t</span> <span class="n">cnode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate &amp; initialize the nodepda for each node.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">cnode</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodepda_t</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phys_cpuid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phys_cpuid</span><span class="p">));</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptc_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate &amp; initialize nodepda for TIOs.  For now, put them on node 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">=</span> <span class="n">num_online_nodes</span><span class="p">();</span> <span class="n">cnode</span> <span class="o">&lt;</span> <span class="n">num_cnodes</span><span class="p">;</span> <span class="n">cnode</span><span class="o">++</span><span class="p">)</span>
		<span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">alloc_bootmem_node</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodepda_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now copy the array of nodepda pointers to each nodepda.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnode</span> <span class="o">&lt;</span> <span class="n">num_cnodes</span><span class="p">;</span> <span class="n">cnode</span><span class="o">++</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pernode_pdaindr</span><span class="p">,</span> <span class="n">nodepdaindr</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up IO related platform-dependent nodepda fields.</span>
<span class="cm">	 * The following routine actually sets up the hubinfo struct</span>
<span class="cm">	 * in nodepda.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">cnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bte_init_node</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">],</span> <span class="n">cnode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the per node hubdev.  This includes IO Nodes and</span>
<span class="cm">	 * headless/memless nodes.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnode</span> <span class="o">&lt;</span> <span class="n">num_cnodes</span><span class="p">;</span> <span class="n">cnode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hubdev_init_node</span><span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">],</span> <span class="n">cnode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_cpu_init - initialize per-cpu data areas</span>
<span class="cm"> * @cpuid: cpuid of the caller</span>
<span class="cm"> *</span>
<span class="cm"> * Called during cpu initialization on each cpu as it starts.</span>
<span class="cm"> * Currently, initializes the per-cpu data area for SNIA.</span>
<span class="cm"> * Also sets up a few fields in the nodepda.  Also known as</span>
<span class="cm"> * platform_cpu_init() by the ia64 machvec code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">sn_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpuid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpuphyid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">subnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slice</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">wars_have_been_checked</span><span class="p">,</span> <span class="n">set_cpu0_number</span><span class="p">;</span>

	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">IS_MEDUSA</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sn_is_fake_prom</span><span class="p">())</span>
			<span class="n">sn_prom_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sn_prom_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Running on medusa with %s PROM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">sn_prom_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;real&quot;</span> <span class="o">:</span> <span class="s">&quot;fake&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pda</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pda</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sn_get_sn_info</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">shub2</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">nasid_bitmask</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">nasid_shift</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sn_system_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_sharing_domain_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sn_partition_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_coherency_id</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sn_region_size</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">as_shift</span> <span class="o">=</span> <span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">nasid_shift</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t check status. The SAL call is not supported on all PROMs</span>
<span class="cm">	 * but a failure is harmless.</span>
<span class="cm">	 * Architecturally, cpu_init is always called twice on cpu 0. We</span>
<span class="cm">	 * should set cpu_number on cpu 0 once.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_cpu0_number</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ia64_sn_set_cpu_number</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>
			<span class="n">set_cpu0_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ia64_sn_set_cpu_number</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The boot cpu makes this call again after platform initialization is</span>
<span class="cm">	 * complete.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PROM_FEATURE_SETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sn_get_prom_feature_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn_prom_features</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="n">cpuphyid</span> <span class="o">=</span> <span class="n">get_sapicid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sn_get_sapic_info</span><span class="p">(</span><span class="n">cpuphyid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nasid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slice</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodepdaindr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">nodepdaindr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phys_cpuid</span><span class="p">[</span><span class="n">cpuid</span><span class="p">].</span><span class="n">nasid</span> <span class="o">=</span> <span class="n">nasid</span><span class="p">;</span>
			<span class="n">nodepdaindr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phys_cpuid</span><span class="p">[</span><span class="n">cpuid</span><span class="p">].</span><span class="n">slice</span> <span class="o">=</span> <span class="n">slice</span><span class="p">;</span>
			<span class="n">nodepdaindr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">phys_cpuid</span><span class="p">[</span><span class="n">cpuid</span><span class="p">].</span><span class="n">subnode</span> <span class="o">=</span> <span class="n">subnode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cnode</span> <span class="o">=</span> <span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>

	<span class="n">sn_nodepda</span> <span class="o">=</span> <span class="n">nodepdaindr</span><span class="p">[</span><span class="n">cnode</span><span class="p">];</span>

	<span class="n">pda</span><span class="o">-&gt;</span><span class="n">led_address</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">pda</span><span class="o">-&gt;</span><span class="n">led_address</span><span class="p">))</span> <span class="p">(</span><span class="n">LED0</span> <span class="o">+</span> <span class="p">(</span><span class="n">slice</span> <span class="o">&lt;&lt;</span> <span class="n">LED_CPU_SHIFT</span><span class="p">));</span>
	<span class="n">pda</span><span class="o">-&gt;</span><span class="n">led_state</span> <span class="o">=</span> <span class="n">LED_ALWAYS_SET</span><span class="p">;</span>
	<span class="n">pda</span><span class="o">-&gt;</span><span class="n">hb_count</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pda</span><span class="o">-&gt;</span><span class="n">hb_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pda</span><span class="o">-&gt;</span><span class="n">idle_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* copy cpu 0&#39;s sn_cnodeid_to_nasid table to this cpu&#39;s */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sn_cnodeid_to_nasid</span><span class="p">,</span>
		       <span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">__sn_cnodeid_to_nasid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">__ia64_per_cpu_var</span><span class="p">(</span><span class="n">__sn_cnodeid_to_nasid</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for WARs.</span>
<span class="cm">	 * Only needs to be done once, on BSP.</span>
<span class="cm">	 * Has to be done after loop above, because it uses this cpu&#39;s</span>
<span class="cm">	 * sn_cnodeid_to_nasid table which was just initialized if this</span>
<span class="cm">	 * isn&#39;t cpu 0.</span>
<span class="cm">	 * Has to be done before assignment below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wars_have_been_checked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn_check_for_wars</span><span class="p">();</span>
		<span class="n">wars_have_been_checked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sn_hub_info</span><span class="o">-&gt;</span><span class="n">shub_1_1_found</span> <span class="o">=</span> <span class="n">shub_1_1_found</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up addresses of PIO/MEM write status registers.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="n">u64</span> <span class="n">pio1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">SH1_PIO_WRITE_STATUS_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SH1_PIO_WRITE_STATUS_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
		<span class="n">u64</span> <span class="n">pio2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">SH2_PIO_WRITE_STATUS_0</span><span class="p">,</span> <span class="n">SH2_PIO_WRITE_STATUS_2</span><span class="p">,</span>
			<span class="n">SH2_PIO_WRITE_STATUS_1</span><span class="p">,</span> <span class="n">SH2_PIO_WRITE_STATUS_3</span><span class="p">};</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">pio</span><span class="p">;</span>
		<span class="n">pio</span> <span class="o">=</span> <span class="n">is_shub1</span><span class="p">()</span> <span class="o">?</span> <span class="n">pio1</span> <span class="o">:</span> <span class="n">pio2</span><span class="p">;</span>
		<span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_addr</span> <span class="o">=</span>
		   <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_ADDR</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">pio</span><span class="p">[</span><span class="n">slice</span><span class="p">]);</span>
		<span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_write_status_val</span> <span class="o">=</span> <span class="n">is_shub1</span><span class="p">()</span> <span class="o">?</span> <span class="n">SH_PIO_WRITE_STATUS_PENDING_WRITE_COUNT_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * WAR addresses for SHUB 1.x.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_node_data</span><span class="o">-&gt;</span><span class="n">active_cpu_count</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">is_shub1</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">buddy_nasid</span><span class="p">;</span>
		<span class="n">buddy_nasid</span> <span class="o">=</span>
		    <span class="n">cnodeid_to_nasid</span><span class="p">(</span><span class="n">numa_node_id</span><span class="p">()</span> <span class="o">==</span>
				     <span class="n">num_online_nodes</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">numa_node_id</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pda</span><span class="o">-&gt;</span><span class="n">pio_shub_war_cam_addr</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBAL_MMR_ADDR</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span>
							      <span class="n">SH1_PI_CAM_CONTROL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build tables for converting between NASIDs and cnodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">board_needs_cnode</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">KLTYPE_SNIA</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">KLTYPE_TIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">build_cnode_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nasid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">lboard_t</span> <span class="o">*</span><span class="n">brd</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">physical_node_map</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">physical_node_map</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sn_cnodeid_to_nasid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">__ia64_per_cpu_var</span><span class="p">(</span><span class="n">__sn_cnodeid_to_nasid</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * First populate the tables with C/M bricks. This ensures that</span>
<span class="cm">	 * cnode == node for all C &amp; M bricks.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nasid</span> <span class="o">=</span> <span class="n">pxm_to_nasid</span><span class="p">(</span><span class="n">node_to_pxm</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
		<span class="n">sn_cnodeid_to_nasid</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nasid</span><span class="p">;</span>
		<span class="n">physical_node_map</span><span class="p">[</span><span class="n">nasid</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * num_cnodes is total number of C/M/TIO bricks. Because of the 256 node</span>
<span class="cm">	 * limit on the number of nodes, we can&#39;t use the generic node numbers </span>
<span class="cm">	 * for this. Note that num_cnodes is incremented below as TIOs or</span>
<span class="cm">	 * headless/memoryless nodes are discovered.</span>
<span class="cm">	 */</span>
	<span class="n">num_cnodes</span> <span class="o">=</span> <span class="n">num_online_nodes</span><span class="p">();</span>

	<span class="cm">/* fakeprom does not support klgraph */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_RUNNING_ON_FAKE_PROM</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Find TIOs &amp; headless/memoryless nodes and add them to the tables */</span>
	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kl_config_hdr_t</span> <span class="o">*</span><span class="n">klgraph_header</span><span class="p">;</span>
		<span class="n">nasid</span> <span class="o">=</span> <span class="n">cnodeid_to_nasid</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">klgraph_header</span> <span class="o">=</span> <span class="n">ia64_sn_get_klconfig_addr</span><span class="p">(</span><span class="n">nasid</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">klgraph_header</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">brd</span> <span class="o">=</span> <span class="n">NODE_OFFSET_TO_LBOARD</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">klgraph_header</span><span class="o">-&gt;</span><span class="n">ch_board_info</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">brd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">board_needs_cnode</span><span class="p">(</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">brd_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">physical_node_map</span><span class="p">[</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">brd_nasid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sn_cnodeid_to_nasid</span><span class="p">[</span><span class="n">num_cnodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">brd_nasid</span><span class="p">;</span>
				<span class="n">physical_node_map</span><span class="p">[</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">brd_nasid</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_cnodes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">brd</span> <span class="o">=</span> <span class="n">find_lboard_next</span><span class="p">(</span><span class="n">brd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nasid_slice_to_cpuid</span><span class="p">(</span><span class="kt">int</span> <span class="n">nasid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuid_to_nasid</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">nasid</span> <span class="o">&amp;&amp;</span>
					<span class="n">cpuid_to_slice</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">slice</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sn_prom_feature_available</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">BITS_PER_LONG</span> <span class="o">*</span> <span class="n">MAX_PROM_FEATURE_SETS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">sn_prom_features</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">sn_kernel_launch_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ignore status until we understand possible failure, if any*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_sn_kernel_launch_event</span><span class="p">())</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;KEXEC is not supported in this PROM, Please update the PROM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_prom_feature_available</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
