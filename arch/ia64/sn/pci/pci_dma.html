<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › pci › pci_dma.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pci_dma.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000,2002-2005 Silicon Graphics, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Routines for PCI DMA mapping.  See Documentation/DMA-API.txt for</span>
<span class="cm"> * a description of how these routines should be used.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/sn/intr.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibus_provider_defs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcidev.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>

<span class="cp">#define SG_ENT_VIRT_ADDRESS(sg)	(sg_virt((sg)))</span>
<span class="cp">#define SG_ENT_PHYS_ADDRESS(SG)	virt_to_phys(SG_ENT_VIRT_ADDRESS(SG))</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_supported - test a DMA mask</span>
<span class="cm"> * @dev: device to test</span>
<span class="cm"> * @mask: DMA mask to test</span>
<span class="cm"> *</span>
<span class="cm"> * Return whether the given PCI device DMA address mask can be supported</span>
<span class="cm"> * properly.  For example, if your device can only drive the low 24-bits</span>
<span class="cm"> * during PCI bus mastering, then you would pass 0x00ffffff as the mask to</span>
<span class="cm"> * this function.  Of course, SN only supports devices that have 32 or more</span>
<span class="cm"> * address bits when using the PMU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_dma_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="mh">0x7fffffff</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_set_mask - set the DMA mask</span>
<span class="cm"> * @dev: device to set</span>
<span class="cm"> * @dma_mask: new mask</span>
<span class="cm"> *</span>
<span class="cm"> * Set @dev&#39;s DMA mask if the hw supports it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sn_dma_set_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_dma_supported</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="n">dma_mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sn_dma_set_mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_alloc_coherent - allocate memory for coherent DMA</span>
<span class="cm"> * @dev: device to allocate for</span>
<span class="cm"> * @size: size of the region</span>
<span class="cm"> * @dma_handle: DMA (bus) address</span>
<span class="cm"> * @flags: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * dma_alloc_coherent() returns a pointer to a memory region suitable for</span>
<span class="cm"> * coherent DMA traffic to/from a PCI device.  On SN platforms, this means</span>
<span class="cm"> * that @dma_handle will have the %PCIIO_DMA_CMD flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This interface is usually used for &quot;command&quot; streams (e.g. the command</span>
<span class="cm"> * queue for a SCSI controller).  See Documentation/DMA-API.txt for</span>
<span class="cm"> * more information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sn_dma_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">dma_addr_t</span> <span class="o">*</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpuaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the memory.</span>
<span class="cm">	 */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">pcibus_to_node</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="n">cpuaddr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpuaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpuaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cpuaddr</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* physical addr. of the memory we just got */</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">cpuaddr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 64 bit address translations should never fail.</span>
<span class="cm">	 * 32 bit translations can fail if there are insufficient mapping</span>
<span class="cm">	 * resources.</span>
<span class="cm">	 */</span>

	<span class="o">*</span><span class="n">dma_handle</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_map_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						   <span class="n">SN_DMA_ADDR_PHYS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">dma_handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: out of ATEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpuaddr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cpuaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_pci_free_coherent - free memory associated with coherent DMAable region</span>
<span class="cm"> * @dev: device to free for</span>
<span class="cm"> * @size: size to free</span>
<span class="cm"> * @cpu_addr: kernel virtual address to free</span>
<span class="cm"> * @dma_handle: DMA address associated with this region</span>
<span class="cm"> *</span>
<span class="cm"> * Frees the memory allocated by dma_alloc_coherent(), potentially unmapping</span>
<span class="cm"> * any associated IOMMU mappings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span><span class="p">,</span>
				 <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_unmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_addr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_map_single_attrs - map a single page for DMA</span>
<span class="cm"> * @dev: device to map for</span>
<span class="cm"> * @cpu_addr: kernel virtual address of the region to map</span>
<span class="cm"> * @size: size of the region</span>
<span class="cm"> * @direction: DMA direction</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Map the region pointed to by @cpu_addr for DMA and return the</span>
<span class="cm"> * DMA address.</span>
<span class="cm"> *</span>
<span class="cm"> * We map this to the one step pcibr_dmamap_trans interface rather than</span>
<span class="cm"> * the two step pcibr_dmamap_alloc/pcibr_dmamap_addr because we have</span>
<span class="cm"> * no way of saving the dmamap handle from the alloc to later free</span>
<span class="cm"> * (which is pretty much unacceptable).</span>
<span class="cm"> *</span>
<span class="cm"> * mappings with the DMA_ATTR_WRITE_BARRIER get mapped with</span>
<span class="cm"> * dma_map_consistent() so that writes force a flush of pending DMA.</span>
<span class="cm"> * (See &quot;SGI Altix Architecture Considerations for Linux Device Drivers&quot;,</span>
<span class="cm"> * Document Number: 007-4763-001)</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: simplify our interface;</span>
<span class="cm"> *       figure out how to save dmamap handle so can use two step.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="nf">sn_dma_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cpu_addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dmabarr</span><span class="p">;</span>

	<span class="n">dmabarr</span> <span class="o">=</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WRITE_BARRIER</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">cpu_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmabarr</span><span class="p">)</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_map_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span>
							<span class="n">size</span><span class="p">,</span> <span class="n">SN_DMA_ADDR_PHYS</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					     <span class="n">SN_DMA_ADDR_PHYS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: out of ATEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_unmap_single_attrs - unamp a DMA mapped page</span>
<span class="cm"> * @dev: device to sync</span>
<span class="cm"> * @dma_addr: DMA address to sync</span>
<span class="cm"> * @size: size of region</span>
<span class="cm"> * @direction: DMA direction</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is supposed to sync the DMA region specified</span>
<span class="cm"> * by @dma_handle into the coherence domain.  On SN, we&#39;re always cache</span>
<span class="cm"> * coherent, so we just need to free any ATEs associated with this mapping.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_unmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_unmap_sg - unmap a DMA scatterlist</span>
<span class="cm"> * @dev: device to unmap</span>
<span class="cm"> * @sg: scatterlist to unmap</span>
<span class="cm"> * @nhwentries: number of scatterlist entries</span>
<span class="cm"> * @direction: DMA direction</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Unmap a set of streaming mode DMA translations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nhwentries</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nhwentries</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_unmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_dma_map_sg - map a scatterlist for DMA</span>
<span class="cm"> * @dev: device to map for</span>
<span class="cm"> * @sg: scatterlist to map</span>
<span class="cm"> * @nhwentries: number of entries</span>
<span class="cm"> * @direction: direction of the DMA transaction</span>
<span class="cm"> * @attrs: optional dma attributes</span>
<span class="cm"> *</span>
<span class="cm"> * mappings with the DMA_ATTR_WRITE_BARRIER get mapped with</span>
<span class="cm"> * dma_map_consistent() so that writes force a flush of pending DMA.</span>
<span class="cm"> * (See &quot;SGI Altix Architecture Considerations for Linux Device Drivers&quot;,</span>
<span class="cm"> * Document Number: 007-4763-001)</span>
<span class="cm"> *</span>
<span class="cm"> * Maps each entry of @sg for DMA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">nhwentries</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dma_attrs</span> <span class="o">*</span><span class="n">attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">saved_sg</span> <span class="o">=</span> <span class="n">sgl</span><span class="p">,</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="o">*</span><span class="n">provider</span> <span class="o">=</span> <span class="n">SN_PCIDEV_BUSPROVIDER</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dmabarr</span><span class="p">;</span>

	<span class="n">dmabarr</span> <span class="o">=</span> <span class="n">dma_get_attr</span><span class="p">(</span><span class="n">DMA_ATTR_WRITE_BARRIER</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup a DMA address for each entry in the scatterlist.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nhwentries</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">SG_ENT_PHYS_ADDRESS</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmabarr</span><span class="p">)</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_map_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
								<span class="n">phys_addr</span><span class="p">,</span>
								<span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
								<span class="n">SN_DMA_ADDR_PHYS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">dma_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">,</span>
						     <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
						     <span class="n">SN_DMA_ADDR_PHYS</span><span class="p">);</span>

		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span> <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: out of ATEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Free any successfully allocated entries.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sn_dma_unmap_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">saved_sg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">attrs</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_length</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nhwentries</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_sync_sg_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_dma_sync_sg_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_dma_mapping_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">sn_dma_get_required_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sn_dma_get_required_mask</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">sn_pci_get_legacy_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_legacy_mem</span> <span class="o">|</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sn_pci_legacy_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u16</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">u8</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">isrv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, try the SN_SAL_IOIF_PCI_SAFE SAL call which can work</span>
<span class="cm">	 * around hw issues at the pci bus level.  SGI proms older than</span>
<span class="cm">	 * 4.10 don&#39;t implement this.</span>
<span class="cm">	 */</span>

	<span class="n">SAL_CALL</span><span class="p">(</span><span class="n">isrv</span><span class="p">,</span> <span class="n">SN_SAL_IOIF_PCI_SAFE</span><span class="p">,</span>
		 <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		 <span class="mi">0</span><span class="p">,</span> <span class="cm">/* io */</span>
		 <span class="mi">0</span><span class="p">,</span> <span class="cm">/* read */</span>
		 <span class="n">port</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isrv</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the above failed, retry using the SAL_PROBE call which should</span>
<span class="cm">	 * be present in all proms (but which cannot work round PCI chipset</span>
<span class="cm">	 * bugs).  This code is retained for compatibility with old</span>
<span class="cm">	 * pre-4.10 proms, and should be removed at some point in the future.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_legacy_io</span> <span class="o">|</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">port</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ia64_sn_probe_mem</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sn_pci_legacy_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u16</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">u8</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">isrv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, try the SN_SAL_IOIF_PCI_SAFE SAL call which can work</span>
<span class="cm">	 * around hw issues at the pci bus level.  SGI proms older than</span>
<span class="cm">	 * 4.10 don&#39;t implement this.</span>
<span class="cm">	 */</span>

	<span class="n">SAL_CALL</span><span class="p">(</span><span class="n">isrv</span><span class="p">,</span> <span class="n">SN_SAL_IOIF_PCI_SAFE</span><span class="p">,</span>
		 <span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">bus</span><span class="p">),</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
		 <span class="mi">0</span><span class="p">,</span> <span class="cm">/* io */</span>
		 <span class="mi">1</span><span class="p">,</span> <span class="cm">/* write */</span>
		 <span class="n">port</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isrv</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the above failed, retry using the SAL_PROBE call which should</span>
<span class="cm">	 * be present in all proms (but which cannot work round PCI chipset</span>
<span class="cm">	 * bugs).  This code is retained for compatibility with old</span>
<span class="cm">	 * pre-4.10 proms, and should be removed at some point in the future.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put the phys addr in uncached space */</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">SN_PCIBUS_BUSSOFT</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bs_legacy_io</span> <span class="o">|</span> <span class="n">__IA64_UNCACHED_OFFSET</span><span class="p">;</span>
	<span class="n">paddr</span> <span class="o">+=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">paddr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_map_ops</span> <span class="n">sn_dma_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc</span>			<span class="o">=</span> <span class="n">sn_dma_alloc_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free</span>			<span class="o">=</span> <span class="n">sn_dma_free_coherent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_page</span>		<span class="o">=</span> <span class="n">sn_dma_map_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_page</span>		<span class="o">=</span> <span class="n">sn_dma_unmap_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_sg</span>			<span class="o">=</span> <span class="n">sn_dma_map_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap_sg</span>		<span class="o">=</span> <span class="n">sn_dma_unmap_sg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_cpu</span> 	<span class="o">=</span> <span class="n">sn_dma_sync_single_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_cpu</span>	<span class="o">=</span> <span class="n">sn_dma_sync_sg_for_cpu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_single_for_device</span> <span class="o">=</span> <span class="n">sn_dma_sync_single_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_sg_for_device</span>	<span class="o">=</span> <span class="n">sn_dma_sync_sg_for_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mapping_error</span>		<span class="o">=</span> <span class="n">sn_dma_mapping_error</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_supported</span>		<span class="o">=</span> <span class="n">sn_dma_supported</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">sn_dma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sn_dma_ops</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
