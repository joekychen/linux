<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › pci › tioca_provider.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tioca_provider.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2005 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/io.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcidev.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibus_provider_defs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/tioca_provider.h&gt;</span>

<span class="n">u32</span> <span class="n">tioca_gart_found</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tioca_gart_found</span><span class="p">);</span>	<span class="cm">/* used by agp-sgi */</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tioca_list</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tioca_list</span><span class="p">);</span>	<span class="cm">/* used by agp-sgi */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">tioca_gart_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_gart_init - Initialize SGI TIOCA GART</span>
<span class="cm"> * @tioca_common: ptr to common prom/kernel struct identifying the </span>
<span class="cm"> *</span>
<span class="cm"> * If the indicated tioca has devices present, initialize its associated</span>
<span class="cm"> * GART MMR&#39;s and kernel memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">tioca_gart_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="n">tioca_kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ap_reg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">tioca_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ca_base</span><span class="p">;</span>

	<span class="n">tioca_common</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">;</span>
	<span class="n">ca_base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_devices</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ap_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate aperature size</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">CA_APERATURE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3ff</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 4MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3fe</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 8MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3fc</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 16MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">32</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3f8</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 32 MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">64</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3f0</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 64 MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">128</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3e0</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 128 MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">256</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3c0</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 256 MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">512</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x380</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 512 MB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1024</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x300</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 1GB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2048</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x200</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 2GB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4096</span>:
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x000</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_AP_SIZE_SHFT</span><span class="p">);</span>	<span class="cm">/* 4 GB */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:  Invalid CA_APERATURE_SIZE &quot;</span>
		       <span class="s">&quot;0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">CA_APERATURE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up other aperature parameters</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;=</span> <span class="mi">16384</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
		<span class="n">ap_reg</span> <span class="o">|=</span> <span class="n">CA_GART_PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_size</span> <span class="o">=</span> <span class="n">CA_APERATURE_SIZE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_bus_base</span> <span class="o">=</span> <span class="n">CA_APERATURE_BASE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_entries</span> <span class="o">=</span>
	    <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_size</span> <span class="o">/</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>

	<span class="n">ap_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CA_GART_AP_ENB_AGP</span> <span class="o">|</span> <span class="n">CA_GART_AP_ENB_PCI</span><span class="p">);</span>
	<span class="n">ap_reg</span> <span class="o">|=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_bus_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and set up the GART</span>
<span class="cm">	 */</span>

	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_size</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span>
	    <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_closest_node</span><span class="p">,</span>
			     <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
			     <span class="n">get_order</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:  Could not allocate &quot;</span>
		       <span class="s">&quot;%llu bytes (order %d) for GART</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_size</span><span class="p">,</span>
		       <span class="n">get_order</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_size</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_coretalk_addr</span> <span class="o">=</span>
	    <span class="n">PHYS_TO_TIODMA</span><span class="p">(</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute PCI/AGP convenience fields </span>
<span class="cm">	 */</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">CA_PCI32_MAPPED_BASE</span> <span class="o">-</span> <span class="n">CA_APERATURE_BASE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_base</span> <span class="o">=</span> <span class="n">CA_PCI32_MAPPED_BASE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_size</span> <span class="o">=</span> <span class="n">CA_PCI32_MAPPED_SIZE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_start</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_base</span> <span class="o">=</span>
	    <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_coretalk_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart</span><span class="p">[</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_start</span><span class="p">];</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_entries</span> <span class="o">=</span>
	    <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_size</span> <span class="o">/</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_pagemap</span> <span class="o">=</span>
	    <span class="n">kzalloc</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_entries</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_pagemap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart</span><span class="p">,</span>
			   <span class="n">get_order</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_size</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">CA_AGP_MAPPED_BASE</span> <span class="o">-</span> <span class="n">CA_APERATURE_BASE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxap_base</span> <span class="o">=</span> <span class="n">CA_AGP_MAPPED_BASE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxap_size</span> <span class="o">=</span> <span class="n">CA_AGP_MAPPED_SIZE</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxgart_start</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxgart_base</span> <span class="o">=</span>
	    <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_coretalk_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxgart</span> <span class="o">=</span>
	    <span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart</span><span class="p">[</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxgart_start</span><span class="p">];</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxgart_entries</span> <span class="o">=</span>
	    <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gfxap_size</span> <span class="o">/</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * various control settings:</span>
<span class="cm">	 *      use agp op-combining</span>
<span class="cm">	 *      use GET semantics to fetch memory</span>
<span class="cm">	 *      participate in coherency domain</span>
<span class="cm">	 * 	DISABLE GART PREFETCHING due to hw bug tracked in SGI PV930029</span>
<span class="cm">	 */</span>

	<span class="n">__sn_setq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_control1</span><span class="p">,</span>
			<span class="n">CA_AGPDMA_OP_ENB_COMBDELAY</span><span class="p">);</span>	<span class="cm">/* PV895469 ? */</span>
	<span class="n">__sn_clrq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_control2</span><span class="p">,</span> <span class="n">CA_GART_MEM_PARAM</span><span class="p">);</span>
	<span class="n">__sn_setq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_control2</span><span class="p">,</span>
			<span class="p">(</span><span class="mh">0x2ull</span> <span class="o">&lt;&lt;</span> <span class="n">CA_GART_MEM_PARAM_SHFT</span><span class="p">));</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_iscoherent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__sn_clrq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_control2</span><span class="p">,</span>
	    		<span class="p">(</span><span class="n">CA_GART_WR_PREFETCH_ENB</span> <span class="o">|</span> <span class="n">CA_GART_RD_PREFETCH_ENB</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unmask GART fetch error interrupts.  Clear residual errors first.</span>
<span class="cm">	 */</span>

	<span class="n">writeq</span><span class="p">(</span><span class="n">CA_GART_FETCH_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_int_status_alias</span><span class="p">);</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">CA_GART_FETCH_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_mult_error_alias</span><span class="p">);</span>
	<span class="n">__sn_clrq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_int_mask</span><span class="p">,</span> <span class="n">CA_GART_FETCH_ERR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the aperature and gart registers in TIOCA</span>
<span class="cm">	 */</span>

	<span class="n">writeq</span><span class="p">(</span><span class="n">ap_reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_gart_aperature</span><span class="p">);</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_gart_coretalk_addr</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_gart_ptr_table</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_fastwrite_enable - enable AGP FW for a tioca and its functions</span>
<span class="cm"> * @tioca_kernel: structure representing the CA</span>
<span class="cm"> *</span>
<span class="cm"> * Given a CA, scan all attached functions making sure they all support</span>
<span class="cm"> * FastWrite.  If so, enable FastWrite for all functions and the CA itself.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">tioca_fastwrite_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="n">tioca_kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cap_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tioca_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">common</span><span class="p">;</span>

	<span class="n">common</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan all vga controllers on this bus making sure they all</span>
<span class="cm">	 * support FW.  If not, return.</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="p">(</span><span class="n">PCI_CLASS_DISPLAY_VGA</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cap_ptr</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_AGP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_ptr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>	<span class="cm">/* no AGP CAP means no FW */</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap_ptr</span> <span class="o">+</span> <span class="n">PCI_AGP_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">PCI_AGP_STATUS_FW</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>	<span class="cm">/* function doesn&#39;t support FW */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set fw for all vga fn&#39;s</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="p">(</span><span class="n">PCI_CLASS_DISPLAY_VGA</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cap_ptr</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_AGP</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap_ptr</span> <span class="o">+</span> <span class="n">PCI_AGP_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">PCI_AGP_COMMAND_FW</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cap_ptr</span> <span class="o">+</span> <span class="n">PCI_AGP_COMMAND</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ca&#39;s fw to match</span>
<span class="cm">	 */</span>

	<span class="n">tioca_base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span><span class="o">*</span><span class="p">)</span><span class="n">common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">__sn_setq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_base</span><span class="o">-&gt;</span><span class="n">ca_control1</span><span class="p">,</span> <span class="n">CA_AGP_FW_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tioca_fastwrite_enable</span><span class="p">);</span>	<span class="cm">/* used by agp-sgi */</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_dma_d64 - create a DMA mapping using 64-bit direct mode</span>
<span class="cm"> * @paddr: system physical address</span>
<span class="cm"> *</span>
<span class="cm"> * Map @paddr into 64-bit CA bus space.  No device context is necessary.</span>
<span class="cm"> * Bits 53:0 come from the coretalk address.  We just need to mask in the</span>
<span class="cm"> * following optional bits of the 64-bit pci address:</span>
<span class="cm"> *</span>
<span class="cm"> * 63:60 - Coretalk Packet Type -  0x1 for Mem Get/Put (coherent)</span>
<span class="cm"> *                                 0x2 for PIO (non-coherent)</span>
<span class="cm"> *                                 We will always use 0x1</span>
<span class="cm"> * 55:55 - Swap bytes		   Currently unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioca_dma_d64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">;</span>

	<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">PHYS_TO_TIODMA</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bus_addr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bus_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">54</span><span class="p">);</span>

	<span class="cm">/* Set upper nibble to Cache Coherent Memory op */</span>
	<span class="n">bus_addr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">60</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_dma_d48 - create a DMA mapping using 48-bit direct mode</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @paddr: system physical address</span>
<span class="cm"> *</span>
<span class="cm"> * Map @paddr into 64-bit bus space of the CA associated with @pcidev_info.</span>
<span class="cm"> *</span>
<span class="cm"> * The CA agp 48 bit direct address falls out as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * When direct mapping AGP addresses, the 48 bit AGP address is</span>
<span class="cm"> * constructed as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * [47:40] - Low 8 bits of the page Node ID extracted from coretalk</span>
<span class="cm"> *              address [47:40].  The upper 8 node bits are fixed</span>
<span class="cm"> *              and come from the xxx register bits [5:0]</span>
<span class="cm"> * [39:38] - Chiplet ID extracted from coretalk address [39:38]</span>
<span class="cm"> * [37:00] - node offset extracted from coretalk address [37:00]</span>
<span class="cm"> * </span>
<span class="cm"> * Since the node id in general will be non-zero, and the chiplet id</span>
<span class="cm"> * will always be non-zero, it follows that the device must support</span>
<span class="cm"> * a dma mask of at least 0xffffffffff (40 bits) to target node 0</span>
<span class="cm"> * and in general should be 0xffffffffffff (48 bits) to target nodes</span>
<span class="cm"> * up to 255.  Nodes above 255 need the support of the xxx register,</span>
<span class="cm"> * and so a given CA can only directly target nodes in the range</span>
<span class="cm"> * xxx - xxx+255.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioca_dma_d48</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">tioca_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ca_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ct_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_upper</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">agp_dma_extn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">tioca_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">ca_base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>

	<span class="n">ct_addr</span> <span class="o">=</span> <span class="n">PHYS_TO_TIODMA</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ct_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bus_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="p">(</span><span class="n">ct_addr</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffUL</span><span class="p">);</span>
	<span class="n">node_upper</span> <span class="o">=</span> <span class="n">ct_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node_upper</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:  coretalk addr 0x%p node id out &quot;</span>
		       <span class="s">&quot;of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ct_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">agp_dma_extn</span> <span class="o">=</span> <span class="n">__sn_readq_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_base</span><span class="o">-&gt;</span><span class="n">ca_agp_dma_addr_extn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_upper</span> <span class="o">!=</span> <span class="p">(</span><span class="n">agp_dma_extn</span> <span class="o">&gt;&gt;</span> <span class="n">CA_AGP_DMA_NODE_ID_SHFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:  coretalk upper node (%u) &quot;</span>
		       <span class="s">&quot;mismatch with ca_agp_dma_addr_extn (%llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span>
		       <span class="n">node_upper</span><span class="p">,</span> <span class="p">(</span><span class="n">agp_dma_extn</span> <span class="o">&gt;&gt;</span> <span class="n">CA_AGP_DMA_NODE_ID_SHFT</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_dma_mapped - create a DMA mapping using a CA GART </span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @paddr: host physical address to map</span>
<span class="cm"> * @req_size: len (bytes) to map</span>
<span class="cm"> *</span>
<span class="cm"> * Map @paddr into CA address space using the GART mechanism.  The mapped</span>
<span class="cm"> * dma_addr_t is guaranteed to be contiguous in CA bus space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dma_addr_t</span>
<span class="nf">tioca_dma_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">req_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ps</span><span class="p">,</span> <span class="n">ps_shift</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xio_addr</span><span class="p">,</span> <span class="n">end_xio_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">tioca_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="n">tioca_kern</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_dmamap</span> <span class="o">*</span><span class="n">ca_dmamap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">tioca_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">tioca_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="p">)</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_kernel_private</span><span class="p">;</span>

	<span class="n">xio_addr</span> <span class="o">=</span> <span class="n">PHYS_TO_TIODMA</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xio_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate a map struct</span>
<span class="cm">	 */</span>

	<span class="n">ca_dmamap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_dmamap</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ca_dmamap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">map_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locate free entries that can hold req_size.  Account for</span>
<span class="cm">	 * unaligned start/length when allocating.</span>
<span class="cm">	 */</span>

	<span class="n">ps</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_ap_pagesize</span><span class="p">;</span>	<span class="cm">/* will be power of 2 */</span>
	<span class="n">ps_shift</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">end_xio_addr</span> <span class="o">=</span> <span class="n">xio_addr</span> <span class="o">+</span> <span class="n">req_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_xio_addr</span> <span class="o">&gt;&gt;</span> <span class="n">ps_shift</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">xio_addr</span> <span class="o">&gt;&gt;</span> <span class="n">ps_shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_pagemap</span><span class="p">;</span>
	<span class="n">mapsize</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_entries</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">bitmap_find_next_zero_area</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">mapsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ca_dmamap</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">map_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bitmap_set</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">entries</span><span class="p">);</span>

	<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">entry</span> <span class="o">*</span> <span class="n">ps</span><span class="p">);</span>

	<span class="n">ca_dmamap</span><span class="o">-&gt;</span><span class="n">cad_dma_addr</span> <span class="o">=</span> <span class="n">bus_addr</span><span class="p">;</span>
	<span class="n">ca_dmamap</span><span class="o">-&gt;</span><span class="n">cad_gart_size</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
	<span class="n">ca_dmamap</span><span class="o">-&gt;</span><span class="n">cad_gart_entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ca_dmamap</span><span class="o">-&gt;</span><span class="n">cad_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_dmamaps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xio_addr</span> <span class="o">%</span> <span class="n">ps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">tioca_paddr_to_gart</span><span class="p">(</span><span class="n">xio_addr</span><span class="p">);</span>
		<span class="n">bus_addr</span> <span class="o">+=</span> <span class="n">xio_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">xio_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">xio_addr</span> <span class="o">+=</span> <span class="n">ps</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">xio_addr</span> <span class="o">&lt;</span> <span class="n">end_xio_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">tioca_paddr_to_gart</span><span class="p">(</span><span class="n">xio_addr</span><span class="p">);</span>
		<span class="n">xio_addr</span> <span class="o">+=</span> <span class="n">ps</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioca_tlbflush</span><span class="p">(</span><span class="n">tioca_kern</span><span class="p">);</span>

<span class="nl">map_return:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_dma_unmap - release CA mapping resources</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @bus_addr: bus address returned by an earlier tioca_dma_map</span>
<span class="cm"> * @dir: mapping direction (unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Locate mapping resources associated with @bus_addr and release them.</span>
<span class="cm"> * For mappings created using the direct modes (64 or 48) there are no</span>
<span class="cm"> * resources to release.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tioca_dma_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">tioca_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="n">tioca_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_dmamap</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">tioca_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">tioca_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="p">)</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_kernel_private</span><span class="p">;</span>

	<span class="cm">/* return straight away if this isn&#39;t be a mapped address */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus_addr</span> <span class="o">&lt;</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_base</span> <span class="o">||</span>
	    <span class="n">bus_addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_base</span> <span class="o">+</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pciap_size</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_dmamaps</span><span class="p">,</span> <span class="n">cad_list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">cad_dma_addr</span> <span class="o">==</span> <span class="n">bus_addr</span><span class="p">)</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">cad_gart_entry</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">cad_gart_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entry</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart_pagemap</span><span class="p">);</span>
		<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_pcigart</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tioca_tlbflush</span><span class="p">(</span><span class="n">tioca_kern</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">cad_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_dma_map - map pages for PCI DMA</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @paddr: host physical address to map</span>
<span class="cm"> * @byte_count: bytes to map</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main wrapper for mapping host physical pages to CA PCI space.</span>
<span class="cm"> * The mapping mode used is based on the devices dma_mask.  As a last resort</span>
<span class="cm"> * use the GART mapped mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioca_dma_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mapaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not supported for now ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_flags</span> <span class="o">&amp;</span> <span class="n">SN_DMA_MSI</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If card is 64 or 48 bit addressable, use a direct mapping.  32</span>
<span class="cm">	 * bit direct is so restrictive w.r.t. where the memory resides that</span>
<span class="cm">	 * we don&#39;t use it even though CA has some support.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioca_dma_d64</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">==</span> <span class="mh">0xffffffffffffUL</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioca_dma_d48</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Last resort ... use PCI portion of CA GART */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioca_dma_mapped</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mapaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_error_intr_handler - SGI TIO CA error interrupt handler</span>
<span class="cm"> * @irq: unused</span>
<span class="cm"> * @arg: pointer to tioca_common struct for the given CA</span>
<span class="cm"> *</span>
<span class="cm"> * Handle a CA error interrupt.  Simply a wrapper around a SAL call which</span>
<span class="cm"> * defers processing to the SGI prom.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">tioca_error_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">soft</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">segment</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">busnum</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">segment</span> <span class="o">=</span> <span class="n">soft</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_persist_segment</span><span class="p">;</span>
	<span class="n">busnum</span> <span class="o">=</span> <span class="n">soft</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_ERROR_INTERRUPT</span><span class="p">,</span>
			<span class="n">segment</span><span class="p">,</span> <span class="n">busnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_bus_fixup - perform final PCI fixup for a TIO CA bus</span>
<span class="cm"> * @prom_bussoft: Common prom/kernel struct representing the bus</span>
<span class="cm"> *</span>
<span class="cm"> * Replicates the tioca_common pointed to by @prom_bussoft in kernel</span>
<span class="cm"> * space.  Allocates and initializes a kernel-only area for a given CA,</span>
<span class="cm"> * and sets up an irq for handling CA error interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * On successful setup, returns the kernel version of tioca_common back to</span>
<span class="cm"> * the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">tioca_bus_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">prom_bussoft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tioca_common</span> <span class="o">*</span><span class="n">tioca_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioca_kernel</span> <span class="o">*</span><span class="n">tioca_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="cm">/* sanity check prom rev */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shub1</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">sn_sal_rev</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mh">0x0406</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:  SGI prom rev 4.06 or greater required &quot;</span>
		     <span class="s">&quot;for tioca support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate kernel bus soft and copy from prom.</span>
<span class="cm">	 */</span>

	<span class="n">tioca_common</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">prom_bussoft</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_common</span><span class="p">),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tioca_common</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="n">ioremap</span><span class="p">(</span><span class="n">REGION_OFFSET</span><span class="p">(</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_base</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_common</span><span class="p">));</span>

	<span class="cm">/* init kernel-private area */</span>

	<span class="n">tioca_kern</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioca_kernel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tioca_kern</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tioca_common</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_common</span> <span class="o">=</span> <span class="n">tioca_common</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_dmamaps</span><span class="p">);</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_closest_node</span> <span class="o">=</span>
	    <span class="n">nasid_to_cnodeid</span><span class="p">(</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_closest_nasid</span><span class="p">);</span>
	<span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_kernel_private</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">tioca_kern</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_persist_segment</span><span class="p">,</span>
		<span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_devices</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>

	<span class="cm">/* init GART */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tioca_gart_init</span><span class="p">(</span><span class="n">tioca_kern</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tioca_kern</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tioca_common</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioca_gart_found</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioca_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">SGI_TIOCA_ERROR</span><span class="p">,</span>
			<span class="n">tioca_error_intr_handler</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;TIOCA error&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tioca_common</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;%s:  Unable to get irq %d.  &quot;</span>
		       <span class="s">&quot;Error interrupts won&#39;t be routed for TIOCA bus %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">SGI_TIOCA_ERROR</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tioca_common</span><span class="o">-&gt;</span><span class="n">ca_common</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">);</span>

	<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">SGI_TIOCA_ERROR</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>
	<span class="n">sn_set_err_irq_affinity</span><span class="p">(</span><span class="n">SGI_TIOCA_ERROR</span><span class="p">);</span>

	<span class="cm">/* Setup locality information */</span>
	<span class="n">controller</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">tioca_kern</span><span class="o">-&gt;</span><span class="n">ca_closest_node</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tioca_common</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="n">tioca_pci_interfaces</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_map</span> <span class="o">=</span> <span class="n">tioca_dma_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_map_consistent</span> <span class="o">=</span> <span class="n">tioca_dma_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_unmap</span> <span class="o">=</span> <span class="n">tioca_dma_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_fixup</span> <span class="o">=</span> <span class="n">tioca_bus_fixup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_interrupt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target_interrupt</span> <span class="o">=</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * tioca_init_provider - init SN PCI provider ops for TIO CA</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">tioca_init_provider</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">PCIIO_ASIC_TYPE_TIOCA</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tioca_pci_interfaces</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
