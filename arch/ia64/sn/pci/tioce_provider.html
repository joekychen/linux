<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › ia64 › sn › pci › tioce_provider.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tioce_provider.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2006 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>
<span class="cp">#include &lt;asm/sn/addrs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/io.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcidev.h&gt;</span>
<span class="cp">#include &lt;asm/sn/pcibus_provider_defs.h&gt;</span>
<span class="cp">#include &lt;asm/sn/tioce_provider.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * 1/26/2006</span>
<span class="cm"> *</span>
<span class="cm"> * WAR for SGI PV 944642.  For revA TIOCE, need to use the following recipe</span>
<span class="cm"> * (taken from the above PV) before and after accessing tioce internal MMR&#39;s</span>
<span class="cm"> * to avoid tioce lockups.</span>
<span class="cm"> *</span>
<span class="cm"> * The recipe as taken from the PV:</span>
<span class="cm"> *</span>
<span class="cm"> *	if(mmr address &lt; 0x45000) {</span>
<span class="cm"> *		if(mmr address == 0 or 0x80)</span>
<span class="cm"> *			mmr wrt or read address 0xc0</span>
<span class="cm"> *		else if(mmr address == 0x148 or 0x200)</span>
<span class="cm"> *			mmr wrt or read address 0x28</span>
<span class="cm"> *		else</span>
<span class="cm"> *			mmr wrt or read address 0x158</span>
<span class="cm"> *</span>
<span class="cm"> *		do desired mmr access (rd or wrt)</span>
<span class="cm"> *</span>
<span class="cm"> *		if(mmr address == 0x100)</span>
<span class="cm"> *			mmr wrt or read address 0x38</span>
<span class="cm"> *		mmr wrt or read address 0xb050</span>
<span class="cm"> *	} else</span>
<span class="cm"> *		do desired mmr access</span>
<span class="cm"> *</span>
<span class="cm"> * According to hw, we can use reads instead of writes to the above address</span>
<span class="cm"> *</span>
<span class="cm"> * Note this WAR can only to be used for accessing internal MMR&#39;s in the</span>
<span class="cm"> * TIOCE Coretalk Address Range 0x0 - 0x07ff_ffff.  This includes the</span>
<span class="cm"> * &quot;Local CE Registers and Memories&quot; and &quot;PCI Compatible Config Space&quot; address</span>
<span class="cm"> * spaces from table 2-1 of the &quot;CE Programmer&#39;s Reference Overview&quot; document.</span>
<span class="cm"> *</span>
<span class="cm"> * All registers defined in struct tioce will meet that criteria.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="kr">inline</span>
<span class="nf">tioce_mmr_war_pre</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">kern</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmr_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mmr_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mmr_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_rev</span> <span class="o">!=</span> <span class="n">TIOCE_REV_A</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mmr_base</span> <span class="o">=</span> <span class="n">kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">mmr_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mmr_addr</span> <span class="o">-</span> <span class="n">mmr_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmr_offset</span> <span class="o">&lt;</span> <span class="mh">0x45000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">mmr_war_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mmr_offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mmr_offset</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span>
			<span class="n">mmr_war_offset</span> <span class="o">=</span> <span class="mh">0xc0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mmr_offset</span> <span class="o">==</span> <span class="mh">0x148</span> <span class="o">||</span> <span class="n">mmr_offset</span> <span class="o">==</span> <span class="mh">0x200</span><span class="p">)</span>
			<span class="n">mmr_war_offset</span> <span class="o">=</span> <span class="mh">0x28</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mmr_war_offset</span> <span class="o">=</span> <span class="mh">0x158</span><span class="p">;</span>

		<span class="n">readq_relaxed</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmr_base</span> <span class="o">+</span> <span class="n">mmr_war_offset</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="kr">inline</span>
<span class="nf">tioce_mmr_war_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">kern</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmr_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mmr_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mmr_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_rev</span> <span class="o">!=</span> <span class="n">TIOCE_REV_A</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mmr_base</span> <span class="o">=</span> <span class="n">kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">mmr_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mmr_addr</span> <span class="o">-</span> <span class="n">mmr_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmr_offset</span> <span class="o">&lt;</span> <span class="mh">0x45000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mmr_offset</span> <span class="o">==</span> <span class="mh">0x100</span><span class="p">)</span>
			<span class="n">readq_relaxed</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmr_base</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">));</span>
		<span class="n">readq_relaxed</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmr_base</span> <span class="o">+</span> <span class="mh">0xb050</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* load mmr contents into a variable */</span>
<span class="cp">#define tioce_mmr_load(kern, mmrp, varp) do {\</span>
<span class="cp">	tioce_mmr_war_pre(kern, mmrp); \</span>
<span class="cp">	*(varp) = readq_relaxed(mmrp); \</span>
<span class="cp">	tioce_mmr_war_post(kern, mmrp); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* store variable contents into mmr */</span>
<span class="cp">#define tioce_mmr_store(kern, mmrp, varp) do {\</span>
<span class="cp">	tioce_mmr_war_pre(kern, mmrp); \</span>
<span class="cp">	writeq(*varp, mmrp); \</span>
<span class="cp">	tioce_mmr_war_post(kern, mmrp); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* store immediate value into mmr */</span>
<span class="cp">#define tioce_mmr_storei(kern, mmrp, val) do {\</span>
<span class="cp">	tioce_mmr_war_pre(kern, mmrp); \</span>
<span class="cp">	writeq(val, mmrp); \</span>
<span class="cp">	tioce_mmr_war_post(kern, mmrp); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* set bits (immediate value) into mmr */</span>
<span class="cp">#define tioce_mmr_seti(kern, mmrp, bits) do {\</span>
<span class="cp">	u64 tmp; \</span>
<span class="cp">	tioce_mmr_load(kern, mmrp, &amp;tmp); \</span>
<span class="cp">	tmp |= (bits); \</span>
<span class="cp">	tioce_mmr_store(kern, mmrp, &amp;tmp); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* clear bits (immediate value) into mmr */</span>
<span class="cp">#define tioce_mmr_clri(kern, mmrp, bits) do { \</span>
<span class="cp">	u64 tmp; \</span>
<span class="cp">	tioce_mmr_load(kern, mmrp, &amp;tmp); \</span>
<span class="cp">	tmp &amp;= ~(bits); \</span>
<span class="cp">	tioce_mmr_store(kern, mmrp, &amp;tmp); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * Bus address ranges for the 5 flavors of TIOCE DMA</span>
<span class="cm"> */</span>

<span class="cp">#define TIOCE_D64_MIN	0x8000000000000000UL</span>
<span class="cp">#define TIOCE_D64_MAX	0xffffffffffffffffUL</span>
<span class="cp">#define TIOCE_D64_ADDR(a)	((a) &gt;= TIOCE_D64_MIN)</span>

<span class="cp">#define TIOCE_D32_MIN	0x0000000080000000UL</span>
<span class="cp">#define TIOCE_D32_MAX	0x00000000ffffffffUL</span>
<span class="cp">#define TIOCE_D32_ADDR(a)	((a) &gt;= TIOCE_D32_MIN &amp;&amp; (a) &lt;= TIOCE_D32_MAX)</span>

<span class="cp">#define TIOCE_M32_MIN	0x0000000000000000UL</span>
<span class="cp">#define TIOCE_M32_MAX	0x000000007fffffffUL</span>
<span class="cp">#define TIOCE_M32_ADDR(a)	((a) &gt;= TIOCE_M32_MIN &amp;&amp; (a) &lt;= TIOCE_M32_MAX)</span>

<span class="cp">#define TIOCE_M40_MIN	0x0000004000000000UL</span>
<span class="cp">#define TIOCE_M40_MAX	0x0000007fffffffffUL</span>
<span class="cp">#define TIOCE_M40_ADDR(a)	((a) &gt;= TIOCE_M40_MIN &amp;&amp; (a) &lt;= TIOCE_M40_MAX)</span>

<span class="cp">#define TIOCE_M40S_MIN	0x0000008000000000UL</span>
<span class="cp">#define TIOCE_M40S_MAX	0x000000ffffffffffUL</span>
<span class="cp">#define TIOCE_M40S_ADDR(a)	((a) &gt;= TIOCE_M40S_MIN &amp;&amp; (a) &lt;= TIOCE_M40S_MAX)</span>

<span class="cm">/*</span>
<span class="cm"> * ATE manipulation macros.</span>
<span class="cm"> */</span>

<span class="cp">#define ATE_PAGESHIFT(ps)	(__ffs(ps))</span>
<span class="cp">#define ATE_PAGEMASK(ps)	((ps)-1)</span>

<span class="cp">#define ATE_PAGE(x, ps) ((x) &gt;&gt; ATE_PAGESHIFT(ps))</span>
<span class="cp">#define ATE_NPAGES(start, len, pagesize) \</span>
<span class="cp">	(ATE_PAGE((start)+(len)-1, pagesize) - ATE_PAGE(start, pagesize) + 1)</span>

<span class="cp">#define ATE_VALID(ate)	((ate) &amp; (1UL &lt;&lt; 63))</span>
<span class="cp">#define ATE_MAKE(addr, ps, msi) \</span>
<span class="cp">	(((addr) &amp; ~ATE_PAGEMASK(ps)) | (1UL &lt;&lt; 63) | ((msi)?(1UL &lt;&lt; 62):0))</span>

<span class="cm">/*</span>
<span class="cm"> * Flavors of ate-based mapping supported by tioce_alloc_map()</span>
<span class="cm"> */</span>

<span class="cp">#define TIOCE_ATE_M32	1</span>
<span class="cp">#define TIOCE_ATE_M40	2</span>
<span class="cp">#define TIOCE_ATE_M40S	3</span>

<span class="cp">#define KB(x)	((u64)(x) &lt;&lt; 10)</span>
<span class="cp">#define MB(x)	((u64)(x) &lt;&lt; 20)</span>
<span class="cp">#define GB(x)	((u64)(x) &lt;&lt; 30)</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma_d64 - create a DMA mapping using 64-bit direct mode</span>
<span class="cm"> * @ct_addr: system coretalk address</span>
<span class="cm"> *</span>
<span class="cm"> * Map @ct_addr into 64-bit CE bus space.  No device context is necessary</span>
<span class="cm"> * and no CE mapping are consumed.</span>
<span class="cm"> *</span>
<span class="cm"> * Bits 53:0 come from the coretalk address.  The remaining bits are set as</span>
<span class="cm"> * follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 63    - must be 1 to indicate d64 mode to CE hardware</span>
<span class="cm"> * 62    - barrier bit ... controlled with tioce_dma_barrier()</span>
<span class="cm"> * 61    - msi bit ... specified through dma_flags</span>
<span class="cm"> * 60:54 - reserved, MBZ</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_dma_d64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bus_addr</span><span class="p">;</span>

	<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">ct_addr</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_flags</span> <span class="o">&amp;</span> <span class="n">SN_DMA_MSI</span><span class="p">)</span>
		<span class="n">bus_addr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">61</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcidev_to_tioce - return misc ce related pointers given a pci_dev</span>
<span class="cm"> * @pci_dev: pci device context</span>
<span class="cm"> * @base: ptr to store struct tioce_mmr * for the CE holding this device</span>
<span class="cm"> * @kernel: ptr to store struct tioce_kernel * for the CE holding this device</span>
<span class="cm"> * @port: ptr to store the CE port number that this device is on</span>
<span class="cm"> *</span>
<span class="cm"> * Return pointers to various CE-related structures for the CE upstream of</span>
<span class="cm"> * @pci_dev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pcidev_to_tioce</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">**</span><span class="n">base</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">**</span><span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">ce_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kernel</span><span class="p">;</span>

	<span class="n">pcidev_info</span> <span class="o">=</span> <span class="n">SN_PCIDEV_INFO</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">ce_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">ce_kernel</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_kernel_private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
		<span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">ce_kernel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we use port as a zero-based value internally, even though the</span>
<span class="cm">	 * documentation is 1-based.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span>
		<span class="o">*</span><span class="n">port</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;</span> <span class="n">ce_kernel</span><span class="o">-&gt;</span><span class="n">ce_port1_secondary</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_alloc_map - Given a coretalk address, map it to pcie bus address</span>
<span class="cm"> * space using one of the various ATE-based address modes.</span>
<span class="cm"> * @ce_kern: tioce context</span>
<span class="cm"> * @type: map mode to use</span>
<span class="cm"> * @port: 0-based port that the requesting device is downstream of</span>
<span class="cm"> * @ct_addr: the coretalk address to map</span>
<span class="cm"> * @len: number of bytes to map</span>
<span class="cm"> *</span>
<span class="cm"> * Given the addressing type, set up various parameters that define the</span>
<span class="cm"> * ATE pool to use.  Search for a contiguous block of entries to cover the</span>
<span class="cm"> * length, and if enough resources exist, fill in the ATEs and construct a</span>
<span class="cm"> * tioce_dmamap struct to track the mapping.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_alloc_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nates</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pagesize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msi_capable</span><span class="p">,</span> <span class="n">msi_wanted</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ate_shadow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ate_reg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bus_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_dmamap</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

	<span class="n">ce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCE_ATE_M32</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The first 64 entries of the ate3240 pool are dedicated to</span>
<span class="cm">		 * super-page (TIOCE_ATE_M40S) mode.</span>
<span class="cm">		 */</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="n">TIOCE_NUM_M3240_ATES</span> <span class="o">-</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">ate_shadow</span> <span class="o">=</span> <span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_shadow</span><span class="p">;</span>
		<span class="n">ate_reg</span> <span class="o">=</span> <span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate3240</span><span class="p">;</span>
		<span class="n">pagesize</span> <span class="o">=</span> <span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_pagesize</span><span class="p">;</span>
		<span class="n">bus_base</span> <span class="o">=</span> <span class="n">TIOCE_M32_MIN</span><span class="p">;</span>
		<span class="n">msi_capable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCE_ATE_M40</span>:
		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="n">TIOCE_NUM_M40_ATES</span><span class="p">;</span>
		<span class="n">ate_shadow</span> <span class="o">=</span> <span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate40_shadow</span><span class="p">;</span>
		<span class="n">ate_reg</span> <span class="o">=</span> <span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate40</span><span class="p">;</span>
		<span class="n">pagesize</span> <span class="o">=</span> <span class="n">MB</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
		<span class="n">bus_base</span> <span class="o">=</span> <span class="n">TIOCE_M40_MIN</span><span class="p">;</span>
		<span class="n">msi_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCE_ATE_M40S</span>:
		<span class="cm">/*</span>
<span class="cm">		 * ate3240 entries 0-31 are dedicated to port1 super-page</span>
<span class="cm">		 * mappings.  ate3240 entries 32-63 are dedicated to port2.</span>
<span class="cm">		 */</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">entries</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">ate_shadow</span> <span class="o">=</span> <span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_shadow</span><span class="p">;</span>
		<span class="n">ate_reg</span> <span class="o">=</span> <span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate3240</span><span class="p">;</span>
		<span class="n">pagesize</span> <span class="o">=</span> <span class="n">GB</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
		<span class="n">bus_base</span> <span class="o">=</span> <span class="n">TIOCE_M40S_MIN</span><span class="p">;</span>
		<span class="n">msi_capable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msi_wanted</span> <span class="o">=</span> <span class="n">dma_flags</span> <span class="o">&amp;</span> <span class="n">SN_DMA_MSI</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msi_wanted</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msi_capable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nates</span> <span class="o">=</span> <span class="n">ATE_NPAGES</span><span class="p">(</span><span class="n">ct_addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nates</span> <span class="o">&gt;</span> <span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">entries</span> <span class="o">-</span> <span class="n">nates</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ATE_VALID</span><span class="p">(</span><span class="n">ate_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nates</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ATE_VALID</span><span class="p">(</span><span class="n">ate_shadow</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nates</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_dmamap</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">ct_addr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nates</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ate</span><span class="p">;</span>

		<span class="n">ate</span> <span class="o">=</span> <span class="n">ATE_MAKE</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">pagesize</span><span class="p">,</span> <span class="n">msi_wanted</span><span class="p">);</span>
		<span class="n">ate_shadow</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ate</span><span class="p">;</span>
		<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ate_reg</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">ate</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">pagesize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">nates</span> <span class="o">*</span> <span class="n">pagesize</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">ct_start</span> <span class="o">=</span> <span class="n">ct_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ATE_PAGEMASK</span><span class="p">(</span><span class="n">pagesize</span><span class="p">);</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">=</span> <span class="n">bus_base</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">pagesize</span><span class="p">);</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ate_reg</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_shadow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ate_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_count</span> <span class="o">=</span> <span class="n">nates</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">ct_addr</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ct_start</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma_d32 - create a DMA mapping using 32-bit direct mode</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @paddr: system physical address</span>
<span class="cm"> *</span>
<span class="cm"> * Map @paddr into 32-bit bus space of the CE associated with @pcidev_info.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_dma_d32</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dma_ok</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ct_upper</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ct_lower</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_flags</span> <span class="o">&amp;</span> <span class="n">SN_DMA_MSI</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ct_upper</span> <span class="o">=</span> <span class="n">ct_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3fffffffUL</span><span class="p">;</span>
	<span class="n">ct_lower</span> <span class="o">=</span> <span class="n">ct_addr</span> <span class="o">&amp;</span> <span class="mh">0x3fffffffUL</span><span class="p">;</span>

	<span class="n">pcidev_to_tioce</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_shadow</span> <span class="o">=</span> <span class="n">ct_upper</span><span class="p">;</span>
		<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_dir_map</span><span class="p">[</span><span class="n">port</span><span class="p">],</span>
				 <span class="n">ct_upper</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_dir_map</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="n">dma_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dma_ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_shadow</span> <span class="o">==</span> <span class="n">ct_upper</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_refcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">TIOCE_D32_MIN</span> <span class="o">+</span> <span class="n">ct_lower</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bus_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma_barrier - swizzle a TIOCE bus address to include or exclude</span>
<span class="cm"> * the barrier bit.</span>
<span class="cm"> * @bus_addr:  bus address to swizzle</span>
<span class="cm"> *</span>
<span class="cm"> * Given a TIOCE bus address, set the appropriate bit to indicate barrier</span>
<span class="cm"> * attributes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_dma_barrier</span><span class="p">(</span><span class="n">u64</span> <span class="n">bus_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">barrier_bit</span><span class="p">;</span>

	<span class="cm">/* barrier not supported in M40/M40S mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TIOCE_M40_ADDR</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">)</span> <span class="o">||</span> <span class="n">TIOCE_M40S_ADDR</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bus_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TIOCE_D64_ADDR</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">))</span>
		<span class="n">barrier_bit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">62</span><span class="p">);</span>
	<span class="k">else</span>			<span class="cm">/* must be m32 or d32 */</span>
		<span class="n">barrier_bit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">bus_addr</span> <span class="o">|</span> <span class="n">barrier_bit</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">bus_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">barrier_bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma_unmap - release CE mapping resources</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @bus_addr: bus address returned by an earlier tioce_dma_map</span>
<span class="cm"> * @dir: mapping direction (unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Locate mapping resources associated with @bus_addr and release them.</span>
<span class="cm"> * For mappings created using the direct modes there are no resources</span>
<span class="cm"> * to release.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">tioce_dma_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">bus_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bus_addr</span> <span class="o">=</span> <span class="n">tioce_dma_barrier</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pcidev_to_tioce</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* nothing to do for D64 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TIOCE_D64_ADDR</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TIOCE_D32_ADDR</span><span class="p">(</span><span class="n">bus_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_port</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">dirmap_shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_dir_map</span><span class="p">[</span><span class="n">port</span><span class="p">],</span>
					 <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tioce_dmamap</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">,</span>
				    <span class="n">ce_dmamap_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">last</span><span class="p">;</span>

			<span class="n">last</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bus_addr</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">&amp;&amp;</span> <span class="n">bus_addr</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s:  %s - no map found for bus_addr 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">bus_addr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ate_hw</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_do_dma_map - map pages for PCI DMA</span>
<span class="cm"> * @pdev: linux pci_dev representing the function</span>
<span class="cm"> * @paddr: host physical address to map</span>
<span class="cm"> * @byte_count: bytes to map</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main wrapper for mapping host physical pages to CE PCI space.</span>
<span class="cm"> * The mapping mode used is based on the device&#39;s dma_mask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_do_dma_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_count</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">barrier</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ct_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mapaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_dmamap</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_mask</span><span class="p">;</span>

	<span class="n">dma_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">barrier</span><span class="p">)</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">:</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>

	<span class="cm">/* cards must be able to address at least 31 bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mask</span> <span class="o">&lt;</span> <span class="mh">0x7fffffffUL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SN_DMA_ADDRTYPE</span><span class="p">(</span><span class="n">dma_flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">SN_DMA_ADDR_PHYS</span><span class="p">)</span>
		<span class="n">ct_addr</span> <span class="o">=</span> <span class="n">PHYS_TO_TIODMA</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ct_addr</span> <span class="o">=</span> <span class="n">paddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device can generate 64 bit addresses, create a D64 map.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mask</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioce_dma_d64</span><span class="p">(</span><span class="n">ct_addr</span><span class="p">,</span> <span class="n">dma_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapaddr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dma_map_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcidev_to_tioce</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * D64 didn&#39;t work ... See if we have an existing map that covers</span>
<span class="cm">	 * this address range.  Must account for devices dma_mask here since</span>
<span class="cm">	 * an existing map might have been done in a mode using more pci</span>
<span class="cm">	 * address bits than this device can support.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">,</span> <span class="n">ce_dmamap_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">last</span><span class="p">;</span>

		<span class="n">last</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ct_start</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct_addr</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ct_start</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ct_addr</span> <span class="o">+</span> <span class="n">byte_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">&lt;=</span> <span class="n">dma_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pci_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">ct_addr</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ct_start</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have a map yet, and the card can generate 40</span>
<span class="cm">	 * bit addresses, try the M40/M40S modes.  Note these modes do not</span>
<span class="cm">	 * support a barrier bit, so if we need a consistent map these</span>
<span class="cm">	 * won&#39;t work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapaddr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">barrier</span> <span class="o">&amp;&amp;</span> <span class="n">dma_mask</span> <span class="o">&gt;=</span> <span class="mh">0xffffffffffUL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have two options for 40-bit mappings:  16GB &quot;super&quot; ATEs</span>
<span class="cm">		 * and 64MB &quot;regular&quot; ATEs.  We&#39;ll try both if needed for a</span>
<span class="cm">		 * given mapping but which one we try first depends on the</span>
<span class="cm">		 * size.  For requests &gt;64MB, prefer to use a super page with</span>
<span class="cm">		 * regular as the fallback. Otherwise, try in the reverse order.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">&gt;</span> <span class="n">MB</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioce_alloc_map</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">TIOCE_ATE_M40S</span><span class="p">,</span>
						  <span class="n">port</span><span class="p">,</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span>
						  <span class="n">dma_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapaddr</span><span class="p">)</span>
				<span class="n">mapaddr</span> <span class="o">=</span>
				    <span class="n">tioce_alloc_map</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">TIOCE_ATE_M40</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						    <span class="n">ct_addr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span>
						    <span class="n">dma_flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioce_alloc_map</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">TIOCE_ATE_M40</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						  <span class="n">ct_addr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span>
						  <span class="n">dma_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapaddr</span><span class="p">)</span>
				<span class="n">mapaddr</span> <span class="o">=</span>
				    <span class="n">tioce_alloc_map</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">TIOCE_ATE_M40S</span><span class="p">,</span>
						    <span class="n">port</span><span class="p">,</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span>
						    <span class="n">dma_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 32-bit direct is the next mode to try</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapaddr</span> <span class="o">&amp;&amp;</span> <span class="n">dma_mask</span> <span class="o">&gt;=</span> <span class="mh">0xffffffffUL</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioce_dma_d32</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ct_addr</span><span class="p">,</span> <span class="n">dma_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last resort, try 32-bit ATE-based map.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapaddr</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span>
		    <span class="n">tioce_alloc_map</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">TIOCE_ATE_M32</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ct_addr</span><span class="p">,</span>
				    <span class="n">byte_count</span><span class="p">,</span> <span class="n">dma_flags</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">dma_map_done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapaddr</span> <span class="o">&amp;&amp;</span> <span class="n">barrier</span><span class="p">)</span>
		<span class="n">mapaddr</span> <span class="o">=</span> <span class="n">tioce_dma_barrier</span><span class="p">(</span><span class="n">mapaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mapaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma - standard pci dma map interface</span>
<span class="cm"> * @pdev: pci device requesting the map</span>
<span class="cm"> * @paddr: system physical address to map into pci space</span>
<span class="cm"> * @byte_count: # bytes to map</span>
<span class="cm"> *</span>
<span class="cm"> * Simply call tioce_do_dma_map() to create a map with the barrier bit clear</span>
<span class="cm"> * in the address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tioce_do_dma_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dma_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_dma_consistent - consistent pci dma map interface</span>
<span class="cm"> * @pdev: pci device requesting the map</span>
<span class="cm"> * @paddr: system physical address to map into pci space</span>
<span class="cm"> * @byte_count: # bytes to map</span>
<span class="cm"> *</span>
<span class="cm"> * Simply call tioce_do_dma_map() to create a map with the barrier bit set</span>
<span class="cm"> * in the address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span>
<span class="nf">tioce_dma_consistent</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">paddr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byte_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tioce_do_dma_map</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dma_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_error_intr_handler - SGI TIO CE error interrupt handler</span>
<span class="cm"> * @irq: unused</span>
<span class="cm"> * @arg: pointer to tioce_common struct for the given CE</span>
<span class="cm"> *</span>
<span class="cm"> * Handle a CE error interrupt.  Simply a wrapper around a SAL call which</span>
<span class="cm"> * defers processing to the SGI prom.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">tioce_error_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">soft</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ia64_sal_retval</span> <span class="n">ret_stuff</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">SAL_CALL_NOLOCK</span><span class="p">(</span><span class="n">ret_stuff</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">SN_SAL_IOIF_ERROR_INTERRUPT</span><span class="p">,</span>
			<span class="n">soft</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_segment</span><span class="p">,</span>
			<span class="n">soft</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_stuff</span><span class="p">.</span><span class="n">v0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tioce_error_intr_handler:  Fatal TIOCE error&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_reserve_m32 - reserve M32 ATEs for the indicated address range</span>
<span class="cm"> * @tioce_kernel: TIOCE context to reserve ATEs for</span>
<span class="cm"> * @base: starting bus address to reserve</span>
<span class="cm"> * @limit: last bus address to reserve</span>
<span class="cm"> *</span>
<span class="cm"> * If base/limit falls within the range of bus space mapped through the</span>
<span class="cm"> * M32 space, reserve the resources corresponding to the range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tioce_reserve_m32</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">,</span> <span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ate_index</span><span class="p">,</span> <span class="n">last_ate</span><span class="p">,</span> <span class="n">ps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>

	<span class="n">ce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">ps</span> <span class="o">=</span> <span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_pagesize</span><span class="p">;</span>
	<span class="n">ate_index</span> <span class="o">=</span> <span class="n">ATE_PAGE</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ps</span><span class="p">);</span>
	<span class="n">last_ate</span> <span class="o">=</span> <span class="n">ate_index</span> <span class="o">+</span> <span class="n">ATE_NPAGES</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="o">-</span><span class="n">base</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ate_index</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">ate_index</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_ate</span> <span class="o">&gt;=</span> <span class="n">TIOCE_NUM_M3240_ATES</span><span class="p">)</span>
		<span class="n">last_ate</span> <span class="o">=</span> <span class="n">TIOCE_NUM_M3240_ATES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ate_index</span> <span class="o">&lt;=</span> <span class="n">last_ate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ate</span><span class="p">;</span>

		<span class="n">ate</span> <span class="o">=</span> <span class="n">ATE_MAKE</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_shadow</span><span class="p">[</span><span class="n">ate_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ate</span><span class="p">;</span>
		<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate3240</span><span class="p">[</span><span class="n">ate_index</span><span class="p">],</span>
				 <span class="n">ate</span><span class="p">);</span>
		<span class="n">ate_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_kern_init - init kernel structures related to a given TIOCE</span>
<span class="cm"> * @tioce_common: ptr to a cached tioce_common struct that originated in prom</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span>
<span class="nf">tioce_kern_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">tioce_common</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tioce_mmr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">tioce_kern</span><span class="p">;</span>

	<span class="n">tioce_kern</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tioce_kern</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_common</span> <span class="o">=</span> <span class="n">tioce_common</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_dmamap_list</span><span class="p">);</span>
	<span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_kernel_private</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">tioce_kern</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the secondary bus number of the port2 logical PPB.</span>
<span class="cm">	 * This is used to decide whether a given pci device resides on</span>
<span class="cm">	 * port1 or port2.  Note:  We don&#39;t have enough plumbing set up</span>
<span class="cm">	 * here to use pci_read_config_xxx() so use raw_pci_read().</span>
<span class="cm">	 */</span>

	<span class="n">seg</span> <span class="o">=</span> <span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_segment</span><span class="p">;</span>
	<span class="n">bus</span> <span class="o">=</span> <span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">;</span>

	<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">PCI_SECONDARY_BUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_port1_secondary</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set PMU pagesize to the largest size available, and zero out</span>
<span class="cm">	 * the ATEs.</span>
<span class="cm">	 */</span>

	<span class="n">tioce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">tioce_mmr_clri</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_page_map</span><span class="p">,</span>
		       <span class="n">CE_URE_PAGESIZE_MASK</span><span class="p">);</span>
	<span class="n">tioce_mmr_seti</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_page_map</span><span class="p">,</span>
		       <span class="n">CE_URE_256K_PAGESIZE</span><span class="p">);</span>
	<span class="n">ps</span> <span class="o">=</span> <span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_pagesize</span> <span class="o">=</span> <span class="n">KB</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TIOCE_NUM_M40_ATES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate40_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate40</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TIOCE_NUM_M3240_ATES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tioce_kern</span><span class="o">-&gt;</span><span class="n">ce_ate3240_shadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_ure_ate3240</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve ATEs corresponding to reserved address ranges.  These</span>
<span class="cm">	 * include:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Memory space covered by each PPB mem base/limit register</span>
<span class="cm">	 * 	Memory space covered by each PPB prefetch base/limit register</span>
<span class="cm">	 *</span>
<span class="cm">	 * These bus ranges are for pio (downstream) traffic only, and so</span>
<span class="cm">	 * cannot be used for DMA.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">dev</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">dev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>

		<span class="cm">/* mem base/limit */</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_MEMORY_BASE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_MEMORY_LIMIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">|=</span> <span class="mh">0xfffffUL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span>
			<span class="n">tioce_reserve_m32</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * prefetch mem base/limit.  The tioce ppb&#39;s have 64-bit</span>
<span class="cm">		 * decoders, so read the upper portions w/o checking the</span>
<span class="cm">		 * attributes.</span>
<span class="cm">		 */</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_PREF_MEMORY_BASE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">base</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PCI_PREF_RANGE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_PREF_BASE_UPPER32</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">base</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_PREF_MEMORY_LIMIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

		<span class="n">limit</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">PCI_PREF_RANGE_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">|=</span> <span class="mh">0xfffffUL</span><span class="p">;</span>

		<span class="n">raw_pci_read</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="n">PCI_PREF_LIMIT_UPPER32</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">limit</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">base</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">TIOCE_M32_ADDR</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
			<span class="n">tioce_reserve_m32</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tioce_kern</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_force_interrupt - implement altix force_interrupt() backend for CE</span>
<span class="cm"> * @sn_irq_info: sn asic irq that we need an interrupt generated for</span>
<span class="cm"> *</span>
<span class="cm"> * Given an sn_irq_info struct, set the proper bit in ce_adm_force_int to</span>
<span class="cm"> * force a secondary interrupt to be generated.  This is to work around an</span>
<span class="cm"> * asic issue where there is a small window of opportunity for a legacy device</span>
<span class="cm"> * interrupt to be lost.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tioce_force_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">ce_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">force_int_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_bridge_type</span> <span class="o">!=</span> <span class="n">PCIIO_ASIC_TYPE_TIOCE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pcidev_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_pciioinfo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcidev_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ce_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">ce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">ce_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_kernel_private</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TIOCE Rev A workaround (PV 945826), force an interrupt by writing</span>
<span class="cm">	 * the TIO_INTx register directly (1/26/2006)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_rev</span> <span class="o">==</span> <span class="n">TIOCE_REV_A</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">int_bit_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">tioce_mmr_load</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_int_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">int_bit_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">force_irq</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">ctalk</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_xtalkaddr</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">nasid</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">nasid</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctalk</span> <span class="o">&amp;</span> <span class="n">CTALK_NASID_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CTALK_NASID_SHFT</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctalk</span> <span class="o">&amp;</span> <span class="n">CTALK_NODE_OFFSET</span><span class="p">);</span>
			<span class="n">HUB_S</span><span class="p">(</span><span class="n">TIO_IOSPACE_ADDR</span><span class="p">(</span><span class="n">nasid</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="n">force_irq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * irq_int_bit is originally set up by prom, and holds the interrupt</span>
<span class="cm">	 * bit shift (not mask) as defined by the bit definitions in the</span>
<span class="cm">	 * ce_adm_int mmr.  These shifts are not the same for the</span>
<span class="cm">	 * ce_adm_force_int register, so do an explicit mapping here to make</span>
<span class="cm">	 * things clearer.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT1_DEV_A_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT1_DEV_A_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT1_DEV_B_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT1_DEV_B_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT1_DEV_C_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT1_DEV_C_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT1_DEV_D_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT1_DEV_D_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT2_DEV_A_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT2_DEV_A_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT2_DEV_B_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT2_DEV_B_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT2_DEV_C_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT2_DEV_C_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CE_ADM_INT_PCIE_PORT2_DEV_D_SHFT</span>:
		<span class="n">force_int_val</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CE_ADM_FORCE_INT_PCIE_PORT2_DEV_D_SHFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_force_int</span><span class="p">,</span> <span class="n">force_int_val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_target_interrupt - implement set_irq_affinity for tioce resident</span>
<span class="cm"> * functions.  Note:  only applies to line interrupts, not MSI&#39;s.</span>
<span class="cm"> *</span>
<span class="cm"> * @sn_irq_info: SN IRQ context</span>
<span class="cm"> *</span>
<span class="cm"> * Given an sn_irq_info, set the associated CE device&#39;s interrupt destination</span>
<span class="cm"> * register.  Since the interrupt destination registers are on a per-ce-slot</span>
<span class="cm"> * basis, this will retarget line interrupts for all functions downstream of</span>
<span class="cm"> * the slot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tioce_target_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_irq_info</span> <span class="o">*</span><span class="n">sn_irq_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="n">pcidev_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">ce_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">ce_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ce_mmr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vector</span><span class="p">;</span>

	<span class="n">pcidev_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pcidev_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_pciioinfo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcidev_info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ce_common</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="p">)</span><span class="n">pcidev_info</span><span class="o">-&gt;</span><span class="n">pdi_pcibus_info</span><span class="p">;</span>
	<span class="n">ce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">ce_kern</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="p">)</span><span class="n">ce_common</span><span class="o">-&gt;</span><span class="n">ce_kernel_private</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_int_bit</span><span class="p">;</span>

	<span class="n">tioce_mmr_seti</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_int_mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
	<span class="n">vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_irq</span> <span class="o">&lt;&lt;</span> <span class="n">INTR_VECTOR_SHFT</span><span class="p">;</span>
	<span class="n">vector</span> <span class="o">|=</span> <span class="n">sn_irq_info</span><span class="o">-&gt;</span><span class="n">irq_xtalkaddr</span><span class="p">;</span>
	<span class="n">tioce_mmr_storei</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_int_dest</span><span class="p">[</span><span class="n">bit</span><span class="p">],</span> <span class="n">vector</span><span class="p">);</span>
	<span class="n">tioce_mmr_clri</span><span class="p">(</span><span class="n">ce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_int_mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>

	<span class="n">tioce_force_interrupt</span><span class="p">(</span><span class="n">sn_irq_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_bus_fixup - perform final PCI fixup for a TIO CE bus</span>
<span class="cm"> * @prom_bussoft: Common prom/kernel struct representing the bus</span>
<span class="cm"> *</span>
<span class="cm"> * Replicates the tioce_common pointed to by @prom_bussoft in kernel</span>
<span class="cm"> * space.  Allocates and initializes a kernel-only area for a given CE,</span>
<span class="cm"> * and sets up an irq for handling CE error interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * On successful setup, returns the kernel version of tioce_common back to</span>
<span class="cm"> * the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">tioce_bus_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcibus_bussoft</span> <span class="o">*</span><span class="n">prom_bussoft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="o">*</span><span class="n">controller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tioce_common</span> <span class="o">*</span><span class="n">tioce_common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce_kernel</span> <span class="o">*</span><span class="n">tioce_kern</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">tioce_mmr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate kernel bus soft and copy from prom.</span>
<span class="cm">	 */</span>

	<span class="n">tioce_common</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tioce_common</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">tioce_common</span><span class="p">,</span> <span class="n">prom_bussoft</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span><span class="p">));</span>
	<span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
		<span class="n">ioremap</span><span class="p">(</span><span class="n">REGION_OFFSET</span><span class="p">(</span><span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tioce_common</span><span class="p">));</span>

	<span class="n">tioce_kern</span> <span class="o">=</span> <span class="n">tioce_kern_init</span><span class="p">(</span><span class="n">tioce_common</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tioce_kern</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tioce_common</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear out any transient errors before registering the error</span>
<span class="cm">	 * interrupt handler.</span>
<span class="cm">	 */</span>

	<span class="n">tioce_mmr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tioce</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_base</span><span class="p">;</span>
	<span class="n">tioce_mmr_seti</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_int_status_alias</span><span class="p">,</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">);</span>
	<span class="n">tioce_mmr_seti</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_adm_error_summary_alias</span><span class="p">,</span>
		       <span class="o">~</span><span class="mi">0ULL</span><span class="p">);</span>
	<span class="n">tioce_mmr_seti</span><span class="p">(</span><span class="n">tioce_kern</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tioce_mmr</span><span class="o">-&gt;</span><span class="n">ce_dre_comp_err_addr</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">SGI_PCIASIC_ERROR</span><span class="p">,</span>
			<span class="n">tioce_error_intr_handler</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;TIOCE error&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tioce_common</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;%s:  Unable to get irq %d.  &quot;</span>
		       <span class="s">&quot;Error interrupts won&#39;t be routed for &quot;</span>
		       <span class="s">&quot;TIOCE bus %04x:%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">SGI_PCIASIC_ERROR</span><span class="p">,</span>
		       <span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_segment</span><span class="p">,</span>
		       <span class="n">tioce_common</span><span class="o">-&gt;</span><span class="n">ce_pcibus</span><span class="p">.</span><span class="n">bs_persist_busnum</span><span class="p">);</span>

	<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">SGI_PCIASIC_ERROR</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>
	<span class="n">sn_set_err_irq_affinity</span><span class="p">(</span><span class="n">SGI_PCIASIC_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tioce_common</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_pcibus_provider</span> <span class="n">tioce_pci_interfaces</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dma_map</span> <span class="o">=</span> <span class="n">tioce_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_map_consistent</span> <span class="o">=</span> <span class="n">tioce_dma_consistent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_unmap</span> <span class="o">=</span> <span class="n">tioce_dma_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_fixup</span> <span class="o">=</span> <span class="n">tioce_bus_fixup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_interrupt</span> <span class="o">=</span> <span class="n">tioce_force_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">target_interrupt</span> <span class="o">=</span> <span class="n">tioce_target_interrupt</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * tioce_init_provider - init SN PCI provider ops for TIO CE</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">tioce_init_provider</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sn_pci_provider</span><span class="p">[</span><span class="n">PCIIO_ASIC_TYPE_TIOCE</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tioce_pci_interfaces</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
