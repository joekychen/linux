<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › score › include › asm › uaccess.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uaccess.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __SCORE_UACCESS_H</span>
<span class="cp">#define __SCORE_UACCESS_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>

<span class="cp">#define VERIFY_READ		0</span>
<span class="cp">#define VERIFY_WRITE		1</span>

<span class="cp">#define get_ds()		(KERNEL_DS)</span>
<span class="cp">#define get_fs()		(current_thread_info()-&gt;addr_limit)</span>
<span class="cp">#define segment_eq(a, b)	((a).seg == (b).seg)</span>

<span class="cm">/*</span>
<span class="cm"> * Is a address valid? This does a straighforward calculation rather</span>
<span class="cm"> * than tests.</span>
<span class="cm"> *</span>
<span class="cm"> * Address valid if:</span>
<span class="cm"> *  - &quot;addr&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;addr+size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - OR we are in kernel mode.</span>
<span class="cm"> *</span>
<span class="cm"> * __ua_size() is a trick to avoid runtime checking of positive constant</span>
<span class="cm"> * sizes; for those we already know at compile time that the size is ok.</span>
<span class="cm"> */</span>
<span class="cp">#define __ua_size(size)							\</span>
<span class="cp">	((__builtin_constant_p(size) &amp;&amp; (signed long) (size) &gt; 0) ? 0 : (size))</span>

<span class="cm">/*</span>
<span class="cm"> * access_ok: - Checks if a user space pointer is valid</span>
<span class="cm"> * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that</span>
<span class="cm"> *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe</span>
<span class="cm"> *        to write to a block, it is always safe to read from it.</span>
<span class="cm"> * @addr: User space pointer to start of block to check</span>
<span class="cm"> * @size: Size of block to check</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks if a pointer to a block of memory in user space is valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true (nonzero) if the memory block may be valid, false (zero)</span>
<span class="cm"> * if it is definitely invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, depending on architecture, this function probably just</span>
<span class="cm"> * checks that the pointer is in the user space range - after calling</span>
<span class="cm"> * this function, memory access functions may still return -EFAULT.</span>
<span class="cm"> */</span>

<span class="cp">#define __access_ok(addr, size)					\</span>
<span class="cp">	(((long)((get_fs().seg) &amp;				\</span>
<span class="cp">		 ((addr) | ((addr) + (size)) |			\</span>
<span class="cp">		  __ua_size(size)))) == 0)</span>

<span class="cp">#define access_ok(type, addr, size)				\</span>
<span class="cp">	likely(__access_ok((unsigned long)(addr), (size)))</span>

<span class="cm">/*</span>
<span class="cm"> * put_user: - Write a simple value into user space.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define put_user(x, ptr) __put_user_check((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * get_user: - Get a simple variable from user space.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define get_user(x, ptr) __get_user_check((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __put_user: - Write a simple value into user space, with less checking.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user(x, ptr) __put_user_nocheck((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __get_user: - Get a simple variable from user space, with less checking.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user(x, ptr) __get_user_nocheck((x), (ptr), sizeof(*(ptr)))</span>

<span class="k">struct</span> <span class="n">__large_struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">};</span>
<span class="cp">#define __m(x) (*(struct __large_struct __user *)(x))</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__get_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_common(val, size, ptr)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1:								\</span>
<span class="cp">		__get_user_asm(val, &quot;lb&quot;, ptr);				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case 2:								\</span>
<span class="cp">		__get_user_asm(val, &quot;lh&quot;, ptr);				\</span>
<span class="cp">		 break;							\</span>
<span class="cp">	case 4:								\</span>
<span class="cp">		__get_user_asm(val, &quot;lw&quot;, ptr);				\</span>
<span class="cp">		 break;							\</span>
<span class="cp">	case 8: 							\</span>
<span class="cp">		if ((copy_from_user((void *)&amp;val, ptr, 8)) == 0)	\</span>
<span class="cp">			__gu_err = 0;					\</span>
<span class="cp">		else							\</span>
<span class="cp">			__gu_err = -EFAULT;				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	default:							\</span>
<span class="cp">		__get_user_unknown();					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __get_user_nocheck(x, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	long __gu_err = 0;						\</span>
<span class="cp">	__get_user_common((x), size, ptr);				\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_check(x, ptr, size)					\</span>
<span class="cp">({									\</span>
<span class="cp">	long __gu_err = -EFAULT;					\</span>
<span class="cp">	const __typeof__(*(ptr)) __user *__gu_ptr = (ptr);		\</span>
<span class="cp">									\</span>
<span class="cp">	if (likely(access_ok(VERIFY_READ, __gu_ptr, size)))		\</span>
<span class="cp">		__get_user_common((x), size, __gu_ptr);			\</span>
<span class="cp">									\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_asm(val, insn, addr)					\</span>
<span class="cp">{									\</span>
<span class="cp">	long __gu_tmp;							\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">		&quot;1:&quot; insn &quot; %1, %3\n&quot;					\</span>
<span class="cp">		&quot;2:\n&quot;							\</span>
<span class="cp">		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;				\</span>
<span class="cp">		&quot;3:li	%0, %4\n&quot;					\</span>
<span class="cp">		&quot;j	2b\n&quot;						\</span>
<span class="cp">		&quot;.previous\n&quot;						\</span>
<span class="cp">		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">		&quot;.word	1b, 3b\n&quot;					\</span>
<span class="cp">		&quot;.previous\n&quot;						\</span>
<span class="cp">		: &quot;=r&quot; (__gu_err), &quot;=r&quot; (__gu_tmp)			\</span>
<span class="cp">		: &quot;0&quot; (0), &quot;o&quot; (__m(addr)), &quot;i&quot; (-EFAULT));		\</span>
<span class="cp">									\</span>
<span class="cp">		(val) = (__typeof__(*(addr))) __gu_tmp;			\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user_nocheck(val, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val;					\</span>
<span class="cp">	long __pu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	__pu_val = (val);						\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1:								\</span>
<span class="cp">		__put_user_asm(&quot;sb&quot;, ptr);				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case 2:								\</span>
<span class="cp">		__put_user_asm(&quot;sh&quot;, ptr);				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case 4:								\</span>
<span class="cp">		__put_user_asm(&quot;sw&quot;, ptr);				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	case 8: 							\</span>
<span class="cp">		if ((__copy_to_user((void *)ptr, &amp;__pu_val, 8)) == 0)	\</span>
<span class="cp">			__pu_err = 0;					\</span>
<span class="cp">		else							\</span>
<span class="cp">			__pu_err = -EFAULT;				\</span>
<span class="cp">		break;							\</span>
<span class="cp">	default:							\</span>
<span class="cp">		 __put_user_unknown();					\</span>
<span class="cp">		 break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>


<span class="cp">#define __put_user_check(val, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val = (val);				\</span>
<span class="cp">	long __pu_err = -EFAULT;					\</span>
<span class="cp">									\</span>
<span class="cp">	if (likely(access_ok(VERIFY_WRITE, __pu_addr, size))) {		\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		case 1:							\</span>
<span class="cp">			__put_user_asm(&quot;sb&quot;, __pu_addr);		\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 2:							\</span>
<span class="cp">			__put_user_asm(&quot;sh&quot;, __pu_addr);		\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 4:							\</span>
<span class="cp">			__put_user_asm(&quot;sw&quot;, __pu_addr);		\</span>
<span class="cp">			break;						\</span>
<span class="cp">		case 8: 						\</span>
<span class="cp">			if ((__copy_to_user((void *)__pu_addr, &amp;__pu_val, 8)) == 0)\</span>
<span class="cp">				__pu_err = 0;				\</span>
<span class="cp">			else						\</span>
<span class="cp">				__pu_err = -EFAULT;			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		default:						\</span>
<span class="cp">			__put_user_unknown();				\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_asm(insn, ptr)					\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">		&quot;1:&quot; insn &quot; %2, %3\n&quot;					\</span>
<span class="cp">		&quot;2:\n&quot;							\</span>
<span class="cp">		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;				\</span>
<span class="cp">		&quot;3:li %0, %4\n&quot;						\</span>
<span class="cp">		&quot;j 2b\n&quot;						\</span>
<span class="cp">		&quot;.previous\n&quot;						\</span>
<span class="cp">		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\</span>
<span class="cp">		&quot;.word 1b, 3b\n&quot;					\</span>
<span class="cp">		&quot;.previous\n&quot;						\</span>
<span class="cp">		: &quot;=r&quot; (__pu_err)					\</span>
<span class="cp">		: &quot;0&quot; (0), &quot;r&quot; (__pu_val), &quot;o&quot; (__m(ptr)),		\</span>
<span class="cp">		  &quot;i&quot; (-EFAULT));</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">over</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">over</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">from</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">TASK_SIZE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">over</span><span class="p">)</span> <span class="o">+</span> <span class="n">over</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">over</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">to</span> <span class="o">&lt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">over</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">to</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">TASK_SIZE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">__copy_tofrom_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">over</span><span class="p">)</span> <span class="o">+</span> <span class="n">over</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __copy_from_user(to, from, len)	\</span>
<span class="cp">		__copy_tofrom_user((to), (from), (len))</span>

<span class="cp">#define __copy_to_user(to, from, len)		\</span>
<span class="cp">		__copy_tofrom_user((to), (from), (len))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_to_user_inatomic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__copy_from_user_inatomic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __copy_in_user(to, from, len)	__copy_from_user(to, from, len)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_in_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		      <span class="n">access_ok</span><span class="p">(</span><span class="n">VERFITY_WRITE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __clear_user: - Zero a block of memory in user space, with less checking.</span>
<span class="cm"> * @to:   Destination address, in user space.</span>
<span class="cm"> * @n:    Number of bytes to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Zero a block of memory in user space.  Caller must check</span>
<span class="cm"> * the specified block with access_ok() before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be cleared.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">clear_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__clear_user</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.</span>
<span class="cm"> * @dst:   Destination address, in kernel space.  This buffer must be at</span>
<span class="cm"> *         least @count bytes long.</span>
<span class="cm"> * @src:   Source address, in user space.</span>
<span class="cm"> * @count: Maximum number of bytes to copy, including the trailing NUL.</span>
<span class="cm"> *</span>
<span class="cm"> * Copies a NUL-terminated string from userspace to kernel space.</span>
<span class="cm"> * Caller must check the specified block with access_ok() before calling</span>
<span class="cm"> * this function.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns the length of the string (not including the trailing</span>
<span class="cm"> * NUL).</span>
<span class="cm"> *</span>
<span class="cm"> * If access to userspace fails, returns -EFAULT (some data may have been</span>
<span class="cm"> * copied).</span>
<span class="cm"> *</span>
<span class="cm"> * If @count is smaller than the length of the string, copies @count bytes</span>
<span class="cm"> * and returns @count.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__strncpy_from_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__strlen_user</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>		
		<span class="k">return</span> <span class="n">__strnlen_user</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fixup</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">fixup_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __SCORE_UACCESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
