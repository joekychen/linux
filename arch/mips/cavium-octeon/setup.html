<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › cavium-octeon › setup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>setup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2007 Cavium Networks</span>
<span class="cm"> * Copyright (C) 2008 Wind River Systems</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;	</span><span class="cm">/* for memset */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/serial_8250.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/reboot.h&gt;</span>
<span class="cp">#include &lt;asm/smp-ops.h&gt;</span>
<span class="cp">#include &lt;asm/irq_cpu.h&gt;</span>
<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/bootinfo.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/pci-octeon.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-mio-defs.h&gt;</span>

<span class="cp">#ifdef CONFIG_CAVIUM_DECODE_RSL</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_interrupt_rsl_decode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__cvmx_interrupt_ecc_report_single_bit_errors</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_interrupt_rsl_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">plat_smp_ops</span> <span class="n">octeon_smp_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_console_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">MAX_MEMORY</span> <span class="o">=</span> <span class="mi">512ull</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">octeon_boot_descriptor</span> <span class="o">*</span><span class="n">octeon_boot_desc_ptr</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">cvmx_bootinfo</span> <span class="o">*</span><span class="n">octeon_bootinfo</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_bootinfo</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CAVIUM_RESERVE32</span>
<span class="kt">uint64_t</span> <span class="n">octeon_reserve32_memory</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_reserve32_memory</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">octeon_uart</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_int</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">plat_irq_dispatch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Return non zero if we are currently running in the Octeon simulator</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">octeon_is_simulation</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_type</span> <span class="o">==</span> <span class="n">CVMX_BOARD_TYPE_SIM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_is_simulation</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Return true if Octeon is in PCI Host mode. This means</span>
<span class="cm"> * Linux can control the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Non zero if Octeon in host mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">octeon_is_pci_host</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">return</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">config_flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTINFO_CFG_FLAG_PCI_HOST</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the clock rate of Octeon</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Clock rate in HZ</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">octeon_get_clock_rate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cvmx_sysinfo</span> <span class="o">*</span><span class="n">sysinfo</span> <span class="o">=</span> <span class="n">cvmx_sysinfo_get</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">cpu_clock_hz</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_get_clock_rate</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">octeon_io_clock_rate</span><span class="p">;</span>

<span class="n">u64</span> <span class="nf">octeon_get_io_clock_rate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_io_clock_rate</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_get_io_clock_rate</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * Write to the LCD display connected to the bootbus. This display</span>
<span class="cm"> * exists on most Cavium evaluation boards. If it doesn&#39;t exist, then</span>
<span class="cm"> * this function doesn&#39;t do anything.</span>
<span class="cm"> *</span>
<span class="cm"> * @s:      String to write</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">octeon_write_lcd</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">led_display_base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">lcd_address</span> <span class="o">=</span>
			<span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">led_display_base_addr</span><span class="p">,</span>
					<span class="mi">8</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
				<span class="n">iowrite8</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">lcd_address</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">iowrite8</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">lcd_address</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">lcd_address</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Return the console uart passed by the bootloader</span>
<span class="cm"> *</span>
<span class="cm"> * Returns uart   (0 or 1)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">octeon_get_boot_uart</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uart</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL</span>
	<span class="n">uart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">uart</span> <span class="o">=</span> <span class="p">(</span><span class="n">octeon_boot_desc_ptr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OCTEON_BL_FLAG_CONSOLE_UART1</span><span class="p">)</span> <span class="o">?</span>
		<span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">uart</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the coremask Linux was booted on.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Core mask</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">octeon_get_boot_coremask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_boot_desc_ptr</span><span class="o">-&gt;</span><span class="n">core_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Check the hardware BIST results for a CPU</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">octeon_check_cpu_bist</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">bist_val</span><span class="p">;</span>

	<span class="cm">/* Check BIST results for COP0 registers */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x1f00000000ull</span><span class="p">;</span>
	<span class="n">bist_val</span> <span class="o">=</span> <span class="n">read_octeon_c0_icacheerr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bist_val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Core%d BIST Failure: CacheErr(icache) = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">coreid</span><span class="p">,</span> <span class="n">bist_val</span><span class="p">);</span>

	<span class="n">bist_val</span> <span class="o">=</span> <span class="n">read_octeon_c0_dcacheerr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bist_val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Core%d L1 Dcache parity error: &quot;</span>
		       <span class="s">&quot;CacheErr(dcache) = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">coreid</span><span class="p">,</span> <span class="n">bist_val</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0xfc00000000000000ull</span><span class="p">;</span>
	<span class="n">bist_val</span> <span class="o">=</span> <span class="n">read_c0_cvmmemctl</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bist_val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Core%d BIST Failure: COP0_CVM_MEM_CTL = 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">coreid</span><span class="p">,</span> <span class="n">bist_val</span><span class="p">);</span>

	<span class="n">write_octeon_c0_dcacheerr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Reboot Octeon</span>
<span class="cm"> *</span>
<span class="cm"> * @command: Command to pass to the bootloader. Currently ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_restart</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable all watchdogs before soft reset. They don&#39;t get cleared */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">cvmx_get_core_num</span><span class="p">()),</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_RST</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Permanently stop a core.</span>
<span class="cm"> *</span>
<span class="cm"> * @arg: Ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_kill_core</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_is_simulation</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* The simulator needs the watchdog to stop for dead cores */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_WDOGX</span><span class="p">(</span><span class="n">cvmx_get_core_num</span><span class="p">()),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* A break instruction causes the simulator stop a core */</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;sync</span><span class="se">\n</span><span class="s">break&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Halt the system</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">octeon_kill_core</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_NAO38</span>:
		<span class="cm">/* Driving a 1 to GPIO 12 shuts off this board */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_GPIO_BIT_CFGX</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_GPIO_TX_SET</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">octeon_write_lcd</span><span class="p">(</span><span class="s">&quot;PowerOff&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">octeon_kill_core</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Handle all the error condition interrupts that might occur.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CAVIUM_DECODE_RSL</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">octeon_rlm_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_interrupt_rsl_decode</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Return a string representing the system type</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">octeon_board_type_string</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s (%s)&quot;</span><span class="p">,</span>
		<span class="n">cvmx_board_type_to_string</span><span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_type</span><span class="p">),</span>
		<span class="n">octeon_model_get_string</span><span class="p">(</span><span class="n">read_c0_prid</span><span class="p">()));</span>
	<span class="k">return</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">get_system_type</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
	<span class="n">__attribute__</span> <span class="p">((</span><span class="n">alias</span><span class="p">(</span><span class="s">&quot;octeon_board_type_string&quot;</span><span class="p">)));</span>

<span class="kt">void</span> <span class="nf">octeon_user_io_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">octeon_cvmemctl</span> <span class="n">cvmmemctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_iob_fau_timeout</span> <span class="n">fau_timeout</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pow_nw_tim</span> <span class="n">nm_tim</span><span class="p">;</span>

	<span class="cm">/* Get the current settings for CP0_CVMMEMCTL_REG */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">read_c0_cvmmemctl</span><span class="p">();</span>
	<span class="cm">/* R/W If set, marked write-buffer entries time out the same</span>
<span class="cm">	 * as as other entries; if clear, marked write-buffer entries</span>
<span class="cm">	 * use the maximum timeout. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dismarkwblongto</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* R/W If set, a merged store does not clear the write-buffer</span>
<span class="cm">	 * entry timeout state. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dismrgclrwbto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W Two bits that are the MSBs of the resultant CVMSEG LM</span>
<span class="cm">	 * word location for an IOBDMA. The other 8 bits come from the</span>
<span class="cm">	 * SCRADDR field of the IOBDMA. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">iobdmascrmsb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, SYNCWS and SYNCS only order marked stores; if</span>
<span class="cm">	 * clear, SYNCWS and SYNCS only order unmarked</span>
<span class="cm">	 * stores. SYNCWSMARKED has no effect when DISSYNCWS is</span>
<span class="cm">	 * set. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">syncwsmarked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, SYNCWS acts as SYNCW and SYNCS acts as SYNC. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dissyncws</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, no stall happens on write buffer full. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN38XX_PASS2</span><span class="p">))</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">diswbfst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">diswbfst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set (and SX set), supervisor-level loads/stores can</span>
<span class="cm">	 * use XKPHYS addresses with &lt;48&gt;==0 */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">xkmemenas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* R/W If set (and UX set), user-level loads/stores can use</span>
<span class="cm">	 * XKPHYS addresses with VA&lt;48&gt;==0 */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">xkmemenau</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* R/W If set (and SX set), supervisor-level loads/stores can</span>
<span class="cm">	 * use XKPHYS addresses with VA&lt;48&gt;==1 */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">xkioenas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* R/W If set (and UX set), user-level loads/stores can use</span>
<span class="cm">	 * XKPHYS addresses with VA&lt;48&gt;==1 */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">xkioenau</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* R/W If set, all stores act as SYNCW (NOMERGE must be set</span>
<span class="cm">	 * when this is set) RW, reset to 0. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">allsyncw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* R/W If set, no stores merge, and all stores reach the</span>
<span class="cm">	 * coherent bus in order. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nomerge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W Selects the bit in the counter used for DID time-outs 0</span>
<span class="cm">	 * = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is</span>
<span class="cm">	 * between 1x and 2x this interval. For example, with</span>
<span class="cm">	 * DIDTTO=3, expiration interval is between 16K and 32K. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">didtto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, the (mem) CSR clock never turns off. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">csrckalwys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, mclk never turns off. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mclkalwys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W Selects the bit in the counter used for write buffer</span>
<span class="cm">	 * flush time-outs (WBFLT+11) is the bit position in an</span>
<span class="cm">	 * internal counter used to determine expiration. The write</span>
<span class="cm">	 * buffer expires between 1x and 2x this interval. For</span>
<span class="cm">	 * example, with WBFLT = 0, a write buffer expires between 2K</span>
<span class="cm">	 * and 4K cycles after the write buffer entry is allocated. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wbfltime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, do not put Istream in the L2 cache. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">istrnol2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * R/W The write buffer threshold. As per erratum Core-14752</span>
<span class="cm">	 * for CN63XX, a sc/scd might fail if the write buffer is</span>
<span class="cm">	 * full.  Lowering WBTHRESH greatly lowers the chances of the</span>
<span class="cm">	 * write buffer ever being full and triggering the erratum.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">))</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wbthresh</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wbthresh</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in</span>
<span class="cm">	 * kernel/debug mode. */</span>
<span class="cp">#if CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE &gt; 0</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cvmsegenak</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cvmsegenak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in</span>
<span class="cm">	 * supervisor mode. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cvmsegenas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in user</span>
<span class="cm">	 * mode. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cvmsegenau</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* R/W Size of local memory in cache blocks, 54 (6912 bytes)</span>
<span class="cm">	 * is max legal value. */</span>
	<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lmemsz</span> <span class="o">=</span> <span class="n">CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE</span><span class="p">;</span>

	<span class="n">write_c0_cvmmemctl</span><span class="p">(</span><span class="n">cvmmemctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;CVMSEG size: %d cache lines (%d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE</span><span class="p">,</span>
			  <span class="n">CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE</span> <span class="o">*</span> <span class="mi">128</span><span class="p">);</span>

	<span class="cm">/* Set a default for the hardware timeouts */</span>
	<span class="n">fau_timeout</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fau_timeout</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tout_val</span> <span class="o">=</span> <span class="mh">0xfff</span><span class="p">;</span>
	<span class="cm">/* Disable tagwait FAU timeout */</span>
	<span class="n">fau_timeout</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tout_enb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_IOB_FAU_TIMEOUT</span><span class="p">,</span> <span class="n">fau_timeout</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">nm_tim</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* 4096 cycles */</span>
	<span class="n">nm_tim</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nw_tim</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_NW_TIM</span><span class="p">,</span> <span class="n">nm_tim</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">write_octeon_c0_icacheerr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">write_c0_derraddr1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Early entry point for arch setup</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">prom_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cvmx_sysinfo</span> <span class="o">*</span><span class="n">sysinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CAVIUM_RESERVE32</span>
	<span class="kt">int64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * The bootloader passes a pointer to the boot descriptor in</span>
<span class="cm">	 * $a3, this is available as fw_arg3.</span>
<span class="cm">	 */</span>
	<span class="n">octeon_boot_desc_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">octeon_boot_descriptor</span> <span class="o">*</span><span class="p">)</span><span class="n">fw_arg3</span><span class="p">;</span>
	<span class="n">octeon_bootinfo</span> <span class="o">=</span>
		<span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">octeon_boot_desc_ptr</span><span class="o">-&gt;</span><span class="n">cvmx_desc_vaddr</span><span class="p">);</span>
	<span class="n">cvmx_bootmem_init</span><span class="p">(</span><span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">phy_mem_desc_addr</span><span class="p">));</span>

	<span class="n">sysinfo</span> <span class="o">=</span> <span class="n">cvmx_sysinfo_get</span><span class="p">();</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sysinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sysinfo</span><span class="p">));</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">system_dram_size</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">dram_size</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">phy_mem_desc_ptr</span> <span class="o">=</span>
		<span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">phy_mem_desc_addr</span><span class="p">);</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">core_mask</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">core_mask</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">exception_base_addr</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">exception_base_addr</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">cpu_clock_hz</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">eclock_hz</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">dram_data_rate_hz</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">dclock_hz</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">board_type</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_type</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">board_rev_major</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_rev_major</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">board_rev_minor</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_rev_minor</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">mac_addr_base</span><span class="p">,</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">mac_addr_base</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">mac_addr_base</span><span class="p">));</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">mac_addr_count</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">mac_addr_count</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">board_serial_number</span><span class="p">,</span>
	       <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_serial_number</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">board_serial_number</span><span class="p">));</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">compact_flash_common_base_addr</span> <span class="o">=</span>
		<span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">compact_flash_common_base_addr</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">compact_flash_attribute_base_addr</span> <span class="o">=</span>
		<span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">compact_flash_attribute_base_addr</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">led_display_base_addr</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">led_display_base_addr</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">dfa_ref_clock_hz</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">dfa_ref_clock_hz</span><span class="p">;</span>
	<span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">bootloader_config_flags</span> <span class="o">=</span> <span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">config_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN6XXX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* I/O clock runs at a different rate than the CPU. */</span>
		<span class="k">union</span> <span class="n">cvmx_mio_rst_boot</span> <span class="n">rst_boot</span><span class="p">;</span>
		<span class="n">rst_boot</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_RST_BOOT</span><span class="p">);</span>
		<span class="n">octeon_io_clock_rate</span> <span class="o">=</span> <span class="mi">50000000</span> <span class="o">*</span> <span class="n">rst_boot</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pnr_mul</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">octeon_io_clock_rate</span> <span class="o">=</span> <span class="n">sysinfo</span><span class="o">-&gt;</span><span class="n">cpu_clock_hz</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only enable the LED controller if we&#39;re running on a CN38XX, CN58XX,</span>
<span class="cm">	 * or CN56XX. The CN30XX and CN31XX don&#39;t have an LED controller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">octeon_is_simulation</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_LED_CONTROLLER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_PRT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_DBG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_PRT_FMT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_UDD_CNTX</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_UDD_CNTX</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_UDD_DATX</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_UDD_DATX</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_LED_EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_CAVIUM_RESERVE32</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to temporarily allocate all memory in the reserve32</span>
<span class="cm">	 * region. This makes sure the kernel doesn&#39;t allocate this</span>
<span class="cm">	 * memory when it is getting memory from the</span>
<span class="cm">	 * bootloader. Later, after the memory allocations are</span>
<span class="cm">	 * complete, the reserve32 will be freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Allocate memory for RESERVED32 aligned on 2MB boundary. This</span>
<span class="cm">	 * is in case we later use hugetlb entries with it.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_named_block_alloc</span><span class="p">(</span><span class="n">CONFIG_CAVIUM_RESERVE32</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
						<span class="s">&quot;CAVIUM_RESERVE32&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to allocate CAVIUM_RESERVE32 memory area</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">octeon_reserve32_memory</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_L2D_FUS3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">3ull</span> <span class="o">&lt;&lt;</span> <span class="mi">34</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Skipping L2 locking due to reduced L2 cache size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">ebase</span> <span class="o">=</span> <span class="n">read_c0_ebase</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x3ffff000</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_TLB</span>
		<span class="cm">/* TLB refill */</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">ebase</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_EXCEPTION</span>
		<span class="cm">/* General exception */</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_LOW_LEVEL_INTERRUPT</span>
		<span class="cm">/* Interrupt handler */</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_INTERRUPT</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">handle_int</span><span class="p">),</span> <span class="mh">0x100</span><span class="p">);</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">plat_irq_dispatch</span><span class="p">),</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_MEMCPY</span>
		<span class="n">cvmx_l2c_lock_mem_region</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">memcpy</span><span class="p">),</span> <span class="mh">0x480</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">octeon_check_cpu_bist</span><span class="p">();</span>

	<span class="n">octeon_uart</span> <span class="o">=</span> <span class="n">octeon_get_boot_uart</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">octeon_write_lcd</span><span class="p">(</span><span class="s">&quot;LinuxSMP&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">octeon_write_lcd</span><span class="p">(</span><span class="s">&quot;Linux&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CAVIUM_GDB</span>
	<span class="cm">/*</span>
<span class="cm">	 * When debugging the linux kernel, force the cores to enter</span>
<span class="cm">	 * the debug exception handler to break in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_get_boot_debug_flag</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_DINT</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cvmx_get_core_num</span><span class="p">());</span>
		<span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_DINT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * BIST should always be enabled when doing a soft reset. L2</span>
<span class="cm">	 * Cache locking for instance is not cleared unless BIST is</span>
<span class="cm">	 * enabled.  Unfortunately due to a chip errata G-200 for</span>
<span class="cm">	 * Cn38XX and CN31XX, BIST msut be disabled on these parts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN38XX_PASS2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN31XX</span><span class="p">))</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_BIST</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_BIST</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Default to 64MB in the simulator to speed things up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_is_simulation</span><span class="p">())</span>
		<span class="n">MAX_MEMORY</span> <span class="o">=</span> <span class="mi">64ull</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>

	<span class="n">arcs_cmdline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">argc</span> <span class="o">=</span> <span class="n">octeon_boot_desc_ptr</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span>
			<span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">octeon_boot_desc_ptr</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;MEM=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;mem=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sscanf</span><span class="p">(</span><span class="n">arg</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MAX_MEMORY</span><span class="p">);</span>
			<span class="n">MAX_MEMORY</span> <span class="o">&lt;&lt;=</span> <span class="mi">20</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">MAX_MEMORY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">MAX_MEMORY</span> <span class="o">=</span> <span class="mi">32ull</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;ecc_verbose&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC</span>
			<span class="n">__cvmx_interrupt_ecc_report_single_bit_errors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Reporting of single bit ECC errors is &quot;</span>
				  <span class="s">&quot;turned on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot;console=&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot; console=ttyS0,115200&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">octeon_uart</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot; console=ttyS1,115200&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot; console=ttyS0,115200&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_is_simulation</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The simulator uses a mtdram device pre filled with</span>
<span class="cm">		 * the filesystem. Also specify the calibration delay</span>
<span class="cm">		 * to avoid calculating it every time.</span>
<span class="cm">		 */</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">arcs_cmdline</span><span class="p">,</span> <span class="s">&quot; rw root=1f00 slram=root,0x40000000,+1073741824&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mips_hpt_frequency</span> <span class="o">=</span> <span class="n">octeon_get_clock_rate</span><span class="p">();</span>

	<span class="n">octeon_init_cvmcount</span><span class="p">();</span>
	<span class="n">octeon_setup_delays</span><span class="p">();</span>

	<span class="n">_machine_restart</span> <span class="o">=</span> <span class="n">octeon_restart</span><span class="p">;</span>
	<span class="n">_machine_halt</span> <span class="o">=</span> <span class="n">octeon_halt</span><span class="p">;</span>

	<span class="n">octeon_user_io_init</span><span class="p">();</span>
	<span class="n">register_smp_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_smp_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Exclude a single page from the regions obtained in plat_mem_setup. */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">memory_exclude_page</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">mem</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">mem</span> <span class="o">+</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">add_memory_region</span><span class="p">(</span><span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">BOOT_MEM_RAM</span><span class="p">);</span>
		<span class="o">*</span><span class="n">mem</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">*</span><span class="n">mem</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">mem</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="o">*</span><span class="n">size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">plat_mem_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">mem_alloc_size</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">memory</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Mips memory init uses the first memory location for</span>
<span class="cm">	 * some memory vectors. When SPARSEMEM is in use, it doesn&#39;t</span>
<span class="cm">	 * verify that the size is big enough for the final</span>
<span class="cm">	 * vectors. Making the smallest chuck 4MB seems to be enough</span>
<span class="cm">	 * to consistently work.</span>
<span class="cm">	 */</span>
	<span class="n">mem_alloc_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_alloc_size</span> <span class="o">&gt;</span> <span class="n">MAX_MEMORY</span><span class="p">)</span>
		<span class="n">mem_alloc_size</span> <span class="o">=</span> <span class="n">MAX_MEMORY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When allocating memory, we want incrementing addresses from</span>
<span class="cm">	 * bootmem_alloc so the code in add_memory_region can merge</span>
<span class="cm">	 * regions next to each other.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_bootmem_lock</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">boot_mem_map</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">&lt;</span> <span class="n">BOOT_MEM_MAP_MAX</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">total</span> <span class="o">&lt;</span> <span class="n">MAX_MEMORY</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)</span>
		<span class="n">memory</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="n">mem_alloc_size</span><span class="p">,</span>
						<span class="n">__pa_symbol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__init_end</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						<span class="mh">0x100000</span><span class="p">,</span>
						<span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_HIGHMEM)</span>
		<span class="n">memory</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="n">mem_alloc_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">,</span>
						<span class="mh">0x100000</span><span class="p">,</span>
						<span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">memory</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="n">mem_alloc_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
						<span class="mh">0x100000</span><span class="p">,</span>
						<span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memory</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">size</span> <span class="o">=</span> <span class="n">mem_alloc_size</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * exclude a page at the beginning and end of</span>
<span class="cm">			 * the 256MB PCIe &#39;hole&#39; so the kernel will not</span>
<span class="cm">			 * try to allocate multi-page buffers that</span>
<span class="cm">			 * span the discontinuity.</span>
<span class="cm">			 */</span>
			<span class="n">memory_exclude_page</span><span class="p">(</span><span class="n">CVMX_PCIE_BAR1_PHYS_BASE</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">memory_exclude_page</span><span class="p">(</span><span class="n">CVMX_PCIE_BAR1_PHYS_BASE</span> <span class="o">+</span>
					    <span class="n">CVMX_PCIE_BAR1_PHYS_SIZE</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * This function automatically merges address</span>
<span class="cm">			 * regions next to each other if they are</span>
<span class="cm">			 * received in incrementing order.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
				<span class="n">add_memory_region</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">BOOT_MEM_RAM</span><span class="p">);</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">mem_alloc_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_CAVIUM_RESERVE32</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now that we&#39;ve allocated the kernel memory it is safe to</span>
<span class="cm">	 * free the reserved region. We free it here so that builtin</span>
<span class="cm">	 * drivers can use the memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_reserve32_memory</span><span class="p">)</span>
		<span class="n">cvmx_bootmem_free_named</span><span class="p">(</span><span class="s">&quot;CAVIUM_RESERVE32&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CAVIUM_RESERVE32 */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory from &quot;</span>
		      <span class="s">&quot;cvmx_bootmem_phy_alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Emit one character to the boot UART.  Exported for use by the</span>
<span class="cm"> * watchdog timer.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prom_putchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">lsrval</span><span class="p">;</span>

	<span class="cm">/* Spin until there is room */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">lsrval</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_UARTX_LSR</span><span class="p">(</span><span class="n">octeon_uart</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">lsrval</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Write the byte */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_MIO_UARTX_THR</span><span class="p">(</span><span class="n">octeon_uart</span><span class="p">),</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xffull</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">prom_putchar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">prom_free_prom_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Check for presence of Core-14449 fix.  */</span>
		<span class="n">u32</span> <span class="n">insn</span><span class="p">;</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>

		<span class="n">foo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">insn</span><span class="p">;</span>

		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;# before&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
		<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
			<span class="s">&quot;.set push</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="s">&quot;.set noreorder</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="s">&quot;bal 1f</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="s">&quot;nop</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;1:</span><span class="se">\t</span><span class="s">lw %0,-12($31)</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="s">&quot;.set pop</span><span class="se">\n\t</span><span class="s">&quot;</span>
			<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">insn</span><span class="p">)</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;$31&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x33</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No PREF instruction at Core-14449 probe point.&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">insn</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">28</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Core-14449 WAR not in place (%04x).</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;Please build kernel with proper options (CONFIG_CAVIUM_CN63XXP1).&quot;</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_CAVIUM_DECODE_RSL</span>
	<span class="n">cvmx_interrupt_rsl_enable</span><span class="p">();</span>

	<span class="cm">/* Add an interrupt handler for general failures. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">OCTEON_IRQ_RML</span><span class="p">,</span> <span class="n">octeon_rlm_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="s">&quot;RML/RSL&quot;</span><span class="p">,</span> <span class="n">octeon_rlm_interrupt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unable to request_irq(OCTEON_IRQ_RML)&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
