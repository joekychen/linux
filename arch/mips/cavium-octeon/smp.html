<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › cavium-octeon › smp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2008, 2009, 2010 Cavium Networks</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>

<span class="cp">#include &quot;octeon_boot.h&quot;</span>

<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">octeon_processor_boot</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">octeon_processor_sp</span><span class="p">;</span>
<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">octeon_processor_gp</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="kt">uint64_t</span> <span class="n">octeon_bootloader_entry_addr</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">octeon_bootloader_entry_addr</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mailbox_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="kt">uint64_t</span> <span class="n">action</span><span class="p">;</span>

	<span class="cm">/* Load the mailbox register to figure out what we&#39;re supposed to do */</span>
	<span class="n">action</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_MBOX_CLRX</span><span class="p">(</span><span class="n">coreid</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="cm">/* Clear the mailbox to clear the interrupt */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_MBOX_CLRX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="n">action</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">SMP_CALL_FUNCTION</span><span class="p">)</span>
		<span class="n">smp_call_function_interrupt</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span><span class="p">)</span>
		<span class="n">scheduler_ipi</span><span class="p">();</span>

	<span class="cm">/* Check if we&#39;ve been told to flush the icache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">SMP_ICACHE_FLUSH</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;synci 0($0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Cause the function described by call_data to be executed on the passed</span>
<span class="cm"> * cpu.  When the function has finished, increment the finished field of</span>
<span class="cm"> * call_data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">octeon_send_ipi_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	pr_info(&quot;SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n&quot;, cpu,</span>
<span class="cm">	       coreid, action);</span>
<span class="cm">	*/</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_MBOX_SETX</span><span class="p">(</span><span class="n">coreid</span><span class="p">),</span> <span class="n">action</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">octeon_send_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
		<span class="n">octeon_send_ipi_single</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Detect available CPUs, populate cpu_possible_mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_smp_hotplug_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="n">labi</span><span class="p">;</span>

	<span class="n">labi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">LABI_ADDR_IN_BOOTLOADER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">labi</span><span class="o">-&gt;</span><span class="n">labi_signature</span> <span class="o">!=</span> <span class="n">LABI_SIGNATURE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;The bootloader version on this board is incorrect.&quot;</span><span class="p">);</span>

	<span class="n">octeon_bootloader_entry_addr</span> <span class="o">=</span> <span class="n">labi</span><span class="o">-&gt;</span><span class="n">InitTLBStart_addr</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_smp_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">core_mask</span> <span class="o">=</span> <span class="n">octeon_get_boot_coremask</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_cores</span> <span class="o">=</span> <span class="n">cvmx_octeon_num_cores</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* The present CPUs are initially just the boot cpu (CPU 0). */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__cpu_number_map</span><span class="p">[</span><span class="n">coreid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__cpu_logical_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coreid</span><span class="p">;</span>

	<span class="cm">/* The present CPUs get the lowest CPU numbers. */</span>
	<span class="n">cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">!=</span> <span class="n">coreid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">core_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">__cpu_number_map</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpus</span><span class="p">;</span>
			<span class="n">__cpu_logical_map</span><span class="p">[</span><span class="n">cpus</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="cm">/*</span>
<span class="cm">	 * The possible CPUs are all those present on the chip.  We</span>
<span class="cm">	 * will assign CPU numbers for possible cores as well.  Cores</span>
<span class="cm">	 * are always consecutively numberd from 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">num_cores</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">core_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="n">__cpu_number_map</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpus</span><span class="p">;</span>
			<span class="n">__cpu_logical_map</span><span class="p">[</span><span class="n">cpus</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">octeon_smp_hotplug_setup</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Firmware CPU startup hook</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_boot_secondary</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SMP: Booting CPU%02d (CoreId %2d)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span>
		<span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="n">octeon_processor_sp</span> <span class="o">=</span> <span class="n">__KSTK_TOS</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="n">octeon_processor_gp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">));</span>
	<span class="n">octeon_processor_boot</span> <span class="o">=</span> <span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">octeon_processor_sp</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Waiting for processor to get the SP and GP */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Secondary boot timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * After we&#39;ve done initial boot, this function is called to allow the</span>
<span class="cm"> * board code to clean up state, if needed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">octeon_init_secondary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sr</span><span class="p">;</span>

	<span class="n">sr</span> <span class="o">=</span> <span class="n">set_c0_status</span><span class="p">(</span><span class="n">ST0_BEV</span><span class="p">);</span>
	<span class="n">write_c0_ebase</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">ebase</span><span class="p">);</span>
	<span class="n">write_c0_status</span><span class="p">(</span><span class="n">sr</span><span class="p">);</span>

	<span class="n">octeon_check_cpu_bist</span><span class="p">();</span>
	<span class="n">octeon_init_cvmcount</span><span class="p">();</span>

	<span class="n">octeon_irq_setup_secondary</span><span class="p">();</span>
	<span class="n">raw_local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Callout to firmware before smp_init</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">octeon_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="n">labi</span><span class="p">;</span>

	<span class="n">labi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">LABI_ADDR_IN_BOOTLOADER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">labi</span><span class="o">-&gt;</span><span class="n">labi_signature</span> <span class="o">!=</span> <span class="n">LABI_SIGNATURE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;The bootloader version on this board is incorrect.&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only the low order mailbox bits are used for IPIs, leave</span>
<span class="cm">	 * the other bits alone.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_MBOX_CLRX</span><span class="p">(</span><span class="n">cvmx_get_core_num</span><span class="p">()),</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">OCTEON_IRQ_MBOX0</span><span class="p">,</span> <span class="n">mailbox_interrupt</span><span class="p">,</span>
			<span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_NO_THREAD</span><span class="p">,</span> <span class="s">&quot;SMP-IPI&quot;</span><span class="p">,</span>
			<span class="n">mailbox_interrupt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot request_irq(OCTEON_IRQ_MBOX0)&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Last chance for the board code to finish SMP initialization before</span>
<span class="cm"> * the CPU is &quot;online&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_smp_finish</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CAVIUM_GDB</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="cm">/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also set the MCD0</span>
<span class="cm">	   to be not masked by this core so we know the signal is received by</span>
<span class="cm">	   someone */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;dmfc0 %0, $22</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;ori   %0, %0, 0x9100</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;dmtc0 %0, $22</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">octeon_user_io_init</span><span class="p">();</span>

	<span class="cm">/* to generate the first CPU timer interrupt */</span>
	<span class="n">write_c0_compare</span><span class="p">(</span><span class="n">read_c0_count</span><span class="p">()</span> <span class="o">+</span> <span class="n">mips_hpt_frequency</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Hook for after all CPUs are online</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_cpus_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CAVIUM_GDB</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="cm">/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also set the MCD0</span>
<span class="cm">	   to be not masked by this core so we know the signal is received by</span>
<span class="cm">	   someone */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;dmfc0 %0, $22</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;ori   %0, %0, 0x9100</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;dmtc0 %0, $22</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="cm">/* State of each CPU. */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cpu_state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fixup_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">);</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">fixup_irqs</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">flush_cache_all</span><span class="p">();</span>
	<span class="n">local_flush_tlb_all</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">block_desc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CPU_DEAD</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a bit complicated strategics of getting/settig available</span>
<span class="cm">	 * cores mask, copied from bootloader</span>
<span class="cm">	 */</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">;</span>
	<span class="cm">/* LINUX_APP_BOOT_BLOCK is initialized in bootoct binary */</span>
	<span class="n">block_desc</span> <span class="o">=</span> <span class="n">cvmx_bootmem_find_named_block</span><span class="p">(</span><span class="n">LINUX_APP_BOOT_BLOCK_NAME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="n">labi</span><span class="p">;</span>

		<span class="n">labi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">LABI_ADDR_IN_BOOTLOADER</span><span class="p">);</span>

		<span class="n">labi</span><span class="o">-&gt;</span><span class="n">avail_coremask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">new_mask</span> <span class="o">=</span> <span class="n">labi</span><span class="o">-&gt;</span><span class="n">avail_coremask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		       <span class="cm">/* alternative, already initialized */</span>
		<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">block_desc</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span>
							       <span class="n">AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">new_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Reset core %d. Available Coremask = 0x%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">coreid</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_RST</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">);</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_RST</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_number_map</span><span class="p">(</span><span class="n">cvmx_get_core_num</span><span class="p">());</span>

	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">octeon_processor_boot</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_DEAD</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>	<span class="cm">/* core will be reset here */</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">kernel_entry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_after_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* set a2 = 0 for secondary core */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_update_boot_vector</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">coreid</span> <span class="o">=</span> <span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">avail_coremask</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">block_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">boot_init_vector</span> <span class="o">*</span><span class="n">boot_vect</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">boot_init_vector</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">BOOTLOADER_BOOT_VECTOR</span><span class="p">);</span>

	<span class="n">block_desc</span> <span class="o">=</span> <span class="n">cvmx_bootmem_find_named_block</span><span class="p">(</span><span class="n">LINUX_APP_BOOT_BLOCK_NAME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="n">labi</span><span class="p">;</span>

		<span class="n">labi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_app_boot_info</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span><span class="n">LABI_ADDR_IN_BOOTLOADER</span><span class="p">);</span>

		<span class="n">avail_coremask</span> <span class="o">=</span> <span class="n">labi</span><span class="o">-&gt;</span><span class="n">avail_coremask</span><span class="p">;</span>
		<span class="n">labi</span><span class="o">-&gt;</span><span class="n">avail_coremask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		       <span class="cm">/* alternative, already initialized */</span>
		<span class="n">avail_coremask</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">PHYS_TO_XKSEG_CACHED</span><span class="p">(</span>
			<span class="n">block_desc</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">avail_coremask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* core not available, assume, that catched by simple-executive */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_RST</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_PP_RST</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">boot_vect</span><span class="p">[</span><span class="n">coreid</span><span class="p">].</span><span class="n">app_start_func_addr</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start_after_reset</span><span class="p">;</span>
	<span class="n">boot_vect</span><span class="p">[</span><span class="n">coreid</span><span class="p">].</span><span class="n">code_addr</span> <span class="o">=</span> <span class="n">octeon_bootloader_entry_addr</span><span class="p">;</span>

	<span class="n">mb</span><span class="p">();</span>

	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_NMI</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">coreid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">avail_coremask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">octeon_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">octeon_update_boot_vector</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Cpu %d online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">register_cavium_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">octeon_cpu_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">register_cavium_notifier</span><span class="p">);</span>

<span class="cp">#endif  </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">plat_smp_ops</span> <span class="n">octeon_smp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">send_ipi_single</span>	<span class="o">=</span> <span class="n">octeon_send_ipi_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_ipi_mask</span>		<span class="o">=</span> <span class="n">octeon_send_ipi_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_secondary</span>		<span class="o">=</span> <span class="n">octeon_init_secondary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">smp_finish</span>		<span class="o">=</span> <span class="n">octeon_smp_finish</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpus_done</span>		<span class="o">=</span> <span class="n">octeon_cpus_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">boot_secondary</span>		<span class="o">=</span> <span class="n">octeon_boot_secondary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">smp_setup</span>		<span class="o">=</span> <span class="n">octeon_smp_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare_cpus</span>		<span class="o">=</span> <span class="n">octeon_prepare_cpus</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="p">.</span><span class="n">cpu_disable</span>		<span class="o">=</span> <span class="n">octeon_cpu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpu_die</span>		<span class="o">=</span> <span class="n">octeon_cpu_die</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
