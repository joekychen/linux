<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › cavium-octeon › executive › cvmx-bootmem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cvmx-bootmem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***********************license start***************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2008 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm"> ***********************license end**************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Simple allocate only memory allocator.  Used to allocate memory at</span>
<span class="cm"> * application start time.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/cvmx.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-spinlock.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-bootmem.h&gt;</span>

<span class="cm">/*#define DEBUG */</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">cvmx_bootmem_desc</span> <span class="o">*</span><span class="n">cvmx_bootmem_desc</span><span class="p">;</span>

<span class="cm">/* See header file for descriptions of functions */</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper functions are provided for reading/writing the size and</span>
<span class="cm"> * next block values as these may not be directly addressible (in 32</span>
<span class="cm"> * bit applications, for instance.)  Offsets of data elements in</span>
<span class="cm"> * bootmem list, must match cvmx_bootmem_block_header_t.</span>
<span class="cm"> */</span>
<span class="cp">#define NEXT_OFFSET 0</span>
<span class="cp">#define SIZE_OFFSET 8</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_write64_uint64</span><span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">SIZE_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_write64_uint64</span><span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">NEXT_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">),</span> <span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_read64_uint64</span><span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">SIZE_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_read64_uint64</span><span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">NEXT_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
			       <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">=</span>
	    <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">min_addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span>
				 <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_bootmem_alloc_range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">address</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_bootmem_alloc_range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc_named_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
				     <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">align</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_named_block_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">min_addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span>
						  <span class="n">align</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc_named_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span>
				       <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cvmx_bootmem_alloc_named_range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">cvmx_bootmem_alloc_named</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cvmx_bootmem_alloc_named_range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cvmx_bootmem_alloc_named</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">cvmx_bootmem_free_named</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_bootmem_phy_named_block_free</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="nf">cvmx_bootmem_find_named_block</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cvmx_bootmem_find_named_block</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cvmx_bootmem_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_spinlock_lock</span><span class="p">((</span><span class="n">cvmx_spinlock_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cvmx_bootmem_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_spinlock_unlock</span><span class="p">((</span><span class="n">cvmx_spinlock_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cvmx_bootmem_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem_desc_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Here we set the global pointer to the bootmem descriptor</span>
<span class="cm">	 * block.  This pointer will be used directly, so we will set</span>
<span class="cm">	 * it up to be directly usable by the application.  It is set</span>
<span class="cm">	 * up as follows for the various runtime/ABI combinations:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Linux 64 bit: Set XKPHYS bit</span>
<span class="cm">	 * Linux 32 bit: use mmap to create mapping, use virtual address</span>
<span class="cm">	 * CVMX 64 bit:  use physical address directly</span>
<span class="cm">	 * CVMX 32 bit:  use physical address directly</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the CVMX environment assumes the use of 1-1 TLB</span>
<span class="cm">	 * mappings so that the physical addresses can be used</span>
<span class="cm">	 * directly</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cvmx_bootmem_desc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if   defined(CVMX_ABI_64)</span>
		<span class="cm">/* Set XKPHYS bit */</span>
		<span class="n">cvmx_bootmem_desc</span> <span class="o">=</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">CAST64</span><span class="p">(</span><span class="n">mem_desc_ptr</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">cvmx_bootmem_desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cvmx_bootmem_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">mem_desc_ptr</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The cvmx_bootmem_phy* functions below return 64 bit physical</span>
<span class="cm"> * addresses, and expose more features that the cvmx_bootmem_functions</span>
<span class="cm"> * above.  These are required for full memory space access in 32 bit</span>
<span class="cm"> * applications, as well as for using some advance features.  Most</span>
<span class="cm"> * applications should not need to use these.</span>
<span class="cm"> */</span>

<span class="kt">int64_t</span> <span class="nf">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">req_size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address_min</span><span class="p">,</span>
			       <span class="kt">uint64_t</span> <span class="n">address_max</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
			       <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">uint64_t</span> <span class="n">head_addr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">ent_addr</span><span class="p">;</span>
	<span class="cm">/* points to previous list entry, NULL current entry is head of list */</span>
	<span class="kt">uint64_t</span> <span class="n">prev_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">new_ent_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">desired_min_addr</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_alloc: req_size: 0x%llx, &quot;</span>
		     <span class="s">&quot;min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">req_size</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">address_min</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">address_max</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">alignment</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;ERROR: Incompatible bootmem descriptor &quot;</span>
			     <span class="s">&quot;version: %d.%d at addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">minor_version</span><span class="p">,</span>
			     <span class="n">cvmx_bootmem_desc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a variety of checks to validate the arguments.  The</span>
<span class="cm">	 * allocator code will later assume that these checks have</span>
<span class="cm">	 * been made.  We validate that the requested constraints are</span>
<span class="cm">	 * not self-contradictory before we look through the list of</span>
<span class="cm">	 * available memory.</span>
<span class="cm">	 */</span>

	<span class="cm">/* 0 is not a valid req_size for this allocator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/* Round req_size up to mult of minimum alignment bytes */</span>
	<span class="n">req_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">req_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">CVMX_BOOTMEM_ALIGNMENT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="p">(</span><span class="n">CVMX_BOOTMEM_ALIGNMENT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert !0 address_min and 0 address_max to special case of</span>
<span class="cm">	 * range that specifies an exact memory block to allocate.  Do</span>
<span class="cm">	 * this before other checks and adjustments so that this</span>
<span class="cm">	 * tranformation will be validated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address_min</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">address_max</span><span class="p">)</span>
		<span class="n">address_max</span> <span class="o">=</span> <span class="n">address_min</span> <span class="o">+</span> <span class="n">req_size</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">address_min</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">address_max</span><span class="p">)</span>
		<span class="n">address_max</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ull</span><span class="p">;</span>  <span class="cm">/* If no limits given, use max limits */</span>


	<span class="cm">/*</span>
<span class="cm">	 * Enforce minimum alignment (this also keeps the minimum free block</span>
<span class="cm">	 * req_size the same as the alignment req_size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alignment</span> <span class="o">&lt;</span> <span class="n">CVMX_BOOTMEM_ALIGNMENT_SIZE</span><span class="p">)</span>
		<span class="n">alignment</span> <span class="o">=</span> <span class="n">CVMX_BOOTMEM_ALIGNMENT_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust address minimum based on requested alignment (round</span>
<span class="cm">	 * up to meet alignment).  Do this here so we can reject</span>
<span class="cm">	 * impossible requests up front. (NOP for address_min == 0)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
		<span class="n">address_min</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">address_min</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reject inconsistent args.  We have adjusted these, so this</span>
<span class="cm">	 * may fail due to our internal changes even if this check</span>
<span class="cm">	 * would pass for the values the user supplied.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_size</span> <span class="o">&gt;</span> <span class="n">address_max</span> <span class="o">-</span> <span class="n">address_min</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/* Walk through the list entries - first fit found is returned */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_lock</span><span class="p">();</span>
	<span class="n">head_addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">head_addr</span><span class="p">;</span>
	<span class="n">ent_addr</span> <span class="o">=</span> <span class="n">head_addr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">ent_addr</span><span class="p">;</span>
	     <span class="n">prev_addr</span> <span class="o">=</span> <span class="n">ent_addr</span><span class="p">,</span>
	     <span class="n">ent_addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">usable_base</span><span class="p">,</span> <span class="n">usable_max</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">ent_size</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">ent_addr</span> <span class="o">&gt;</span> <span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;Internal bootmem_alloc() error: ent: &quot;</span>
				<span class="s">&quot;0x%llx, next: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ent_addr</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Determine if this is an entry that can satisify the</span>
<span class="cm">		 * request Check to make sure entry is large enough to</span>
<span class="cm">		 * satisfy request.</span>
<span class="cm">		 */</span>
		<span class="n">usable_base</span> <span class="o">=</span>
		    <span class="n">ALIGN</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">address_min</span><span class="p">,</span> <span class="n">ent_addr</span><span class="p">),</span> <span class="n">alignment</span><span class="p">);</span>
		<span class="n">usable_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">address_max</span><span class="p">,</span> <span class="n">ent_addr</span> <span class="o">+</span> <span class="n">ent_size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We should be able to allocate block at address</span>
<span class="cm">		 * usable_base.</span>
<span class="cm">		 */</span>

		<span class="n">desired_min_addr</span> <span class="o">=</span> <span class="n">usable_base</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Determine if request can be satisfied from the</span>
<span class="cm">		 * current entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">ent_addr</span> <span class="o">+</span> <span class="n">ent_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">usable_base</span>
				<span class="o">&amp;&amp;</span> <span class="n">ent_addr</span> <span class="o">&lt;</span> <span class="n">address_max</span>
				<span class="o">&amp;&amp;</span> <span class="n">req_size</span> <span class="o">&lt;=</span> <span class="n">usable_max</span> <span class="o">-</span> <span class="n">usable_base</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have found an entry that has room to satisfy the</span>
<span class="cm">		 * request, so allocate it from this entry.  If end</span>
<span class="cm">		 * CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate from</span>
<span class="cm">		 * the end of this block rather than the beginning.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_END_ALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desired_min_addr</span> <span class="o">=</span> <span class="n">usable_max</span> <span class="o">-</span> <span class="n">req_size</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Align desired address down to required</span>
<span class="cm">			 * alignment.</span>
<span class="cm">			 */</span>
			<span class="n">desired_min_addr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Match at start of entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desired_min_addr</span> <span class="o">==</span> <span class="n">ent_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">req_size</span> <span class="o">&lt;</span> <span class="n">ent_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * big enough to create a new block</span>
<span class="cm">				 * from top portion of block.</span>
<span class="cm">				 */</span>
				<span class="n">new_ent_addr</span> <span class="o">=</span> <span class="n">ent_addr</span> <span class="o">+</span> <span class="n">req_size</span><span class="p">;</span>
				<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">new_ent_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">));</span>
				<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">new_ent_addr</span><span class="p">,</span>
							<span class="n">ent_size</span> <span class="o">-</span>
							<span class="n">req_size</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Adjust next pointer as following</span>
<span class="cm">				 * code uses this.</span>
<span class="cm">				 */</span>
				<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">,</span>
							<span class="n">new_ent_addr</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * adjust prev ptr or head to remove this</span>
<span class="cm">			 * entry from list.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_addr</span><span class="p">)</span>
				<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="cm">/*</span>
<span class="cm">				 * head of list being returned, so</span>
<span class="cm">				 * update head ptr.</span>
<span class="cm">				 */</span>
				<span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">head_addr</span> <span class="o">=</span>
					<span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
				<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">desired_min_addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * block returned doesn&#39;t start at beginning of entry,</span>
<span class="cm">		 * so we know that we will be splitting a block off</span>
<span class="cm">		 * the front of this one.  Create a new block from the</span>
<span class="cm">		 * beginning, add to list, and go to top of loop</span>
<span class="cm">		 * again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * create new block from high portion of</span>
<span class="cm">		 * block, so that top block starts at desired</span>
<span class="cm">		 * addr.</span>
<span class="cm">		 */</span>
		<span class="n">new_ent_addr</span> <span class="o">=</span> <span class="n">desired_min_addr</span><span class="p">;</span>
		<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">new_ent_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_next</span>
					<span class="p">(</span><span class="n">ent_addr</span><span class="p">));</span>
		<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">new_ent_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_size</span>
					<span class="p">(</span><span class="n">ent_addr</span><span class="p">)</span> <span class="o">-</span>
					<span class="p">(</span><span class="n">desired_min_addr</span> <span class="o">-</span>
						<span class="n">ent_addr</span><span class="p">));</span>
		<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">,</span>
					<span class="n">desired_min_addr</span> <span class="o">-</span> <span class="n">ent_addr</span><span class="p">);</span>
		<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">ent_addr</span><span class="p">,</span> <span class="n">new_ent_addr</span><span class="p">);</span>
		<span class="cm">/* Loop again to handle actual alloc from new block */</span>
	<span class="p">}</span>
<span class="nl">error_out:</span>
	<span class="cm">/* We didn&#39;t find anything, so return error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__cvmx_bootmem_phy_free</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">cur_addr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">prev_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* zero is invalid */</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phy_addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;ERROR: Incompatible bootmem descriptor &quot;</span>
			     <span class="s">&quot;version: %d.%d at addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">minor_version</span><span class="p">,</span>
			     <span class="n">cvmx_bootmem_desc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 0 is not a valid size for this allocator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_lock</span><span class="p">();</span>
	<span class="n">cur_addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">head_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">phy_addr</span> <span class="o">&lt;</span> <span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add at front of list - special case with changing head ptr */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_addr</span> <span class="o">&amp;&amp;</span> <span class="n">phy_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">cur_addr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bootmem_free_done</span><span class="p">;</span>	<span class="cm">/* error, overlapping section */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Add to front of existing first block */</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_next</span>
						  <span class="p">(</span><span class="n">cur_addr</span><span class="p">));</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_size</span>
						  <span class="p">(</span><span class="n">cur_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">head_addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* New block before first block.  OK if cur_addr is 0 */</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">cur_addr</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">head_addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bootmem_free_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find place in list to add block */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur_addr</span> <span class="o">&amp;&amp;</span> <span class="n">phy_addr</span> <span class="o">&gt;</span> <span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_addr</span> <span class="o">=</span> <span class="n">cur_addr</span><span class="p">;</span>
		<span class="n">cur_addr</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">cur_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have reached the end of the list, add on to end,</span>
<span class="cm">		 * checking to see if we need to combine with last</span>
<span class="cm">		 * block</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_addr</span> <span class="o">+</span> <span class="n">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">phy_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_size</span>
						  <span class="p">(</span><span class="n">prev_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bootmem_free_done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * insert between prev and cur nodes, checking for</span>
<span class="cm">		 * merge with either/both.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_addr</span> <span class="o">+</span> <span class="n">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">phy_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Merge with previous */</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_size</span>
						  <span class="p">(</span><span class="n">prev_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Also merge with current */</span>
				<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="n">cur_addr</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">cvmx_bootmem_phy_get_size</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">));</span>
				<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span>
					<span class="n">cvmx_bootmem_phy_get_next</span><span class="p">(</span><span class="n">cur_addr</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bootmem_free_done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">cur_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Merge with current */</span>
			<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_size</span>
						  <span class="p">(</span><span class="n">cur_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span>
						  <span class="n">cvmx_bootmem_phy_get_next</span>
						  <span class="p">(</span><span class="n">cur_addr</span><span class="p">));</span>
			<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bootmem_free_done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* It is a standalone block, add in between prev and cur */</span>
		<span class="n">cvmx_bootmem_phy_set_size</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">phy_addr</span><span class="p">,</span> <span class="n">cur_addr</span><span class="p">);</span>
		<span class="n">cvmx_bootmem_phy_set_next</span><span class="p">(</span><span class="n">prev_addr</span><span class="p">,</span> <span class="n">phy_addr</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">bootmem_free_done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span>
	<span class="nf">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">named_block_array_ptr</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_named_block_find: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lock the structure to make sure that it is not being</span>
<span class="cm">	 * changed while we are examining it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_lock</span><span class="p">();</span>

	<span class="cm">/* Use XKPHYS for 64 bit linux */</span>
	<span class="n">named_block_array_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="p">)</span>
	    <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">named_block_array_addr</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span>
	    <span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_named_block_find: named_block_array_ptr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">named_block_array_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">named_block_num_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">named_block_array_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span>
			     <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">named_block_array_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					 <span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">named_block_name_len</span>
					 <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">named_block_array_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
					<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>

				<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">named_block_array_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;ERROR: Incompatible bootmem descriptor &quot;</span>
			     <span class="s">&quot;version: %d.%d at addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">minor_version</span><span class="p">,</span>
			     <span class="n">cvmx_bootmem_desc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cvmx_bootmem_phy_named_block_free</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">named_block_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;ERROR: Incompatible bootmem descriptor version: &quot;</span>
			     <span class="s">&quot;%d.%d at addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">minor_version</span><span class="p">,</span>
			     <span class="n">cvmx_bootmem_desc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_named_block_free: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take lock here, as name lookup/block free/name free need to</span>
<span class="cm">	 * be atomic.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_bootmem_lock</span><span class="p">();</span>

	<span class="n">named_block_ptr</span> <span class="o">=</span>
	    <span class="n">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
					      <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">named_block_ptr</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_named_block_free: &quot;</span>
			     <span class="s">&quot;%s, base: 0x%llx, size: 0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">name</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">named_block_ptr</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">named_block_ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">__cvmx_bootmem_phy_free</span><span class="p">(</span><span class="n">named_block_ptr</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span>
					<span class="n">named_block_ptr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					<span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
		<span class="n">named_block_ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Set size to zero to indicate block not used. */</span>
	<span class="p">}</span>

	<span class="n">cvmx_bootmem_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">named_block_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* 0 on failure, 1 on success */</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="nf">cvmx_bootmem_phy_named_block_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
					   <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span>
					   <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span> <span class="n">addr_allocated</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">named_block_desc_ptr</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: &quot;</span>
		     <span class="s">&quot;0x%llx, max: 0x%llx, align: 0x%llx, name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">min_addr</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">max_addr</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">alignment</span><span class="p">,</span>
		     <span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;ERROR: Incompatible bootmem descriptor version: &quot;</span>
			     <span class="s">&quot;%d.%d at addr: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">major_version</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">minor_version</span><span class="p">,</span>
			     <span class="n">cvmx_bootmem_desc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take lock here, as name lookup/block alloc/name add need to</span>
<span class="cm">	 * be atomic.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_spinlock_lock</span><span class="p">((</span><span class="n">cvmx_spinlock_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

	<span class="cm">/* Get pointer to first available named block descriptor */</span>
	<span class="n">named_block_desc_ptr</span> <span class="o">=</span>
		<span class="n">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
						  <span class="n">flags</span> <span class="o">|</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if name already in use, return error if name</span>
<span class="cm">	 * not available or no more room for blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
					      <span class="n">flags</span> <span class="o">|</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">named_block_desc_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
			<span class="n">cvmx_spinlock_unlock</span><span class="p">((</span><span class="n">cvmx_spinlock_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Round size up to mult of minimum alignment bytes We need</span>
<span class="cm">	 * the actual size allocated to allow for blocks to be</span>
<span class="cm">	 * coallesced when they are freed.  The alloc routine does the</span>
<span class="cm">	 * same rounding up on all allocations.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">CVMX_BOOTMEM_ALIGNMENT_SIZE</span><span class="p">);</span>

	<span class="n">addr_allocated</span> <span class="o">=</span> <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">min_addr</span><span class="p">,</span> <span class="n">max_addr</span><span class="p">,</span>
						<span class="n">alignment</span><span class="p">,</span>
						<span class="n">flags</span> <span class="o">|</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr_allocated</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">named_block_desc_ptr</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">addr_allocated</span><span class="p">;</span>
		<span class="n">named_block_desc_ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">named_block_desc_ptr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			<span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">named_block_name_len</span><span class="p">);</span>
		<span class="n">named_block_desc_ptr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">named_block_name_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CVMX_BOOTMEM_FLAG_NO_LOCKING</span><span class="p">))</span>
		<span class="n">cvmx_spinlock_unlock</span><span class="p">((</span><span class="n">cvmx_spinlock_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cvmx_bootmem_desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">addr_allocated</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
