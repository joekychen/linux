<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › pci › pci-octeon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pci-octeon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2009 Cavium Networks</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/swiotlb.h&gt;</span>

<span class="cp">#include &lt;asm/time.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-npi-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pci-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/pci-octeon.h&gt;</span>

<span class="cp">#include &lt;dma-coherence.h&gt;</span>

<span class="cp">#define USE_OCTEON_INTERNAL_ARBITER</span>

<span class="cm">/*</span>
<span class="cm"> * Octeon&#39;s PCI controller uses did=3, subdid=2 for PCI IO</span>
<span class="cm"> * addresses. Use PCI endian swapping 1 so no address swapping is</span>
<span class="cm"> * necessary. The Linux io routines will endian swap the data.</span>
<span class="cm"> */</span>
<span class="cp">#define OCTEON_PCI_IOSPACE_BASE     0x80011a0400000000ull</span>
<span class="cp">#define OCTEON_PCI_IOSPACE_SIZE     (1ull&lt;&lt;32)</span>

<span class="cm">/* Octeon&#39;t PCI controller uses did=3, subdid=3 for PCI memory. */</span>
<span class="cp">#define OCTEON_PCI_MEMSPACE_OFFSET  (0x00011b0000000000ull)</span>

<span class="n">u64</span> <span class="n">octeon_bar1_pci_phys</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This is the bit decoding used for the Octeon PCI controller addresses</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">octeon_pci_address</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">upper</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">subdid</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">endian_swap</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">bus</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">dev</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">func</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reg</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__initdata</span> <span class="p">(</span><span class="o">*</span><span class="n">octeon_pcibios_map_irq</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">octeon_dma_bar_type</span> <span class="n">octeon_dma_bar_type</span> <span class="o">=</span> <span class="n">OCTEON_DMA_BAR_TYPE_INVALID</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Map a PCI device to the appropriate interrupt line</span>
<span class="cm"> *</span>
<span class="cm"> * @dev:    The Linux PCI device structure for the device to map</span>
<span class="cm"> * @slot:   The slot number for this device on __BUS 0__. Linux</span>
<span class="cm"> *               enumerates through all the bridges and figures out the</span>
<span class="cm"> *               slot on Bus 0 where this device eventually hooks to.</span>
<span class="cm"> * @pin:    The PCI interrupt pin read from the device, then swizzled</span>
<span class="cm"> *               as it goes through each bridge.</span>
<span class="cm"> * Returns Interrupt number for the device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcibios_map_irq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_pcibios_map_irq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">octeon_pcibios_map_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;octeon_pcibios_map_irq not set.&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called to perform platform specific PCI setup</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcibios_plat_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">config</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dconfig</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Force the Cache line setting to 64 bytes. The standard</span>
<span class="cm">	 * Linux bus scan doesn&#39;t seem to set it. Octeon really has</span>
<span class="cm">	 * 128 byte lines, but Intel bridges get really upset if you</span>
<span class="cm">	 * try and set values above 64 bytes. Value is specified in</span>
<span class="cm">	 * 32bit words.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="mi">64</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="cm">/* Set latency timers for all devices */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="cm">/* Enable reporting System errors and parity errors on all devices */</span>
	<span class="cm">/* Enable parity checking and error reporting */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
	<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_PARITY</span> <span class="o">|</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set latency timers on sub bridges */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_SEC_LATENCY_TIMER</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="cm">/* More bridge error detection */</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_BRIDGE_CTL_PARITY</span> <span class="o">|</span> <span class="n">PCI_BRIDGE_CTL_SERR</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BRIDGE_CONTROL</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable the PCIe normal error reporting */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update Device Control */</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL_CERE</span><span class="p">;</span> <span class="cm">/* Correctable Error Reporting */</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL_NFERE</span><span class="p">;</span> <span class="cm">/* Non-Fatal Error Reporting */</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL_FERE</span><span class="p">;</span>  <span class="cm">/* Fatal Error Reporting */</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_EXP_DEVCTL_URRE</span><span class="p">;</span>  <span class="cm">/* Unsupported Request */</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Find the Advanced Error Reporting capability */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_EXT_CAP_ID_ERR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear Uncorrectable Error Status */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_STATUS</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">dconfig</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_STATUS</span><span class="p">,</span>
				       <span class="n">dconfig</span><span class="p">);</span>
		<span class="cm">/* Enable reporting of all uncorrectable errors */</span>
		<span class="cm">/* Uncorrectable Error Mask - turned on bits disable errors */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_UNCOR_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Leave severity at HW default. This only controls if</span>
<span class="cm">		 * errors are reported as uncorrectable or</span>
<span class="cm">		 * correctable, not if the error is reported.</span>
<span class="cm">		 */</span>
		<span class="cm">/* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */</span>
		<span class="cm">/* Clear Correctable Error Status */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_COR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dconfig</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_COR_STATUS</span><span class="p">,</span> <span class="n">dconfig</span><span class="p">);</span>
		<span class="cm">/* Enable reporting of all correctable errors */</span>
		<span class="cm">/* Correctable Error Mask - turned on bits disable errors */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_COR_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Advanced Error Capabilities */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_CAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dconfig</span><span class="p">);</span>
		<span class="cm">/* ECRC Generation Enable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_CAP_ECRC_GENC</span><span class="p">)</span>
			<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_ERR_CAP_ECRC_GENE</span><span class="p">;</span>
		<span class="cm">/* ECRC Check Enable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_CAP_ECRC_CHKC</span><span class="p">)</span>
			<span class="n">config</span> <span class="o">|=</span> <span class="n">PCI_ERR_CAP_ECRC_CHKE</span><span class="p">;</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_CAP</span><span class="p">,</span> <span class="n">dconfig</span><span class="p">);</span>
		<span class="cm">/* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */</span>
		<span class="cm">/* Report all errors to the root complex */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_ROOT_COMMAND</span><span class="p">,</span>
				       <span class="n">PCI_ERR_ROOT_CMD_COR_EN</span> <span class="o">|</span>
				       <span class="n">PCI_ERR_ROOT_CMD_NONFATAL_EN</span> <span class="o">|</span>
				       <span class="n">PCI_ERR_ROOT_CMD_FATAL_EN</span><span class="p">);</span>
		<span class="cm">/* Clear the Root status register */</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_ROOT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dconfig</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_ERR_ROOT_STATUS</span><span class="p">,</span> <span class="n">dconfig</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">dma_ops</span> <span class="o">=</span> <span class="n">octeon_pci_dma_map_ops</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Return the mapping of PCI device number to IRQ line. Each</span>
<span class="cm"> * character in the return string represents the interrupt</span>
<span class="cm"> * line for the device at that position. Device 1 maps to the</span>
<span class="cm"> * first character, etc. The characters A-D are used for PCI</span>
<span class="cm"> * interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns PCI interrupt mapping</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">octeon_get_pci_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Returning an empty string causes the interrupts to be</span>
<span class="cm">	 * routed based on the PCI specification. From the PCI spec:</span>
<span class="cm">	 *</span>
<span class="cm">	 * INTA# of Device Number 0 is connected to IRQW on the system</span>
<span class="cm">	 * board.  (Device Number has no significance regarding being</span>
<span class="cm">	 * located on the system board or in a connector.) INTA# of</span>
<span class="cm">	 * Device Number 1 is connected to IRQX on the system</span>
<span class="cm">	 * board. INTA# of Device Number 2 is connected to IRQY on the</span>
<span class="cm">	 * system board. INTA# of Device Number 3 is connected to IRQZ</span>
<span class="cm">	 * on the system board. The table below describes how each</span>
<span class="cm">	 * agent&#39;s INTx# lines are connected to the system board</span>
<span class="cm">	 * interrupt lines. The following equation can be used to</span>
<span class="cm">	 * determine to which INTx# signal on the system board a given</span>
<span class="cm">	 * device&#39;s INTx# line(s) is connected.</span>
<span class="cm">	 *</span>
<span class="cm">	 * MB = (D + I) MOD 4 MB = System board Interrupt (IRQW = 0,</span>
<span class="cm">	 * IRQX = 1, IRQY = 2, and IRQZ = 3) D = Device Number I =</span>
<span class="cm">	 * Interrupt Number (INTA# = 0, INTB# = 1, INTC# = 2, and</span>
<span class="cm">	 * INTD# = 3)</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">octeon_bootinfo</span><span class="o">-&gt;</span><span class="n">board_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_NAO38</span>:
		<span class="cm">/* This is really the NAC38 */</span>
		<span class="k">return</span> <span class="s">&quot;AAAAADABAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_EBH3100</span>:
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_CN3010_EVB_HS5</span>:
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_CN3005_EVB_HS5</span>:
		<span class="k">return</span> <span class="s">&quot;AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_BBGW_REF</span>:
		<span class="k">return</span> <span class="s">&quot;AABCD&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_THUNDER</span>:
	<span class="k">case</span> <span class="n">CVMX_BOARD_TYPE_EBH3000</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Map a PCI device to the appropriate interrupt line</span>
<span class="cm"> *</span>
<span class="cm"> * @dev:    The Linux PCI device structure for the device to map</span>
<span class="cm"> * @slot:   The slot number for this device on __BUS 0__. Linux</span>
<span class="cm"> *               enumerates through all the bridges and figures out the</span>
<span class="cm"> *               slot on Bus 0 where this device eventually hooks to.</span>
<span class="cm"> * @pin:    The PCI interrupt pin read from the device, then swizzled</span>
<span class="cm"> *               as it goes through each bridge.</span>
<span class="cm"> * Returns Interrupt number for the device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">octeon_pci_pcibios_map_irq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_num</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">interrupts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_num</span><span class="p">;</span>

	<span class="cm">/* Get the board specific interrupt mapping */</span>
	<span class="n">interrupts</span> <span class="o">=</span> <span class="n">octeon_get_pci_interrupts</span><span class="p">();</span>

	<span class="n">dev_num</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_num</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">interrupts</span><span class="p">))</span>
		<span class="n">irq_num</span> <span class="o">=</span> <span class="p">((</span><span class="n">interrupts</span><span class="p">[</span><span class="n">dev_num</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">pin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">OCTEON_IRQ_PCI_INT0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq_num</span> <span class="o">=</span> <span class="p">((</span><span class="n">slot</span> <span class="o">+</span> <span class="n">pin</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">OCTEON_IRQ_PCI_INT0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">irq_num</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Read a value from configuration space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">octeon_pci_address</span> <span class="n">pci_addr</span><span class="p">;</span>

	<span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">subdid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">endian_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>

<span class="cp">#if PCI_CONFIG_SPACE_DELAY</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">PCI_CONFIG_SPACE_DELAY</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cvmx_read64_uint32</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cvmx_read64_uint16</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">cvmx_read64_uint8</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Write a value to PCI configuration space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">octeon_pci_address</span> <span class="n">pci_addr</span><span class="p">;</span>

	<span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">subdid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">endian_swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">pci_addr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>

<span class="cp">#if PCI_CONFIG_SPACE_DELAY</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">PCI_CONFIG_SPACE_DELAY</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">cvmx_write64_uint16</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">cvmx_write64_uint8</span><span class="p">(</span><span class="n">pci_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">octeon_pci_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">octeon_read_config</span><span class="p">,</span>
	<span class="n">octeon_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pci_mem_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCI MEM&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * PCI ports must be above 16KB so the ISA bus filtering in the PCI-X to PCI</span>
<span class="cm"> * bridge</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pci_io_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">OCTEON_PCI_IOSPACE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCI IO&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">octeon_pci_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pci_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pci_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pci_mem_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_offset</span> <span class="o">=</span> <span class="n">OCTEON_PCI_MEMSPACE_OFFSET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pci_io_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_map_base</span> <span class="o">=</span> <span class="n">OCTEON_PCI_IOSPACE_BASE</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Low level initialize the Octeon PCI controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">octeon_pci_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pci_cfg01</span> <span class="n">cfg01</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npi_ctl_status</span> <span class="n">ctl_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pci_ctl_status_2</span> <span class="n">ctl_status_2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pci_cfg19</span> <span class="n">cfg19</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pci_cfg16</span> <span class="n">cfg16</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pci_cfg22</span> <span class="n">cfg22</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pci_cfg56</span> <span class="n">cfg56</span><span class="p">;</span>

	<span class="cm">/* Reset the PCI Bus */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>		<span class="cm">/* Hold PCI reset for 2 ms */</span>

	<span class="n">ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* cvmx_read_csr(CVMX_NPI_CTL_STATUS); */</span>
	<span class="n">ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">max_word</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_NPI_CTL_STATUS</span><span class="p">,</span> <span class="n">ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Deassert PCI reset and advertize PCX Host Mode Device Capability</span>
<span class="cm">	   (64b) */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>
	<span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>		<span class="cm">/* Wait 2 ms after deasserting PCI reset */</span>

	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tsr_hwm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Initializes to 0.  Must be set</span>
<span class="cm">					   before any PCI reads. */</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2pres</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Enable BAR2 */</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_cax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Don&#39;t use L2 */</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_esx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pmo_amod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Round robin priority */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_dma_bar_type</span> <span class="o">==</span> <span class="n">OCTEON_DMA_BAR_TYPE_BIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* BAR1 hole */</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb1_hole</span> <span class="o">=</span> <span class="n">OCTEON_PCI_BAR1_HOLE_BITS</span><span class="p">;</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb1_siz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* BAR1 is 2GB */</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb_ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Don&#39;t use L2 with big bars */</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb_es</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Big bar in byte swap mode */</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* BAR1 is big */</span>
		<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bb0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* BAR0 is big */</span>
	<span class="p">}</span>

	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CTL_STATUS_2</span><span class="p">,</span> <span class="n">ctl_status_2</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>		<span class="cm">/* Wait 2 ms before doing PCI reads */</span>

	<span class="n">ctl_status_2</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">octeon_npi_read32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CTL_STATUS_2</span><span class="p">);</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCI Status: %s %s-bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ap_pcix</span> <span class="o">?</span> <span class="s">&quot;PCI-X&quot;</span> <span class="o">:</span> <span class="s">&quot;PCI&quot;</span><span class="p">,</span>
		  <span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ap_64ad</span> <span class="o">?</span> <span class="s">&quot;64&quot;</span> <span class="o">:</span> <span class="s">&quot;32&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN58XX</span><span class="p">)</span> <span class="o">||</span> <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN50XX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pci_cnt_reg</span> <span class="n">cnt_reg_start</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">cvmx_pci_cnt_reg</span> <span class="n">cnt_reg_end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">pci_clock</span><span class="p">;</span>

		<span class="n">cnt_reg_start</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CNT_REG</span><span class="p">);</span>
		<span class="n">cycles</span> <span class="o">=</span> <span class="n">read_c0_cvmcount</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">cnt_reg_end</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CNT_REG</span><span class="p">);</span>
		<span class="n">cycles</span> <span class="o">=</span> <span class="n">read_c0_cvmcount</span><span class="p">()</span> <span class="o">-</span> <span class="n">cycles</span><span class="p">;</span>
		<span class="n">pci_clock</span> <span class="o">=</span> <span class="p">(</span><span class="n">cnt_reg_end</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pcicnt</span> <span class="o">-</span> <span class="n">cnt_reg_start</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pcicnt</span><span class="p">)</span> <span class="o">/</span>
			    <span class="p">(</span><span class="n">cycles</span> <span class="o">/</span> <span class="p">(</span><span class="n">mips_hpt_frequency</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">));</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCI Clock: %lu MHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_clock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * TDOMC must be set to one in PCI mode. TDOMC should be set to 4</span>
<span class="cm">	 * in PCI-X mode to allow four outstanding splits. Otherwise,</span>
<span class="cm">	 * should not change from its reset value. Don&#39;t write PCI_CFG19</span>
<span class="cm">	 * in PCI mode (0x82000001 reset value), write it to 0x82000004</span>
<span class="cm">	 * after PCI-X mode is known. MRBCI,MDWE,MDRE -&gt; must be zero.</span>
<span class="cm">	 * MRBCM -&gt; must be one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_status_2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ap_pcix</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg19</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Target Delayed/Split request outstanding maximum</span>
<span class="cm">		 * count. [1..31] and 0=32.  NOTE: If the user</span>
<span class="cm">		 * programs these bits beyond the Designed Maximum</span>
<span class="cm">		 * outstanding count, then the designed maximum table</span>
<span class="cm">		 * depth will be used instead.  No additional</span>
<span class="cm">		 * Deferred/Split transactions will be accepted if</span>
<span class="cm">		 * this outstanding maximum count is</span>
<span class="cm">		 * reached. Furthermore, no additional deferred/split</span>
<span class="cm">		 * transactions will be accepted if the I/O delay/ I/O</span>
<span class="cm">		 * Split Request outstanding maximum is reached.</span>
<span class="cm">		 */</span>
		<span class="n">cfg19</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tdomc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Master Deferred Read Request Outstanding Max Count</span>
<span class="cm">		 * (PCI only).  CR4C[26:24] Max SAC cycles MAX DAC</span>
<span class="cm">		 * cycles 000 8 4 001 1 0 010 2 1 011 3 1 100 4 2 101</span>
<span class="cm">		 * 5 2 110 6 3 111 7 3 For example, if these bits are</span>
<span class="cm">		 * programmed to 100, the core can support 2 DAC</span>
<span class="cm">		 * cycles, 4 SAC cycles or a combination of 1 DAC and</span>
<span class="cm">		 * 2 SAC cycles. NOTE: For the PCI-X maximum</span>
<span class="cm">		 * outstanding split transactions, refer to</span>
<span class="cm">		 * CRE0[22:20].</span>
<span class="cm">		 */</span>
		<span class="n">cfg19</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mdrrmc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Master Request (Memory Read) Byte Count/Byte Enable</span>
<span class="cm">		 * select. 0 = Byte Enables valid. In PCI mode, a</span>
<span class="cm">		 * burst transaction cannot be performed using Memory</span>
<span class="cm">		 * Read command=4?h6. 1 = DWORD Byte Count valid</span>
<span class="cm">		 * (default). In PCI Mode, the memory read byte</span>
<span class="cm">		 * enables are automatically generated by the</span>
<span class="cm">		 * core. Note: N3 Master Request transaction sizes are</span>
<span class="cm">		 * always determined through the</span>
<span class="cm">		 * am_attr[&lt;35:32&gt;|&lt;7:0&gt;] field.</span>
<span class="cm">		 */</span>
		<span class="n">cfg19</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrbcm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG19</span><span class="p">,</span> <span class="n">cfg19</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">cfg01</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg01</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">msae</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Memory Space Access Enable */</span>
	<span class="n">cfg01</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">me</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Master Enable */</span>
	<span class="n">cfg01</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* PERR# Enable */</span>
	<span class="n">cfg01</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">see</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* System Error Enable */</span>
	<span class="n">cfg01</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">fbbe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Fast Back to Back Transaction Enable */</span>

	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG01</span><span class="p">,</span> <span class="n">cfg01</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

<span class="cp">#ifdef USE_OCTEON_INTERNAL_ARBITER</span>
	<span class="cm">/*</span>
<span class="cm">	 * When OCTEON is a PCI host, most systems will use OCTEON&#39;s</span>
<span class="cm">	 * internal arbiter, so must enable it before any PCI/PCI-X</span>
<span class="cm">	 * traffic can occur.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npi_pci_int_arb_cfg</span> <span class="n">pci_int_arb_cfg</span><span class="p">;</span>

		<span class="n">pci_int_arb_cfg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_int_arb_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Internal arbiter enable */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_INT_ARB_CFG</span><span class="p">,</span> <span class="n">pci_int_arb_cfg</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* USE_OCTEON_INTERNAL_ARBITER */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Preferably written to 1 to set MLTD. [RDSATI,TRTAE,</span>
<span class="cm">	 * TWTAE,TMAE,DPPMR -&gt; must be zero. TILT -&gt; must not be set to</span>
<span class="cm">	 * 1..7.</span>
<span class="cm">	 */</span>
	<span class="n">cfg16</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg16</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mltd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Master Latency Timer Disable */</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG16</span><span class="p">,</span> <span class="n">cfg16</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should be written to 0x4ff00. MTTV -&gt; must be zero.</span>
<span class="cm">	 * FLUSH -&gt; must be 1. MRV -&gt; should be 0xFF.</span>
<span class="cm">	 */</span>
	<span class="n">cfg22</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Master Retry Value [1..255] and 0=infinite */</span>
	<span class="n">cfg22</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrv</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * AM_DO_FLUSH_I control NOTE: This bit MUST BE ONE for proper</span>
<span class="cm">	 * N3K operation.</span>
<span class="cm">	 */</span>
	<span class="n">cfg22</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG22</span><span class="p">,</span> <span class="n">cfg22</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * MOST Indicates the maximum number of outstanding splits (in -1</span>
<span class="cm">	 * notation) when OCTEON is in PCI-X mode.  PCI-X performance is</span>
<span class="cm">	 * affected by the MOST selection.  Should generally be written</span>
<span class="cm">	 * with one of 0x3be807, 0x2be807, 0x1be807, or 0x0be807,</span>
<span class="cm">	 * depending on the desired MOST of 3, 2, 1, or 0, respectively.</span>
<span class="cm">	 */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pxcid</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>	<span class="cm">/* RO - PCI-X Capability ID */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ncp</span> <span class="o">=</span> <span class="mh">0xe8</span><span class="p">;</span>	<span class="cm">/* RO - Next Capability Pointer */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dpere</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Data Parity Error Recovery Enable */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">roe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Relaxed Ordering Enable */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mmbc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Maximum Memory Byte Count</span>
<span class="cm">				   [0=512B,1=1024B,2=2048B,3=4096B] */</span>
	<span class="n">cfg56</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">most</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* Maximum outstanding Split transactions [0=1</span>
<span class="cm">				   .. 7=32] */</span>

	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG56</span><span class="p">,</span> <span class="n">cfg56</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Affects PCI performance when OCTEON services reads to its</span>
<span class="cm">	 * BAR1/BAR2. Refer to Section 10.6.1.  The recommended values are</span>
<span class="cm">	 * 0x22, 0x33, and 0x33 for PCI_READ_CMD_6, PCI_READ_CMD_C, and</span>
<span class="cm">	 * PCI_READ_CMD_E, respectively. Unfortunately due to errata DDR-700,</span>
<span class="cm">	 * these values need to be changed so they won&#39;t possibly prefetch off</span>
<span class="cm">	 * of the end of memory if PCI is DMAing a buffer at the end of</span>
<span class="cm">	 * memory. Note that these values differ from their reset values.</span>
<span class="cm">	 */</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_READ_CMD_6</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">);</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_READ_CMD_C</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">);</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_READ_CMD_E</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize the Octeon PCI controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">octeon_pci_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_npi_mem_access_subidx</span> <span class="n">mem_access</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Only these chips have PCI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_PCIE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Point pcibios_map_irq() to the PCI version of it */</span>
	<span class="n">octeon_pcibios_map_irq</span> <span class="o">=</span> <span class="n">octeon_pci_pcibios_map_irq</span><span class="p">;</span>

	<span class="cm">/* Only use the big bars on chips that support it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN31XX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN38XX_PASS2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN38XX_PASS1</span><span class="p">))</span>
		<span class="n">octeon_dma_bar_type</span> <span class="o">=</span> <span class="n">OCTEON_DMA_BAR_TYPE_SMALL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">octeon_dma_bar_type</span> <span class="o">=</span> <span class="n">OCTEON_DMA_BAR_TYPE_BIG</span><span class="p">;</span>

	<span class="cm">/* PCI I/O and PCI MEM values */</span>
	<span class="n">set_io_port_base</span><span class="p">(</span><span class="n">OCTEON_PCI_IOSPACE_BASE</span><span class="p">);</span>
	<span class="n">ioport_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioport_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">OCTEON_PCI_IOSPACE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">octeon_is_pci_host</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Not in host mode, PCI Controller not initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%s Octeon big bar support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">octeon_dma_bar_type</span> <span class="o">==</span>
		  <span class="n">OCTEON_DMA_BAR_TYPE_BIG</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Enabling&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabling&quot;</span><span class="p">);</span>

	<span class="n">octeon_pci_initialize</span><span class="p">();</span>

	<span class="n">mem_access</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Endian-Swap on read. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Endian-Swap on write. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No-Snoop on read. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nsw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No-Snoop on write. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Relax Read on read. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Relax Order on write. */</span>
	<span class="n">mem_access</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* PCI Address bits [63:36]. */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_NPI_MEM_ACCESS_SUBID3</span><span class="p">,</span> <span class="n">mem_access</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remap the Octeon BAR 2 above all 32 bit devices</span>
<span class="cm">	 * (0x8000000000ul).  This is done here so it is remapped</span>
<span class="cm">	 * before the readl()&#39;s below. We don&#39;t want BAR2 overlapping</span>
<span class="cm">	 * with BAR0/BAR1 during these reads.</span>
<span class="cm">	 */</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG08</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">OCTEON_BAR2_PCI_ADDRESS</span> <span class="o">&amp;</span> <span class="mh">0xffffffffull</span><span class="p">));</span>
	<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG09</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">OCTEON_BAR2_PCI_ADDRESS</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_dma_bar_type</span> <span class="o">==</span> <span class="n">OCTEON_DMA_BAR_TYPE_BIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Remap the Octeon BAR 0 to 0-2GB */</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG04</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG05</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remap the Octeon BAR 1 to map 2GB-4GB (minus the</span>
<span class="cm">		 * BAR 1 hole).</span>
<span class="cm">		 */</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG06</span><span class="p">,</span> <span class="mi">2ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG07</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* BAR1 movable mappings set for identity mapping */</span>
		<span class="n">octeon_bar1_pci_phys</span> <span class="o">=</span> <span class="mh">0x80000000ull</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_pci_bar1_indexx</span> <span class="n">bar1_index</span><span class="p">;</span>

			<span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Address bits[35:22] sent to L2C */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">octeon_bar1_pci_phys</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
			<span class="cm">/* Don&#39;t put PCI accesses in L2. */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Endian Swap Mode */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">end_swp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Set &#39;1&#39; when the selected address range is valid. */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_BAR1_INDEXX</span><span class="p">(</span><span class="n">index</span><span class="p">),</span>
					   <span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Devices go after BAR1 */</span>
		<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span>
			<span class="n">OCTEON_PCI_MEMSPACE_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">OCTEON_PCI_BAR1_HOLE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span>
			<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Remap the Octeon BAR 0 to map 128MB-(128MB+4KB) */</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG04</span><span class="p">,</span> <span class="mi">128ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG05</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Remap the Octeon BAR 1 to map 0-128MB */</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG06</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_CFG07</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* BAR1 movable regions contiguous to cover the swiotlb */</span>
		<span class="n">octeon_bar1_pci_phys</span> <span class="o">=</span>
			<span class="n">virt_to_phys</span><span class="p">(</span><span class="n">octeon_swiotlb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_pci_bar1_indexx</span> <span class="n">bar1_index</span><span class="p">;</span>

			<span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Address bits[35:22] sent to L2C */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">octeon_bar1_pci_phys</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
			<span class="cm">/* Don&#39;t put PCI accesses in L2. */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Endian Swap Mode */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">end_swp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Set &#39;1&#39; when the selected address range is valid. */</span>
			<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">octeon_npi_write32</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_BAR1_INDEXX</span><span class="p">(</span><span class="n">index</span><span class="p">),</span>
					   <span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Devices go after BAR0 */</span>
		<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span>
			<span class="n">OCTEON_PCI_MEMSPACE_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="mi">128ul</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="mi">4ul</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span>
			<span class="n">octeon_pci_mem_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">register_pci_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_pci_controller</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any errors that might be pending from before the bus</span>
<span class="cm">	 * was setup properly.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_NPI_PCI_INT_SUM2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">octeon_pci_dma_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arch_initcall</span><span class="p">(</span><span class="n">octeon_pci_setup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
