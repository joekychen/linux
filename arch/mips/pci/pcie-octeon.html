<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › pci › pcie-octeon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pcie-octeon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007, 2008, 2009, 2010, 2011 Cavium Networks</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/octeon/octeon.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-npei-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pciercx-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pescx-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pexp-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-pemx-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-dpi-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-sli-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-sriox-defs.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/cvmx-helper-errata.h&gt;</span>
<span class="cp">#include &lt;asm/octeon/pci-octeon.h&gt;</span>

<span class="cp">#define MRRS_CN5XXX 0 </span><span class="cm">/* 128 byte Max Read Request Size */</span><span class="cp"></span>
<span class="cp">#define MPS_CN5XXX  0 </span><span class="cm">/* 128 byte Max Packet Size (Limit of most PCs) */</span><span class="cp"></span>
<span class="cp">#define MRRS_CN6XXX 3 </span><span class="cm">/* 1024 byte Max Read Request Size */</span><span class="cp"></span>
<span class="cp">#define MPS_CN6XXX  0 </span><span class="cm">/* 128 byte Max Packet Size (Limit of most PCs) */</span><span class="cp"></span>

<span class="cm">/* Module parameter to disable PCI probing */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcie_disable</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">pcie_disable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">enable_pcie_14459_war</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">enable_pcie_bus_num_war</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">union</span> <span class="n">cvmx_pcie_address</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">upper</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Normally 2 for XKPHYS */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 1 for IO space access */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>	<span class="cm">/* PCIe DID = 3 */</span>
		<span class="kt">uint64_t</span> <span class="n">subdid</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* PCIe SubDID = 1 */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_36_39</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">es</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Endian swap = 1 */</span>
		<span class="kt">uint64_t</span> <span class="n">port</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* PCIe port 0,1 */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_29_31</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Selects the type of the configuration request (0 = type 0,</span>
<span class="cm">		 * 1 = type 1).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">ty</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Target bus number sent in the ID in the request. */</span>
		<span class="kt">uint64_t</span> <span class="n">bus</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Target device number sent in the ID in the</span>
<span class="cm">		 * request. Note that Dev must be zero for type 0</span>
<span class="cm">		 * configuration requests.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">dev</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="cm">/* Target function number sent in the ID in the request. */</span>
		<span class="kt">uint64_t</span> <span class="n">func</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Selects a register in the configuration space of</span>
<span class="cm">		 * the target.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">reg</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">config</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">upper</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Normally 2 for XKPHYS */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 1 for IO space access */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>	<span class="cm">/* PCIe DID = 3 */</span>
		<span class="kt">uint64_t</span> <span class="n">subdid</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* PCIe SubDID = 2 */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_36_39</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">es</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Endian swap = 1 */</span>
		<span class="kt">uint64_t</span> <span class="n">port</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* PCIe port 0,1 */</span>
		<span class="kt">uint64_t</span> <span class="n">address</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>	<span class="cm">/* PCIe IO address */</span>
	<span class="p">}</span> <span class="n">io</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">upper</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Normally 2 for XKPHYS */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 1 for IO space access */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>	<span class="cm">/* PCIe DID = 3 */</span>
		<span class="kt">uint64_t</span> <span class="n">subdid</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* PCIe SubDID = 3-6 */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_36_39</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">address</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>	<span class="cm">/* PCIe Mem address */</span>
	<span class="p">}</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cvmx_pcie_rc_initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">);</span>

<span class="cp">#include &lt;dma-coherence.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * Return the Core virtual base address for PCIe IO access. IOs are</span>
<span class="cm"> * read/written as an offset from this address.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the IO is for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 64bit Octeon IO base address for read/write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pcie_address</span> <span class="n">pcie_addr</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">subdid</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">pcie_port</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Size of the IO address region returned at address</span>
<span class="cm"> * cvmx_pcie_get_io_base_address()</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the IO is for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Size of the IO window</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_pcie_get_io_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Return the Core virtual base address for PCIe MEM access. Memory is</span>
<span class="cm"> * read/written as an offset from this address.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the IO is for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 64bit Octeon IO base address for read/write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pcie_address</span> <span class="n">pcie_addr</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">subdid</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">pcie_port</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Size of the Mem address region returned at address</span>
<span class="cm"> * cvmx_pcie_get_mem_base_address()</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the IO is for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Size of the Mem window</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_pcie_get_mem_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">36</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Read a PCIe config space register indirectly. This is used for</span>
<span class="cm"> * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port:  PCIe port to read from</span>
<span class="cm"> * @cfg_offset: Address to read</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Value read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cfg_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pescx_cfg_rd</span> <span class="n">pescx_cfg_rd</span><span class="p">;</span>
		<span class="n">pescx_cfg_rd</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pescx_cfg_rd</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cfg_offset</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CFG_RD</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pescx_cfg_rd</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">pescx_cfg_rd</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CFG_RD</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">pescx_cfg_rd</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pemx_cfg_rd</span> <span class="n">pemx_cfg_rd</span><span class="p">;</span>
		<span class="n">pemx_cfg_rd</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pemx_cfg_rd</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cfg_offset</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CFG_RD</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pemx_cfg_rd</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">pemx_cfg_rd</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CFG_RD</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">pemx_cfg_rd</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write a PCIe config space register indirectly. This is used for</span>
<span class="cm"> * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port:  PCIe port to write to</span>
<span class="cm"> * @cfg_offset: Address to write</span>
<span class="cm"> * @val:        Value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cfg_offset</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pescx_cfg_wr</span> <span class="n">pescx_cfg_wr</span><span class="p">;</span>
		<span class="n">pescx_cfg_wr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pescx_cfg_wr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cfg_offset</span><span class="p">;</span>
		<span class="n">pescx_cfg_wr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CFG_WR</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pescx_cfg_wr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pemx_cfg_wr</span> <span class="n">pemx_cfg_wr</span><span class="p">;</span>
		<span class="n">pemx_cfg_wr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pemx_cfg_wr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cfg_offset</span><span class="p">;</span>
		<span class="n">pemx_cfg_wr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CFG_WR</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pemx_cfg_wr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Build a PCIe config space request address for a device</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to access</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 64bit Octeon IO address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pcie_address</span> <span class="n">pcie_addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg006</span> <span class="n">pciercx_cfg006</span><span class="p">;</span>

	<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span>
	    <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG006</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bus</span> <span class="o">&lt;=</span> <span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pbnum</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">subdid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">pcie_port</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">ty</span> <span class="o">=</span> <span class="p">(</span><span class="n">bus</span> <span class="o">&gt;</span> <span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pbnum</span><span class="p">);</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
	<span class="n">pcie_addr</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pcie_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Read 8bits from a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Result of the read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">cvmx_pcie_config_read8</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cvmx_read64_uint8</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Read 16bits from a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Result of the read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">cvmx_pcie_config_read16</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">cvmx_read64_uint16</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Read 32bits from a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Result of the read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">cvmx_pcie_config_read32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cvmx_read64_uint32</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write 8bits to a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> * @val:       Value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_pcie_config_write8</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fn</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="n">cvmx_write64_uint8</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write 16bits to a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> * @val:       Value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_pcie_config_write16</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="n">cvmx_write64_uint16</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write 32bits to a Device&#39;s config space</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port the device is on</span>
<span class="cm"> * @bus:       Sub bus</span>
<span class="cm"> * @dev:       Device ID</span>
<span class="cm"> * @fn:        Device sub function</span>
<span class="cm"> * @reg:       Register to access</span>
<span class="cm"> * @val:       Value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cvmx_pcie_config_write32</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span>
	    <span class="n">__cvmx_pcie_build_config_addr</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize the RC config space CSRs</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cvmx_pcie_rc_initialize_config_space</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg030</span> <span class="n">pciercx_cfg030</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg070</span> <span class="n">pciercx_cfg070</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg001</span> <span class="n">pciercx_cfg001</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg032</span> <span class="n">pciercx_cfg032</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg006</span> <span class="n">pciercx_cfg006</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg008</span> <span class="n">pciercx_cfg008</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg009</span> <span class="n">pciercx_cfg009</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg010</span> <span class="n">pciercx_cfg010</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg011</span> <span class="n">pciercx_cfg011</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg035</span> <span class="n">pciercx_cfg035</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg075</span> <span class="n">pciercx_cfg075</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg034</span> <span class="n">pciercx_cfg034</span><span class="p">;</span>

	<span class="cm">/* Max Payload Size (PCIE*_CFG030[MPS]) */</span>
	<span class="cm">/* Max Read Request Size (PCIE*_CFG030[MRRS]) */</span>
	<span class="cm">/* Relaxed-order, no-snoop enables (PCIE*_CFG030[RO_EN,NS_EN] */</span>
	<span class="cm">/* Error Message Enables (PCIE*_CFG030[CE_EN,NFE_EN,FE_EN,UR_EN]) */</span>

	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG030</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN5XXX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mps</span> <span class="o">=</span> <span class="n">MPS_CN5XXX</span><span class="p">;</span>
		<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrrs</span> <span class="o">=</span> <span class="n">MRRS_CN5XXX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mps</span> <span class="o">=</span> <span class="n">MPS_CN6XXX</span><span class="p">;</span>
		<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrrs</span> <span class="o">=</span> <span class="n">MRRS_CN6XXX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable relaxed order processing. This will allow devices to</span>
<span class="cm">	 * affect read response ordering.</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ro_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Enable no snoop processing. Not used by Octeon */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ns_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Correctable error reporting enable. */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ce_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Non-fatal error reporting enable. */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nfe_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Fatal error reporting enable. */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">fe_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Unsupported request reporting enable. */</span>
	<span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ur_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG030</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg030</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npei_ctl_status2</span> <span class="n">npei_ctl_status2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Max Payload Size (NPEI_CTL_STATUS2[MPS]) must match</span>
<span class="cm">		 * PCIE*_CFG030[MPS].  Max Read Request Size</span>
<span class="cm">		 * (NPEI_CTL_STATUS2[MRRS]) must not exceed</span>
<span class="cm">		 * PCIE*_CFG030[MRRS]</span>
<span class="cm">		 */</span>
		<span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_STATUS2</span><span class="p">);</span>
		<span class="cm">/* Max payload size = 128 bytes for best Octeon DMA performance */</span>
		<span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mps</span> <span class="o">=</span> <span class="n">MPS_CN5XXX</span><span class="p">;</span>
		<span class="cm">/* Max read request size = 128 bytes for best Octeon DMA performance */</span>
		<span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrrs</span> <span class="o">=</span> <span class="n">MRRS_CN5XXX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span>
			<span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">c1_b1_s</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* Port1 BAR1 Size 256MB */</span>
		<span class="k">else</span>
			<span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">c0_b1_s</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* Port0 BAR1 Size 256MB */</span>

		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_STATUS2</span><span class="p">,</span> <span class="n">npei_ctl_status2</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Max Payload Size (DPI_SLI_PRTX_CFG[MPS]) must match</span>
<span class="cm">		 * PCIE*_CFG030[MPS].  Max Read Request Size</span>
<span class="cm">		 * (DPI_SLI_PRTX_CFG[MRRS]) must not exceed</span>
<span class="cm">		 * PCIE*_CFG030[MRRS].</span>
<span class="cm">		 */</span>
		<span class="k">union</span> <span class="n">cvmx_dpi_sli_prtx_cfg</span> <span class="n">prt_cfg</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">cvmx_sli_s2m_portx_ctl</span> <span class="n">sli_s2m_portx_ctl</span><span class="p">;</span>
		<span class="n">prt_cfg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_DPI_SLI_PRTX_CFG</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="n">prt_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mps</span> <span class="o">=</span> <span class="n">MPS_CN6XXX</span><span class="p">;</span>
		<span class="n">prt_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrrs</span> <span class="o">=</span> <span class="n">MRRS_CN6XXX</span><span class="p">;</span>
		<span class="cm">/* Max outstanding load request. */</span>
		<span class="n">prt_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">molr</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_DPI_SLI_PRTX_CFG</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">prt_cfg</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

		<span class="n">sli_s2m_portx_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_S2M_PORTX_CTL</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="n">sli_s2m_portx_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mrrs</span> <span class="o">=</span> <span class="n">MRRS_CN6XXX</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_S2M_PORTX_CTL</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">sli_s2m_portx_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ECRC Generation (PCIE*_CFG070[GE,CE]) */</span>
	<span class="n">pciercx_cfg070</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG070</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg070</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* ECRC generation enable. */</span>
	<span class="n">pciercx_cfg070</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* ECRC check enable. */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG070</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg070</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Access Enables (PCIE*_CFG001[MSAE,ME])</span>
<span class="cm">	 * ME and MSAE should always be set.</span>
<span class="cm">	 * Interrupt Disable (PCIE*_CFG001[I_DIS])</span>
<span class="cm">	 * System Error Message Enable (PCIE*_CFG001[SEE])</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG001</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">msae</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Memory space enable. */</span>
	<span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">me</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Bus master enable. */</span>
	<span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">i_dis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* INTx assertion disable. */</span>
	<span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">see</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* SERR# enable */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG001</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg001</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/* Advanced Error Recovery Message Enables */</span>
	<span class="cm">/* (PCIE*_CFG066,PCIE*_CFG067,PCIE*_CFG069) */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG066</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Use CVMX_PCIERCX_CFG067 hardware default */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG069</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>


	<span class="cm">/* Active State Power Management (PCIE*_CFG032[ASLPC]) */</span>
	<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">aslpc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Active state Link PM control. */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link Width Mode (PCIERCn_CFG452[LME]) - Set during</span>
<span class="cm">	 * cvmx_pcie_rc_initialize_link()</span>
<span class="cm">	 *</span>
<span class="cm">	 * Primary Bus Number (PCIERCn_CFG006[PBNUM])</span>
<span class="cm">	 *</span>
<span class="cm">	 * We set the primary bus number to 1 so IDT bridges are</span>
<span class="cm">	 * happy. They don&#39;t like zero.</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pbnum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">sbnum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">subbnum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG006</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Memory-mapped I/O BAR (PCIERCn_CFG008)</span>
<span class="cm">	 * Most applications should disable the memory-mapped I/O BAR by</span>
<span class="cm">	 * setting PCIERCn_CFG008[ML_ADDR] &lt; PCIERCn_CFG008[MB_ADDR]</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg008</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pciercx_cfg008</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mb_addr</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">pciercx_cfg008</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ml_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG008</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg008</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Prefetchable BAR (PCIERCn_CFG009,PCIERCn_CFG010,PCIERCn_CFG011)</span>
<span class="cm">	 * Most applications should disable the prefetchable BAR by setting</span>
<span class="cm">	 * PCIERCn_CFG011[UMEM_LIMIT],PCIERCn_CFG009[LMEM_LIMIT] &lt;</span>
<span class="cm">	 * PCIERCn_CFG010[UMEM_BASE],PCIERCn_CFG009[LMEM_BASE]</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg009</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG009</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg010</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG010</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg011</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG011</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg009</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lmem_base</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">pciercx_cfg009</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lmem_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pciercx_cfg010</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">umem_base</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
	<span class="n">pciercx_cfg011</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">umem_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG009</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg009</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG010</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg010</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG011</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg011</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * System Error Interrupt Enables (PCIERCn_CFG035[SECEE,SEFEE,SENFEE])</span>
<span class="cm">	 * PME Interrupt Enables (PCIERCn_CFG035[PMEIE])</span>
<span class="cm">	*/</span>
	<span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG035</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">secee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* System error on correctable error enable. */</span>
	<span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">sefee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* System error on fatal error enable. */</span>
	<span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">senfee</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* System error on non-fatal error enable. */</span>
	<span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pmeie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* PME interrupt enable. */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG035</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg035</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Advanced Error Recovery Interrupt Enables</span>
<span class="cm">	 * (PCIERCn_CFG075[CERE,NFERE,FERE])</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg075</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG075</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg075</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cere</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Correctable error reporting enable. */</span>
	<span class="n">pciercx_cfg075</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nfere</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Non-fatal error reporting enable. */</span>
	<span class="n">pciercx_cfg075</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">fere</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Fatal error reporting enable. */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG075</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg075</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * HP Interrupt Enables (PCIERCn_CFG034[HPINT_EN],</span>
<span class="cm">	 * PCIERCn_CFG034[DLLS_EN,CCINT_EN])</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg034</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG034</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg034</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">hpint_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Hot-plug interrupt enable. */</span>
	<span class="n">pciercx_cfg034</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dlls_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Data Link Layer state changed enable */</span>
	<span class="n">pciercx_cfg034</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ccint_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Command completed interrupt enable. */</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG034</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg034</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize a host mode PCIe gen 1 link. This function takes a PCIe</span>
<span class="cm"> * port from reset to a link up state. Software can then begin</span>
<span class="cm"> * configuring the rest of the link.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cvmx_pcie_rc_initialize_link_gen1</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pescx_ctl_status</span> <span class="n">pescx_ctl_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg452</span> <span class="n">pciercx_cfg452</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg032</span> <span class="n">pciercx_cfg032</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg448</span> <span class="n">pciercx_cfg448</span><span class="p">;</span>

	<span class="cm">/* Set the lane width */</span>
	<span class="n">pciercx_cfg452</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG452</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qlm_cfg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* We&#39;re in 8 lane (56XX) or 4 lane (54XX) mode */</span>
		<span class="n">pciercx_cfg452</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lme</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* We&#39;re in 4 lane (56XX) or 2 lane (52XX) mode */</span>
		<span class="n">pciercx_cfg452</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lme</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG452</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg452</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CN52XX pass 1.x has an errata where length mismatches on UR</span>
<span class="cm">	 * responses can cause bus errors on 64bit memory</span>
<span class="cm">	 * reads. Turning off length error checking fixes this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_X</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pciercx_cfg455</span> <span class="n">pciercx_cfg455</span><span class="p">;</span>
		<span class="n">pciercx_cfg455</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG455</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="n">pciercx_cfg455</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">m_cpl_len_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG455</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg455</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Lane swap needs to be manually enabled for CN52XX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pcie_port</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lane_swp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Bring up the link */</span>
	<span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lnk_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pescx_ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CN52XX pass 1.0: Due to a bug in 2nd order CDR, it needs to</span>
<span class="cm">	 * be disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_0</span><span class="p">))</span>
		<span class="n">__cvmx_helper_errata_qlm_disable_2nd_order_cdr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Wait for the link to come up */</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">cvmx_get_cycle</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_get_cycle</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_cycle</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">octeon_get_clock_rate</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d link timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
		<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dlla</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Clear all pending errors */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_INT_SUM</span><span class="p">,</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_INT_SUM</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the Replay Time Limit. Empirically, some PCIe</span>
<span class="cm">	 * devices take a little longer to respond than expected under</span>
<span class="cm">	 * load. As a workaround for this we configure the Replay Time</span>
<span class="cm">	 * Limit to the value expected for a 512 byte MPS instead of</span>
<span class="cm">	 * our actual 256 byte MPS. The numbers below are directly</span>
<span class="cm">	 * from the PCIe spec table 3-4.</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG448</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nlw</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* 1 lane */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">1677</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* 2 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">867</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:		<span class="cm">/* 4 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">462</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:		<span class="cm">/* 8 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG448</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cvmx_increment_ba</span><span class="p">(</span><span class="k">union</span> <span class="n">cvmx_sli_mem_access_subidx</span> <span class="o">*</span><span class="n">pmas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN68XX</span><span class="p">))</span>
		<span class="n">pmas</span><span class="o">-&gt;</span><span class="n">cn68xx</span><span class="p">.</span><span class="n">ba</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pmas</span><span class="o">-&gt;</span><span class="n">cn63xx</span><span class="p">.</span><span class="n">ba</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize a PCIe gen 1 port for use in host(RC) mode. It doesn&#39;t</span>
<span class="cm"> * enumerate the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cvmx_pcie_rc_initialize_gen1</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">addr_swizzle</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_ciu_soft_prst</span> <span class="n">ciu_soft_prst</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pescx_bist_status</span> <span class="n">pescx_bist_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pescx_bist_status2</span> <span class="n">pescx_bist_status2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npei_ctl_status</span> <span class="n">npei_ctl_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npei_mem_access_ctl</span> <span class="n">npei_mem_access_ctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npei_mem_access_subidx</span> <span class="n">mem_access_subid</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npei_dbg_data</span> <span class="n">npei_dbg_data</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pescx_ctl_status2</span> <span class="n">pescx_ctl_status2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg032</span> <span class="n">pciercx_cfg032</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_npei_bar1_indexx</span> <span class="n">bar1_index</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we aren&#39;t trying to setup a target mode interface</span>
<span class="cm">	 * in host mode.</span>
<span class="cm">	 */</span>
	<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pcie_port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">host_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d in endpoint mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure a CN52XX isn&#39;t trying to bring up port 1 when it</span>
<span class="cm">	 * is disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">npei_dbg_data</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_DATA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pcie_port</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">npei_dbg_data</span><span class="p">.</span><span class="n">cn52xx</span><span class="p">.</span><span class="n">qlm0_link_width</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: ERROR: cvmx_pcie_rc_initialize() called on port1, but port1 is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCIe switch arbitration mode. &#39;0&#39; == fixed priority NPEI,</span>
<span class="cm">	 * PCIe0, then PCIe1. &#39;1&#39; == round robin.</span>
<span class="cm">	 */</span>
	<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">arb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Allow up to 0x20 config retries */</span>
	<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cfg_rtry</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * CN52XX pass1.x has an errata where P0_NTAGS and P1_NTAGS</span>
<span class="cm">	 * don&#39;t reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_X</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">p0_ntags</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">p1_ntags</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_STATUS</span><span class="p">,</span> <span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Bring the PCIe out of reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_sysinfo_get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">board_type</span> <span class="o">==</span> <span class="n">CVMX_BOARD_TYPE_EBH5200</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The EBH5200 board swapped the PCIe reset lines on</span>
<span class="cm">		 * the board. As a workaround for this bug, we bring</span>
<span class="cm">		 * both PCIe ports out of reset at the same time</span>
<span class="cm">		 * instead of on separate calls. So for port 0, we</span>
<span class="cm">		 * bring both out of reset and do nothing on port 1</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * After a chip reset the PCIe will also be in</span>
<span class="cm">			 * reset. If it isn&#39;t, most likely someone is</span>
<span class="cm">			 * trying to init it again without a proper</span>
<span class="cm">			 * PCIe reset.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Reset the ports */</span>
				<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
				<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
				<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
				<span class="cm">/* Wait until pcie resets the ports. */</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The normal case: The PCIe ports are completely</span>
<span class="cm">		 * separate and can be brought out of reset</span>
<span class="cm">		 * independently.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * After a chip reset the PCIe will also be in</span>
<span class="cm">		 * reset. If it isn&#39;t, most likely someone is trying</span>
<span class="cm">		 * to init it again without a proper PCIe reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Reset the port */</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span>
				<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
			<span class="cm">/* Wait until pcie resets the ports. */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
			<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for PCIe reset to complete. Due to errata PCIE-700, we</span>
<span class="cm">	 * don&#39;t poll PESCX_CTL_STATUS2[PCIERST], but simply wait a</span>
<span class="cm">	 * fixed number of cycles.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">400000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * PESCX_BIST_STATUS2[PCLK_RUN] was missing on pass 1 of</span>
<span class="cm">	 * CN56XX and CN52XX, so we only probe it on newer chips</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1_X</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_X</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clear PCLK_RUN so we can check if the clock is running */</span>
		<span class="n">pescx_ctl_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="n">pescx_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pclk_run</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pescx_ctl_status2</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="cm">/* Now that we cleared PCLK_RUN, wait for it to be set</span>
<span class="cm">		 * again telling us the clock is running</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_WAIT_FOR_FIELD64</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span>
					  <span class="k">union</span> <span class="n">cvmx_pescx_ctl_status2</span><span class="p">,</span> <span class="n">pclk_run</span><span class="p">,</span> <span class="o">==</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d isn&#39;t clocked, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check and make sure PCIe came out of reset. If it doesn&#39;t</span>
<span class="cm">	 * the board probably hasn&#39;t wired the clocks up and the</span>
<span class="cm">	 * interface should be skipped.</span>
<span class="cm">	 */</span>
	<span class="n">pescx_ctl_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_CTL_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pescx_ctl_status2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pcierst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d stuck in reset, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check BIST2 status. If any bits are set skip this</span>
<span class="cm">	 * interface. This is an attempt to catch PCIE-813 on pass 1</span>
<span class="cm">	 * parts.</span>
<span class="cm">	 */</span>
	<span class="n">pescx_bist_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_BIST_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pescx_bist_status2</span><span class="p">.</span><span class="n">u64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d BIST2 failed. Most likely this port isn&#39;t hooked up, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check BIST status */</span>
	<span class="n">pescx_bist_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_BIST_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pescx_bist_status</span><span class="p">.</span><span class="n">u64</span><span class="p">)</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: BIST FAILED for port %d (0x%016llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">pcie_port</span><span class="p">,</span> <span class="n">CAST64</span><span class="p">(</span><span class="n">pescx_bist_status</span><span class="p">.</span><span class="n">u64</span><span class="p">));</span>

	<span class="cm">/* Initialize the config space CSRs */</span>
	<span class="n">__cvmx_pcie_rc_initialize_config_space</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">);</span>

	<span class="cm">/* Bring the link up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cvmx_pcie_rc_initialize_link_gen1</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Failed to initialize port %d, probably the slot is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Store merge control (NPEI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */</span>
	<span class="n">npei_mem_access_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_MEM_ACCESS_CTL</span><span class="p">);</span>
	<span class="n">npei_mem_access_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">max_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* Allow 16 words to combine */</span>
	<span class="n">npei_mem_access_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>      <span class="cm">/* Wait up to 127 cycles for more data */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_MEM_ACCESS_CTL</span><span class="p">,</span> <span class="n">npei_mem_access_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Setup Mem access SubDIDs */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">pcie_port</span><span class="p">;</span> <span class="cm">/* Port the request is sent to. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nmerge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Due to an errata on pass 1 chips, no merging is allowed. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Endian-swap for Reads. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Endian-swap for Writes. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Enable Snooping for Reads. Octeon doesn&#39;t care, but devices might want this more conservative setting */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nsw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Enable Snoop for Writes. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Disable Relaxed Ordering for Reads. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Disable Relaxed Ordering for Writes. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* PCIe Adddress Bits &lt;63:34&gt;. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup mem access 12-15 for port 0, 16-19 for port 1,</span>
<span class="cm">	 * supplying 36 bits of address space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">pcie_port</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">pcie_port</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_MEM_ACCESS_SUBIDX</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mem_access_subid</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ba</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Set each SUBID to extend the addressable range */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable the peer to peer forwarding register. This must be</span>
<span class="cm">	 * setup by the OS after it enumerates the bus and assigns</span>
<span class="cm">	 * addresses to the PCIe busses.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_P2P_BARX_START</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_P2P_BARX_END</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set Octeon&#39;s BAR0 to decode 0-16KB. It overlaps with Bar2 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_P2N_BAR0_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* BAR1 follows BAR2 with a gap so it has the same address as for gen2. */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_P2N_BAR1_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">CVMX_PCIE_BAR1_RC_BASE</span><span class="p">);</span>

	<span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">CVMX_PCIE_BAR1_PHYS_BASE</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="cm">/* Not Cached */</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">end_swp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Endian Swap mode */</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Valid entry */</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">pcie_port</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Big endian swizzle for 32-bit PEXP_NCB register. */</span>
<span class="cp">#ifdef __MIPSEB__</span>
	<span class="n">addr_swizzle</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">addr_swizzle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write64_uint32</span><span class="p">((</span><span class="n">CVMX_PEXP_NPEI_BAR1_INDEXX</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">^</span> <span class="n">addr_swizzle</span><span class="p">),</span>
				    <span class="n">bar1_index</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">base</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* 256MB / 16 &gt;&gt; 22 == 4 */</span>
		<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">+=</span> <span class="p">(((</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16ull</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Octeon&#39;s BAR2 to decode 0-2^39. Bar0 and Bar1 take</span>
<span class="cm">	 * precedence where they overlap. It also overlaps with the</span>
<span class="cm">	 * device addresses, so make sure the peer to peer forwarding</span>
<span class="cm">	 * is set right.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PESCX_P2N_BAR2_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup BAR2 attributes</span>
<span class="cm">	 *</span>
<span class="cm">	 * Relaxed Ordering (NPEI_CTL_PORTn[PTLP_RO,CTLP_RO, WAIT_COM])</span>
<span class="cm">	 * - PTLP_RO,CTLP_RO should normally be set (except for debug).</span>
<span class="cm">	 * - WAIT_COM=0 will likely work for all applications.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM]).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npei_ctl_port1</span> <span class="n">npei_ctl_port</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_PORT1</span><span class="p">);</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_esx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_cax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ptlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ctlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wait_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">waitl_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_PORT1</span><span class="p">,</span> <span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npei_ctl_port0</span> <span class="n">npei_ctl_port</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_PORT0</span><span class="p">);</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_esx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_cax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ptlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ctlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wait_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">waitl_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_PORT0</span><span class="p">,</span> <span class="n">npei_ctl_port</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Both pass 1 and pass 2 of CN52XX and CN56XX have an errata</span>
<span class="cm">	 * that causes TLP ordering to not be preserved after multiple</span>
<span class="cm">	 * PCIe port resets. This code detects this fault and corrects</span>
<span class="cm">	 * it by aligning the TLP counters properly. Another link</span>
<span class="cm">	 * reset is then performed. See PCIE-13340</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS2_X</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS2_X</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_X</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npei_dbg_data</span> <span class="n">dbg_data</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">old_in_fif_p_count</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">in_fif_p_count</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">out_p_count</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">in_p_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span> <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1_X</span><span class="p">))</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Choose a write address of 1MB. It should be</span>
<span class="cm">		 * harmless as all bars haven&#39;t been setup.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">write_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x100000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="mi">63</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure at least in_p_offset have been executed before we try and</span>
<span class="cm">		 * read in_fif_p_count</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">in_p_offset</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">write_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the IN_FIF_P_COUNT from the debug</span>
<span class="cm">		 * select. IN_FIF_P_COUNT can be unstable sometimes so</span>
<span class="cm">		 * read it twice with a write between the reads.  This</span>
<span class="cm">		 * way we can tell the value is good as it will</span>
<span class="cm">		 * increment by one due to the write</span>
<span class="cm">		 */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_SELECT</span><span class="p">,</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xd7fc</span> <span class="o">:</span> <span class="mh">0xcffc</span><span class="p">);</span>
		<span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_SELECT</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">dbg_data</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_DATA</span><span class="p">);</span>
			<span class="n">old_in_fif_p_count</span> <span class="o">=</span> <span class="n">dbg_data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">write_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
			<span class="n">dbg_data</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_DATA</span><span class="p">);</span>
			<span class="n">in_fif_p_count</span> <span class="o">=</span> <span class="n">dbg_data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">in_fif_p_count</span> <span class="o">!=</span> <span class="p">((</span><span class="n">old_in_fif_p_count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>

		<span class="cm">/* Update in_fif_p_count for it&#39;s offset with respect to out_p_count */</span>
		<span class="n">in_fif_p_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_fif_p_count</span> <span class="o">+</span> <span class="n">in_p_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/* Read the OUT_P_COUNT from the debug select */</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_SELECT</span><span class="p">,</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0xd00f</span> <span class="o">:</span> <span class="mh">0xc80f</span><span class="p">);</span>
		<span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_SELECT</span><span class="p">);</span>
		<span class="n">dbg_data</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_DATA</span><span class="p">);</span>
		<span class="n">out_p_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbg_data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="cm">/* Check that the two counters are aligned */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">out_p_count</span> <span class="o">!=</span> <span class="n">in_fif_p_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d aligning TLP counters as workaround to maintain ordering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">in_fif_p_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">write_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
				<span class="n">in_fif_p_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_fif_p_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * The EBH5200 board swapped the PCIe reset</span>
<span class="cm">			 * lines on the board. This means we must</span>
<span class="cm">			 * bring both links down and up, which will</span>
<span class="cm">			 * cause the PCIe0 to need alignment</span>
<span class="cm">			 * again. Lots of messages will be displayed,</span>
<span class="cm">			 * but everything should work</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cvmx_sysinfo_get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">board_type</span> <span class="o">==</span> <span class="n">CVMX_BOARD_TYPE_EBH5200</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">pcie_port</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">cvmx_pcie_rc_initialize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Rety bringing this port up */</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Display the link status */</span>
	<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">cvmx_dprintf</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d link active, %d lanes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nlw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * Initialize a host mode PCIe gen 2 link. This function takes a PCIe</span>
<span class="cm"> * port from reset to a link up state. Software can then begin</span>
<span class="cm"> * configuring the rest of the link.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Return Zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cvmx_pcie_rc_initialize_link_gen2</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">start_cycle</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_ctl_status</span> <span class="n">pem_ctl_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg032</span> <span class="n">pciercx_cfg032</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg448</span> <span class="n">pciercx_cfg448</span><span class="p">;</span>

	<span class="cm">/* Bring up the link */</span>
	<span class="n">pem_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pem_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lnk_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pem_ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Wait for the link to come up */</span>
	<span class="n">start_cycle</span> <span class="o">=</span> <span class="n">cvmx_get_cycle</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_get_cycle</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_cycle</span> <span class="o">&gt;</span>  <span class="n">octeon_get_clock_rate</span><span class="p">())</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">cvmx_wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
		<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dlla</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">lt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the Replay Time Limit. Empirically, some PCIe</span>
<span class="cm">	 * devices take a little longer to respond than expected under</span>
<span class="cm">	 * load. As a workaround for this we configure the Replay Time</span>
<span class="cm">	 * Limit to the value expected for a 512 byte MPS instead of</span>
<span class="cm">	 * our actual 256 byte MPS. The numbers below are directly</span>
<span class="cm">	 * from the PCIe spec table 3-4</span>
<span class="cm">	 */</span>
	<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG448</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nlw</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* 1 lane */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">1677</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* 2 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">867</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="cm">/* 4 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">462</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>: <span class="cm">/* 8 lanes */</span>
		<span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtl</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG448</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg448</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Initialize a PCIe gen 2 port for use in host(RC) mode. It doesn&#39;t enumerate</span>
<span class="cm"> * the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cvmx_pcie_rc_initialize_gen2</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_ciu_soft_prst</span> <span class="n">ciu_soft_prst</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_mio_rst_ctlx</span> <span class="n">mio_rst_ctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_bar_ctl</span> <span class="n">pemx_bar_ctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_ctl_status</span> <span class="n">pemx_ctl_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_bist_status</span> <span class="n">pemx_bist_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_bist_status2</span> <span class="n">pemx_bist_status2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg032</span> <span class="n">pciercx_cfg032</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pciercx_cfg515</span> <span class="n">pciercx_cfg515</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sli_ctl_portx</span> <span class="n">sli_ctl_portx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sli_mem_access_ctl</span> <span class="n">sli_mem_access_ctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sli_mem_access_subidx</span> <span class="n">mem_access_subid</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sriox_status_reg</span> <span class="n">sriox_status_reg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_bar1_indexx</span> <span class="n">bar1_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_SRIO</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Make sure this interface isn&#39;t SRIO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN66XX</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The CN66XX requires reading the</span>
<span class="cm">			 * MIO_QLMX_CFG register to figure out the</span>
<span class="cm">			 * port type.</span>
<span class="cm">			 */</span>
			<span class="k">union</span> <span class="n">cvmx_mio_qlmx_cfg</span> <span class="n">qlmx_cfg</span><span class="p">;</span>
			<span class="n">qlmx_cfg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_QLMX_CFG</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">qlmx_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qlm_spd</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is disabled, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">qlmx_cfg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qlm_spd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x1</span>: <span class="cm">/* SRIO 1x4 short */</span>
			<span class="k">case</span> <span class="mh">0x3</span>: <span class="cm">/* SRIO 1x4 long */</span>
			<span class="k">case</span> <span class="mh">0x4</span>: <span class="cm">/* SRIO 2x2 short */</span>
			<span class="k">case</span> <span class="mh">0x6</span>: <span class="cm">/* SRIO 2x2 long */</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is SRIO, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x9</span>: <span class="cm">/* SGMII */</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is SGMII, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0xb</span>: <span class="cm">/* XAUI */</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is XAUI, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">case</span> <span class="mh">0x0</span>: <span class="cm">/* PCIE gen2 */</span>
			<span class="k">case</span> <span class="mh">0x8</span>: <span class="cm">/* PCIE gen2 (alias) */</span>
			<span class="k">case</span> <span class="mh">0x2</span>: <span class="cm">/* PCIE gen1 */</span>
			<span class="k">case</span> <span class="mh">0xa</span>: <span class="cm">/* PCIE gen1 (alias) */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is unknown, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_SRIOX_STATUS_REG</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">srio</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d is SRIO, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    /* This code is so that the PCIe analyzer is able to see 63XX traffic */</span>
<span class="c">	pr_notice(&quot;PCIE : init for pcie analyzer.\n&quot;);</span>
<span class="c">	cvmx_helper_qlm_jtag_init();</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);</span>
<span class="c">	cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);</span>
<span class="c">	cvmx_helper_qlm_jtag_update(pcie_port);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Make sure we aren&#39;t trying to setup a target mode interface in host mode */</span>
	<span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_RST_CTLX</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">host_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d in endpoint mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_ciu_qlm1</span> <span class="n">ciu_qlm</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_QLM1</span><span class="p">);</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txbypass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txdeemph</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txmargin</span> <span class="o">=</span> <span class="mh">0x17</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_QLM1</span><span class="p">,</span> <span class="n">ciu_qlm</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_ciu_qlm0</span> <span class="n">ciu_qlm</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_QLM0</span><span class="p">);</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txbypass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txdeemph</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="n">ciu_qlm</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">txmargin</span> <span class="o">=</span> <span class="mh">0x17</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_QLM0</span><span class="p">,</span> <span class="n">ciu_qlm</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Bring the PCIe out of reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * After a chip reset the PCIe will also be in reset. If it</span>
<span class="cm">	 * isn&#39;t, most likely someone is trying to init it again</span>
<span class="cm">	 * without a proper PCIe reset</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset the port */</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="cm">/* Wait until pcie resets the ports. */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">);</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST1</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">);</span>
		<span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">soft_prst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_CIU_SOFT_PRST</span><span class="p">,</span> <span class="n">ciu_soft_prst</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for PCIe reset to complete */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check and make sure PCIe came out of reset. If it doesn&#39;t</span>
<span class="cm">	 * the board probably hasn&#39;t wired the clocks up and the</span>
<span class="cm">	 * interface should be skipped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_WAIT_FOR_FIELD64</span><span class="p">(</span><span class="n">CVMX_MIO_RST_CTLX</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="k">union</span> <span class="n">cvmx_mio_rst_ctlx</span><span class="p">,</span> <span class="n">rst_done</span><span class="p">,</span> <span class="o">==</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d stuck in reset, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check BIST status */</span>
	<span class="n">pemx_bist_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_BIST_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pemx_bist_status</span><span class="p">.</span><span class="n">u64</span><span class="p">)</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: BIST FAILED for port %d (0x%016llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">CAST64</span><span class="p">(</span><span class="n">pemx_bist_status</span><span class="p">.</span><span class="n">u64</span><span class="p">));</span>
	<span class="n">pemx_bist_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_BIST_STATUS2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="cm">/* Errata PCIE-14766 may cause the lower 6 bits to be randomly set on CN63XXp1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">))</span>
		<span class="n">pemx_bist_status2</span><span class="p">.</span><span class="n">u64</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x3full</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pemx_bist_status2</span><span class="p">.</span><span class="n">u64</span><span class="p">)</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: BIST2 FAILED for port %d (0x%016llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">CAST64</span><span class="p">(</span><span class="n">pemx_bist_status2</span><span class="p">.</span><span class="n">u64</span><span class="p">));</span>

	<span class="cm">/* Initialize the config space CSRs */</span>
	<span class="n">__cvmx_pcie_rc_initialize_config_space</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">);</span>

	<span class="cm">/* Enable gen2 speed selection */</span>
	<span class="n">pciercx_cfg515</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG515</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pciercx_cfg515</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">dsc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG515</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg515</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>

	<span class="cm">/* Bring the link up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__cvmx_pcie_rc_initialize_link_gen2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some gen1 devices don&#39;t handle the gen 2 training</span>
<span class="cm">		 * correctly. Disable gen2 and try again with only</span>
<span class="cm">		 * gen1</span>
<span class="cm">		 */</span>
		<span class="k">union</span> <span class="n">cvmx_pciercx_cfg031</span> <span class="n">pciercx_cfg031</span><span class="p">;</span>
		<span class="n">pciercx_cfg031</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG031</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
		<span class="n">pciercx_cfg031</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mls</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG031</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pciercx_cfg031</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__cvmx_pcie_rc_initialize_link_gen2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Link timeout on port %d, probably the slot is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */</span>
	<span class="n">sli_mem_access_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_MEM_ACCESS_CTL</span><span class="p">);</span>
	<span class="n">sli_mem_access_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">max_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Allow 16 words to combine */</span>
	<span class="n">sli_mem_access_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>	<span class="cm">/* Wait up to 127 cycles for more data */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_MEM_ACCESS_CTL</span><span class="p">,</span> <span class="n">sli_mem_access_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Setup Mem access SubDIDs */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">pcie_port</span><span class="p">;</span> <span class="cm">/* Port the request is sent to. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nmerge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Allow merging as it works on CN6XXX. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Endian-swap for Reads. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">esw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Endian-swap for Writes. */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wtype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* &quot;No snoop&quot; and &quot;Relaxed ordering&quot; are not set */</span>
	<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rtype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* &quot;No snoop&quot; and &quot;Relaxed ordering&quot; are not set */</span>
	<span class="cm">/* PCIe Adddress Bits &lt;63:34&gt;. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN68XX</span><span class="p">))</span>
		<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">cn68xx</span><span class="p">.</span><span class="n">ba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mem_access_subid</span><span class="p">.</span><span class="n">cn63xx</span><span class="p">.</span><span class="n">ba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup mem access 12-15 for port 0, 16-19 for port 1,</span>
<span class="cm">	 * supplying 36 bits of address space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">pcie_port</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">pcie_port</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mem_access_subid</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="cm">/* Set each SUBID to extend the addressable range */</span>
		<span class="n">__cvmx_increment_ba</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_access_subid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable the peer to peer forwarding register. This must be</span>
<span class="cm">	 * setup by the OS after it enumerates the bus and assigns</span>
<span class="cm">	 * addresses to the PCIe busses.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_P2P_BARX_START</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_P2P_BARX_END</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set Octeon&#39;s BAR0 to decode 0-16KB. It overlaps with Bar2 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_P2N_BAR0_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Octeon&#39;s BAR2 to decode 0-2^41. Bar0 and Bar1 take</span>
<span class="cm">	 * precedence where they overlap. It also overlaps with the</span>
<span class="cm">	 * device addresses, so make sure the peer to peer forwarding</span>
<span class="cm">	 * is set right.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_P2N_BAR2_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup BAR2 attributes</span>
<span class="cm">	 * Relaxed Ordering (NPEI_CTL_PORTn[PTLP_RO,CTLP_RO, WAIT_COM])</span>
<span class="cm">	 * - PTLP_RO,CTLP_RO should normally be set (except for debug).</span>
<span class="cm">	 * - WAIT_COM=0 will likely work for all applications.</span>
<span class="cm">	 * Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM])</span>
<span class="cm">	 */</span>
	<span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_BAR_CTL</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar1_siz</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* 256MB BAR1*/</span>
	<span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_enb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_esx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bar2_cax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_BAR_CTL</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pemx_bar_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ptlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ctlp_ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wait_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">waitl_com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* BAR1 follows BAR2 */</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_P2N_BAR1_START</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">CVMX_PCIE_BAR1_RC_BASE</span><span class="p">);</span>

	<span class="n">bar1_index</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">CVMX_PCIE_BAR1_PHYS_BASE</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="cm">/* Not Cached */</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">end_swp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Endian Swap mode */</span>
	<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Valid entry */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_BAR1_INDEXX</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">),</span> <span class="n">bar1_index</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="cm">/* 256MB / 16 &gt;&gt; 22 == 4 */</span>
		<span class="n">bar1_index</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">addr_idx</span> <span class="o">+=</span> <span class="p">(((</span><span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16ull</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow config retries for 250ms. Count is based off the 5Ghz</span>
<span class="cm">	 * SERDES clock.</span>
<span class="cm">	 */</span>
	<span class="n">pemx_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pemx_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cfg_rtry</span> <span class="o">=</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">5000000</span> <span class="o">/</span> <span class="mh">0x10000</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span> <span class="n">pemx_ctl_status</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* Display the link status */</span>
	<span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">CVMX_PCIERCX_CFG032</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
	<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port %d link active, %d lanes, speed gen%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">nlw</span><span class="p">,</span> <span class="n">pciercx_cfg032</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">ls</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize a PCIe port for use in host(RC) mode. It doesn&#39;t enumerate the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * @pcie_port: PCIe port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cvmx_pcie_rc_initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcie_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__cvmx_pcie_rc_initialize_gen1</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__cvmx_pcie_rc_initialize_gen2</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Above was cvmx-pcie.c, below original pcie.c */</span>

<span class="cm">/**</span>
<span class="cm"> * Map a PCI device to the appropriate interrupt line</span>
<span class="cm"> *</span>
<span class="cm"> * @dev:    The Linux PCI device structure for the device to map</span>
<span class="cm"> * @slot:   The slot number for this device on __BUS 0__. Linux</span>
<span class="cm"> *               enumerates through all the bridges and figures out the</span>
<span class="cm"> *               slot on Bus 0 where this device eventually hooks to.</span>
<span class="cm"> * @pin:    The PCI interrupt pin read from the device, then swizzled</span>
<span class="cm"> *               as it goes through each bridge.</span>
<span class="cm"> * Returns Interrupt number for the device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">octeon_pcie_pcibios_map_irq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The EBH5600 board with the PCI to PCIe bridge mistakenly</span>
<span class="cm">	 * wires the first slot for both device id 2 and interrupt</span>
<span class="cm">	 * A. According to the PCI spec, device id 2 should be C. The</span>
<span class="cm">	 * following kludge attempts to fix this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">octeon_board_type_string</span><span class="p">(),</span> <span class="s">&quot;EBH5600&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Iterate all the way up the device chain and find</span>
<span class="cm">		 * the root bus.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bridge</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the root bus is number 0 and the PEX 8114 is the</span>
<span class="cm">		 * root, assume we are behind the miswired bus. We</span>
<span class="cm">		 * need to correct the swizzle level by two. Yuck.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="mh">0x10b5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x8114</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The pin field is one based, not zero. We</span>
<span class="cm">			 * need to swizzle it by minus two.</span>
<span class="cm">			 */</span>
			<span class="n">pin</span> <span class="o">=</span> <span class="p">((</span><span class="n">pin</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The -1 is because pin starts with one, not zero. It might</span>
<span class="cm">	 * be that this equation needs to include the slot number, but</span>
<span class="cm">	 * I don&#39;t have hardware to check that against.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">pin</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">OCTEON_IRQ_PCI_INT0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>  <span class="kt">void</span> <span class="nf">set_cfg_read_retry</span><span class="p">(</span><span class="n">u32</span> <span class="n">retry_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_ctl_status</span> <span class="n">pemx_ctl</span><span class="p">;</span>
	<span class="n">pemx_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">pemx_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cfg_rtry</span> <span class="o">=</span> <span class="n">retry_cnt</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pemx_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u32</span> <span class="nf">disable_cfg_read_retry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">retry_cnt</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">cvmx_pemx_ctl_status</span> <span class="n">pemx_ctl</span><span class="p">;</span>
	<span class="n">pemx_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">retry_cnt</span> <span class="o">=</span>  <span class="n">pemx_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cfg_rtry</span><span class="p">;</span>
	<span class="n">pemx_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">cfg_rtry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_CTL_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">pemx_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retry_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_cfg_retry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pemx_int_sum</span> <span class="n">pemx_int_sum</span><span class="p">;</span>
	<span class="n">pemx_int_sum</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEMX_INT_SUM</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pemx_int_sum</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">crs_dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a value from configuration space</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie_read_config</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">octeon_cvmemctl</span> <span class="n">cvmmemctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">octeon_cvmemctl</span> <span class="n">cvmmemctl_save</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus_number</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_retry_cnt</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg_retry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cvmmemctl_save</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pcie_port</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enable_pcie_bus_num_war</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * For the top level bus make sure our hardware bus number</span>
<span class="cm">	 * matches the software one</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable_pcie_bus_num_war</span><span class="p">[</span><span class="n">pcie_port</span><span class="p">])</span>
			<span class="n">bus_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_pciercx_cfg006</span> <span class="n">pciercx_cfg006</span><span class="p">;</span>
			<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">u32</span> <span class="o">=</span> <span class="n">cvmx_pcie_cfgx_read</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span>
					     <span class="n">CVMX_PCIERCX_CFG006</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pbnum</span> <span class="o">!=</span> <span class="n">bus_number</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pbnum</span> <span class="o">=</span> <span class="n">bus_number</span><span class="p">;</span>
				<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">sbnum</span> <span class="o">=</span> <span class="n">bus_number</span><span class="p">;</span>
				<span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">subbnum</span> <span class="o">=</span> <span class="n">bus_number</span><span class="p">;</span>
				<span class="n">cvmx_pcie_cfgx_write</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span>
					    <span class="n">CVMX_PCIERCX_CFG006</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">),</span>
					    <span class="n">pciercx_cfg006</span><span class="p">.</span><span class="n">u32</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCIe only has a single device connected to Octeon. It is</span>
<span class="cm">	 * always device ID 0. Don&#39;t bother doing reads for other</span>
<span class="cm">	 * device IDs on the first segment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following is a workaround for the CN57XX, CN56XX,</span>
<span class="cm">	 * CN55XX, and CN54XX errata with PCIe config reads from non</span>
<span class="cm">	 * existent devices.  These chips will hang the PCIe link if a</span>
<span class="cm">	 * config read is performed that causes a UR response.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1_1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For our EBH5600 board, port 0 has a bridge with two</span>
<span class="cm">		 * PCI-X slots. We need a new special checks to make</span>
<span class="cm">		 * sure we only probe valid stuff.  The PCIe-&gt;PCI-X</span>
<span class="cm">		 * bridge only respondes to device ID 0, function</span>
<span class="cm">		 * 0-1</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The PCI-X slots are device ID 2,3. Choose one of</span>
<span class="cm">		 * the below &quot;if&quot; blocks based on what is plugged into</span>
<span class="cm">		 * the board.</span>
<span class="cm">		 */</span>
<span class="cp">#if 1</span>
		<span class="cm">/* Use this option if you aren&#39;t using either slot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="cp">#elif 0</span>
		<span class="cm">/*</span>
<span class="cm">		 * Use this option if you are using the first slot but</span>
<span class="cm">		 * not the second.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="cp">#elif 0</span>
		<span class="cm">/*</span>
<span class="cm">		 * Use this option if you are using the second slot</span>
<span class="cm">		 * but not the first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="cp">#elif 0</span>
		<span class="cm">/* Use this opion if you are using both slots */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bus_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">((</span><span class="n">devfn</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">devfn</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))))</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="cm">/* The following #if gives a more complicated example. This is</span>
<span class="cm">		   the required checks for running a Nitrox CN16XX-NHBX in the</span>
<span class="cm">		   slot of the EBH5600. This card has a PLX PCIe bridge with</span>
<span class="cm">		   four Nitrox PLX parts behind it */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* PLX bridge with 4 ports */</span>
<span class="c">		if ((bus_number == 4) &amp;&amp;</span>
<span class="c">		    !((devfn &gt;&gt; 3 &gt;= 1) &amp;&amp; (devfn &gt;&gt; 3 &lt;= 4)))</span>
<span class="c">			return PCIBIOS_FUNC_NOT_SUPPORTED;</span>
<span class="c">		/* Nitrox behind PLX 1 */</span>
<span class="c">		if ((bus_number == 5) &amp;&amp; (devfn &gt;&gt; 3 != 0))</span>
<span class="c">			return PCIBIOS_FUNC_NOT_SUPPORTED;</span>
<span class="c">		/* Nitrox behind PLX 2 */</span>
<span class="c">		if ((bus_number == 6) &amp;&amp; (devfn &gt;&gt; 3 != 0))</span>
<span class="c">			return PCIBIOS_FUNC_NOT_SUPPORTED;</span>
<span class="c">		/* Nitrox behind PLX 3 */</span>
<span class="c">		if ((bus_number == 7) &amp;&amp; (devfn &gt;&gt; 3 != 0))</span>
<span class="c">			return PCIBIOS_FUNC_NOT_SUPPORTED;</span>
<span class="c">		/* Nitrox behind PLX 4 */</span>
<span class="c">		if ((bus_number == 8) &amp;&amp; (devfn &gt;&gt; 3 != 0))</span>
<span class="c">			return PCIBIOS_FUNC_NOT_SUPPORTED;</span>
<span class="cp">#endif</span>

		<span class="cm">/*</span>
<span class="cm">		 * Shorten the DID timeout so bus errors for PCIe</span>
<span class="cm">		 * config reads from non existent devices happen</span>
<span class="cm">		 * faster. This allows us to continue booting even if</span>
<span class="cm">		 * the above &quot;if&quot; checks are wrong.  Once one of these</span>
<span class="cm">		 * errors happens, the PCIe port is dead.</span>
<span class="cm">		 */</span>
		<span class="n">cvmmemctl_save</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">__read_64bit_c0_register</span><span class="p">(</span><span class="err">$</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmmemctl_save</span><span class="p">.</span><span class="n">u64</span><span class="p">;</span>
		<span class="n">cvmmemctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">didtto</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">__write_64bit_c0_register</span><span class="p">(</span><span class="err">$</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">cvmmemctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">enable_pcie_14459_war</span><span class="p">))</span>
		<span class="n">cfg_retry_cnt</span> <span class="o">=</span> <span class="n">disable_cfg_read_retry</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pcie_cfg_rd port=%d b=%d devfn=0x%03x reg=0x%03x&quot;</span>
		 <span class="s">&quot; size=%d &quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">cvmx_pcie_config_read32</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span>
				<span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">cvmx_pcie_config_read16</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span>
				<span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">cvmx_pcie_config_read8</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span>
				<span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX</span><span class="p">))</span>
				<span class="n">set_cfg_read_retry</span><span class="p">(</span><span class="n">cfg_retry_cnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">enable_pcie_14459_war</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cfg_retry</span> <span class="o">=</span> <span class="n">is_cfg_retry</span><span class="p">();</span>
			<span class="n">retry_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retry_cnt</span> <span class="o">&gt;</span> <span class="n">max_retry_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; pcie cfg_read retries failed. retry_cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">retry_cnt</span><span class="p">);</span>
				<span class="n">cfg_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cfg_retry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">enable_pcie_14459_war</span><span class="p">))</span>
		<span class="n">set_cfg_read_retry</span><span class="p">(</span><span class="n">cfg_retry_cnt</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;val=%08x  : tries=%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">retry_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN56XX_PASS1_1</span><span class="p">))</span>
		<span class="n">write_c0_cvmmemctl</span><span class="p">(</span><span class="n">cvmmemctl_save</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie0_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_pcie_read_config</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie1_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_pcie_read_config</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_dummy_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write a value to PCI configuration space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie_write_config</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bus_number</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pcie_port</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">enable_pcie_bus_num_war</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">enable_pcie_bus_num_war</span><span class="p">[</span><span class="n">pcie_port</span><span class="p">]))</span>
		<span class="n">bus_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pcie_cfg_wr port=%d b=%d devfn=0x%03x&quot;</span>
		 <span class="s">&quot; reg=0x%03x size=%d val=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
		 <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">cvmx_pcie_config_write32</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
					 <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">cvmx_pcie_config_write16</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
					 <span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">cvmx_pcie_config_write8</span><span class="p">(</span><span class="n">pcie_port</span><span class="p">,</span> <span class="n">bus_number</span><span class="p">,</span> <span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
					<span class="n">devfn</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if PCI_CONFIG_SPACE_DELAY</span>
	<span class="cm">/*</span>
<span class="cm">	 * Delay on writes so that devices have time to come up. Some</span>
<span class="cm">	 * bridges need this to allow time for the secondary busses to</span>
<span class="cm">	 * work</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">PCI_CONFIG_SPACE_DELAY</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie0_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_pcie_write_config</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_pcie1_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">octeon_pcie_write_config</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">octeon_dummy_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PCIBIOS_FUNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">octeon_pcie0_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">octeon_pcie0_read_config</span><span class="p">,</span>
	<span class="n">octeon_pcie0_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pcie0_mem_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCIe0 MEM&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pcie0_io_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCIe0 IO&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">octeon_pcie0_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pci_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie0_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie0_mem_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie0_io_resource</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">octeon_pcie1_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">octeon_pcie1_read_config</span><span class="p">,</span>
	<span class="n">octeon_pcie1_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pcie1_mem_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCIe1 MEM&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_pcie1_io_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Octeon PCIe1 IO&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">octeon_pcie1_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pci_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie1_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie1_mem_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_pcie1_io_resource</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">octeon_dummy_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">octeon_dummy_read_config</span><span class="p">,</span>
	<span class="n">octeon_dummy_write_config</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_dummy_mem_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Virtual PCIe MEM&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">octeon_dummy_io_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Virtual PCIe IO&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">octeon_dummy_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pci_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_dummy_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_dummy_mem_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_resource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">octeon_dummy_io_resource</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_needs_bus_num_war</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">deviceid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define IDT_VENDOR_ID 0x111d</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">deviceid</span>  <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="n">IDT_VENDOR_ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize the Octeon PCIe controllers</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">octeon_pcie_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">srio_war15205</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sli_ctl_portx</span> <span class="n">sli_ctl_portx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_sriox_status_reg</span> <span class="n">sriox_status_reg</span><span class="p">;</span>

	<span class="cm">/* These chips don&#39;t have PCIe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_PCIE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* No PCIe simulation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_is_simulation</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable PCI if instructed on the command line */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Point pcibios_map_irq() to the PCIe version of it */</span>
	<span class="n">octeon_pcibios_map_irq</span> <span class="o">=</span> <span class="n">octeon_pcie_pcibios_map_irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCIe I/O range. It is based on port 0 but includes up until</span>
<span class="cm">	 * port 1&#39;s end.</span>
<span class="cm">	 */</span>
	<span class="n">set_io_port_base</span><span class="p">(</span><span class="n">CVMX_ADD_IO_SEG</span><span class="p">(</span><span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>
	<span class="n">ioport_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioport_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span>
		<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">cvmx_pcie_get_io_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a dummy PCIe controller to swallow up bus 0. IDT bridges</span>
<span class="cm">	 * don&#39;t work if the primary bus number is zero. Here we add a fake</span>
<span class="cm">	 * PCIe controller that the kernel will give bus 0. This allows</span>
<span class="cm">	 * us to not change the normal kernel bus enumeration</span>
<span class="cm">	 */</span>
	<span class="n">octeon_dummy_controller</span><span class="p">.</span><span class="n">io_map_base</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">octeon_dummy_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="mi">48</span><span class="p">);</span>
	<span class="n">octeon_dummy_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="mi">48</span><span class="p">);</span>
	<span class="n">register_pci_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_dummy_controller</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_npei_ctl_status</span> <span class="n">npei_ctl_status</span><span class="p">;</span>
		<span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_CTL_STATUS</span><span class="p">);</span>
		<span class="n">host_mode</span> <span class="o">=</span> <span class="n">npei_ctl_status</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">host_mode</span><span class="p">;</span>
		<span class="n">octeon_dma_bar_type</span> <span class="o">=</span> <span class="n">OCTEON_DMA_BAR_TYPE_PCIE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_mio_rst_ctlx</span> <span class="n">mio_rst_ctl</span><span class="p">;</span>
		<span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_RST_CTLX</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">host_mode</span> <span class="o">=</span> <span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">host_mode</span><span class="p">;</span>
		<span class="n">octeon_dma_bar_type</span> <span class="o">=</span> <span class="n">OCTEON_DMA_BAR_TYPE_PCIE2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Initializing port 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* CN63XX pass 1_x/2.0 errata PCIe-15205 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS2_0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_SRIOX_STATUS_REG</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">srio</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">srio_war15205</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Port is SRIO */</span>
				<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">cvmx_pcie_rc_initialize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">device0</span><span class="p">;</span>
			<span class="cm">/* Memory offsets are physical addresses */</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">mem_offset</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* IO offsets are Mips virtual addresses */</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">io_map_base</span> <span class="o">=</span>
				<span class="n">CVMX_ADD_IO_SEG</span><span class="p">(</span><span class="n">cvmx_pcie_get_io_base_address</span>
						<span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">io_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * To keep things similar to PCI, we start</span>
<span class="cm">			 * device addresses at the same place as PCI</span>
<span class="cm">			 * uisng big bar support. This normally</span>
<span class="cm">			 * translates to 4GB-256MB, which is the same</span>
<span class="cm">			 * as most x86 PCs.</span>
<span class="cm">			 */</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
				<span class="p">(</span><span class="mi">4ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">OCTEON_PCI_BAR1_HOLE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">cvmx_pcie_get_mem_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ports must be above 16KB for the ISA bus</span>
<span class="cm">			 * filtering in the PCI-X to PCI bridge.</span>
<span class="cm">			 */</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">io_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">octeon_pcie0_controller</span><span class="p">.</span><span class="n">io_resource</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_io_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="cm">/* Some devices need extra time */</span>
			<span class="n">register_pci_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_pcie0_controller</span><span class="p">);</span>
			<span class="n">device0</span> <span class="o">=</span> <span class="n">cvmx_pcie_config_read32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">enable_pcie_bus_num_war</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">device_needs_bus_num_war</span><span class="p">(</span><span class="n">device0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port 0 in endpoint mode, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* CN63XX pass 1_x/2.0 errata PCIe-15205 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS2_0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">srio_war15205</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">octeon_has_feature</span><span class="p">(</span><span class="n">OCTEON_FEATURE_NPEI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">host_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Skip the 2nd port on CN52XX if port 0 is in 4 lane mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN52XX</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">cvmx_npei_dbg_data</span> <span class="n">dbg_data</span><span class="p">;</span>
			<span class="n">dbg_data</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_NPEI_DBG_DATA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dbg_data</span><span class="p">.</span><span class="n">cn52xx</span><span class="p">.</span><span class="n">qlm0_link_width</span><span class="p">)</span>
				<span class="n">host_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_mio_rst_ctlx</span> <span class="n">mio_rst_ctl</span><span class="p">;</span>
		<span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_MIO_RST_CTLX</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">host_mode</span> <span class="o">=</span> <span class="n">mio_rst_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">host_mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Initializing port 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* CN63XX pass 1_x/2.0 errata PCIe-15205 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS2_0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_SRIOX_STATUS_REG</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sriox_status_reg</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">srio</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">srio_war15205</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Port is SRIO */</span>
				<span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">cvmx_pcie_rc_initialize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">device0</span><span class="p">;</span>
			<span class="cm">/* Memory offsets are physical addresses */</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">mem_offset</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * To calculate the address for accessing the 2nd PCIe device,</span>
<span class="cm">			 * either &#39;io_map_base&#39; (pci_iomap()), or &#39;mips_io_port_base&#39;</span>
<span class="cm">			 * (ioport_map()) value is added to</span>
<span class="cm">			 * pci_resource_start(dev,bar)). The &#39;mips_io_port_base&#39; is set</span>
<span class="cm">			 * only once based on first PCIe. Also changing &#39;io_map_base&#39;</span>
<span class="cm">			 * based on first slot&#39;s value so that both the routines will</span>
<span class="cm">			 * work properly.</span>
<span class="cm">			 */</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">io_map_base</span> <span class="o">=</span>
				<span class="n">CVMX_ADD_IO_SEG</span><span class="p">(</span><span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="cm">/* IO offsets are Mips virtual addresses */</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">io_offset</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * To keep things similar to PCI, we start device</span>
<span class="cm">			 * addresses at the same place as PCI uisng big bar</span>
<span class="cm">			 * support. This normally translates to 4GB-256MB,</span>
<span class="cm">			 * which is the same as most x86 PCs.</span>
<span class="cm">			 */</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4ul</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">OCTEON_PCI_BAR1_HOLE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">mem_resource</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_mem_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">cvmx_pcie_get_mem_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ports must be above 16KB for the ISA bus filtering</span>
<span class="cm">			 * in the PCI-X to PCI bridge.</span>
<span class="cm">			 */</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">io_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span>
				<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">cvmx_pcie_get_io_base_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">io_resource</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span>
				<span class="n">octeon_pcie1_controller</span><span class="p">.</span><span class="n">io_resource</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
				<span class="n">cvmx_pcie_get_io_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="cm">/* Some devices need extra time */</span>
			<span class="n">register_pci_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="n">octeon_pcie1_controller</span><span class="p">);</span>
			<span class="n">device0</span> <span class="o">=</span> <span class="n">cvmx_pcie_config_read32</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">enable_pcie_bus_num_war</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">device_needs_bus_num_war</span><span class="p">(</span><span class="n">device0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;PCIe: Port 1 not in root complex mode, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* CN63XX pass 1_x/2.0 errata PCIe-15205  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS2_0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">srio_war15205</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * CN63XX pass 1_x/2.0 errata PCIe-15205 requires setting all</span>
<span class="cm">	 * of SRIO MACs SLI_CTL_PORT*[INT*_MAP] to similar value and</span>
<span class="cm">	 * all of PCIe Macs SLI_CTL_PORT*[INT*_MAP] to different value</span>
<span class="cm">	 * from the previous set values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS1_X</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN63XX_PASS2_0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srio_war15205</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">inta_map</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intb_map</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intc_map</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intd_map</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="n">port</span><span class="p">),</span> <span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">));</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">inta_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intb_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intc_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">intd_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PEXP_SLI_CTL_PORTX</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">),</span> <span class="n">sli_ctl_portx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">octeon_pci_dma_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">arch_initcall</span><span class="p">(</span><span class="n">octeon_pcie_setup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
