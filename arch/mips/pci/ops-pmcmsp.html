<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › pci › ops-pmcmsp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ops-pmcmsp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PMC-Sierra MSP board specific pci_ops</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2001 MontaVista Software Inc.</span>
<span class="cm"> * Copyright 2005-2007 PMC-Sierra, Inc</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net</span>
<span class="cm"> *</span>
<span class="cm"> * Much of the code is derived from the original DDB5074 port by</span>
<span class="cm"> * Geert Uytterhoeven &lt;geert@sonycom.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define PCI_COUNTERS	1</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(PCI_COUNTERS)</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS &amp;&amp; PCI_COUNTERS */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)</span>
<span class="cp">#include &lt;asm/mipsmtregs.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;msp_prom.h&gt;</span>
<span class="cp">#include &lt;msp_cic_int.h&gt;</span>
<span class="cp">#include &lt;msp_pci.h&gt;</span>
<span class="cp">#include &lt;msp_regs.h&gt;</span>
<span class="cp">#include &lt;msp_regops.h&gt;</span>

<span class="cp">#define PCI_ACCESS_READ		0</span>
<span class="cp">#define PCI_ACCESS_WRITE	1</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(PCI_COUNTERS)</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">proc_init</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_bus_pci_dir</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_int_count</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">pci_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: read_msp_pci_counts</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Prints the count of how many times each PCI</span>
<span class="cm"> *               interrupt has asserted. Can be invoked by the</span>
<span class="cm"> *               /proc filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS:      page    - part of STDOUT calculation</span>
<span class="cm"> *               off     - part of STDOUT calculation</span>
<span class="cm"> *               count   - part of STDOUT calculation</span>
<span class="cm"> *               data    - unused</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:     start   - new start location</span>
<span class="cm"> *               eof     - end of file pointer</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     len     - STDOUT length</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_msp_pci_counts</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">off</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intcount</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intcount</span> <span class="o">=</span> <span class="n">pci_int_count</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intcount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;[%d] = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">intcount</span><span class="p">);</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">intcount</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;total = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">off</span><span class="o">+</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: gen_pci_cfg_wr</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Generates a configuration write cycle for debug purposes.</span>
<span class="cm"> *               The IDSEL line asserted and location and data written are</span>
<span class="cm"> *               immaterial. Just want to be able to prove that a</span>
<span class="cm"> *               configuration write can be correctly generated on the</span>
<span class="cm"> *               PCI bus.  Intent is that this function by invocable from</span>
<span class="cm"> *               the /proc filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS:      page    - part of STDOUT calculation</span>
<span class="cm"> *               off     - part of STDOUT calculation</span>
<span class="cm"> *               count   - part of STDOUT calculation</span>
<span class="cm"> *               data    - unused</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:     start   - new start location</span>
<span class="cm"> *               eof     - end of file pointer</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     len     - STDOUT length</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gen_pci_cfg_wr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">off</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">where</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Write to static Device/Vendor ID */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bus_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Bus 0 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dev_fn</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">;</span> <span class="cm">/* Arbitrary device number */</span>
	<span class="n">u32</span> <span class="n">wr_data</span> <span class="o">=</span> <span class="mh">0xFF00AA00</span><span class="p">;</span> <span class="cm">/* Arbitrary data */</span>
	<span class="k">struct</span> <span class="n">msp_pci_regs</span> <span class="o">*</span><span class="n">preg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_BASE_REG</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intr</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;PMC MSP PCI: Beginning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">proc_init</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_proc_init</span><span class="p">();</span>
		<span class="n">proc_init</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;PMC MSP PCI: Before Cfg Wr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate PCI Configuration Write Cycle</span>
<span class="cm">	 */</span>

	<span class="cm">/* Clear cause register bits */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">BPCI_IFSTATUS_BC0F</span> <span class="o">|</span> <span class="n">BPCI_IFSTATUS_BC1F</span><span class="p">);</span>

	<span class="cm">/* Setup address that is to appear on PCI bus */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="n">BPCI_CFGADDR_ENABLE</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">bus_num</span> <span class="o">&lt;&lt;</span> <span class="n">BPCI_CFGADDR_BUSNUM_SHF</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">dev_fn</span> <span class="o">&lt;&lt;</span> <span class="n">BPCI_CFGADDR_FUNCTNUM_SHF</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mh">0xFC</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">wr_data</span><span class="p">);</span>

	<span class="cm">/* Launch the PCI configuration write cycle */</span>
	<span class="o">*</span><span class="n">PCI_CONFIG_SPACE_REG</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the PCI configuration cycle (rd or wr) succeeded, by</span>
<span class="cm">	 * checking the status bits for errors like master or target abort.</span>
<span class="cm">	 */</span>
	<span class="n">intr</span> <span class="o">=</span> <span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;PMC MSP PCI: After Cfg Wr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Handle STDOUT calculations */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">off</span><span class="o">+</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: pci_proc_init</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Create entries in the /proc filesystem for debug access.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS:      none</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:     none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     none</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">create_proc_read_entry</span><span class="p">(</span><span class="s">&quot;pmc_msp_pci_rd_cnt&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">read_msp_pci_counts</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">create_proc_read_entry</span><span class="p">(</span><span class="s">&quot;pmc_msp_pci_cfg_wr&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">gen_pci_cfg_wr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS &amp;&amp; PCI_COUNTERS */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">bpci_lock</span><span class="p">);</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  STRUCT: pci_io_resource</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Defines the address range that pciauto() will use to</span>
<span class="cm"> *               assign to the I/O BARs of PCI devices.</span>
<span class="cm"> *</span>
<span class="cm"> *               Use the start and end addresses of the MSP7120 PCI Host</span>
<span class="cm"> *               Controller I/O space, in the form that they appear on the</span>
<span class="cm"> *               PCI bus AFTER MSP7120 has performed address translation.</span>
<span class="cm"> *</span>
<span class="cm"> *               For I/O accesses, MSP7120 ignores OATRAN and maps I/O</span>
<span class="cm"> *               accesses into the bottom 0xFFF region of address space,</span>
<span class="cm"> *               so that is the range to put into the pci_io_resource</span>
<span class="cm"> *               struct.</span>
<span class="cm"> *</span>
<span class="cm"> *               In MSP4200, the start address was 0x04 instead of the</span>
<span class="cm"> * 		 expected 0x00. Will just assume there was a good reason</span>
<span class="cm"> * 		 for this!</span>
<span class="cm"> *</span>
<span class="cm"> *  NOTES:       Linux, by default, will assign I/O space to the lowest</span>
<span class="cm"> *               region of address space. Since MSP7120 and Linux,</span>
<span class="cm"> *               by default, have no offset in between how they map, the</span>
<span class="cm"> *               io_offset element of pci_controller struct should be set</span>
<span class="cm"> *               to zero.</span>
<span class="cm"> *  ELEMENTS:</span>
<span class="cm"> *    name       - String used for a meaningful name.</span>
<span class="cm"> *</span>
<span class="cm"> *    start      - Start address of MSP7120&#39;s I/O space, as MSP7120 presents</span>
<span class="cm"> *                 the address on the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> *    end        - End address of MSP7120&#39;s I/O space, as MSP7120 presents</span>
<span class="cm"> *                 the address on the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> *    flags      - Attributes indicating the type of resource. In this case,</span>
<span class="cm"> *                 indicate I/O space.</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">pci_io_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;pci IO space&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="mh">0x0FFF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_IO</span>	<span class="cm">/* I/O space */</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  STRUCT: pci_mem_resource</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Defines the address range that pciauto() will use to</span>
<span class="cm"> *               assign to the memory BARs of PCI devices.</span>
<span class="cm"> *</span>
<span class="cm"> *               The .start and .end values are dependent upon how address</span>
<span class="cm"> *               translation is performed by the OATRAN regiser.</span>
<span class="cm"> *</span>
<span class="cm"> *               The values to use for .start and .end are the values</span>
<span class="cm"> *               in the form they appear on the PCI bus AFTER MSP7120 has</span>
<span class="cm"> *               performed OATRAN address translation.</span>
<span class="cm"> *</span>
<span class="cm"> *  ELEMENTS:</span>
<span class="cm"> *    name       - String used for a meaningful name.</span>
<span class="cm"> *</span>
<span class="cm"> *    start      - Start address of MSP7120&#39;s memory space, as MSP7120 presents</span>
<span class="cm"> *                 the address on the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> *    end        - End address of MSP7120&#39;s memory space, as MSP7120 presents</span>
<span class="cm"> *                 the address on the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> *    flags      - Attributes indicating the type of resource. In this case,</span>
<span class="cm"> *                 indicate memory space.</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">pci_mem_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;pci memory space&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">MSP_PCI_SPACE_BASE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>	<span class="o">=</span> <span class="n">MSP_PCI_SPACE_END</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">IORESOURCE_MEM</span>	 <span class="cm">/* memory space */</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: bpci_interrupt</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: PCI status interrupt handler. Updates the count of how</span>
<span class="cm"> *               many times each status bit has been set, then clears</span>
<span class="cm"> *               the status bits. If the appropriate macros are defined,</span>
<span class="cm"> *               these counts can be viewed via the /proc filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS:      irq     - unused</span>
<span class="cm"> *               dev_id  - unused</span>
<span class="cm"> *               pt_regs - unused</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:     none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL  - success</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bpci_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msp_pci_regs</span> <span class="o">*</span><span class="n">preg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_BASE_REG</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(PCI_COUNTERS)</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="p">)</span>
			<span class="o">++</span><span class="n">pci_int_count</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* PROC_FS &amp;&amp; PCI_COUNTERS */</span><span class="cp"></span>

	<span class="cm">/* printk(&quot;PCI ISR: Status=%08X\n&quot;, stat); */</span>

	<span class="cm">/* write to clear all asserted interrupts */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">=</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_config_access</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Performs a PCI configuration access (rd or wr), then</span>
<span class="cm"> *               checks that the access succeeded by querying MSP7120&#39;s</span>
<span class="cm"> *               PCI status bits.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS:</span>
<span class="cm"> *               access_type  - kind of PCI configuration cycle to perform</span>
<span class="cm"> *                              (read or write). Legal values are</span>
<span class="cm"> *                              PCI_ACCESS_WRITE and PCI_ACCESS_READ.</span>
<span class="cm"> *</span>
<span class="cm"> *               bus          - pointer to the bus number of the device to</span>
<span class="cm"> *                              be targeted for the configuration cycle.</span>
<span class="cm"> *                              The only element of the pci_bus structure</span>
<span class="cm"> *                              used is bus-&gt;number. This argument determines</span>
<span class="cm"> *                              if the configuration access will be Type 0 or</span>
<span class="cm"> *                              Type 1. Since MSP7120 assumes itself to be the</span>
<span class="cm"> *                              PCI Host, any non-zero bus-&gt;number generates</span>
<span class="cm"> *                              a Type 1 access.</span>
<span class="cm"> *</span>
<span class="cm"> *               devfn        - this is an 8-bit field. The lower three bits</span>
<span class="cm"> *                              specify the function number of the device to</span>
<span class="cm"> *                              be targeted for the configuration cycle, with</span>
<span class="cm"> *                              all three-bit combinations being legal. The</span>
<span class="cm"> *                              upper five bits specify the device number,</span>
<span class="cm"> *                              with legal values being 10 to 31.</span>
<span class="cm"> *</span>
<span class="cm"> *               where        - address within the Configuration Header</span>
<span class="cm"> *                              space to access.</span>
<span class="cm"> *</span>
<span class="cm"> *               data         - for write accesses, contains the data to</span>
<span class="cm"> *                              write.</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:</span>
<span class="cm"> *               data         - for read accesses, contains the value read.</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL  - success</span>
<span class="cm"> *               -1                  - access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="kt">int</span> <span class="nf">msp_pcibios_config_access</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">access_type</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msp_pci_regs</span> <span class="o">*</span><span class="n">preg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_BASE_REG</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bus_num</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dev_fn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">devfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">intr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">pciirqflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">vpe_status</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(PCI_COUNTERS)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_init</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_proc_init</span><span class="p">();</span>
		<span class="n">proc_init</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS &amp;&amp; PCI_COUNTERS */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Just the first time this function invokes, allocate</span>
<span class="cm">	 * an interrupt line for PCI host status interrupts. The</span>
<span class="cm">	 * allocation assigns an interrupt handler to the interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pciirqflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MSP_INT_PCI</span><span class="p">,</span><span class="cm">/* Hardcoded internal MSP7120 wiring */</span>
				<span class="n">bpci_interrupt</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span>
				<span class="s">&quot;PMC MSP PCI Host&quot;</span><span class="p">,</span>
				<span class="n">preg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">pciirqflag</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">vpe_status</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear PCI cause register bits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In Polo, the PCI Host had a dedicated DMA called the</span>
<span class="cm">	 * Block Copy (not to be confused with the general purpose Block</span>
<span class="cm">	 * Copy Engine block). There appear to have been special interrupts</span>
<span class="cm">	 * for this Block Copy, called Block Copy 0 Fault (BC0F) and</span>
<span class="cm">	 * Block Copy 1 Fault (BC1F). MSP4200 and MSP7120 don&#39;t have this</span>
<span class="cm">	 * dedicated Block Copy block, so these two interrupts are now</span>
<span class="cm">	 * marked reserved. In case the  Block Copy is resurrected in a</span>
<span class="cm">	 * future design, maintain the code that treats these two interrupts</span>
<span class="cm">	 * specially.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Write to clear all interrupts in the PCI status register, aside</span>
<span class="cm">	 * from BC0F and BC1F.</span>
<span class="cm">	 */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">BPCI_IFSTATUS_BC0F</span> <span class="o">|</span> <span class="n">BPCI_IFSTATUS_BC1F</span><span class="p">);</span>

	<span class="cm">/* Setup address that is to appear on PCI bus */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="n">BPCI_CFGADDR_ENABLE</span>	<span class="o">|</span>
		<span class="p">(</span><span class="n">bus_num</span> <span class="o">&lt;&lt;</span> <span class="n">BPCI_CFGADDR_BUSNUM_SHF</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">dev_fn</span> <span class="o">&lt;&lt;</span> <span class="n">BPCI_CFGADDR_FUNCTNUM_SHF</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mh">0xFC</span><span class="p">);</span>

	<span class="cm">/* IF access is a PCI configuration write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access_type</span> <span class="o">==</span> <span class="n">PCI_ACCESS_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
		<span class="o">*</span><span class="n">PCI_CONFIG_SPACE_REG</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* ELSE access is a PCI configuration read */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">PCI_CONFIG_SPACE_REG</span><span class="p">);</span>
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the PCI configuration cycle (rd or wr) succeeded, by</span>
<span class="cm">	 * checking the status bits for errors like master or target abort.</span>
<span class="cm">	 */</span>
	<span class="n">intr</span> <span class="o">=</span> <span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span><span class="p">;</span>

	<span class="cm">/* Clear config access */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* IF error occurred */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BPCI_IFSTATUS_BC0F</span> <span class="o">|</span> <span class="n">BPCI_IFSTATUS_BC1F</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clear status bits */</span>
		<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">BPCI_IFSTATUS_BC0F</span> <span class="o">|</span> <span class="n">BPCI_IFSTATUS_BC1F</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">vpe_status</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">vpe_status</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bpci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_read_config_byte</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Read a byte from PCI configuration address spac</span>
<span class="cm"> *               Since the hardware can&#39;t address 8 bit chunks</span>
<span class="cm"> *               directly, read a 32-bit chunk, then mask off extraneous</span>
<span class="cm"> *               bits.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the read is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the read is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      val    - read data</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL  - success</span>
<span class="cm"> *               -1                  - read access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_read_config_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the config access did not complete normally (e.g., underwent</span>
<span class="cm">	 * master abort) do the PCI compliant thing, which is to supply an</span>
<span class="cm">	 * all ones value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_READ</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_read_config_word</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Read a word (16 bits) from PCI configuration address space.</span>
<span class="cm"> *               Since the hardware can&#39;t address 16 bit chunks</span>
<span class="cm"> *               directly, read a 32-bit chunk, then mask off extraneous</span>
<span class="cm"> *               bits.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the read is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the read is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      val    - read data</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL           - success</span>
<span class="cm"> *               PCIBIOS_BAD_REGISTER_NUMBER  - bad register address</span>
<span class="cm"> *               -1                           - read access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_read_config_word</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if (where &amp; 1) */</span>	<span class="cm">/* Commented out non-compliant code.</span>
<span class="cm">				 * Should allow word access to configuration</span>
<span class="cm">				 * registers, with only exception being when</span>
<span class="cm">				 * the word access would wrap around into</span>
<span class="cm">				 * the next dword.</span>
<span class="cm">				 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PCIBIOS_BAD_REGISTER_NUMBER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the config access did not complete normally (e.g., underwent</span>
<span class="cm">	 * master abort) do the PCI compliant thing, which is to supply an</span>
<span class="cm">	 * all ones value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_READ</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x0ffff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_read_config_dword</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Read a double word (32 bits) from PCI configuration</span>
<span class="cm"> *               address space.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the read is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the read is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      val    - read data</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL           - success</span>
<span class="cm"> *               PCIBIOS_BAD_REGISTER_NUMBER  - bad register address</span>
<span class="cm"> *               -1                           - read access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_read_config_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Address must be dword aligned. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PCIBIOS_BAD_REGISTER_NUMBER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the config access did not complete normally (e.g., underwent</span>
<span class="cm">	 * master abort) do the PCI compliant thing, which is to supply an</span>
<span class="cm">	 * all ones value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_READ</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_write_config_byte</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Write a byte to PCI configuration address space.</span>
<span class="cm"> *               Since the hardware can&#39;t address 8 bit chunks</span>
<span class="cm"> *               directly, a read-modify-write is performed.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the write is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the write is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *               val    - value to write</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL  - success</span>
<span class="cm"> *               -1                  - write access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_write_config_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* read config space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_READ</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* modify the byte within the dword */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>

	<span class="cm">/* write back the full dword */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_WRITE</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_write_config_word</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Write a word (16-bits) to PCI configuration address space.</span>
<span class="cm"> *               Since the hardware can&#39;t address 16 bit chunks</span>
<span class="cm"> *               directly, a read-modify-write is performed.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the write is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the write is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *               val    - value to write</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL           - success</span>
<span class="cm"> *               PCIBIOS_BAD_REGISTER_NUMBER  - bad register address</span>
<span class="cm"> *               -1                           - write access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_write_config_word</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fixed non-compliance: if (where &amp; 1) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCIBIOS_BAD_REGISTER_NUMBER</span><span class="p">;</span>

	<span class="cm">/* read config space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_READ</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* modify the word within the dword */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xffff</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>

	<span class="cm">/* write back the full dword */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_WRITE</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_write_config_dword</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Write a double word (32-bits) to PCI configuration address</span>
<span class="cm"> *               space.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the write is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the write is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *               val    - value to write</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL           - success</span>
<span class="cm"> *               PCIBIOS_BAD_REGISTER_NUMBER  - bad register address</span>
<span class="cm"> *               -1                           - write access failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msp_pcibios_write_config_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* check that address is dword aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCIBIOS_BAD_REGISTER_NUMBER</span><span class="p">;</span>

	<span class="cm">/* perform write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_config_access</span><span class="p">(</span><span class="n">PCI_ACCESS_WRITE</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
					<span class="n">where</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_read_config</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Interface the PCI configuration read request with</span>
<span class="cm"> *               the appropriate function, based on how many bytes</span>
<span class="cm"> *               the read request is.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the write is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the write is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *               size   - in units of bytes, should be 1, 2, or 4.</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS      val    - value read, with any extraneous bytes masked</span>
<span class="cm"> *                        to zero.</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL   - success</span>
<span class="cm"> *               -1                   - failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="kt">int</span>
<span class="nf">msp_pcibios_read_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">devfn</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_read_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_read_config_word</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_read_config_dword</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pcibios_write_config</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Interface the PCI configuration write request with</span>
<span class="cm"> *               the appropriate function, based on how many bytes</span>
<span class="cm"> *               the read request is.</span>
<span class="cm"> *</span>
<span class="cm"> *  INPUTS       bus    - structure containing attributes for the PCI bus</span>
<span class="cm"> *                        that the write is destined for.</span>
<span class="cm"> *               devfn  - device/function combination that the write is</span>
<span class="cm"> *                        destined for.</span>
<span class="cm"> *               where  - register within the Configuration Header space</span>
<span class="cm"> *                        to access.</span>
<span class="cm"> *               size   - in units of bytes, should be 1, 2, or 4.</span>
<span class="cm"> *               val    - value to write</span>
<span class="cm"> *</span>
<span class="cm"> *  OUTPUTS:     none</span>
<span class="cm"> *</span>
<span class="cm"> *  RETURNS:     PCIBIOS_SUCCESSFUL   - success</span>
<span class="cm"> *               -1                   - failure</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="kt">int</span>
<span class="nf">msp_pcibios_write_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_write_config_byte</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
						<span class="n">where</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_write_config_word</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span>
						<span class="n">where</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="mh">0xFFFF</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msp_pcibios_write_config_dword</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PCIBIOS_SUCCESSFUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  STRUCTURE: msp_pci_ops</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: structure to abstract the hardware specific PCI</span>
<span class="cm"> *               configuration accesses.</span>
<span class="cm"> *</span>
<span class="cm"> *  ELEMENTS:</span>
<span class="cm"> *    read      - function for Linux to generate PCI Configuration reads.</span>
<span class="cm"> *    write     - function for Linux to generate PCI Configuration writes.</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">struct</span> <span class="n">pci_ops</span> <span class="n">msp_pci_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">msp_pcibios_read_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">msp_pcibios_write_config</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  STRUCTURE: msp_pci_controller</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  Describes the attributes of the MSP7120 PCI Host Controller</span>
<span class="cm"> *</span>
<span class="cm"> *  ELEMENTS:</span>
<span class="cm"> *    pci_ops      - abstracts the hardware specific PCI configuration</span>
<span class="cm"> *                   accesses.</span>
<span class="cm"> *</span>
<span class="cm"> *    mem_resource - address range pciauto() uses to assign to PCI device</span>
<span class="cm"> *                   memory BARs.</span>
<span class="cm"> *</span>
<span class="cm"> *    mem_offset   - offset between how MSP7120 outbound PCI memory</span>
<span class="cm"> *                   transaction addresses appear on the PCI bus and how Linux</span>
<span class="cm"> *                   wants to configure memory BARs of the PCI devices.</span>
<span class="cm"> *                   MSP7120 does nothing funky, so just set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> *    io_resource  - address range pciauto() uses to assign to PCI device</span>
<span class="cm"> *                   I/O BARs.</span>
<span class="cm"> *</span>
<span class="cm"> *    io_offset    - offset between how MSP7120 outbound PCI I/O</span>
<span class="cm"> *                   transaction addresses appear on the PCI bus and how</span>
<span class="cm"> *                   Linux defaults to configure I/O BARs of the PCI devices.</span>
<span class="cm"> *                   MSP7120 maps outbound I/O accesses into the bottom</span>
<span class="cm"> *                   bottom 4K of PCI address space (and ignores OATRAN).</span>
<span class="cm"> *                   Since the Linux default is to configure I/O BARs to the</span>
<span class="cm"> *                   bottom 4K, no special offset is needed. Just set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_controller</span> <span class="n">msp_pci_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pci_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">msp_pci_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_resource</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_mem_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mem_offset</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_map_base</span>	<span class="o">=</span> <span class="n">MSP_PCI_IOSPACE_BASE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_resource</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_io_resource</span><span class="p">,</span>
	<span class="p">.</span><span class="n">io_offset</span>	<span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *  FUNCTION: msp_pci_init</span>
<span class="cm"> *  _________________________________________________________________________</span>
<span class="cm"> *</span>
<span class="cm"> *  DESCRIPTION: Initialize the PCI Host Controller and register it with</span>
<span class="cm"> *               Linux so Linux can seize control of the PCI bus.</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">msp_pci_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msp_pci_regs</span> <span class="o">*</span><span class="n">preg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">PCI_BASE_REG</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/* Extract Device ID */</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">read_reg32</span><span class="p">(</span><span class="n">PCI_JTAG_DEVID_REG</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>

	<span class="cm">/* Check if JTAG ID identifies MSP7120 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MSP_HAS_PCI</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;PCI: No PCI; id reads as %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_pci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable flushing of the PCI-SDRAM queue upon a read</span>
<span class="cm">	 * of the SDRAM&#39;s Memory Configuration Register.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">QFLUSH_REG_1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Configure PCI Host Controller. */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_status</span>	<span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Clear cause register bits */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">config_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Clear config access */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">oatran</span>	<span class="o">=</span> <span class="n">MSP_PCI_OATRAN</span><span class="p">;</span> <span class="cm">/* PCI outbound addr translation */</span>
	<span class="n">preg</span><span class="o">-&gt;</span><span class="n">if_mask</span>	<span class="o">=</span> <span class="mh">0xF8BF87C0</span><span class="p">;</span>	<span class="cm">/* Enable all PCI status interrupts */</span>

	<span class="cm">/* configure so inb(), outb(), and family are functional */</span>
	<span class="n">set_io_port_base</span><span class="p">(</span><span class="n">MSP_PCI_IOSPACE_BASE</span><span class="p">);</span>

	<span class="cm">/* Tell Linux the details of the MSP7120 PCI Host Controller */</span>
	<span class="n">register_pci_controller</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msp_pci_controller</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">no_pci:</span>
	<span class="cm">/* Disable PCI channel */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;PCI: no host PCI bus detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
