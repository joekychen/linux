<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › alchemy › common › time.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>time.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2008-2009 Manuel Lauss &lt;manuel.lauss@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Previous incarnations were:</span>
<span class="cm"> * Copyright (C) 2001, 2006, 2008 MontaVista Software, &lt;source@mvista.com&gt;</span>
<span class="cm"> * Copied and modified Carsten Langgaard&#39;s time.c</span>
<span class="cm"> *</span>
<span class="cm"> * Carsten Langgaard, carstenl@mips.com</span>
<span class="cm"> * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * ########################################################################</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can distribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License (Version 2) as</span>
<span class="cm"> *  published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> *  for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * ########################################################################</span>
<span class="cm"> *</span>
<span class="cm"> * Clocksource/event using the 32.768kHz-clocked Counter1 (&#39;RTC&#39; in the</span>
<span class="cm"> * databooks).  Firmware/Board init code must enable the counters in the</span>
<span class="cm"> * counter control register, otherwise the CP0 counter clocksource/event</span>
<span class="cm"> * will be installed instead (and use of &#39;wait&#39; instruction is prohibited).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/mach-au1x00/au1000.h&gt;</span>

<span class="cm">/* 32kHz clock enabled and detected */</span>
<span class="cp">#define CNTR_OK (SYS_CNTRL_E0 | SYS_CNTRL_32S)</span>

<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">au1x_counter1_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_RTCREAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">au1x_counter1_clocksource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;alchemy-counter1&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">au1x_counter1_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>		<span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">au1x_rtcmatch2_set_next_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">delta</span> <span class="o">+=</span> <span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_RTCREAD</span><span class="p">);</span>
	<span class="cm">/* wait for register access */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_COUNTER_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SYS_CNTRL_M21</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">au_writel</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">SYS_RTCMATCH2</span><span class="p">);</span>
	<span class="n">au_sync</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">au1x_rtcmatch2_set_mode</span><span class="p">(</span><span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">au1x_rtcmatch2_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="n">au1x_rtcmatch2_clockdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rtcmatch2&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_next_event</span>	<span class="o">=</span> <span class="n">au1x_rtcmatch2_set_next_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mode</span>	<span class="o">=</span> <span class="n">au1x_rtcmatch2_set_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpumask</span>	<span class="o">=</span> <span class="n">cpu_all_mask</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">au1x_rtcmatch2_irqaction</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">au1x_rtcmatch2_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IRQF_TIMER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;timer&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_id</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">au1x_rtcmatch2_clockdev</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">alchemy_time_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m2int</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">au1x_rtcmatch2_clockdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">au1x_rtcmatch2_clockdev</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">m2int</span><span class="p">;</span>

	<span class="cm">/* Check if firmware (YAMON, ...) has enabled 32kHz and clock</span>
<span class="cm">	 * has been detected.  If so install the rtcmatch2 clocksource,</span>
<span class="cm">	 * otherwise don&#39;t bother.  Note that both bits being set is by</span>
<span class="cm">	 * no means a definite guarantee that the counters actually work</span>
<span class="cm">	 * (the 32S bit seems to be stuck set to 1 once a single clock-</span>
<span class="cm">	 * edge is detected, hence the timeouts).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CNTR_OK</span> <span class="o">!=</span> <span class="p">(</span><span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_COUNTER_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CNTR_OK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cntr_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup counter 1 (RTC) to tick at full speed</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_COUNTER_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SYS_CNTRL_T1S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">t</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;nop&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cntr_err</span><span class="p">;</span>

	<span class="n">au_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SYS_RTCTRIM</span><span class="p">);</span>	<span class="cm">/* 32.768 kHz */</span>
	<span class="n">au_sync</span><span class="p">();</span>

	<span class="n">t</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_COUNTER_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SYS_CNTRL_C1S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">t</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;nop&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cntr_err</span><span class="p">;</span>
	<span class="n">au_writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SYS_RTCWRITE</span><span class="p">);</span>
	<span class="n">au_sync</span><span class="p">();</span>

	<span class="n">t</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">au_readl</span><span class="p">(</span><span class="n">SYS_COUNTER_CNTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SYS_CNTRL_C1S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">t</span><span class="p">)</span>
		<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;nop&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cntr_err</span><span class="p">;</span>

	<span class="cm">/* register counter1 clocksource and event device */</span>
	<span class="n">clocksource_register_hz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">au1x_counter1_clocksource</span><span class="p">,</span> <span class="mi">32768</span><span class="p">);</span>

	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">=</span> <span class="n">div_sc</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">max_delta_ns</span> <span class="o">=</span> <span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">=</span> <span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>	<span class="cm">/* ~0.28ms */</span>
	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="n">setup_irq</span><span class="p">(</span><span class="n">m2int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">au1x_rtcmatch2_irqaction</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Alchemy clocksource installed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cntr_err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">alchemy_setup_c0timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * MIPS kernel assigns &#39;au1k_wait&#39; to &#39;cpu_wait&#39; before this</span>
<span class="cm">	 * function is called.  Because the Alchemy counters are unusable</span>
<span class="cm">	 * the C0 timekeeping code is installed and use of the &#39;wait&#39;</span>
<span class="cm">	 * instruction must be prohibited, which is done most easily by</span>
<span class="cm">	 * assigning NULL to cpu_wait.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_wait</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">r4k_clockevent_init</span><span class="p">();</span>
	<span class="n">init_r4k_clocksource</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">alchemy_m2inttab</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AU1000_RTC_MATCH2_INT</span><span class="p">,</span>
	<span class="n">AU1500_RTC_MATCH2_INT</span><span class="p">,</span>
	<span class="n">AU1100_RTC_MATCH2_INT</span><span class="p">,</span>
	<span class="n">AU1550_RTC_MATCH2_INT</span><span class="p">,</span>
	<span class="n">AU1200_RTC_MATCH2_INT</span><span class="p">,</span>
	<span class="n">AU1300_RTC_MATCH2_INT</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">plat_time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">alchemy_get_cputype</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">ALCHEMY_CPU_UNKNOWN</span><span class="p">)</span>
		<span class="n">alchemy_setup_c0timer</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">alchemy_time_init</span><span class="p">(</span><span class="n">alchemy_m2inttab</span><span class="p">[</span><span class="n">t</span><span class="p">]))</span>
		<span class="n">alchemy_setup_c0timer</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
