<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › kernel › smtc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smtc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Mips Technologies, Inc</span>
<span class="cm"> * Copyright (C) 2008 Kevin D. Kissell</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/hardirq.h&gt;</span>
<span class="cp">#include &lt;asm/hazards.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/addrspace.h&gt;</span>
<span class="cp">#include &lt;asm/smtc.h&gt;</span>
<span class="cp">#include &lt;asm/smtc_proc.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * SMTC Kernel needs to manipulate low-level CPU interrupt mask</span>
<span class="cm"> * in do_IRQ. These are passed in setup_irq_smtc() and stored</span>
<span class="cm"> * in this table.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_hwmask</span><span class="p">[</span><span class="n">NR_IRQS</span><span class="p">];</span>

<span class="cp">#define LOCK_MT_PRA() \</span>
<span class="cp">	local_irq_save(flags); \</span>
<span class="cp">	mtflags = dmt()</span>

<span class="cp">#define UNLOCK_MT_PRA() \</span>
<span class="cp">	emt(mtflags); \</span>
<span class="cp">	local_irq_restore(flags)</span>

<span class="cp">#define LOCK_CORE_PRA() \</span>
<span class="cp">	local_irq_save(flags); \</span>
<span class="cp">	mtflags = dvpe()</span>

<span class="cp">#define UNLOCK_CORE_PRA() \</span>
<span class="cp">	evpe(mtflags); \</span>
<span class="cp">	local_irq_restore(flags)</span>

<span class="cm">/*</span>
<span class="cm"> * Data structures purely associated with SMTC parallelism</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Table for tracking ASIDs whose lifetime is prolonged.</span>
<span class="cm"> */</span>

<span class="n">asiduse</span> <span class="n">smtc_live_asid</span><span class="p">[</span><span class="n">MAX_SMTC_TLBS</span><span class="p">][</span><span class="n">MAX_SMTC_ASIDS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Number of InterProcessor Interrupt (IPI) message buffers to allocate</span>
<span class="cm"> */</span>

<span class="cp">#define IPIBUF_PER_CPU 4</span>

<span class="k">struct</span> <span class="n">smtc_ipi_q</span> <span class="n">IPIQ</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">smtc_ipi_q</span> <span class="n">freeIPIq</span><span class="p">;</span>


<span class="cm">/* Forward declarations */</span>

<span class="kt">void</span> <span class="n">ipi_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">post_direct_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">setup_cross_vpe_interrupts</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nvpe</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_smtc_stats</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Global SMTC Status */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">smtc_status</span><span class="p">;</span>

<span class="cm">/* Boot command line configuration overrides */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">vpe0limit</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ipibuffers</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nostlb</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">asidmask</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smtc_asid_mask</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vpe0tcs</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpe0limit</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ipibufs</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipibuffers</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">stlb_disable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nostlb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">asidmask_set</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asidmask</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">asidmask</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x1</span>:
	<span class="k">case</span> <span class="mh">0x3</span>:
	<span class="k">case</span> <span class="mh">0x7</span>:
	<span class="k">case</span> <span class="mh">0xf</span>:
	<span class="k">case</span> <span class="mh">0x1f</span>:
	<span class="k">case</span> <span class="mh">0x3f</span>:
	<span class="k">case</span> <span class="mh">0x7f</span>:
	<span class="k">case</span> <span class="mh">0xff</span>:
		<span class="n">smtc_asid_mask</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">asidmask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ILLEGAL ASID mask 0x%x from command line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asidmask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;vpe0tcs=&quot;</span><span class="p">,</span> <span class="n">vpe0tcs</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ipibufs=&quot;</span><span class="p">,</span> <span class="n">ipibufs</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nostlb&quot;</span><span class="p">,</span> <span class="n">stlb_disable</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;asidmask=&quot;</span><span class="p">,</span> <span class="n">asidmask_set</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hang_trig</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hangtrig_enable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hang_trig</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;hangtrig&quot;</span><span class="p">,</span> <span class="n">hangtrig_enable</span><span class="p">);</span>

<span class="cp">#define DEFAULT_BLOCKED_IPI_LIMIT 32</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">timerq_limit</span> <span class="o">=</span> <span class="n">DEFAULT_BLOCKED_IPI_LIMIT</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">tintq</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timerq_limit</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;tintq=&quot;</span><span class="p">,</span> <span class="n">tintq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">imstuckcount</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>
<span class="cm">/* vpemask represents IM/IE bits of per-VPE Status registers, low-to-high */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vpemask</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">tcnoprog</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">idle_hook_initialized</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">clock_hang_reported</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMTC_IDLE_HOOK_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Configure shared TLB - VPC configuration bit must be set by caller</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smtc_configure_tlb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">tlbsiz</span><span class="p">,</span> <span class="n">vpes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mvpconf0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">config1val</span><span class="p">;</span>

	<span class="cm">/* Set up ASID preservation table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vpes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">vpes</span><span class="o">&lt;</span><span class="n">MAX_SMTC_TLBS</span><span class="p">;</span> <span class="n">vpes</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_SMTC_ASIDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smtc_live_asid</span><span class="p">[</span><span class="n">vpes</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mvpconf0</span> <span class="o">=</span> <span class="n">read_c0_mvpconf0</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vpes</span> <span class="o">=</span> <span class="p">((</span><span class="n">mvpconf0</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PVPE</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PVPE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/* If we have multiple VPEs, try to share the TLB */</span>
	    <span class="k">if</span> <span class="p">((</span><span class="n">mvpconf0</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_TLBS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nostlb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If TLB sizing is programmable, shared TLB</span>
<span class="cm">		 * size is the total available complement.</span>
<span class="cm">		 * Otherwise, we have to take the sum of all</span>
<span class="cm">		 * static VPE TLB entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tlbsiz</span> <span class="o">=</span> <span class="p">((</span><span class="n">mvpconf0</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTLBE</span><span class="p">)</span>
				<span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PTLBE_SHIFT</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		    <span class="cm">/*</span>
<span class="cm">		     * If there&#39;s more than one VPE, there had better</span>
<span class="cm">		     * be more than one TC, because we need one to bind</span>
<span class="cm">		     * to each VPE in turn to be able to read</span>
<span class="cm">		     * its configuration state!</span>
<span class="cm">		     */</span>
		    <span class="n">settc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		    <span class="cm">/* Stop the TC from doing anything foolish */</span>
		    <span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
		    <span class="n">mips_ihb</span><span class="p">();</span>
		    <span class="cm">/* No need to un-Halt - that happens later anyway */</span>
		    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vpes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		    	<span class="n">write_tc_c0_tcbind</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * To be 100% sure we&#39;re really getting the right</span>
<span class="cm">			 * information, we exit the configuration state</span>
<span class="cm">			 * and do an IHB after each rebinding.</span>
<span class="cm">			 */</span>
			<span class="n">write_c0_mvpcontrol</span><span class="p">(</span>
				<span class="n">read_c0_mvpcontrol</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span> <span class="n">MVPCONTROL_VPC</span> <span class="p">);</span>
			<span class="n">mips_ihb</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only count if the MMU Type indicated is TLB</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">read_vpe_c0_config</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">MIPS_CONF_MT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">config1val</span> <span class="o">=</span> <span class="n">read_vpe_c0_config1</span><span class="p">();</span>
				<span class="n">tlbsiz</span> <span class="o">+=</span> <span class="p">((</span><span class="n">config1val</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Put core back in configuration state */</span>
			<span class="n">write_c0_mvpcontrol</span><span class="p">(</span>
				<span class="n">read_c0_mvpcontrol</span><span class="p">()</span> <span class="o">|</span> <span class="n">MVPCONTROL_VPC</span> <span class="p">);</span>
			<span class="n">mips_ihb</span><span class="p">();</span>
		    <span class="p">}</span>
		<span class="p">}</span>
		<span class="n">write_c0_mvpcontrol</span><span class="p">(</span><span class="n">read_c0_mvpcontrol</span><span class="p">()</span> <span class="o">|</span> <span class="n">MVPCONTROL_STLB</span><span class="p">);</span>
		<span class="n">ehb</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup kernel data structures to use software total,</span>
<span class="cm">		 * rather than read the per-VPE Config1 value. The values</span>
<span class="cm">		 * for &quot;CPU 0&quot; gets copied to all the other CPUs as part</span>
<span class="cm">		 * of their initialization in smtc_cpu_setup().</span>
<span class="cm">		 */</span>

		<span class="cm">/* MIPS32 limits TLB indices to 64 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlbsiz</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
			<span class="n">tlbsiz</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">cpu_data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tlbsize</span> <span class="o">=</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">tlbsize</span> <span class="o">=</span> <span class="n">tlbsiz</span><span class="p">;</span>
		<span class="n">smtc_status</span> <span class="o">|=</span> <span class="n">SMTC_TLB_SHARED</span><span class="p">;</span>
		<span class="n">local_flush_tlb_all</span><span class="p">();</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TLB of %d entry pairs shared by %d VPEs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tlbsiz</span><span class="p">,</span> <span class="n">vpes</span><span class="p">);</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;WARNING: TLB Not Sharable on SMTC Boot!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	    <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Incrementally build the CPU map out of constituent MIPS MT cores,</span>
<span class="cm"> * using the specified available VPEs and TCs.  Plaform code needs</span>
<span class="cm"> * to ensure that each MIPS MT core invokes this routine on reset,</span>
<span class="cm"> * one at a time(!).</span>
<span class="cm"> *</span>
<span class="cm"> * This version of the build_cpu_map and prepare_cpus routines assumes</span>
<span class="cm"> * that *all* TCs of a MIPS MT core will be used for Linux, and that</span>
<span class="cm"> * they will be spread across *all* available VPEs (to minimise the</span>
<span class="cm"> * loss of efficiency due to exception service serialization).</span>
<span class="cm"> * An improved version would pick up configuration information and</span>
<span class="cm"> * possibly leave some TCs/VPEs as &quot;slave&quot; processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Use c0_MVPConf0 to find out how many TCs are available, setting up</span>
<span class="cm"> * cpu_possible_mask and the logical/physical mappings.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">smtc_build_cpu_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_cpu_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ntcs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The CPU map isn&#39;t actually used for anything at this point,</span>
<span class="cm">	 * so it&#39;s not clear what else we should do apart from set</span>
<span class="cm">	 * everything up so that &quot;logical&quot; = &quot;physical&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">ntcs</span> <span class="o">=</span> <span class="p">((</span><span class="n">read_c0_mvpconf0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PTC_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">start_cpu_slot</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NR_CPUS</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ntcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">__cpu_number_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">__cpu_logical_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_FPAFF</span>
	<span class="cm">/* Initialize map of CPUs with FPUs */</span>
	<span class="n">cpus_clear</span><span class="p">(</span><span class="n">mt_fpu_cpumask</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* One of those TC&#39;s is the one booting, and not a secondary... */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%i available secondary CPU TC(s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common setup before any secondaries are started</span>
<span class="cm"> * Make sure all CPU&#39;s are in a sensible state before we boot any of the</span>
<span class="cm"> * secondaries.</span>
<span class="cm"> *</span>
<span class="cm"> * For MIPS MT &quot;SMTC&quot; operation, we set up all TCs, spread as evenly</span>
<span class="cm"> * as possible across the available VPEs.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smtc_tc_setup</span><span class="p">(</span><span class="kt">int</span> <span class="n">vpe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">settc</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
	<span class="n">mips_ihb</span><span class="p">();</span>
	<span class="n">write_tc_c0_tcstatus</span><span class="p">((</span><span class="n">read_tc_c0_tcstatus</span><span class="p">()</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCSTATUS_TKSU</span> <span class="o">|</span> <span class="n">TCSTATUS_DA</span> <span class="o">|</span> <span class="n">TCSTATUS_IXMT</span><span class="p">))</span>
			<span class="o">|</span> <span class="n">TCSTATUS_A</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * TCContext gets an offset from the base of the IPIQ array</span>
<span class="cm">	 * to be used in low-level code to detect the presence of</span>
<span class="cm">	 * an active IPI queue</span>
<span class="cm">	 */</span>
	<span class="n">write_tc_c0_tccontext</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smtc_ipi_q</span><span class="p">)</span> <span class="o">*</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="cm">/* Bind tc to vpe */</span>
	<span class="n">write_tc_c0_tcbind</span><span class="p">(</span><span class="n">vpe</span><span class="p">);</span>
	<span class="cm">/* In general, all TCs should have the same cpu_data indications */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_mips</span><span class="p">));</span>
	<span class="cm">/* For 34Kf, start with TC/CPU 0 as sole owner of single FPU context */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cputype</span> <span class="o">==</span> <span class="n">CPU_34K</span> <span class="o">||</span>
	    <span class="n">cpu_data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cputype</span> <span class="o">==</span> <span class="n">CPU_1004K</span><span class="p">)</span>
		<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MIPS_CPU_FPU</span><span class="p">;</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">=</span> <span class="n">vpe</span><span class="p">;</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
	<span class="cm">/* Multi-core SMTC hasn&#39;t been tested, but be prepared */</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">core</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_vpe_c0_ebase</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tweak to get Count registes in as close a sync as possible.</span>
<span class="cm"> * Value seems good for 34K-class cores.</span>
<span class="cm"> */</span>

<span class="cp">#define CP0_SKEW 8</span>

<span class="kt">void</span> <span class="nf">smtc_prepare_cpus</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vpe</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">ntc</span><span class="p">,</span> <span class="n">nvpe</span><span class="p">,</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">],</span> <span class="n">slop</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nipi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">;</span>

	<span class="cm">/* disable interrupts so we can disable MT */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* disable MT so we can configure */</span>
	<span class="n">dvpe</span><span class="p">();</span>
	<span class="n">dmt</span><span class="p">();</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeIPIq</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We probably don&#39;t have as many VPEs as we do SMP &quot;CPUs&quot;,</span>
<span class="cm">	 * but it&#39;s possible - and in any case we&#39;ll never use more!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span> <span class="o">=</span> <span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* No reschedules queued initially */</span>
	<span class="p">}</span>

	<span class="cm">/* cpu_data index starts at zero */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">core</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_c0_ebase</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">cpu</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Report on boot-time options */</span>
	<span class="n">mips_mt_set_cpuoptions</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpelimit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Limit of %d VPEs set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vpelimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tclimit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Limit of %d TCs set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tclimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nostlb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Shared TLB Use Inhibited - UNSAFE for Multi-VPE Operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asidmask</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ASID mask value override to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">asidmask</span><span class="p">);</span>

	<span class="cm">/* Temporary */</span>
<span class="cp">#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hang_trig</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Logic Analyser Trigger on suspected TC hang</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMTC_IDLE_HOOK_DEBUG */</span><span class="cp"></span>

	<span class="cm">/* Put MVPE&#39;s into &#39;configuration state&#39; */</span>
	<span class="n">write_c0_mvpcontrol</span><span class="p">(</span> <span class="n">read_c0_mvpcontrol</span><span class="p">()</span> <span class="o">|</span> <span class="n">MVPCONTROL_VPC</span> <span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_mvpconf0</span><span class="p">();</span>
	<span class="n">nvpe</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PVPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PVPE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpelimit</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nvpe</span> <span class="o">&gt;</span> <span class="n">vpelimit</span><span class="p">)</span>
		<span class="n">nvpe</span> <span class="o">=</span> <span class="n">vpelimit</span><span class="p">;</span>
	<span class="n">ntc</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PTC_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntc</span> <span class="o">&gt;</span> <span class="n">NR_CPUS</span><span class="p">)</span>
		<span class="n">ntc</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tclimit</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ntc</span> <span class="o">&gt;</span> <span class="n">tclimit</span><span class="p">)</span>
		<span class="n">ntc</span> <span class="o">=</span> <span class="n">tclimit</span><span class="p">;</span>
	<span class="n">slop</span> <span class="o">=</span> <span class="n">ntc</span> <span class="o">%</span> <span class="n">nvpe</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvpe</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntc</span> <span class="o">/</span> <span class="n">nvpe</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slop</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">((</span><span class="n">slop</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Handle command line override for VPE0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpe0limit</span> <span class="o">&gt;</span> <span class="n">ntc</span><span class="p">)</span> <span class="n">vpe0limit</span> <span class="o">=</span> <span class="n">ntc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vpe0limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">slopslop</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpe0limit</span> <span class="o">&lt;</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		    <span class="cm">/* Reducing TC count - distribute to others */</span>
		    <span class="n">slop</span> <span class="o">=</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vpe0limit</span><span class="p">;</span>
		    <span class="n">slopslop</span> <span class="o">=</span> <span class="n">slop</span> <span class="o">%</span> <span class="p">(</span><span class="n">nvpe</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		    <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpe0limit</span><span class="p">;</span>
		    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvpe</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">slop</span> <span class="o">/</span> <span class="p">(</span><span class="n">nvpe</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">slopslop</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">slopslop</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))</span>
				<span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vpe0limit</span> <span class="o">&gt;</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		    <span class="cm">/* Increasing TC count - steal from others */</span>
		    <span class="n">slop</span> <span class="o">=</span> <span class="n">vpe0limit</span> <span class="o">-</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		    <span class="n">slopslop</span> <span class="o">=</span> <span class="n">slop</span> <span class="o">%</span> <span class="p">(</span><span class="n">nvpe</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		    <span class="n">tcpervpe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpe0limit</span><span class="p">;</span>
		    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvpe</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">slop</span> <span class="o">/</span> <span class="p">(</span><span class="n">nvpe</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">slopslop</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">slopslop</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))</span>
				<span class="n">tcpervpe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set up shared TLB */</span>
	<span class="n">smtc_configure_tlb</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vpe</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">(</span><span class="n">vpe</span> <span class="o">&lt;</span> <span class="n">nvpe</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span> <span class="n">ntc</span><span class="p">)</span> <span class="p">;</span> <span class="n">vpe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcpervpe</span><span class="p">[</span><span class="n">vpe</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpe</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;VPE %d: TC&quot;</span><span class="p">,</span> <span class="n">vpe</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tcpervpe</span><span class="p">[</span><span class="n">vpe</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * TC 0 is bound to VPE 0 at reset,</span>
<span class="cm">			 * and is presumably executing this</span>
<span class="cm">			 * code.  Leave it alone!</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">smtc_tc_setup</span><span class="p">(</span><span class="n">vpe</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="n">cpu</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">tc</span><span class="p">);</span>
			<span class="n">tc</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpe</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Allow this VPE to control others.</span>
<span class="cm">			 */</span>
			<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">|</span>
					      <span class="n">VPECONF0_MVP</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Clear any stale software interrupts from VPE&#39;s Cause</span>
<span class="cm">			 */</span>
			<span class="n">write_vpe_c0_cause</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Clear ERL/EXL of VPEs other than 0</span>
<span class="cm">			 * and set restricted interrupt enable/mask.</span>
<span class="cm">			 */</span>
			<span class="n">write_vpe_c0_status</span><span class="p">((</span><span class="n">read_vpe_c0_status</span><span class="p">()</span>
				<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ST0_BEV</span> <span class="o">|</span> <span class="n">ST0_ERL</span> <span class="o">|</span> <span class="n">ST0_EXL</span> <span class="o">|</span> <span class="n">ST0_IM</span><span class="p">))</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">STATUSF_IP0</span> <span class="o">|</span> <span class="n">STATUSF_IP1</span> <span class="o">|</span> <span class="n">STATUSF_IP7</span>
				<span class="o">|</span> <span class="n">ST0_IE</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * set config to be the same as vpe0,</span>
<span class="cm">			 *  particularly kseg0 coherency alg</span>
<span class="cm">			 */</span>
			<span class="n">write_vpe_c0_config</span><span class="p">(</span><span class="n">read_c0_config</span><span class="p">());</span>
			<span class="cm">/* Clear any pending timer interrupt */</span>
			<span class="n">write_vpe_c0_compare</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Propagate Config7 */</span>
			<span class="n">write_vpe_c0_config7</span><span class="p">(</span><span class="n">read_c0_config7</span><span class="p">());</span>
			<span class="n">write_vpe_c0_count</span><span class="p">(</span><span class="n">read_c0_count</span><span class="p">()</span> <span class="o">+</span> <span class="n">CP0_SKEW</span><span class="p">);</span>
			<span class="n">ehb</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* enable multi-threading within VPE */</span>
		<span class="n">write_vpe_c0_vpecontrol</span><span class="p">(</span><span class="n">read_vpe_c0_vpecontrol</span><span class="p">()</span> <span class="o">|</span> <span class="n">VPECONTROL_TE</span><span class="p">);</span>
		<span class="cm">/* enable the VPE */</span>
		<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">|</span> <span class="n">VPECONF0_VPA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pull any physically present but unused TCs out of circulation.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span> <span class="p">(((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PTC_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">tc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* release config state */</span>
	<span class="n">write_c0_mvpcontrol</span><span class="p">(</span> <span class="n">read_c0_mvpcontrol</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span> <span class="n">MVPCONTROL_VPC</span> <span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set up coprocessor affinity CPU mask(s) */</span>

<span class="cp">#ifdef CONFIG_MIPS_MT_FPAFF</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tc</span> <span class="o">&lt;</span> <span class="n">ntc</span><span class="p">;</span> <span class="n">tc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">MIPS_CPU_FPU</span><span class="p">)</span>
			<span class="n">cpu_set</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">mt_fpu_cpumask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* set up ipi interrupts... */</span>

	<span class="cm">/* If we have multiple VPEs running, set up the cross-VPE interrupt */</span>

	<span class="n">setup_cross_vpe_interrupts</span><span class="p">(</span><span class="n">nvpe</span><span class="p">);</span>

	<span class="cm">/* Set up queue of free IPI &quot;messages&quot;. */</span>
	<span class="n">nipi</span> <span class="o">=</span> <span class="n">NR_CPUS</span> <span class="o">*</span> <span class="n">IPIBUF_PER_CPU</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipibuffers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nipi</span> <span class="o">=</span> <span class="n">ipibuffers</span><span class="p">;</span>

	<span class="n">pipi</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nipi</span> <span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smtc_ipi</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;kmalloc of IPI message buffers failed&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IPI buffer pool of %d buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nipi</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nipi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smtc_ipi_nq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeIPIq</span><span class="p">,</span> <span class="n">pipi</span><span class="p">);</span>
		<span class="n">pipi</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Arm multithreading and enable other VPEs - but all TCs are Halted */</span>
	<span class="n">emt</span><span class="p">(</span><span class="n">EMT_ENABLE</span><span class="p">);</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">EVPE_ENABLE</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Initialize SMTC /proc statistics/diagnostics */</span>
	<span class="n">init_smtc_stats</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Setup the PC, SP, and GP of a secondary processor and start it</span>
<span class="cm"> * running!</span>
<span class="cm"> * smp_bootstrap is the place to resume from</span>
<span class="cm"> * __KSTK_TOS(idle) is apparently the stack pointer</span>
<span class="cm"> * (unsigned long)idle-&gt;thread_info the gp</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">smtc_boot_secondary</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="n">u32</span> <span class="n">kernelsp</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtflags</span><span class="p">;</span>

	<span class="n">LOCK_MT_PRA</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">!=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">vpe_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dvpe</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>

	<span class="cm">/* pc */</span>
	<span class="n">write_tc_c0_tcrestart</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">smp_bootstrap</span><span class="p">);</span>

	<span class="cm">/* stack pointer */</span>
	<span class="n">kernelsp</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">__KSTK_TOS</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="n">write_tc_gpr_sp</span><span class="p">(</span><span class="n">__KSTK_TOS</span><span class="p">(</span><span class="n">idle</span><span class="p">));</span>

	<span class="cm">/* global pointer */</span>
	<span class="n">write_tc_gpr_gp</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">));</span>

	<span class="n">smtc_status</span> <span class="o">|=</span> <span class="n">SMTC_MTC_ACTIVE</span><span class="p">;</span>
	<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">!=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">vpe_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">EVPE_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">UNLOCK_MT_PRA</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_init_secondary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_smp_finish</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lowest-numbered CPU per VPE starts a clock tick.</span>
<span class="cm">	 * Like per_cpu_trap_init() hack, this assumes that</span>
<span class="cm">	 * SMTC init code assigns TCs consdecutively and</span>
<span class="cm">	 * in ascending order across available VPEs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">!=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">vpe_id</span><span class="p">))</span>
		<span class="n">write_c0_compare</span><span class="p">(</span><span class="n">read_c0_count</span><span class="p">()</span> <span class="o">+</span> <span class="n">mips_hpt_frequency</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TC %d going on-line as CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">tc_id</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_cpus_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Support for SMTC-optimized driver IRQ registration</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * SMTC Kernel needs to manipulate low-level CPU interrupt mask</span>
<span class="cm"> * in do_IRQ. These are passed in setup_irq_smtc() and stored</span>
<span class="cm"> * in this table.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">setup_irq_smtc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span> <span class="n">new</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hwmask</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vpe</span> <span class="o">=</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">vpe_id</span><span class="p">;</span>

	<span class="n">vpemask</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">irq</span> <span class="o">-</span> <span class="n">MIPS_CPU_IRQ_BASE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">irq_hwmask</span><span class="p">[</span><span class="n">irq</span><span class="p">]</span> <span class="o">=</span> <span class="n">hwmask</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC_IRQAFF</span>
<span class="cm">/*</span>
<span class="cm"> * Support for IRQ affinity to TCs</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">smtc_set_irq_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">cpumask_t</span> <span class="n">affinity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If a &quot;fast path&quot; cache of quickly decodable affinity state</span>
<span class="cm">	 * is maintained, this is where it gets done, on a call up</span>
<span class="cm">	 * from the platform affinity code.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_forward_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK wise guy, now figure out how to get the IRQ</span>
<span class="cm">	 * to be serviced on an authorized &quot;CPU&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ideally, to handle the situation where an IRQ has multiple</span>
<span class="cm">	 * eligible CPUS, we would maintain state per IRQ that would</span>
<span class="cm">	 * allow a fair distribution of service requests.  Since the</span>
<span class="cm">	 * expected use model is any-or-only-one, for simplicity</span>
<span class="cm">	 * and efficiency, we just pick the easiest one to find.</span>
<span class="cm">	 */</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We depend on the platform code to have correctly processed</span>
<span class="cm">	 * IRQ affinity change requests to ensure that the IRQ affinity</span>
<span class="cm">	 * mask has been purged of bits corresponding to nonexistent and</span>
<span class="cm">	 * offline &quot;CPUs&quot;, and to TCs bound to VPEs other than the VPE</span>
<span class="cm">	 * connected to the physical interrupt input for the interrupt</span>
<span class="cm">	 * in question.  Otherwise we have a nasty problem with interrupt</span>
<span class="cm">	 * mask management.  This is best handled in non-performance-critical</span>
<span class="cm">	 * platform IRQ affinity setting code,  to minimize interrupt-time</span>
<span class="cm">	 * checks.</span>
<span class="cm">	 */</span>

	<span class="cm">/* If no one is eligible, service locally */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">NR_CPUS</span><span class="p">)</span>
		<span class="n">do_IRQ_no_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">smtc_send_ipi</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">IRQ_AFFINITY_IPI</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC_IRQAFF */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * IPI model for SMTC is tricky, because interrupts aren&#39;t TC-specific.</span>
<span class="cm"> * Within a VPE one TC can interrupt another by different approaches.</span>
<span class="cm"> * The easiest to get right would probably be to make all TCs except</span>
<span class="cm"> * the target IXMT and set a software interrupt, but an IXMT-based</span>
<span class="cm"> * scheme requires that a handler must run before a new IPI could</span>
<span class="cm"> * be sent, which would break the &quot;broadcast&quot; loops in MIPS MT.</span>
<span class="cm"> * A more gonzo approach within a VPE is to halt the TC, extract</span>
<span class="cm"> * its Restart, Status, and a couple of GPRs, and program the Restart</span>
<span class="cm"> * address to emulate an interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Within a VPE, one can be confident that the target TC isn&#39;t in</span>
<span class="cm"> * a critical EXL state when halted, since the write to the Halt</span>
<span class="cm"> * register could not have issued on the writing thread if the</span>
<span class="cm"> * halting thread had EXL set. So k0 and k1 of the target TC</span>
<span class="cm"> * can be used by the injection code.  Across VPEs, one can&#39;t</span>
<span class="cm"> * be certain that the target TC isn&#39;t in a critical exception</span>
<span class="cm"> * state. So we try a two-step process of sending a software</span>
<span class="cm"> * interrupt to the target VPE, which either handles the event</span>
<span class="cm"> * itself (if it was the target) or injects the event within</span>
<span class="cm"> * the VPE.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smtc_ipi_qdump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IPIQ[%d]: head = 0x%x, tail = 0x%x, depth = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tail</span><span class="p">,</span>
			<span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">depth</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">IPIQ</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%d %d %d: &quot;</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef	SMTC_IPI_DEBUG</span>
		    <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%u %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">);</span>
<span class="cp">#else</span>
		    <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">flink</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The standard atomic.h primitives don&#39;t quite do what we want</span>
<span class="cm"> * here: We need an atomic add-and-return-previous-value (which</span>
<span class="cm"> * could be done with atomic_add_return and a decrement) and an</span>
<span class="cm"> * atomic set/zero-and-return-previous-value (which can&#39;t really</span>
<span class="cm"> * be done with the atomic.h primitives). And since this is</span>
<span class="cm"> * MIPS MT, we can assume that we have LL/SC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atomic_postincrement</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;1:	ll	%0, %2					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	addu	%1, %0, 1				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	sc	%1, %2					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	beqz	%1, 1b					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="n">__WEAK_LLSC_MB</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_send_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tcstatus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcrestart</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">r4k_wait_irqoff</span><span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="n">__pastwait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">set_resched_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LINUX_SMP_IPI</span> <span class="o">&amp;&amp;</span>
				<span class="n">action</span> <span class="o">==</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Cannot Send IPI to self!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_resched_flag</span> <span class="o">&amp;&amp;</span> <span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* There is a reschedule queued already */</span>

	<span class="cm">/* Set up a descriptor, to be delivered either promptly or queued */</span>
	<span class="n">pipi</span> <span class="o">=</span> <span class="n">smtc_ipi_dq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeIPIq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">mips_mt_regdump</span><span class="p">(</span><span class="n">dvpe</span><span class="p">());</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;IPI Msg. Buffers Depleted&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pipi</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">pipi</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">action</span><span class="p">;</span>
	<span class="n">pipi</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">!=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">vpe_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If not on same VPE, enqueue and send cross-VPE interrupt */</span>
		<span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">|=</span> <span class="n">set_resched_flag</span><span class="p">;</span>
		<span class="n">smtc_ipi_nq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">pipi</span><span class="p">);</span>
		<span class="n">LOCK_CORE_PRA</span><span class="p">();</span>
		<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
		<span class="n">write_vpe_c0_cause</span><span class="p">(</span><span class="n">read_vpe_c0_cause</span><span class="p">()</span> <span class="o">|</span> <span class="n">C_SW1</span><span class="p">);</span>
		<span class="n">UNLOCK_CORE_PRA</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not sufficient to do a LOCK_MT_PRA (dmt) here,</span>
<span class="cm">		 * since ASID shootdown on the other VPE may</span>
<span class="cm">		 * collide with this operation.</span>
<span class="cm">		 */</span>
		<span class="n">LOCK_CORE_PRA</span><span class="p">();</span>
		<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
		<span class="cm">/* Halt the targeted TC */</span>
		<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
		<span class="n">mips_ihb</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">	 	 * Inspect TCStatus - if IXMT is set, we have to queue</span>
<span class="cm">		 * a message. Otherwise, we set up the &quot;interrupt&quot;</span>
<span class="cm">		 * of the other TC</span>
<span class="cm">	 	 */</span>
		<span class="n">tcstatus</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">tcstatus</span> <span class="o">&amp;</span> <span class="n">TCSTATUS_IXMT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;re in the the irq-off version of the wait</span>
<span class="cm">			 * loop, we need to force exit from the wait and</span>
<span class="cm">			 * do a direct post of the IPI.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_wait</span> <span class="o">==</span> <span class="n">r4k_wait_irqoff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcrestart</span> <span class="o">=</span> <span class="n">read_tc_c0_tcrestart</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcrestart</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">r4k_wait_irqoff</span>
				    <span class="o">&amp;&amp;</span> <span class="n">tcrestart</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__pastwait</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">write_tc_c0_tcrestart</span><span class="p">(</span><span class="n">__pastwait</span><span class="p">);</span>
					<span class="n">tcstatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCSTATUS_IXMT</span><span class="p">;</span>
					<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">tcstatus</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">postdirect</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Otherwise we queue the message for the target TC</span>
<span class="cm">			 * to pick up when he does a local_irq_restore()</span>
<span class="cm">			 */</span>
			<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">UNLOCK_CORE_PRA</span><span class="p">();</span>
			<span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">|=</span> <span class="n">set_resched_flag</span><span class="p">;</span>
			<span class="n">smtc_ipi_nq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">pipi</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">postdirect:</span>
			<span class="n">post_direct_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pipi</span><span class="p">);</span>
			<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">UNLOCK_CORE_PRA</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send IPI message to Halted TC, TargTC/TargVPE already having been set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">post_direct_ipi</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">kstack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcstatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcrestart</span><span class="p">;</span>
	<span class="k">extern</span> <span class="n">u32</span> <span class="n">kernelsp</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
	<span class="k">extern</span> <span class="kt">void</span> <span class="n">__smtc_ipi_vector</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>printk("%s: on %d for %d\n", <strong>func</strong>, smp<em>processor</em>id(), cpu);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Extract Status, EPC from halted TC */</span>
	<span class="n">tcstatus</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>
	<span class="n">tcrestart</span> <span class="o">=</span> <span class="n">read_tc_c0_tcrestart</span><span class="p">();</span>
	<span class="cm">/* If TCRestart indicates a WAIT instruction, advance the PC */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tcrestart</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">tcrestart</span> <span class="o">&amp;</span> <span class="mh">0xfe00003f</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x42000020</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcrestart</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Save on TC&#39;s future kernel stack</span>
<span class="cm">	 *</span>
<span class="cm">	 * CU bit of Status is indicator that TC was</span>
<span class="cm">	 * already running on a kernel stack...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcstatus</span> <span class="o">&amp;</span> <span class="n">ST0_CU0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="cm">/* Note that this &quot;- 1&quot; is pointer arithmetic */</span>
		<span class="n">kstack</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span><span class="n">read_tc_gpr_sp</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kstack</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span><span class="n">kernelsp</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kstack</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tcrestart</span><span class="p">;</span>
	<span class="cm">/* Save TCStatus */</span>
	<span class="n">kstack</span><span class="o">-&gt;</span><span class="n">cp0_tcstatus</span> <span class="o">=</span> <span class="n">tcstatus</span><span class="p">;</span>
	<span class="cm">/* Pass token of operation to be performed kernel stack pad area */</span>
	<span class="n">kstack</span><span class="o">-&gt;</span><span class="n">pad0</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pipi</span><span class="p">;</span>
	<span class="cm">/* Pass address of function to be called likewise */</span>
	<span class="n">kstack</span><span class="o">-&gt;</span><span class="n">pad0</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ipi_decode</span><span class="p">;</span>
	<span class="cm">/* Set interrupt exempt and kernel mode */</span>
	<span class="n">tcstatus</span> <span class="o">|=</span> <span class="n">TCSTATUS_IXMT</span><span class="p">;</span>
	<span class="n">tcstatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCSTATUS_TKSU</span><span class="p">;</span>
	<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">tcstatus</span><span class="p">);</span>
	<span class="n">ehb</span><span class="p">();</span>
	<span class="cm">/* Set TC Restart address to be SMTC IPI vector */</span>
	<span class="n">write_tc_c0_tcrestart</span><span class="p">(</span><span class="n">__smtc_ipi_vector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipi_resched_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scheduler_ipi</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipi_call_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Invoke generic function invocation code in smp.c */</span>
	<span class="n">smp_call_function_interrupt</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span><span class="p">,</span> <span class="n">mips_clockevent_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smtc_clock_tick_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">MIPS_CPU_IRQ_BASE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">kstat_incr_irqs_this_cpu</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">));</span>
	<span class="n">cd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mips_clockevent_device</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">cd</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipi_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg_copy</span> <span class="o">=</span> <span class="n">pipi</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type_copy</span> <span class="o">=</span> <span class="n">pipi</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">smtc_ipi_nq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeIPIq</span><span class="p">,</span> <span class="n">pipi</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type_copy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMTC_CLOCK_TICK</span>:
		<span class="n">smtc_clock_tick_interrupt</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LINUX_SMP_IPI</span>:
		<span class="k">switch</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">arg_copy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span>:
			<span class="n">ipi_resched_interrupt</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SMP_CALL_FUNCTION</span>:
			<span class="n">ipi_call_interrupt</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Impossible SMTC IPI Argument %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg_copy</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC_IRQAFF</span>
	<span class="k">case</span> <span class="n">IRQ_AFFINITY_IPI</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Accept a &quot;forwarded&quot; interrupt that was initially</span>
<span class="cm">		 * taken by a TC who doesn&#39;t have affinity for the IRQ.</span>
<span class="cm">		 */</span>
		<span class="n">do_IRQ_no_affinity</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">arg_copy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC_IRQAFF */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Impossible SMTC IPI Type 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type_copy</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to smtc_ipi_replay(), but invoked from context restore,</span>
<span class="cm"> * so it reuses the current exception frame rather than set up a</span>
<span class="cm"> * new one with self_ipi.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">deferred_smtc_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Test is not atomic, but much faster than a dequeue,</span>
<span class="cm">	 * and the vast majority of invocations will have a null queue.</span>
<span class="cm">	 * If irq_disabled when this was called, then any IPIs queued</span>
<span class="cm">	 * after we test last will be taken on the next irq_enable/restore.</span>
<span class="cm">	 * If interrupts were enabled, then any IPIs added after the</span>
<span class="cm">	 * last test will be taken directly.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smtc_ipi_q</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It may be possible we&#39;ll come in with interrupts</span>
<span class="cm">		 * already enabled.</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">pipi</span> <span class="o">=</span> <span class="n">__smtc_ipi_dq</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LINUX_SMP_IPI</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pipi</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">==</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span><span class="p">)</span>
				<span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ipi_decode</span><span class="p">(</span><span class="n">pipi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The use of the __raw_local restore isn&#39;t</span>
<span class="cm">		 * as obviously necessary here as in smtc_ipi_replay(),</span>
<span class="cm">		 * but it&#39;s more efficient, given that we&#39;re already</span>
<span class="cm">		 * running down the IPI queue.</span>
<span class="cm">		 */</span>
		<span class="n">__arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross-VPE interrupts in the SMTC prototype use &quot;software interrupts&quot;</span>
<span class="cm"> * set via cross-VPE MTTR manipulation of the Cause register. It would be</span>
<span class="cm"> * in some regards preferable to have external logic for &quot;doorbell&quot; hardware</span>
<span class="cm"> * interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cpu_ipi_irq</span> <span class="o">=</span> <span class="n">MIPS_CPU_IRQ_BASE</span> <span class="o">+</span> <span class="n">MIPS_CPU_IPI_IRQ</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ipi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_idm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">my_vpe</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">vpe_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">my_tc</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()].</span><span class="n">tc_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcstatus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mtflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vpflags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * So long as cross-VPE interrupts are done via</span>
<span class="cm">	 * MFTR/MTTR read-modify-writes of Cause, we need</span>
<span class="cm">	 * to stop other VPEs whenever the local VPE does</span>
<span class="cm">	 * anything similar.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">vpflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
	<span class="n">clear_c0_cause</span><span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">MIPS_CPU_IPI_IRQ</span><span class="p">);</span>
	<span class="n">set_c0_status</span><span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">MIPS_CPU_IPI_IRQ</span><span class="p">);</span>
	<span class="n">irq_enable_hazard</span><span class="p">();</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">vpflags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cross-VPE Interrupt handler: Try to directly deliver IPIs</span>
<span class="cm">	 * queued for TCs on this VPE other than the current one.</span>
<span class="cm">	 * Return-from-interrupt should cause us to drain the queue</span>
<span class="cm">	 * for the current TC, so we ought not to have to do it explicitly here.</span>
<span class="cm">	 */</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">!=</span> <span class="n">my_vpe</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pipi</span> <span class="o">=</span> <span class="n">smtc_ipi_dq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span> <span class="o">!=</span> <span class="n">my_tc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">LOCK_MT_PRA</span><span class="p">();</span>
				<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
				<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
				<span class="n">mips_ihb</span><span class="p">();</span>
				<span class="n">tcstatus</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">tcstatus</span> <span class="o">&amp;</span> <span class="n">TCSTATUS_IXMT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">post_direct_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pipi</span><span class="p">);</span>
					<span class="n">sent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">UNLOCK_MT_PRA</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sent</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">smtc_ipi_req</span><span class="p">(</span><span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">pipi</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * ipi_decode() should be called</span>
<span class="cm">				 * with interrupts off</span>
<span class="cm">				 */</span>
				<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LINUX_SMP_IPI</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pipi</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">==</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span><span class="p">)</span>
					<span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">resched_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ipi_decode</span><span class="p">(</span><span class="n">pipi</span><span class="p">);</span>
				<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipi_irq_dispatch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_IRQ</span><span class="p">(</span><span class="n">cpu_ipi_irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="n">irq_ipi</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handler</span>	<span class="o">=</span> <span class="n">ipi_interrupt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IRQF_PERCPU</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;SMTC_IPI&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_cross_vpe_interrupts</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nvpe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvpe</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_vint</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;SMTC Kernel requires Vectored Interrupt support&quot;</span><span class="p">);</span>

	<span class="n">set_vi_handler</span><span class="p">(</span><span class="n">MIPS_CPU_IPI_IRQ</span><span class="p">,</span> <span class="n">ipi_irq_dispatch</span><span class="p">);</span>

	<span class="n">setup_irq_smtc</span><span class="p">(</span><span class="n">cpu_ipi_irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_ipi</span><span class="p">,</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">MIPS_CPU_IPI_IRQ</span><span class="p">));</span>

	<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">cpu_ipi_irq</span><span class="p">,</span> <span class="n">handle_percpu_irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SMTC-specific hacks invoked from elsewhere in the kernel.</span>
<span class="cm"> */</span>

 <span class="cm">/*</span>
<span class="cm">  * smtc_ipi_replay is called from raw_local_irq_restore</span>
<span class="cm">  */</span>

<span class="kt">void</span> <span class="nf">smtc_ipi_replay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * To the extent that we&#39;ve ever turned interrupts off,</span>
<span class="cm">	 * we may have accumulated deferred IPIs.  This is subtle.</span>
<span class="cm">	 * we should be OK:  If we pick up something and dispatch</span>
<span class="cm">	 * it here, that&#39;s great. If we see nothing, but concurrent</span>
<span class="cm">	 * with this operation, another TC sends us an IPI, IXMT</span>
<span class="cm">	 * is clear, and we&#39;ll handle it as a real pseudo-interrupt</span>
<span class="cm">	 * and not a pseudo-pseudo interrupt.  The important thing</span>
<span class="cm">	 * is to do the last check for queued message *after* the</span>
<span class="cm">	 * re-enabling of interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smtc_ipi_q</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">IPIQ</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">smtc_ipi</span> <span class="o">*</span><span class="n">pipi</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s just possible we&#39;ll come in with interrupts</span>
<span class="cm">		 * already enabled.</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">pipi</span> <span class="o">=</span> <span class="n">__smtc_ipi_dq</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 ** But use a raw restore here to avoid recursion.</span>
<span class="cm">		 */</span>
		<span class="n">__arch_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pipi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">self_ipi</span><span class="p">(</span><span class="n">pipi</span><span class="p">);</span>
			<span class="n">smtc_cpu_stats</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">selfipis</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smtc_ipi_replay</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">smtc_idle_loop_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG</span>
	<span class="kt">int</span> <span class="n">im</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vpe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hook_ntcs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * printk within DMT-protected regions can deadlock,</span>
<span class="cm">	 * so buffer diagnostic messages for later output.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pdb_msg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">id_ho_db_msg</span><span class="p">[</span><span class="mi">768</span><span class="p">];</span> <span class="cm">/* worst-case use should be less than 700 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_hook_initialized</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* fast test */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idle_hook_initialized</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mvpconf0</span><span class="p">;</span>
			<span class="cm">/* Tedious stuff to just do once */</span>
			<span class="n">mvpconf0</span> <span class="o">=</span> <span class="n">read_c0_mvpconf0</span><span class="p">();</span>
			<span class="n">hook_ntcs</span> <span class="o">=</span> <span class="p">((</span><span class="n">mvpconf0</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PTC_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hook_ntcs</span> <span class="o">&gt;</span> <span class="n">NR_CPUS</span><span class="p">)</span>
				<span class="n">hook_ntcs</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">tc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tc</span> <span class="o">&lt;</span> <span class="n">hook_ntcs</span><span class="p">;</span> <span class="n">tc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcnoprog</span><span class="p">[</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">clock_hang_reported</span><span class="p">[</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    		<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">vpe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vpe</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">vpe</span><span class="o">++</span><span class="p">)</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">im</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">im</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">im</span><span class="o">++</span><span class="p">)</span>
					<span class="n">imstuckcount</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">im</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Idle loop test hook initialized for %d TCs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hook_ntcs</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_hook_initialized</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Someone else is initializing in parallel - let &#39;em finish */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_hook_initialized</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
				<span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Have we stupidly left IXMT set somewhere? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_c0_tcstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x400</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_c0_tcstatus</span><span class="p">(</span><span class="n">read_c0_tcstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x400</span><span class="p">);</span>
		<span class="n">ehb</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Dangling IXMT in cpu_idle()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Have we stupidly left an IM bit turned off? */</span>
<span class="cp">#define IM_LIMIT 2000</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
	<span class="n">pdb_msg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">id_ho_db_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">im</span> <span class="o">=</span> <span class="n">read_c0_status</span><span class="p">();</span>
	<span class="n">vpe</span> <span class="o">=</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">vpe_id</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In current prototype, I/O interrupts</span>
<span class="cm">		 * are masked for VPE &gt; 0</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpemask</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">bit</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">im</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)))</span>
				<span class="n">imstuckcount</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">bit</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">imstuckcount</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">imstuckcount</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">bit</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">IM_LIMIT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_c0_status</span><span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
				<span class="n">ehb</span><span class="p">();</span>
				<span class="n">imstuckcount</span><span class="p">[</span><span class="n">vpe</span><span class="p">][</span><span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">pdb_msg</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">pdb_msg</span><span class="p">,</span>
					<span class="s">&quot;Dangling IM %d fixed for VPE %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span>
					<span class="n">vpe</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">emt</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdb_msg</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">id_ho_db_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CPU%d: %s&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">id_ho_db_msg</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMTC_IDLE_HOOK_DEBUG */</span><span class="cp"></span>

	<span class="n">smtc_ipi_replay</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smtc_soft_dump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Counter Interrupts taken per CPU (TC)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">smtc_cpu_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timerints</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Self-IPI invocations:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">smtc_cpu_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">selfipis</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">smtc_ipi_qdump</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d Recoveries of </span><span class="se">\&quot;</span><span class="s">stolen</span><span class="se">\&quot;</span><span class="s"> FPU</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smtc_fpu_recoveries</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * TLB management routines special to SMTC</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">smtc_get_new_mmu_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mtflags</span><span class="p">,</span> <span class="n">tcstat</span><span class="p">,</span> <span class="n">prevhalt</span><span class="p">,</span> <span class="n">asid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tlb</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It would be nice to be able to use a spinlock here,</span>
<span class="cm">	 * but this is invoked from within TLB flush routines</span>
<span class="cm">	 * that protect themselves with DVPE, so if a lock is</span>
<span class="cm">	 * held by another TC, it&#39;ll never be freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * DVPE/DMT must not be done with interrupts enabled,</span>
<span class="cm">	 * so even so most callers will already have disabled</span>
<span class="cm">	 * them, let&#39;s be really careful...</span>
<span class="cm">	 */</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smtc_status</span> <span class="o">&amp;</span> <span class="n">SMTC_TLB_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
		<span class="n">tlb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
		<span class="n">tlb</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">asid</span> <span class="o">=</span> <span class="n">asid_cache</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">asid</span> <span class="o">+=</span> <span class="n">ASID_INC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ASID_MASK</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vtag_icache</span><span class="p">)</span>
				<span class="n">flush_icache_all</span><span class="p">();</span>
			<span class="cm">/* Traverse all online CPUs (hack requires contiguous range) */</span>
			<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We don&#39;t need to worry about our own CPU, nor those of</span>
<span class="cm">				 * CPUs who don&#39;t share our TLB.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
				    <span class="p">((</span><span class="n">smtc_status</span> <span class="o">&amp;</span> <span class="n">SMTC_TLB_SHARED</span><span class="p">)</span> <span class="o">||</span>
				     <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
					<span class="n">prevhalt</span> <span class="o">=</span> <span class="n">read_tc_c0_tchalt</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">TCHALT_H</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prevhalt</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
						<span class="n">mips_ihb</span><span class="p">();</span>
					<span class="p">}</span>
					<span class="n">tcstat</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>
					<span class="n">smtc_live_asid</span><span class="p">[</span><span class="n">tlb</span><span class="p">][(</span><span class="n">tcstat</span> <span class="o">&amp;</span> <span class="n">ASID_MASK</span><span class="p">)]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">asiduse</span><span class="p">)(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prevhalt</span><span class="p">)</span>
						<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asid</span><span class="p">)</span>		<span class="cm">/* fix version if needed */</span>
				<span class="n">asid</span> <span class="o">=</span> <span class="n">ASID_FIRST_VERSION</span><span class="p">;</span>
			<span class="n">local_flush_tlb_all</span><span class="p">();</span>	<span class="cm">/* start new asid cycle */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">smtc_live_asid</span><span class="p">[</span><span class="n">tlb</span><span class="p">][(</span><span class="n">asid</span> <span class="o">&amp;</span> <span class="n">ASID_MASK</span><span class="p">)]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SMTC shares the TLB within VPEs and possibly across all VPEs.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">smtc_status</span> <span class="o">&amp;</span> <span class="n">SMTC_TLB_SHARED</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vpe_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">vpe_id</span><span class="p">))</span>
			<span class="n">cpu_context</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mm</span><span class="p">)</span> <span class="o">=</span> <span class="n">asid_cache</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">asid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smtc_status</span> <span class="o">&amp;</span> <span class="n">SMTC_TLB_SHARED</span><span class="p">)</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">emt</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invoked from macros defined in mmu_context.h</span>
<span class="cm"> * which must already have disabled interrupts</span>
<span class="cm"> * and done a DVPE or DMT as appropriate.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">smtc_flush_tlb_asid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">asid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ehi</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">read_c0_wired</span><span class="p">();</span>

	<span class="cm">/* Traverse all non-wired entries */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">tlbsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_c0_index</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">ehb</span><span class="p">();</span>
		<span class="n">tlb_read</span><span class="p">();</span>
		<span class="n">ehb</span><span class="p">();</span>
		<span class="n">ehi</span> <span class="o">=</span> <span class="n">read_c0_entryhi</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ehi</span> <span class="o">&amp;</span> <span class="n">ASID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">asid</span><span class="p">)</span> <span class="p">{</span>
		    <span class="cm">/*</span>
<span class="cm">		     * Invalidate only entries with specified ASID,</span>
<span class="cm">		     * makiing sure all entries differ.</span>
<span class="cm">		     */</span>
		    <span class="n">write_c0_entryhi</span><span class="p">(</span><span class="n">CKSEG0</span> <span class="o">+</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
		    <span class="n">write_c0_entrylo0</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		    <span class="n">write_c0_entrylo1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		    <span class="n">mtc0_tlbw_hazard</span><span class="p">();</span>
		    <span class="n">tlb_write_indexed</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_c0_index</span><span class="p">(</span><span class="n">PARKED_INDEX</span><span class="p">);</span>
	<span class="n">tlbw_use_hazard</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Support for single-threading cache flush operations.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">halt_state_save</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * To really, really be sure that nothing is being done</span>
<span class="cm"> * by other TCs, halt them all.  This code assumes that</span>
<span class="cm"> * a DVPE has already been done, so while their Halted</span>
<span class="cm"> * state is theoretically architecturally unstable, in</span>
<span class="cm"> * practice, it&#39;s not going to change while we&#39;re looking</span>
<span class="cm"> * at it.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">smtc_cflush_lockdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
			<span class="n">halt_state_save</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_tc_c0_tchalt</span><span class="p">();</span>
			<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mips_ihb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* It would be cheating to change the cpu_online states during a flush! */</span>

<span class="kt">void</span> <span class="nf">smtc_cflush_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with a hazard barrier to ensure</span>
<span class="cm">	 * that all CACHE ops have played through.</span>
<span class="cm">	 */</span>
	<span class="n">mips_ihb</span><span class="p">();</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">settc</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">tc_id</span><span class="p">);</span>
			<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">halt_state_save</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mips_ihb</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
