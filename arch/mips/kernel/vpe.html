<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › kernel › vpe.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vpe.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2004, 2005 MIPS Technologies, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can distribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License (Version 2) as</span>
<span class="cm"> *  published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> *  for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * VPE support module</span>
<span class="cm"> *</span>
<span class="cm"> * Provides support for loading a MIPS SP program on VPE1.</span>
<span class="cm"> * The SP environment is rather simple, no tlb&#39;s.  It needs to be relocatable</span>
<span class="cm"> * (or partially linked). You should initialise your stack in the startup</span>
<span class="cm"> * code. This loader looks for the symbol __start and sets up</span>
<span class="cm"> * execution to resume from there. The MIPS SDE kit contains suitable examples.</span>
<span class="cm"> *</span>
<span class="cm"> * To load and run, simply cat a SP &#39;program file&#39; to /dev/vpe1.</span>
<span class="cm"> * i.e cat spapp &gt;/dev/vpe1.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/mipsmtregs.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/mips_mt.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/vpe.h&gt;</span>
<span class="cp">#include &lt;asm/kspd.h&gt;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vpe_handle</span><span class="p">;</span>

<span class="cp">#ifndef ARCH_SHF_SMALL</span>
<span class="cp">#define ARCH_SHF_SMALL 0</span>
<span class="cp">#endif</span>

<span class="cm">/* If this is set, the section belongs in the init part of the module */</span>
<span class="cp">#define INIT_OFFSET_MASK (1UL &lt;&lt; (BITS_PER_LONG-1))</span>

<span class="cm">/*</span>
<span class="cm"> * The number of TCs and VPEs physically available on the core</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hw_tcs</span><span class="p">,</span> <span class="n">hw_vpes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">module_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;vpe&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">major</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* fixed for now  */</span>

<span class="cp">#ifdef CONFIG_MIPS_APSP_KSPD</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kspd_notifications</span> <span class="n">kspd_events</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">kspd_events_reqd</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* grab the likely amount of memory we will need. */</span>
<span class="cp">#ifdef CONFIG_MIPS_VPE_LOADER_TOM</span>
<span class="cp">#define P_SIZE (2 * 1024 * 1024)</span>
<span class="cp">#else</span>
<span class="cm">/* add an overhead to the max kmalloc size for non-striped symbols/etc */</span>
<span class="cp">#define P_SIZE (256 * 1024)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physical_memsize</span><span class="p">;</span>

<span class="cp">#define MAX_VPES 16</span>
<span class="cp">#define VPE_PATH_MAX 256</span>

<span class="k">enum</span> <span class="n">vpe_state</span> <span class="p">{</span>
	<span class="n">VPE_STATE_UNUSED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VPE_STATE_INUSE</span><span class="p">,</span>
	<span class="n">VPE_STATE_RUNNING</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">tc_state</span> <span class="p">{</span>
	<span class="n">TC_STATE_UNUSED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TC_STATE_INUSE</span><span class="p">,</span>
	<span class="n">TC_STATE_RUNNING</span><span class="p">,</span>
	<span class="n">TC_STATE_DYNAMIC</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vpe</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">vpe_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* (device) minor associated with this vpe */</span>
	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>

	<span class="cm">/* elfloader stuff */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">load_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">plen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cwd</span><span class="p">[</span><span class="n">VPE_PATH_MAX</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__start</span><span class="p">;</span>

	<span class="cm">/* tc&#39;s associated with this vpe */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tc</span><span class="p">;</span>

	<span class="cm">/* The list of vpe&#39;s */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* shared symbol address */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">shared_ptr</span><span class="p">;</span>

	<span class="cm">/* the list of who wants to know when something major happens */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">notify</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ntcs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tc</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">tc_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">pvpe</span><span class="p">;</span>	<span class="cm">/* parent VPE */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tc</span><span class="p">;</span>	<span class="cm">/* The list of TC&#39;s with this VPE */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* The global list of tc&#39;s */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">vpe_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vpe_list</span><span class="p">;</span>	<span class="cm">/* Virtual processing elements */</span>
	<span class="n">spinlock_t</span> <span class="n">tc_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tc_list</span><span class="p">;</span>	<span class="cm">/* Thread contexts */</span>
<span class="p">}</span> <span class="n">vpecontrol</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vpe_list_lock</span>	<span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">vpe_list_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">vpe_list</span>	<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list</span><span class="p">),</span>
	<span class="p">.</span><span class="n">tc_list_lock</span>	<span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">tc_list_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">tc_list</span>	<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">release_progmem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="cm">/* get the vpe associated with this minor */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="nf">get_vpe</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_mipsmt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">==</span> <span class="n">minor</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get the vpe associated with this minor */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="nf">get_tc</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* allocate a vpe and associate it with this minor (or index) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="nf">alloc_vpe</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpe</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list_lock</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">);</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="n">minor</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* allocate a tc. At startup only tc0 is running, all other can be halted. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="nf">alloc_tc</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">tc_list_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">tc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clean up and free everything */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_vpe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">)</span>
		<span class="n">release_progmem</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">dump_mtregs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_config3</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;config3 0x%lx MT %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CONFIG3_MT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CONFIG3_MT_SHIFT</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_mvpcontrol</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MVPControl 0x%lx, STLB %ld VPC %ld EVP %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONTROL_STLB</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONTROL_STLB_SHIFT</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONTROL_VPC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONTROL_VPC_SHIFT</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONTROL_EVP</span><span class="p">));</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_mvpconf0</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;mvpconf0 0x%lx, PVPE %ld PTC %ld M %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PVPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PVPE_SHIFT</span><span class="p">,</span>
	       <span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_M</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_M_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Find some VPE program space  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_progmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MIPS_VPE_LOADER_TOM</span>
	<span class="cm">/*</span>
<span class="cm">	 * This means you must tell Linux to use less memory than you</span>
<span class="cm">	 * physically have, for example by passing a mem= boot argument.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">pfn_to_kaddr</span><span class="p">(</span><span class="n">max_low_pfn</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/* simple grab some mem for now */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_progmem</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_MIPS_VPE_LOADER_TOM</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Update size with this section: return offset. */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">get_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span> <span class="n">sechdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_addralign</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld</span>
<span class="cm">   might -- code, read-only data, read-write data, small data.  Tally</span>
<span class="cm">   sizes, and place the offsets into sh_entsize fields: high bit means it</span>
<span class="cm">   belongs in init. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">layout_sections</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elf_Ehdr</span> <span class="o">*</span> <span class="n">hdr</span><span class="p">,</span>
			    <span class="n">Elf_Shdr</span> <span class="o">*</span> <span class="n">sechdrs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">masks</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* NOTE: all executable code must be the first section</span>
<span class="cm">		 * in this array; otherwise modify the text_size</span>
<span class="cm">		 * finder in the two loops below */</span>
		<span class="p">{</span><span class="n">SHF_EXECINSTR</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">ARCH_SHF_SMALL</span><span class="p">},</span>
		<span class="p">{</span><span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">SHF_WRITE</span> <span class="o">|</span> <span class="n">ARCH_SHF_SMALL</span><span class="p">},</span>
		<span class="p">{</span><span class="n">SHF_WRITE</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="n">ARCH_SHF_SMALL</span><span class="p">},</span>
		<span class="p">{</span><span class="n">ARCH_SHF_SMALL</span> <span class="o">|</span> <span class="n">SHF_ALLOC</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_entsize</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">masks</span><span class="p">);</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>|| strncmp(secstrings + s->sh_name, ".init", 5) == 0)</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">masks</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
			    <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sh_entsize</span> <span class="o">=</span>
				<span class="n">get_offset</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_text_size</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">core_size</span><span class="p">;</span>

	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* from module-elf32.c, but subverted a little */</span>

<span class="k">struct</span> <span class="n">mips_hi16</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mips_hi16</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mips_hi16</span> <span class="o">*</span><span class="n">mips_hi16_list</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gp_offs</span><span class="p">,</span> <span class="n">gp_addr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_none</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			     <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_gprel16</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
				<span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rel</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">location</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="n">gp_addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* .sbss + gp(relative) + offset */</span>
		<span class="cm">/* kludge! */</span>
		<span class="n">rel</span> <span class="o">=</span>  <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">short</span><span class="p">)((</span><span class="kt">int</span><span class="p">)</span><span class="n">v</span> <span class="o">+</span> <span class="n">gp_offs</span> <span class="o">+</span>
				    <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">short</span><span class="p">)(</span><span class="o">*</span><span class="n">location</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">-</span> <span class="n">gp_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&gt;</span> <span class="mi">32768</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">32768</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;VPE loader: apply_r_mips_gprel16: &quot;</span>
		       <span class="s">&quot;relative address 0x%x out of range of gp register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">rel</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">location</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_pc16</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			     <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rel</span><span class="p">;</span>
	<span class="n">rel</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">v</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">location</span><span class="p">));</span>
	<span class="n">rel</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>		<span class="c1">// because the offset is in _instructions_ not bytes.</span>
	<span class="n">rel</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">// and one instruction less due to the branch delay slot.</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&gt;</span> <span class="mi">32768</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">32768</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;VPE loader: &quot;</span>
 		       <span class="s">&quot;apply_r_mips_pc16: relative address out of range 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rel</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">location</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">rel</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_32</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			   <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">location</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_26</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			   <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;VPE loader: apply_r_mips_26 &quot;</span>
		       <span class="s">&quot; unaligned relocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Not desperately convinced this is a good check of an overflow condition</span>
<span class="cm"> * anyway. But it gets in the way of handling undefined weak symbols which</span>
<span class="cm"> * we want to set to zero.</span>
<span class="cm"> * if ((v &amp; 0xf0000000) != (((unsigned long)location + 4) &amp; 0xf0000000)) {</span>
<span class="cm"> * printk(KERN_ERR</span>
<span class="cm"> * &quot;module %s: relocation overflow\n&quot;,</span>
<span class="cm"> * me-&gt;name);</span>
<span class="cm"> * return -ENOEXEC;</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>

	<span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">location</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03ffffff</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="o">*</span><span class="n">location</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x03ffffff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_hi16</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			     <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mips_hi16</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot relocate this one now because we don&#39;t know the value of</span>
<span class="cm">	 * the carry we need to add.  Save the information, and let LO16 do the</span>
<span class="cm">	 * actual relocation.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">n</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">location</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">mips_hi16_list</span><span class="p">;</span>
	<span class="n">mips_hi16_list</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_r_mips_lo16</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			     <span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insnlo</span> <span class="o">=</span> <span class="o">*</span><span class="n">location</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="n">val</span><span class="p">,</span> <span class="n">vallo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mips_hi16</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Sign extend the addend we extract from the lo insn.  */</span>
	<span class="n">vallo</span> <span class="o">=</span> <span class="p">((</span><span class="n">insnlo</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mips_hi16_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">l</span> <span class="o">=</span> <span class="n">mips_hi16_list</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The value for the HI16 had best be the same.</span>
<span class="cm">			 */</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;VPE loader: &quot;</span>
				       <span class="s">&quot;apply_r_mips_lo16/hi16: </span><span class="se">\t</span><span class="s">&quot;</span>
				       <span class="s">&quot;inconsistent value information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do the HI16 relocation.  Note that we actually don&#39;t</span>
<span class="cm">			 * need to know anything about the LO16 itself, except</span>
<span class="cm">			 * where to find the low 16 bits of the addend needed</span>
<span class="cm">			 * by the LO16.</span>
<span class="cm">			 */</span>
			<span class="n">insn</span> <span class="o">=</span> <span class="o">*</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">vallo</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Account for the sign extension that will happen in</span>
<span class="cm">			 * the low bits.</span>
<span class="cm">			 */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

			<span class="n">insn</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span><span class="p">;</span>
			<span class="o">*</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">insn</span><span class="p">;</span>

			<span class="n">next</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mips_hi16_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, we&#39;re done with the HI16 relocs.  Now deal with the LO16.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">vallo</span><span class="p">;</span>
	<span class="n">insnlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">insnlo</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">insnlo</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mips_hi16_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reloc_handlers</span><span class="p">[])</span> <span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
				<span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">R_MIPS_NONE</span><span class="p">]</span>	<span class="o">=</span> <span class="n">apply_r_mips_none</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_32</span><span class="p">]</span>	<span class="o">=</span> <span class="n">apply_r_mips_32</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_26</span><span class="p">]</span>	<span class="o">=</span> <span class="n">apply_r_mips_26</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_HI16</span><span class="p">]</span>	<span class="o">=</span> <span class="n">apply_r_mips_hi16</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_LO16</span><span class="p">]</span>	<span class="o">=</span> <span class="n">apply_r_mips_lo16</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_GPREL16</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_r_mips_gprel16</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_PC16</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_r_mips_pc16</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rstrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">R_MIPS_NONE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MIPS_NONE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_32</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MIPS_32&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_26</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MIPS_26&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_HI16</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MIPS_HI16&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_LO16</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;MIPS_LO16&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_GPREL16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;MIPS_GPREL16&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">R_MIPS_PC16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;MIPS_PC16&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_relocations</span><span class="p">(</span><span class="n">Elf32_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf32_Rel</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">Elf32_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">location</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf32_Addr</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf32_Word</span> <span class="n">r_info</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">;</span>

		<span class="cm">/* This is where to make the change */</span>
		<span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">;</span>
		<span class="cm">/* This is the symbol it is referring to */</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf32_Sym</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">ELF32_R_SYM</span><span class="p">(</span><span class="n">r_info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: undefined weak symbol %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">);</span>
			<span class="cm">/* just print the warning, dont barf */</span>
		<span class="p">}</span>

		<span class="n">v</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">reloc_handlers</span><span class="p">[</span><span class="n">ELF32_R_TYPE</span><span class="p">(</span><span class="n">r_info</span><span class="p">)](</span><span class="n">me</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">res</span> <span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">rstrs</span><span class="p">[</span><span class="n">ELF32_R_TYPE</span><span class="p">(</span><span class="n">r_info</span><span class="p">)];</span>
		    	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: .text+0x%x &quot;</span>
			       <span class="s">&quot;relocation type %s for symbol </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">,</span> <span class="n">r</span> <span class="o">?</span> <span class="n">r</span> <span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">,</span>
			       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_gp_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">secbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gp_addr</span> <span class="o">=</span> <span class="n">secbase</span> <span class="o">+</span> <span class="n">rel</span><span class="p">;</span>
	<span class="n">gp_offs</span> <span class="o">=</span> <span class="n">gp_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">secbase</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* end module-elf32.c */</span>



<span class="cm">/* Change all symbols so that sh_value encodes the pointer directly. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">simplify_symbols</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span> <span class="n">sechdrs</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsecs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">secbase</span><span class="p">,</span> <span class="n">bssbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* find the .bss section for COMMON symbols */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">secstrings</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">,</span> <span class="s">&quot;.bss&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bssbase</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SHN_COMMON</span>:
			<span class="cm">/* Allocate space for the symbol in the .bss section.</span>
<span class="cm">			   st_value is currently size.</span>
<span class="cm">			   We want it to have the address of the symbol. */</span>

			<span class="n">size</span> <span class="o">=</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
			<span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">=</span> <span class="n">bssbase</span><span class="p">;</span>

			<span class="n">bssbase</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SHN_ABS</span>:
			<span class="cm">/* Don&#39;t need to do anything */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SHN_UNDEF</span>:
			<span class="cm">/* ret = -ENOENT; */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SHN_MIPS_SCOMMON</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;simplify_symbols: ignoring SHN_MIPS_SCOMMON &quot;</span>
			       <span class="s">&quot;symbol &lt;%s&gt; st_shndx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span>
			       <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>.sbss section</p></td><td class="code"><div class="highlight"><pre>			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">secbase</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_shndx</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span> <span class="s">&quot;_gp&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">save_gp_address</span><span class="p">(</span><span class="n">secbase</span><span class="p">,</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span> <span class="o">+=</span> <span class="n">secbase</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG_ELFLOADER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_elfsymbols</span><span class="p">(</span><span class="n">Elf_Shdr</span> <span class="o">*</span> <span class="n">sechdrs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;dump_elfsymbols: n %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; i %d name &lt;%s&gt; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
		       <span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* We are prepared so configure and start the VPE... */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vpe_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">dmt_flag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe_notifications</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vpeflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/* check we are the Master VPE */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_vpeconf0</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">VPECONF0_MVP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;VPE loader: only Master VPE&#39;s are allowed to configure MT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dmt_flag</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
	<span class="n">vpeflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tc</span><span class="p">,</span> <span class="n">tc</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">evpe</span><span class="p">(</span><span class="n">vpeflags</span><span class="p">);</span>
			<span class="n">emt</span><span class="p">(</span><span class="n">dmt_flag</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;VPE loader: TC %d is already in use.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                               <span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">vpeflags</span><span class="p">);</span>
		<span class="n">emt</span><span class="p">(</span><span class="n">dmt_flag</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;VPE loader: No TC&#39;s associated with VPE %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">v</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put MVPE&#39;s into &#39;configuration state&#39; */</span>
	<span class="n">set_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="n">settc</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="cm">/* should check it is halted, and not activated */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">read_tc_c0_tcstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">TCSTATUS_A</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">read_tc_c0_tchalt</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">TCHALT_H</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">vpeflags</span><span class="p">);</span>
		<span class="n">emt</span><span class="p">(</span><span class="n">dmt_flag</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: TC %d is already active!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write the address we want it to start running from in the TCPC register. */</span>
	<span class="n">write_tc_c0_tcrestart</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span><span class="p">);</span>
	<span class="n">write_tc_c0_tccontext</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the TC as activated, not interrupt exempt and not dynamically</span>
<span class="cm">	 * allocatable</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCSTATUS_DA</span> <span class="o">|</span> <span class="n">TCSTATUS_IXMT</span><span class="p">))</span> <span class="o">|</span> <span class="n">TCSTATUS_A</span><span class="p">;</span>
	<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

	<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">read_tc_c0_tchalt</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TCHALT_H</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The sde-kit passes &#39;memsize&#39; to __start in $a3, so set something</span>
<span class="cm">	 * here...  Or set $a3 to zero and define DFLT_STACK_SIZE and</span>
<span class="cm">	 * DFLT_HEAP_SIZE when you compile your program</span>
<span class="cm">	 */</span>
	<span class="n">mttgpr</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">ntcs</span><span class="p">);</span>
	<span class="n">mttgpr</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">physical_memsize</span><span class="p">);</span>

	<span class="cm">/* set up VPE1 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * bind the TC to VPE 1 as late as possible so we only have the final</span>
<span class="cm">	 * VPE registers to set up, and so an EJTAG probe can trigger on it</span>
<span class="cm">	 */</span>
	<span class="n">write_tc_c0_tcbind</span><span class="p">((</span><span class="n">read_tc_c0_tcbind</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TCBIND_CURVPE</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">VPECONF0_VPA</span><span class="p">));</span>

	<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>

	<span class="cm">/* Set up the XTC bit in vpeconf0 to point at our tc */</span>
	<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span> <span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">VPECONF0_XTC</span><span class="p">))</span>
	                      <span class="o">|</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">VPECONF0_XTC_SHIFT</span><span class="p">));</span>

	<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>

	<span class="cm">/* enable this VPE */</span>
	<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">|</span> <span class="n">VPECONF0_VPA</span><span class="p">);</span>

	<span class="cm">/* clear out any left overs from a previous program */</span>
	<span class="n">write_vpe_c0_status</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">write_vpe_c0_cause</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* take system out of configuration state */</span>
	<span class="n">clear_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SMTC/SMVP kernels manage VPE enable independently,</span>
<span class="cm">	 * but uniprocessor kernels need to turn it on, even</span>
<span class="cm">	 * if that wasn&#39;t the pre-dvpe() state.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">vpeflags</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">EVPE_ENABLE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">emt</span><span class="p">(</span><span class="n">dmt_flag</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_vpe_symbols</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span> <span class="n">sechdrs</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Sym</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span> <span class="s">&quot;__start&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span> <span class="o">=</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_name</span><span class="p">,</span> <span class="s">&quot;vpe_shared&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sym</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">st_value</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates a VPE with some program code space(the load address), copies the</span>
<span class="cm"> * contents of the program (p)buffer performing relocatations/etc, free&#39;s it</span>
<span class="cm"> * when finished.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vpe_elfload</span><span class="p">(</span><span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">,</span> <span class="o">*</span><span class="n">strtab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">symindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">relocate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="n">mod</span><span class="p">;</span>	<span class="c1">// so we can re-use the relocations code</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span><span class="p">));</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">mod</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;VPE loader&quot;</span><span class="p">);</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">;</span>

	<span class="cm">/* Sanity checks against insmoding binaries or wrong arch,</span>
<span class="cm">	   weird elf version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_REL</span> <span class="o">&amp;&amp;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span><span class="p">)</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
	    <span class="o">||</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shentsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sechdrs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;VPE loader: program wrong arch or weird elf version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_REL</span><span class="p">)</span>
		<span class="n">relocate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf_Shdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;VPE loader: program length %u truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">len</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convenience variables */</span>
	<span class="n">sechdrs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">;</span>
	<span class="n">secstrings</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
	<span class="n">sechdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* And these should exist, but gcc whinges if we don&#39;t init them */</span>
	<span class="n">symindex</span> <span class="o">=</span> <span class="n">strindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">relocate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_NOBITS</span>
			    <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;VPE program length %u truncated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">len</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Mark all sections sh_addr with their address in the</span>
<span class="cm">			   temporary image. */</span>
			<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

			<span class="cm">/* Internal symbols and strings. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">symindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">strindex</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">;</span>
				<span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">strindex</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">layout_sections</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">,</span> <span class="n">secstrings</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">=</span> <span class="n">alloc_progmem</span><span class="p">(</span><span class="n">mod</span><span class="p">.</span><span class="n">core_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;VPE loader: loading to %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">relocate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">dest</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_entsize</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">!=</span> <span class="n">SHT_NOBITS</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">,</span>
				       <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">);</span>
			<span class="cm">/* Update sh_addr to point to copy in image. */</span>
			<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; section sh_name %s sh_addr 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">secstrings</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">);</span>
		<span class="p">}</span>

 		<span class="cm">/* Fix up syms, so that st_value is a pointer to location. */</span>
 		<span class="n">simplify_symbols</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">symindex</span><span class="p">,</span> <span class="n">strtab</span><span class="p">,</span> <span class="n">secstrings</span><span class="p">,</span>
 				 <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="p">);</span>

 		<span class="cm">/* Now do relocations. */</span>
 		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">strindex</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
 			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_info</span><span class="p">;</span>

 			<span class="cm">/* Not a valid relocation section? */</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&gt;=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">)</span>
 				<span class="k">continue</span><span class="p">;</span>

 			<span class="cm">/* Don&#39;t bother with non-allocated sections */</span>
 			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="p">].</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">))</span>
 				<span class="k">continue</span><span class="p">;</span>

 			<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_REL</span><span class="p">)</span>
 				<span class="n">err</span> <span class="o">=</span> <span class="n">apply_relocations</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">strtab</span><span class="p">,</span> <span class="n">symindex</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
 							<span class="o">&amp;</span><span class="n">mod</span><span class="p">);</span>
 			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_RELA</span><span class="p">)</span>
 				<span class="n">err</span> <span class="o">=</span> <span class="n">apply_relocate_add</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">,</span> <span class="n">strtab</span><span class="p">,</span> <span class="n">symindex</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
 							 <span class="o">&amp;</span><span class="n">mod</span><span class="p">);</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
 				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

  		<span class="p">}</span>
  	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">phdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_LOAD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span>
				       <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span> <span class="o">+</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">,</span>
				       <span class="mi">0</span><span class="p">,</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">-</span> <span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
		    <span class="p">}</span>
		    <span class="n">phdr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 			<span class="cm">/* Internal symbols and strings. */</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB</span><span class="p">)</span> <span class="p">{</span>
 				<span class="n">symindex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
 				<span class="n">strindex</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">;</span>
 				<span class="n">strtab</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">strindex</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

 				<span class="cm">/* mark the symtab&#39;s address for when we try to find the</span>
<span class="cm"> 				   magic symbols */</span>
 				<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
 			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* make sure it&#39;s physically written out */</span>
	<span class="n">flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">find_vpe_symbols</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">,</span> <span class="n">symindex</span><span class="p">,</span> <span class="n">strtab</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mod</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: program does not contain &quot;</span>
			       <span class="s">&quot;a __start symbol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: &quot;</span>
			       <span class="s">&quot;program does not contain vpe_shared symbol.</span><span class="se">\n</span><span class="s">&quot;</span>
			       <span class="s">&quot; Unable to use AMVP (AP/SP) facilities.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; elf loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mtflags</span><span class="p">,</span> <span class="n">vpflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
	<span class="n">vpflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
	<span class="cm">/* Put MVPE&#39;s into &#39;configuration state&#39; */</span>
	<span class="n">set_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="n">settc</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>

	<span class="cm">/* mark not allocated and not dynamically allocatable */</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TCSTATUS_A</span> <span class="o">|</span> <span class="n">TCSTATUS_DA</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">TCSTATUS_IXMT</span><span class="p">;</span>	<span class="cm">/* interrupt exempt */</span>
	<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
	<span class="n">mips_ihb</span><span class="p">();</span>

	<span class="cm">/* bind it to anything other than VPE1 */</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>write<em>tc</em>c0<em>tcbind(read</em>tc<em>c0</em>tcbind() &amp; ~TCBIND<em>CURVPE); // | TCBIND</em>CURVPE</p></td><td class="code"><div class="highlight"><pre>	<span class="n">clear_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">vpflags</span><span class="p">);</span>
	<span class="n">emt</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">getcwd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sys_getcwd</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* checks VPE is unused and gets ready to load program  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vpe_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">vpe_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe_notifications</span> <span class="o">*</span><span class="n">not</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">!=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* assume only 1 device at the moment. */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;VPE loader: only vpe1 is supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;VPE loader: unable to get vpe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">VPE_STATE_INUSE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VPE_STATE_UNUSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;VPE loader: tc in use dumping regs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">not</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">not</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">release_progmem</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">);</span>
		<span class="n">cleanup_tc</span><span class="p">(</span><span class="n">get_tc</span><span class="p">(</span><span class="n">tclimit</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* this of-course trashes what was there before... */</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">P_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;VPE loader: unable to allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">plen</span> <span class="o">=</span> <span class="n">P_SIZE</span><span class="p">;</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">load_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_cred</span><span class="o">-&gt;</span><span class="n">fsuid</span><span class="p">;</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_cred</span><span class="o">-&gt;</span><span class="n">fsgid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MIPS_APSP_KSPD</span>
	<span class="cm">/* get kspd to tell us when a syscall_exit happens */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kspd_events_reqd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kspd_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kspd_events</span><span class="p">);</span>
		<span class="n">kspd_events_reqd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">,</span> <span class="n">VPE_PATH_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: open, getcwd returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vpe_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vpe_elfload</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vpe_run</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: ELF load failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE loader: only elf files are supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It&#39;s good to be able to run the SP and if it chokes have a look at</span>
<span class="cm">	   the /dev/rt?. But if we reset the pointer to the shared struct we</span>
<span class="cm">	   lose what has happened. So perhaps if garbage is sent to the vpe</span>
<span class="cm">	   device, use it as a trigger for the reset. Hopefully a nice</span>
<span class="cm">	   executable will be along shortly. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span><span class="p">);</span>
	<span class="n">v</span><span class="o">-&gt;</span><span class="n">plen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vpe_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iminor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">minor</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;VPE loader: elf size too big. Perhaps strip uneeded symbols</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">-=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">pbuffer</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">vpe_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">vpe_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">vpe_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">vpe_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* module wrapper entry points */</span>
<span class="cm">/* give me a vpe */</span>
<span class="n">vpe_handle</span> <span class="nf">vpe_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="cm">/* find a vpe */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VPE_STATE_INUSE</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_alloc</span><span class="p">);</span>

<span class="cm">/* start running from here */</span>
<span class="kt">int</span> <span class="nf">vpe_start</span><span class="p">(</span><span class="n">vpe_handle</span> <span class="n">vpe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">vpe</span><span class="p">;</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">__start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vpe_run</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_start</span><span class="p">);</span>

<span class="cm">/* halt it for now */</span>
<span class="kt">int</span> <span class="nf">vpe_stop</span><span class="p">(</span><span class="n">vpe_handle</span> <span class="n">vpe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">vpe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evpe_flags</span><span class="p">;</span>

	<span class="n">evpe_flags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tc</span><span class="p">,</span> <span class="n">tc</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">settc</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VPECONF0_VPA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">evpe</span><span class="p">(</span><span class="n">evpe_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_stop</span><span class="p">);</span>

<span class="cm">/* I&#39;ve done with it thank you */</span>
<span class="kt">int</span> <span class="nf">vpe_free</span><span class="p">(</span><span class="n">vpe_handle</span> <span class="n">vpe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">vpe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">evpe_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tc</span><span class="p">,</span> <span class="n">tc</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">evpe_flags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>

	<span class="cm">/* Put MVPE&#39;s into &#39;configuration state&#39; */</span>
	<span class="n">set_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="n">settc</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">read_vpe_c0_vpeconf0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VPECONF0_VPA</span><span class="p">);</span>

	<span class="cm">/* halt the TC */</span>
	<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
	<span class="n">mips_ihb</span><span class="p">();</span>

	<span class="cm">/* mark the TC unallocated */</span>
	<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">read_tc_c0_tcstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TCSTATUS_A</span><span class="p">);</span>

	<span class="n">v</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VPE_STATE_UNUSED</span><span class="p">;</span>

	<span class="n">clear_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>
	<span class="n">evpe</span><span class="p">(</span><span class="n">evpe_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_free</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">vpe_get_shared</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">shared_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_get_shared</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vpe_getuid</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_getuid</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vpe_getgid</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_getgid</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vpe_notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vpe_notifications</span> <span class="o">*</span><span class="n">notify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_notify</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">vpe_getcwd</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vpe_getcwd</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MIPS_APSP_KSPD</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kspd_sp_exit</span><span class="p">(</span> <span class="kt">int</span> <span class="n">sp_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cleanup_tc</span><span class="p">(</span><span class="n">get_tc</span><span class="p">(</span><span class="n">sp_id</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">vpe</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vpe_notifications</span> <span class="o">*</span><span class="n">not</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">not</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpe</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">not</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">release_progmem</span><span class="p">(</span><span class="n">vpe</span><span class="o">-&gt;</span><span class="n">load_addr</span><span class="p">);</span>
	<span class="n">cleanup_tc</span><span class="p">(</span><span class="n">get_tc</span><span class="p">(</span><span class="n">tclimit</span><span class="p">));</span>
	<span class="n">vpe_stop</span><span class="p">(</span><span class="n">vpe</span><span class="p">);</span>
	<span class="n">vpe_free</span><span class="p">(</span><span class="n">vpe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_ntcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">vpe</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vpe</span><span class="o">-&gt;</span><span class="n">ntcs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_ntcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">vpe</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="n">tclimit</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">==</span> <span class="n">buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_einval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">hw_tcs</span> <span class="o">-</span> <span class="n">tclimit</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_einval</span><span class="p">;</span>

	<span class="n">vpe</span><span class="o">-&gt;</span><span class="n">ntcs</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out_einval:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">vpe_class_attributes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">kill</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_kill</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">ntcs</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">show_ntcs</span><span class="p">,</span> <span class="n">store_ntcs</span><span class="p">),</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vpe_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">class</span> <span class="n">vpe_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;vpe&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_release</span> <span class="o">=</span> <span class="n">vpe_device_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span> <span class="o">=</span> <span class="n">vpe_class_attributes</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device</span> <span class="n">vpe_device</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">vpe_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mtflags</span><span class="p">,</span> <span class="n">vpflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tc</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_mipsmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;VPE loader: not a MIPS MT capable processor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vpelimit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No VPEs reserved for AP/SP, not &quot;</span>
		       <span class="s">&quot;initializing VPE loader.</span><span class="se">\n</span><span class="s">Pass maxvpes=&lt;n&gt; argument as &quot;</span>
		       <span class="s">&quot;kernel argument</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclimit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No TCs reserved for AP/SP, not &quot;</span>
		       <span class="s">&quot;initializing VPE loader.</span><span class="se">\n</span><span class="s">Pass maxtcs=&lt;n&gt; argument as &quot;</span>
		       <span class="s">&quot;kernel argument</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">major</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpe_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;VPE loader: unable to register character device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">major</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vpe_class registration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_chrdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_device</span><span class="p">);</span>
	<span class="n">vpe_device</span><span class="p">.</span><span class="n">class</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">vpe_class</span><span class="p">,</span>
	<span class="n">vpe_device</span><span class="p">.</span><span class="n">parent</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_device</span><span class="p">,</span> <span class="s">&quot;vpe1&quot;</span><span class="p">);</span>
	<span class="n">vpe_device</span><span class="p">.</span><span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Adding vpe_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_class</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
	<span class="n">vpflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>

	<span class="cm">/* Put MVPE&#39;s into &#39;configuration state&#39; */</span>
	<span class="n">set_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="cm">/* dump_mtregs(); */</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">read_c0_mvpconf0</span><span class="p">();</span>
	<span class="n">hw_tcs</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PTC</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw_vpes</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MVPCONF0_PVPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MVPCONF0_PVPE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tclimit</span><span class="p">;</span> <span class="n">tc</span> <span class="o">&lt;</span> <span class="n">hw_tcs</span><span class="p">;</span> <span class="n">tc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Must re-enable multithreading temporarily or in case we</span>
<span class="cm">		 * reschedule send IPIs or similar we might hang.</span>
<span class="cm">		 */</span>
		<span class="n">clear_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>
		<span class="n">evpe</span><span class="p">(</span><span class="n">vpflags</span><span class="p">);</span>
		<span class="n">emt</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">alloc_tc</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">mtflags</span> <span class="o">=</span> <span class="n">dmt</span><span class="p">();</span>
		<span class="n">vpflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
		<span class="n">set_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

		<span class="cm">/* VPE&#39;s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span> <span class="n">hw_tcs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">settc</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">alloc_vpe</span><span class="p">(</span><span class="n">tc</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VPE: unable to allocate VPE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">out_reenable</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">v</span><span class="o">-&gt;</span><span class="n">ntcs</span> <span class="o">=</span> <span class="n">hw_tcs</span> <span class="o">-</span> <span class="n">tclimit</span><span class="p">;</span>

			<span class="cm">/* add the tc to the list of this vpe&#39;s tc&#39;s. */</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">tc</span><span class="p">);</span>

			<span class="cm">/* deactivate all but vpe0 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">tclimit</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">read_vpe_c0_vpeconf0</span><span class="p">();</span>

				<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VPECONF0_VPA</span><span class="p">;</span>

				<span class="cm">/* master VPE */</span>
				<span class="n">tmp</span> <span class="o">|=</span> <span class="n">VPECONF0_MVP</span><span class="p">;</span>
				<span class="n">write_vpe_c0_vpeconf0</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* disable multi-threading with TC&#39;s */</span>
			<span class="n">write_vpe_c0_vpecontrol</span><span class="p">(</span><span class="n">read_vpe_c0_vpecontrol</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VPECONTROL_TE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">vpelimit</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Set config to be the same as vpe0,</span>
<span class="cm">				 * particularly kseg0 coherency alg</span>
<span class="cm">				 */</span>
				<span class="n">write_vpe_c0_config</span><span class="p">(</span><span class="n">read_c0_config</span><span class="p">());</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* TC&#39;s */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">pvpe</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>	<span class="cm">/* set the parent vpe */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">tclimit</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="n">settc</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>

			<span class="cm">/* Any TC that is bound to VPE0 gets left as is - in case</span>
<span class="cm">			   we are running SMTC on VPE0. A TC that is bound to any</span>
<span class="cm">			   other VPE gets bound to VPE0, ideally I&#39;d like to make</span>
<span class="cm">			   it homeless but it doesn&#39;t appear to let me bind a TC</span>
<span class="cm">			   to a non-existent VPE. Which is perfectly reasonable.</span>

<span class="cm">			   The (un)bound state is visible to an EJTAG probe so may</span>
<span class="cm">			   notify GDB...</span>
<span class="cm">			*/</span>

			<span class="k">if</span> <span class="p">(((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">read_tc_c0_tcbind</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">TCBIND_CURVPE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* tc is bound &gt;vpe0 */</span>
				<span class="n">write_tc_c0_tcbind</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TCBIND_CURVPE</span><span class="p">);</span>

				<span class="n">t</span><span class="o">-&gt;</span><span class="n">pvpe</span> <span class="o">=</span> <span class="n">get_vpe</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* set the parent vpe */</span>
			<span class="p">}</span>

			<span class="cm">/* halt the TC */</span>
			<span class="n">write_tc_c0_tchalt</span><span class="p">(</span><span class="n">TCHALT_H</span><span class="p">);</span>
			<span class="n">mips_ihb</span><span class="p">();</span>

			<span class="n">tmp</span> <span class="o">=</span> <span class="n">read_tc_c0_tcstatus</span><span class="p">();</span>

			<span class="cm">/* mark not activated and not dynamically allocatable */</span>
			<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TCSTATUS_A</span> <span class="o">|</span> <span class="n">TCSTATUS_DA</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">TCSTATUS_IXMT</span><span class="p">;</span>	<span class="cm">/* interrupt exempt */</span>
			<span class="n">write_tc_c0_tcstatus</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_reenable:</span>
	<span class="cm">/* release config state */</span>
	<span class="n">clear_c0_mvpcontrol</span><span class="p">(</span><span class="n">MVPCONTROL_VPC</span><span class="p">);</span>

	<span class="n">evpe</span><span class="p">(</span><span class="n">vpflags</span><span class="p">);</span>
	<span class="n">emt</span><span class="p">(</span><span class="n">mtflags</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MIPS_APSP_KSPD</span>
	<span class="n">kspd_events</span><span class="p">.</span><span class="n">kspd_sp_exit</span> <span class="o">=</span> <span class="n">kspd_sp_exit</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_class:</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_class</span><span class="p">);</span>
<span class="nl">out_chrdev:</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">module_name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">vpe_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vpe</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpe_device</span><span class="p">);</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">module_name</span><span class="p">);</span>

	<span class="cm">/* No locking needed here */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpecontrol</span><span class="p">.</span><span class="n">vpe_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VPE_STATE_UNUSED</span><span class="p">)</span>
			<span class="n">release_vpe</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">vpe_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">vpe_module_exit</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MIPS VPE Loader&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Elizabeth Oldham, MIPS Technologies, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
