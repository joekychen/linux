<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › kernel › traps.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>traps.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1994 - 1999, 2000, 01, 06 Ralf Baechle</span>
<span class="cm"> * Copyright (C) 1995, 1996 Paul M. Antoine</span>
<span class="cm"> * Copyright (C) 1998 Ulf Carlsson</span>
<span class="cm"> * Copyright (C) 1999 Silicon Graphics, Inc.</span>
<span class="cm"> * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com</span>
<span class="cm"> * Copyright (C) 2000, 01 MIPS Technologies, Inc.</span>
<span class="cm"> * Copyright (C) 2002, 2003, 2004, 2005, 2007  Maciej W. Rozycki</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kdb.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>

<span class="cp">#include &lt;asm/bootinfo.h&gt;</span>
<span class="cp">#include &lt;asm/branch.h&gt;</span>
<span class="cp">#include &lt;asm/break.h&gt;</span>
<span class="cp">#include &lt;asm/cop2.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/dsp.h&gt;</span>
<span class="cp">#include &lt;asm/fpu.h&gt;</span>
<span class="cp">#include &lt;asm/fpu_emulator.h&gt;</span>
<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/mipsmtregs.h&gt;</span>
<span class="cp">#include &lt;asm/module.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/tlbdebug.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/watch.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/stacktrace.h&gt;</span>
<span class="cp">#include &lt;asm/uasm.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">check_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">r4k_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">rollback_handle_int</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_int</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_tlbm</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_tlbl</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_tlbs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_adel</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ades</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ibe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_dbe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_sys</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_bp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ri</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ri_rdhwr_vivt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ri_rdhwr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_ov</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_tr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_fpe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_mdmx</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_watch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_mt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_dsp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_mcheck</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">handle_reserved</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">fpu_emulator_cop1Handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">xcp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">mips_fpu_struct</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">has_fpu</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">__user</span> <span class="o">*</span><span class="n">fault_addr</span><span class="p">);</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">board_be_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">board_be_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_fixup</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">board_nmi_handler_setup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">board_ejtag_handler_setup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">board_bind_eic_interrupt</span><span class="p">)(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regset</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">board_ebase_setup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__cpuinitdata</span><span class="p">(</span><span class="o">*</span><span class="n">board_cache_error_setup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_raw_backtrace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg29</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">reg29</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Call Trace:&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kstack_end</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (Bad stack address)&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__kernel_text_address</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KALLSYMS</span>
<span class="kt">int</span> <span class="n">raw_show_trace</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_raw_show_trace</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_show_trace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;raw_show_trace&quot;</span><span class="p">,</span> <span class="n">set_raw_show_trace</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_backtrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raw_show_trace</span> <span class="o">||</span> <span class="o">!</span><span class="n">__kernel_text_address</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">show_raw_backtrace</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Call Trace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
		<span class="n">pc</span> <span class="o">=</span> <span class="n">unwind_stack</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ra</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine abuses get_user()/put_user() to reference pointers</span>
<span class="cm"> * with at least a bit of error checking ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_stacktrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">stackdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Stack :&quot;</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="mi">64</span> <span class="o">/</span> <span class="n">field</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">       &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">39</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ...&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">stackdata</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (Bad stack address)&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %0*lx&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">stackdata</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">show_backtrace</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span>
		<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">regs</span><span class="p">.</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">reg29</span><span class="p">;</span>
			<span class="n">regs</span><span class="p">.</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">regs</span><span class="p">.</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">reg31</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kgdb_active</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
			   <span class="n">kdb_current_regs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="n">kdb_current_regs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KGDB_KDB */</span><span class="cp"></span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">prepare_frametrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">show_stacktrace</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The architecture-independent dump_stack generator</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dump_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">prepare_frametrace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">show_backtrace</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_stack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_code</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pc16</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Code:&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pc16</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pc16</span> <span class="o">?</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">pc16</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (Bad address in epc)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%c%0*x%c&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">?</span><span class="sc">&#39; &#39;</span><span class="o">:</span><span class="sc">&#39;&lt;&#39;</span><span class="p">),</span> <span class="n">pc16</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">?</span><span class="sc">&#39; &#39;</span><span class="o">:</span><span class="sc">&#39;&gt;&#39;</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__show_regs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cause</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_cause</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved main processor registers</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;$%2d   :&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %0*lx&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">26</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">27</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %*s&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %0*lx&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CPU_HAS_SMARTMIPS</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Acx    : %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">acx</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Hi    : %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">hi</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Lo    : %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">lo</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved cp0 registers</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;epc   : %0*lx %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;    %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">print_tainted</span><span class="p">());</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ra    : %0*lx %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">],</span>
	       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Status: %08x    &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_cpu_data</span><span class="p">.</span><span class="n">isa_level</span> <span class="o">==</span> <span class="n">MIPS_CPU_ISA_I</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_KUO</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;KUo &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_IEO</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IEo &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_KUP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;KUp &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_IEP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IEp &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_KUC</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;KUc &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_IEC</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IEc &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_KX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;KX &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_SX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SX &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_UX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;UX &quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_KSU</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">KSU_USER</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;USER &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KSU_SUPERVISOR</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SUPERVISOR &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">KSU_KERNEL</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;KERNEL &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BAD_MODE &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_ERL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ERL &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_EXL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;EXL &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_IE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IE &quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Cause : %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cause</span><span class="p">);</span>

	<span class="n">cause</span> <span class="o">=</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">CAUSEF_EXCCODE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CAUSEB_EXCCODE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">cause</span> <span class="o">&amp;&amp;</span> <span class="n">cause</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BadVA : %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_badvaddr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;PrId  : %08x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">read_c0_prid</span><span class="p">(),</span>
	       <span class="n">cpu_name_string</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: really the generic show_regs should take a const pointer argument.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">show_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__show_regs</span><span class="p">((</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="n">__show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">print_modules</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Process %s (pid: %d, threadinfo=%p, task=%p, tls=%0*lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current_thread_info</span><span class="p">(),</span> <span class="n">current</span><span class="p">,</span>
	      <span class="n">field</span><span class="p">,</span> <span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">tp_value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_userlocal</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tls</span><span class="p">;</span>

		<span class="n">tls</span> <span class="o">=</span> <span class="n">read_c0_userlocal</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tls</span> <span class="o">!=</span> <span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">tp_value</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;*HwTLS: %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">tls</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">show_stacktrace</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">show_code</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">regs_to_trapnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_cause</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">die_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__noreturn</span> <span class="nf">die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">die_counter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dvpret</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

	<span class="n">oops_enter</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_OOPS</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">console_verbose</span><span class="p">();</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">die_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="n">dvpret</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>
	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="n">mips_mt_regdump</span><span class="p">(</span><span class="n">dvpret</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s[#%d]:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="o">++</span><span class="n">die_counter</span><span class="p">);</span>
	<span class="n">show_registers</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_DIE</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">die_lock</span><span class="p">);</span>

	<span class="n">oops_exit</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Fatal exception in interrupt&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">panic_on_oops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Fatal exception: panic in 5 seconds&quot;</span><span class="p">);</span>
		<span class="n">ssleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Fatal exception&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">do_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="n">__start___dbe_table</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="n">__stop___dbe_table</span><span class="p">[];</span>

<span class="n">__asm__</span><span class="p">(</span>
<span class="s">&quot;	.section	__dbe_table, </span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;\n</span><span class="s">&quot;</span>
<span class="s">&quot;	.previous			</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Given an address, look for it in the exception tables. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="nf">search_dbe_tables</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">search_extable</span><span class="p">(</span><span class="n">__start___dbe_table</span><span class="p">,</span> <span class="n">__stop___dbe_table</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">search_module_dbetables</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_be</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">exception_table_entry</span> <span class="o">*</span><span class="n">fixup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_cause</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">MIPS_BE_FATAL</span><span class="p">;</span>

	<span class="cm">/* XXX For now.  Fixme, this searches the wrong table ...  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="n">fixup</span> <span class="o">=</span> <span class="n">search_dbe_tables</span><span class="p">(</span><span class="n">exception_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fixup</span><span class="p">)</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">MIPS_BE_FIXUP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">board_be_handler</span><span class="p">)</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">board_be_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">fixup</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MIPS_BE_DISCARD</span>:
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MIPS_BE_FIXUP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">fixup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">nextinsn</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume it would be too dangerous to continue ...</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s bus error, epc == %0*lx, ra == %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">data</span> <span class="o">?</span> <span class="s">&quot;Data&quot;</span> <span class="o">:</span> <span class="s">&quot;Instruction&quot;</span><span class="p">,</span>
	       <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_OOPS</span><span class="p">,</span> <span class="s">&quot;bus error&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGBUS</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ll/sc, rdhwr, sync emulation</span>
<span class="cm"> */</span>

<span class="cp">#define OPCODE 0xfc000000</span>
<span class="cp">#define BASE   0x03e00000</span>
<span class="cp">#define RT     0x001f0000</span>
<span class="cp">#define OFFSET 0x0000ffff</span>
<span class="cp">#define LL     0xc0000000</span>
<span class="cp">#define SC     0xe0000000</span>
<span class="cp">#define SPEC0  0x00000000</span>
<span class="cp">#define SPEC3  0x7c000000</span>
<span class="cp">#define RD     0x0000f800</span>
<span class="cp">#define FUNC   0x0000003f</span>
<span class="cp">#define SYNC   0x0000000f</span>
<span class="cp">#define RDHWR  0x0000003b</span>

<span class="cm">/*</span>
<span class="cm"> * The ll_bit is cleared by r*_switch.S</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ll_bit</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ll_task</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">simulate_ll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="n">__user</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * analyse the ll instruction that just caused a ri exception</span>
<span class="cm">	 * and put the referenced address to addr.</span>
<span class="cm">	 */</span>

	<span class="cm">/* sign extend offset */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OFFSET</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
	        <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SIGBUS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SIGSEGV</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ll_task</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ll_task</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ll_bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ll_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">RT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">simulate_sc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * analyse the sc instruction that just caused a ri exception</span>
<span class="cm">	 * and put the referenced address to addr.</span>
<span class="cm">	 */</span>

	<span class="cm">/* sign extend offset */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OFFSET</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
	        <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">RT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SIGBUS</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ll_bit</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ll_task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">reg</span><span class="p">],</span> <span class="n">vaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SIGSEGV</span><span class="p">;</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ll uses the opcode of lwc0 and sc uses the opcode of swc0.  That is both</span>
<span class="cm"> * opcodes are supposed to result in coprocessor unusable exceptions if</span>
<span class="cm"> * executed on ll/sc-less processors.  That&#39;s the theory.  In practice a</span>
<span class="cm"> * few processors such as NEC&#39;s VR4100 throw reserved instruction exceptions</span>
<span class="cm"> * instead, so we&#39;re doing the emulation thing in both exception handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">simulate_llsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OPCODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">LL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_EMULATION_FAULTS</span><span class="p">,</span>
				<span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">simulate_ll</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OPCODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">SC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_EMULATION_FAULTS</span><span class="p">,</span>
				<span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">simulate_sc</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Must be something else ... */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Simulate trapping &#39;rdhwr&#39; instructions to provide user accessible</span>
<span class="cm"> * registers not implemented in hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">simulate_rdhwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OPCODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPEC3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">FUNC</span><span class="p">)</span> <span class="o">==</span> <span class="n">RDHWR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rd</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">RD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">RT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_EMULATION_FAULTS</span><span class="p">,</span>
				<span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* CPU number */</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* SYNCI length */</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">current_cpu_data</span><span class="p">.</span><span class="n">dcache</span><span class="p">.</span><span class="n">linesz</span><span class="p">,</span>
					     <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">icache</span><span class="p">.</span><span class="n">linesz</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* Read count register */</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_c0_count</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:		<span class="cm">/* Count register resolution */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_data</span><span class="p">.</span><span class="n">cputype</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">CPU_20KC</span>:
			<span class="k">case</span> <span class="n">CPU_25KF</span>:
				<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">29</span>:
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">tp_value</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Not ours.  */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">simulate_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OPCODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPEC0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">FUNC</span><span class="p">)</span> <span class="o">==</span> <span class="n">SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_EMULATION_FAULTS</span><span class="p">,</span>
				<span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Must be something else ... */</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_ov</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Integer overflow&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_INTOVF</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGFPE</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_fpemu_return</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fault_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span> <span class="o">||</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGBUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
		<span class="n">si</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="n">fault_addr</span><span class="p">;</span>
		<span class="n">si</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fault_addr</span><span class="p">))</span>
				<span class="n">si</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_ACCERR</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">si</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SEGV_MAPERR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">si</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">BUS_ADRERR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX Delayed fp exceptions when doing a lazy ctx switch XXX</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_fpe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fcr31</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_FP</span><span class="p">,</span> <span class="s">&quot;FP exception&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGFPE</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;FP exception in kernel code&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_UNI_X</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sig</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fault_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unimplemented operation exception.  If we&#39;ve got the full</span>
<span class="cm">		 * software emulator on-board, let&#39;s use it...</span>
<span class="cm">		 *</span>
<span class="cm">		 * Force FPU to dump state into task/thread context.  We&#39;re</span>
<span class="cm">		 * moving a lot of data here for what is probably a single</span>
<span class="cm">		 * instruction, but the alternative is to pre-decode the FP</span>
<span class="cm">		 * register operands before invoking the emulator, which seems</span>
<span class="cm">		 * a bit extreme for what should be an infrequent event.</span>
<span class="cm">		 */</span>
		<span class="cm">/* Ensure &#39;resume&#39; not overwrite saved fp context again. */</span>
		<span class="n">lose_fpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Run the emulator */</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">fpu_emulator_cop1Handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">fault_addr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t allow the emulated instruction to leave any of</span>
<span class="cm">		 * the cause bit set in $fcr31.</span>
<span class="cm">		 */</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">.</span><span class="n">fcr31</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FPU_CSR_ALL_X</span><span class="p">;</span>

		<span class="cm">/* Restore the hardware register state */</span>
		<span class="n">own_fpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Using the FPU again.  */</span>

		<span class="cm">/* If something went wrong, signal */</span>
		<span class="n">process_fpemu_return</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">fault_addr</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_INV_X</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTINV</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_DIV_X</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTDIV</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_OVF_X</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTOVF</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_UDF_X</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTUND</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcr31</span> <span class="o">&amp;</span> <span class="n">FPU_CSR_INE_X</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTRES</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">__SI_FAULT</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGFPE</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_trap_or_bp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_ll_trap</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KGDB_LOW_LEVEL_TRAP */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A short test says that IRIX 5.3 sends SIGTRAP for all trap</span>
<span class="cm">	 * insns, even for trap and break codes that indicate arithmetic</span>
<span class="cm">	 * failures.  Weird ...</span>
<span class="cm">	 * But should we continue the brokenness???  --macro</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BRK_OVERFLOW</span>:
	<span class="k">case</span> <span class="n">BRK_DIVZERO</span>:
		<span class="n">scnprintf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s">&quot;%s instruction in kernel code&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
		<span class="n">die_if_kernel</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="n">BRK_DIVZERO</span><span class="p">)</span>
			<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_INTDIV</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_INTOVF</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGFPE</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRK_BUG</span>:
		<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Kernel bug detected&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRK_MEMU</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Address errors may be deliberately induced by the FPU</span>
<span class="cm">		 * emulator to retake control of the CPU after executing the</span>
<span class="cm">		 * instruction in the delay slot of an emulated branch.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Terminate if exception was recognized as a delay slot return</span>
<span class="cm">		 * otherwise handle as normal.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_dsemulret</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Math emu break/trap&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">scnprintf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s">&quot;%s instruction in kernel code&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
		<span class="n">die_if_kernel</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_bp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">bcode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">exception_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_sigsegv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is the ancient bug in the MIPS assemblers that the break</span>
<span class="cm">	 * code starts left to bit 16 instead to bit 6 in the opcode.</span>
<span class="cm">	 * Gas is bug-compatible, but not always, grrr...</span>
<span class="cm">	 * We handle both cases with a simple heuristics.  --macro</span>
<span class="cm">	 */</span>
	<span class="n">bcode</span> <span class="o">=</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcode</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span>
		<span class="n">bcode</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * notify the kprobe handlers, if instruction is likely to</span>
<span class="cm">	 * pertain to them.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BRK_KPROBE_BP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_BREAK</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">bcode</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BRK_KPROBE_SSTEPBP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_SSTEPBP</span><span class="p">,</span> <span class="s">&quot;single_step&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">bcode</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_trap_or_bp</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">bcode</span><span class="p">,</span> <span class="s">&quot;Break&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_sigsegv:</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_tr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">tcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">exception_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_sigsegv</span><span class="p">;</span>

	<span class="cm">/* Immediate versions don&#39;t provide a code.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">OPCODE</span><span class="p">))</span>
		<span class="n">tcode</span> <span class="o">=</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">do_trap_or_bp</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">tcode</span><span class="p">,</span> <span class="s">&quot;Trap&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_sigsegv:</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_ri</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">epc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">exception_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_epc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_RI</span><span class="p">,</span> <span class="s">&quot;RI Fault&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs_to_trapnr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">SIGILL</span><span class="p">)</span>
	    <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Reserved instruction in kernel code&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">compute_return_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">epc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_llsc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">simulate_llsc</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">simulate_rdhwr</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">simulate_sync</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">SIGILL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">old_epc</span><span class="p">;</span>		<span class="cm">/* Undo skip-over.  */</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * MIPS MT processors may have fewer FPU contexts than CPU threads. If we&#39;ve</span>
<span class="cm"> * emulated more than some threshold number of instructions, force migration to</span>
<span class="cm"> * a &quot;CPU&quot; that has FP support.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mt_ase_fp_affinity</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_FPAFF</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mt_fpemul_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	     <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">emulated_fp</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">mt_fpemul_threshold</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there&#39;s no FPU present, or if the application has already</span>
<span class="cm">		 * restricted the allowed set to exclude any CPUs with FPUs,</span>
<span class="cm">		 * we&#39;ll skip the procedure.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpus_intersects</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">mt_fpu_cpumask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpumask_t</span> <span class="n">tmask</span><span class="p">;</span>

			<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">user_cpus_allowed</span>
				<span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">;</span>
			<span class="n">cpus_and</span><span class="p">(</span><span class="n">tmask</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span>
				<span class="n">mt_fpu_cpumask</span><span class="p">);</span>
			<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmask</span><span class="p">);</span>
			<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_FPUBOUND</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_FPAFF */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * No lock; only written during early bootup by CPU 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">RAW_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">cu2_chain</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ref</span> <span class="nf">register_cu2_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cu2_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cu2_notifier_call_chain</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cu2_chain</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">default_cu2_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;Unhandled kernel unaligned access or invalid &quot;</span>
			      <span class="s">&quot;instruction&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="cm">/* Fall through  */</span>

	<span class="k">case</span> <span class="n">CU2_EXCEPTION</span>:
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">epc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_epc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__maybe_unused</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;do_cpu invoked from kernel context!&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">cpid</span> <span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_cause</span> <span class="o">&gt;&gt;</span> <span class="n">CAUSEB_CE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cpid</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">epc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">exception_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">old_epc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
		<span class="n">opcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">compute_return_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">epc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SIGSEGV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_llsc</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">simulate_llsc</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">simulate_rdhwr</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">SIGILL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">old_epc</span><span class="p">;</span>	<span class="cm">/* Undo skip-over.  */</span>
			<span class="n">force_sig</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">used_math</span><span class="p">())</span>	<span class="cm">/* Using the FPU again.  */</span>
			<span class="n">own_fpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>			<span class="cm">/* First time FPU user.  */</span>
			<span class="n">init_fpu</span><span class="p">();</span>
			<span class="n">set_used_math</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_cpu_has_fpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sig</span><span class="p">;</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fault_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">sig</span> <span class="o">=</span> <span class="n">fpu_emulator_cop1Handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">,</span>
						       <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fault_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">process_fpemu_return</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">fault_addr</span><span class="p">))</span>
				<span class="n">mt_ase_fp_affinity</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cu2_chain</span><span class="p">,</span> <span class="n">CU2_EXCEPTION</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_mdmx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_watch</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cause</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear WP (bit 22) bit of cause register so we don&#39;t loop</span>
<span class="cm">	 * forever.</span>
<span class="cm">	 */</span>
	<span class="n">cause</span> <span class="o">=</span> <span class="n">read_c0_cause</span><span class="p">();</span>
	<span class="n">cause</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">write_c0_cause</span><span class="p">(</span><span class="n">cause</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current thread has the watch registers loaded, save</span>
<span class="cm">	 * their values and send SIGTRAP.  Otherwise another thread</span>
<span class="cm">	 * left the registers set, clear them and continue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">TIF_LOAD_WATCH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mips_read_watch_registers</span><span class="p">();</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mips_clear_watch_registers</span><span class="p">();</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_mcheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">multi_match</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_status</span> <span class="o">&amp;</span> <span class="n">ST0_TS</span><span class="p">;</span>

	<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">multi_match</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Index   : %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">read_c0_index</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Pagemask: %0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">read_c0_pagemask</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;EntryHi : %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_entryhi</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;EntryLo0: %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_entrylo0</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;EntryLo1: %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_entrylo1</span><span class="p">());</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_tlb_all</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">show_code</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some chips may have other causes of machine check (e.g. SB1</span>
<span class="cm">	 * graduation timer)</span>
<span class="cm">	 */</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Caught Machine Check exception - %scaused by multiple &quot;</span>
	      <span class="s">&quot;matching entries in the TLB.&quot;</span><span class="p">,</span>
	      <span class="p">(</span><span class="n">multi_match</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_mt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subcode</span><span class="p">;</span>

	<span class="n">subcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_vpe_c0_vpecontrol</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">VPECONTROL_EXCPT</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">VPECONTROL_EXCPT_SHIFT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">subcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Thread Underflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Thread Overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Invalid YIELD Qualifier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Gating Storage Exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;YIELD Scheduler Exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Gating Storage Scheduler Exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;*** UNKNOWN THREAD EXCEPTION %d ***</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">subcode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">die_if_kernel</span><span class="p">(</span><span class="s">&quot;MIPS MT Thread exception in kernel&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_dsp</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Unexpected DSP exception&quot;</span><span class="p">);</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_reserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Game over - no way to handle this if it ever occurs.  Most probably</span>
<span class="cm">	 * caused by a new unknown cpu type or after another deadly</span>
<span class="cm">	 * hard/software error.</span>
<span class="cm">	 */</span>
	<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Caught reserved exception %ld - should not happen.&quot;</span><span class="p">,</span>
	      <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_cause</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">l1parity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nol1parity</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">l1parity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nol1par&quot;</span><span class="p">,</span> <span class="n">nol1parity</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">l2parity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nol2parity</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">l2parity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nol2par&quot;</span><span class="p">,</span> <span class="n">nol2parity</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some MIPS CPUs can enable/disable for cache parity detection, but do</span>
<span class="cm"> * it different ways.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parity_protection_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_24K</span>:
	<span class="k">case</span> <span class="n">CPU_34K</span>:
	<span class="k">case</span> <span class="n">CPU_74K</span>:
	<span class="k">case</span> <span class="n">CPU_1004K</span>:
		<span class="p">{</span>
<span class="cp">#define ERRCTL_PE	0x80000000</span>
<span class="cp">#define ERRCTL_L2P	0x00800000</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">errctl</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l1parity_present</span><span class="p">,</span> <span class="n">l2parity_present</span><span class="p">;</span>

			<span class="n">errctl</span> <span class="o">=</span> <span class="n">read_c0_ecc</span><span class="p">();</span>
			<span class="n">errctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ERRCTL_PE</span><span class="o">|</span><span class="n">ERRCTL_L2P</span><span class="p">);</span>

			<span class="cm">/* probe L1 parity support */</span>
			<span class="n">write_c0_ecc</span><span class="p">(</span><span class="n">errctl</span> <span class="o">|</span> <span class="n">ERRCTL_PE</span><span class="p">);</span>
			<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>
			<span class="n">l1parity_present</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_c0_ecc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">ERRCTL_PE</span><span class="p">);</span>

			<span class="cm">/* probe L2 parity support */</span>
			<span class="n">write_c0_ecc</span><span class="p">(</span><span class="n">errctl</span><span class="o">|</span><span class="n">ERRCTL_L2P</span><span class="p">);</span>
			<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>
			<span class="n">l2parity_present</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_c0_ecc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">ERRCTL_L2P</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">l1parity_present</span> <span class="o">&amp;&amp;</span> <span class="n">l2parity_present</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l1parity</span><span class="p">)</span>
					<span class="n">errctl</span> <span class="o">|=</span> <span class="n">ERRCTL_PE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l1parity</span> <span class="o">^</span> <span class="n">l2parity</span><span class="p">)</span>
					<span class="n">errctl</span> <span class="o">|=</span> <span class="n">ERRCTL_L2P</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l1parity_present</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l1parity</span><span class="p">)</span>
					<span class="n">errctl</span> <span class="o">|=</span> <span class="n">ERRCTL_PE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l2parity_present</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l2parity</span><span class="p">)</span>
					<span class="n">errctl</span> <span class="o">|=</span> <span class="n">ERRCTL_L2P</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* No parity available */</span>
			<span class="p">}</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Writing ErrCtl register=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errctl</span><span class="p">);</span>

			<span class="n">write_c0_ecc</span><span class="p">(</span><span class="n">errctl</span><span class="p">);</span>
			<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>
			<span class="n">errctl</span> <span class="o">=</span> <span class="n">read_c0_ecc</span><span class="p">();</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Readback ErrCtl register=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errctl</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">l1parity_present</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Cache parity protection %sabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">errctl</span> <span class="o">&amp;</span> <span class="n">ERRCTL_PE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">l2parity_present</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l1parity_present</span> <span class="o">&amp;&amp;</span> <span class="n">l1parity</span><span class="p">)</span>
					<span class="n">errctl</span> <span class="o">^=</span> <span class="n">ERRCTL_L2P</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;L2 cache parity protection %sabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">errctl</span> <span class="o">&amp;</span> <span class="n">ERRCTL_L2P</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_5KC</span>:
		<span class="n">write_c0_ecc</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">);</span>
		<span class="n">back_to_back_c0_hazard</span><span class="p">();</span>
		<span class="cm">/* Set the PE bit (bit 31) in the c0_errctl register. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Cache parity protection %sabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">read_c0_ecc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;en&quot;</span> <span class="o">:</span> <span class="s">&quot;dis&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_20KC</span>:
	<span class="k">case</span> <span class="n">CPU_25KF</span>:
		<span class="cm">/* Clear the DE bit (bit 16) in the c0_status register. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Enable cache parity protection for &quot;</span>
		       <span class="s">&quot;MIPS 20KC/25KF CPUs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">clear_c0_status</span><span class="p">(</span><span class="n">ST0_DE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">cache_parity_error</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_val</span><span class="p">;</span>

	<span class="cm">/* For the moment, report the problem and hang. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Cache error exception:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;cp0_errorepc == %0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_errorepc</span><span class="p">());</span>
	<span class="n">reg_val</span> <span class="o">=</span> <span class="n">read_c0_cacheerr</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;c0_cacheerr == %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Decoded c0_cacheerr: %s cache fault in %s reference.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;secondary&quot;</span> <span class="o">:</span> <span class="s">&quot;primary&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">31</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;data&quot;</span> <span class="o">:</span> <span class="s">&quot;insn&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error bits: %s%s%s%s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">29</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ED &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ET &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;EE &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;EB &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;EI &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;E1 &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;E0 &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IDX: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

<span class="cp">#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">22</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DErrAddr0: 0x%0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_derraddr0</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DErrAddr1: 0x%0*lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">read_c0_derraddr1</span><span class="p">());</span>
<span class="cp">#endif</span>

	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t handle the cache error!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SDBBP EJTAG debug exception handler.</span>
<span class="cm"> * We skip the instruction and return to the next instruction.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ejtag_exception_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">field</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">depc</span><span class="p">,</span> <span class="n">old_epc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;SDBBP EJTAG debug exception - not handled yet, just ignored!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">depc</span> <span class="o">=</span> <span class="n">read_c0_depc</span><span class="p">();</span>
	<span class="n">debug</span> <span class="o">=</span> <span class="n">read_c0_debug</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;c0_depc = %0*lx, DEBUG = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">depc</span><span class="p">,</span> <span class="n">debug</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In branch delay slot.</span>
<span class="cm">		 * We cheat a little bit here and use EPC to calculate the</span>
<span class="cm">		 * debug return address (DEPC). EPC is restored after the</span>
<span class="cm">		 * calculation.</span>
<span class="cm">		 */</span>
		<span class="n">old_epc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">depc</span><span class="p">;</span>
		<span class="n">__compute_return_epc</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">depc</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cp0_epc</span> <span class="o">=</span> <span class="n">old_epc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">depc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">write_c0_depc</span><span class="p">(</span><span class="n">depc</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_DEBUG &quot;\n\n----- Enable EJTAG single stepping ----\n\n&quot;);</span>
<span class="c">	write_c0_debug(debug | 0x100);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NMI exception handler.</span>
<span class="cm"> * No lock; only written during early bootup by CPU 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">RAW_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">nmi_chain</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">register_nmi_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmi_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__noreturn</span> <span class="nf">nmi_exception_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmi_chain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;NMI taken!!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">die</span><span class="p">(</span><span class="s">&quot;NMI&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define VECTORSPACING 0x100	</span><span class="cm">/* for EI/VI mode */</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ebase</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exception_handlers</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vi_handlers</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="o">*</span><span class="nf">set_except_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_handler</span> <span class="o">=</span> <span class="n">exception_handlers</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

	<span class="n">exception_handlers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has_divec</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jump_mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k0</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">handler</span> <span class="o">&amp;</span> <span class="n">jump_mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">jump_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">handler</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">jump_mask</span><span class="p">);</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">UASM_i_LA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">k0</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
			<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">local_flush_icache_range</span><span class="p">(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">old_handler</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">do_default_vi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">show_regs</span><span class="p">(</span><span class="n">get_irq_regs</span><span class="p">());</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Caught unexpected vectored interrupt.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">set_vi_srs_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vi_handler_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handler</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_handler</span> <span class="o">=</span> <span class="n">vi_handlers</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">srssets</span> <span class="o">=</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">srsets</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_has_veic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_vint</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">do_default_vi</span><span class="p">;</span>
		<span class="n">srs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">vi_handlers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x200</span> <span class="o">+</span> <span class="n">n</span><span class="o">*</span><span class="n">VECTORSPACING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srs</span> <span class="o">&gt;=</span> <span class="n">srssets</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Shadow register set %d not supported&quot;</span><span class="p">,</span> <span class="n">srs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_veic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">board_bind_eic_interrupt</span><span class="p">)</span>
			<span class="n">board_bind_eic_interrupt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">srs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vint</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SRSMap is only defined if shadow sets are implemented */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srssets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">change_c0_srsmap</span><span class="p">(</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">srs</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If no shadow set is selected then use the default handler</span>
<span class="cm">		 * that does normal register saving and a standard interrupt exit</span>
<span class="cm">		 */</span>

		<span class="k">extern</span> <span class="kt">char</span> <span class="n">except_vec_vi</span><span class="p">,</span> <span class="n">except_vec_vi_lui</span><span class="p">;</span>
		<span class="k">extern</span> <span class="kt">char</span> <span class="n">except_vec_vi_ori</span><span class="p">,</span> <span class="n">except_vec_vi_end</span><span class="p">;</span>
		<span class="k">extern</span> <span class="kt">char</span> <span class="n">rollback_except_vec_vi</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">vec_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu_wait</span> <span class="o">==</span> <span class="n">r4k_wait</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">rollback_except_vec_vi</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">except_vec_vi</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to provide the SMTC vectored interrupt handler</span>
<span class="cm">		 * not only with the address of the handler, but with the</span>
<span class="cm">		 * Status.IM bit to be masked before going there.</span>
<span class="cm">		 */</span>
		<span class="k">extern</span> <span class="kt">char</span> <span class="n">except_vec_vi_mori</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">mori_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">except_vec_vi_mori</span> <span class="o">-</span> <span class="n">vec_start</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">handler_len</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">except_vec_vi_end</span> <span class="o">-</span> <span class="n">vec_start</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">lui_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">except_vec_vi_lui</span> <span class="o">-</span> <span class="n">vec_start</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">ori_offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">except_vec_vi_ori</span> <span class="o">-</span> <span class="n">vec_start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">handler_len</span> <span class="o">&gt;</span> <span class="n">VECTORSPACING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Sigh... panicing won&#39;t help as the console</span>
<span class="cm">			 * is probably not configured :(</span>
<span class="cm">			 */</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;VECTORSPACING too small&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">vec_start</span><span class="p">,</span> <span class="n">handler_len</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">);</span>	<span class="cm">/* Vector index %d exceeds SMTC maximum. */</span>

		<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">b</span> <span class="o">+</span> <span class="n">mori_offset</span><span class="p">);</span>
		<span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>
		<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">b</span> <span class="o">+</span> <span class="n">lui_offset</span><span class="p">);</span>
		<span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">handler</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">b</span> <span class="o">+</span> <span class="n">ori_offset</span><span class="p">);</span>
		<span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">w</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">handler</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">b</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">b</span><span class="o">+</span><span class="n">handler_len</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In other cases jump directly to the interrupt handler</span>
<span class="cm">		 *</span>
<span class="cm">		 * It is the handlers responsibility to save registers if required</span>
<span class="cm">		 * (eg hi/lo) and return from the exception using &quot;eret&quot;</span>
<span class="cm">		 */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
		<span class="o">*</span><span class="n">w</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x08000000</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">handler</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03fffff</span><span class="p">);</span> <span class="cm">/* j handler */</span>
		<span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">b</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">b</span><span class="o">+</span><span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">old_handler</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">set_vi_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vi_handler_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_vi_srs_handler</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tlb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_tlb_handlers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Timer interrupt</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">cp0_compare_irq</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cp0_compare_irq_shift</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Performance counter IRQ or -1 if shared with timer</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">cp0_perfcount_irq</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cp0_perfcount_irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinitdata</span> <span class="n">noulri</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ulri_disable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Disabling ulri</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">noulri</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noulri&quot;</span><span class="p">,</span> <span class="n">ulri_disable</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">per_cpu_trap_init</span><span class="p">(</span><span class="n">bool</span> <span class="n">is_boot_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status_set</span> <span class="o">=</span> <span class="n">ST0_CU0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwrena</span> <span class="o">=</span> <span class="n">cpu_hwrena_impl_bits</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="kt">int</span> <span class="n">secondaryTC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bootTC</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only do per_cpu_trap_init() for first TC of Each VPE.</span>
<span class="cm">	 * Note that this hack assumes that the SMTC init code</span>
<span class="cm">	 * assigns TCs consecutively and in ascending order.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">read_c0_tcbind</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">TCBIND_CURTC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">read_c0_tcbind</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">TCBIND_CURVPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">vpe_id</span><span class="p">))</span>
		<span class="n">secondaryTC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable coprocessors and select 32-bit or 64-bit addressing</span>
<span class="cm">	 * and the 16/32 or 32/32 FPR register model.  Reset the BEV</span>
<span class="cm">	 * flag that some firmware may have left set and the TS bit (for</span>
<span class="cm">	 * IP27).  Set XX for ISA IV code to work.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">status_set</span> <span class="o">|=</span> <span class="n">ST0_FR</span><span class="o">|</span><span class="n">ST0_KX</span><span class="o">|</span><span class="n">ST0_SX</span><span class="o">|</span><span class="n">ST0_UX</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_cpu_data</span><span class="p">.</span><span class="n">isa_level</span> <span class="o">==</span> <span class="n">MIPS_CPU_ISA_IV</span><span class="p">)</span>
		<span class="n">status_set</span> <span class="o">|=</span> <span class="n">ST0_XX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_dsp</span><span class="p">)</span>
		<span class="n">status_set</span> <span class="o">|=</span> <span class="n">ST0_MX</span><span class="p">;</span>

	<span class="n">change_c0_status</span><span class="p">(</span><span class="n">ST0_CU</span><span class="o">|</span><span class="n">ST0_MX</span><span class="o">|</span><span class="n">ST0_RE</span><span class="o">|</span><span class="n">ST0_FR</span><span class="o">|</span><span class="n">ST0_BEV</span><span class="o">|</span><span class="n">ST0_TS</span><span class="o">|</span><span class="n">ST0_KX</span><span class="o">|</span><span class="n">ST0_SX</span><span class="o">|</span><span class="n">ST0_UX</span><span class="p">,</span>
			 <span class="n">status_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mips_r2</span><span class="p">)</span>
		<span class="n">hwrena</span> <span class="o">|=</span> <span class="mh">0x0000000f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noulri</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has_userlocal</span><span class="p">)</span>
		<span class="n">hwrena</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwrena</span><span class="p">)</span>
		<span class="n">write_c0_hwrena</span><span class="p">(</span><span class="n">hwrena</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secondaryTC</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_veic</span> <span class="o">||</span> <span class="n">cpu_has_vint</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">set_c0_status</span><span class="p">(</span><span class="n">ST0_BEV</span><span class="p">);</span>
		<span class="n">write_c0_ebase</span><span class="p">(</span><span class="n">ebase</span><span class="p">);</span>
		<span class="n">write_c0_status</span><span class="p">(</span><span class="n">sr</span><span class="p">);</span>
		<span class="cm">/* Setting vector spacing enables EI/VI mode  */</span>
		<span class="n">change_c0_intctl</span><span class="p">(</span><span class="mh">0x3e0</span><span class="p">,</span> <span class="n">VECTORSPACING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_divec</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mipsmt</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vpflags</span> <span class="o">=</span> <span class="n">dvpe</span><span class="p">();</span>
			<span class="n">set_c0_cause</span><span class="p">(</span><span class="n">CAUSEF_IV</span><span class="p">);</span>
			<span class="n">evpe</span><span class="p">(</span><span class="n">vpflags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">set_c0_cause</span><span class="p">(</span><span class="n">CAUSEF_IV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before R2 both interrupt numbers were fixed to 7, so on R2 only:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  o read IntCtl.IPTI to determine the timer interrupt</span>
<span class="cm">	 *  o read IntCtl.IPPCI to determine the performance counter interrupt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mips_r2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp0_compare_irq_shift</span> <span class="o">=</span> <span class="n">CAUSEB_TI</span> <span class="o">-</span> <span class="n">CAUSEB_IP</span><span class="p">;</span>
		<span class="n">cp0_compare_irq</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_c0_intctl</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">INTCTLB_IPTI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">cp0_perfcount_irq</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_c0_intctl</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">INTCTLB_IPPCI</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp0_perfcount_irq</span> <span class="o">==</span> <span class="n">cp0_compare_irq</span><span class="p">)</span>
			<span class="n">cp0_perfcount_irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp0_compare_irq</span> <span class="o">=</span> <span class="n">CP0_LEGACY_COMPARE_IRQ</span><span class="p">;</span>
		<span class="n">cp0_compare_irq_shift</span> <span class="o">=</span> <span class="n">cp0_compare_irq</span><span class="p">;</span>
		<span class="n">cp0_perfcount_irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">asid_cache</span><span class="p">)</span>
		<span class="n">cpu_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">asid_cache</span> <span class="o">=</span> <span class="n">ASID_FIRST_VERSION</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bootTC</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>
		<span class="cm">/* Boot CPU&#39;s cache setup in setup_arch(). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_boot_cpu</span><span class="p">)</span>
			<span class="n">cpu_cache_init</span><span class="p">();</span>
		<span class="n">tlb_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secondaryTC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First TC in non-boot VPE must do subset of tlb_init()</span>
<span class="cm">		 * for MMU countrol registers.</span>
<span class="cm">		 */</span>
		<span class="n">write_c0_pagemask</span><span class="p">(</span><span class="n">PM_DEFAULT_MASK</span><span class="p">);</span>
		<span class="n">write_c0_wired</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>
	<span class="n">TLBMISS_HANDLER_SETUP</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Install CPU exception handler */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">local_flush_icache_range</span><span class="p">(</span><span class="n">ebase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ebase</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">panic_null_cerr</span><span class="p">[]</span> <span class="n">__cpuinitdata</span> <span class="o">=</span>
	<span class="s">&quot;Trying to set NULL cache error exception handler&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Install uncached CPU exception handler.</span>
<span class="cm"> * This is suitable only for the cache error exception which is the only</span>
<span class="cm"> * exception handler that is being run uncached.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_uncached_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uncached_ebase</span> <span class="o">=</span> <span class="n">CKSEG1ADDR</span><span class="p">(</span><span class="n">ebase</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">panic_null_cerr</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">uncached_ebase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">rdhwr_noopt</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_rdhwr_noopt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rdhwr_noopt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;rdhwr_noopt&quot;</span><span class="p">,</span> <span class="n">set_rdhwr_noopt</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">except_vec3_generic</span><span class="p">,</span> <span class="n">except_vec3_r4000</span><span class="p">;</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">except_vec4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rollback</span><span class="p">;</span>

	<span class="n">check_wait</span><span class="p">();</span>
	<span class="n">rollback</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu_wait</span> <span class="o">==</span> <span class="n">r4k_wait</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_KGDB)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_early_setup</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* Already done */</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_veic</span> <span class="o">||</span> <span class="n">cpu_has_vint</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x200</span> <span class="o">+</span> <span class="n">VECTORSPACING</span><span class="o">*</span><span class="mi">64</span><span class="p">;</span>
		<span class="n">ebase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ebase</span> <span class="o">=</span> <span class="n">CKSEG0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mips_r2</span><span class="p">)</span>
			<span class="n">ebase</span> <span class="o">+=</span> <span class="p">(</span><span class="n">read_c0_ebase</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x3ffff000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">board_ebase_setup</span><span class="p">)</span>
		<span class="n">board_ebase_setup</span><span class="p">();</span>
	<span class="n">per_cpu_trap_init</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the generic exception handlers to their final destination.</span>
<span class="cm">	 * This will be overriden later as suitable for a particular</span>
<span class="cm">	 * configuration.</span>
<span class="cm">	 */</span>
	<span class="n">set_handler</span><span class="p">(</span><span class="mh">0x180</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">except_vec3_generic</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup default vectors</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_except_vector</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">handle_reserved</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the EJTAG debug exception vector handler code to it&#39;s final</span>
<span class="cm">	 * destination.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_ejtag</span> <span class="o">&amp;&amp;</span> <span class="n">board_ejtag_handler_setup</span><span class="p">)</span>
		<span class="n">board_ejtag_handler_setup</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only some CPUs have the watch exceptions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_watch</span><span class="p">)</span>
		<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="n">handle_watch</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise interrupt handlers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_veic</span> <span class="o">||</span> <span class="n">cpu_has_vint</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nvec</span> <span class="o">=</span> <span class="n">cpu_has_veic</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvec</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">set_vi_handler</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_divec</span><span class="p">)</span>
		<span class="n">set_handler</span><span class="p">(</span><span class="mh">0x200</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">except_vec4</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some CPUs can enable/disable for cache parity detection, but does</span>
<span class="cm">	 * it different ways.</span>
<span class="cm">	 */</span>
	<span class="n">parity_protection_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Data Bus Errors / Instruction Bus Errors are signaled</span>
<span class="cm">	 * by external hardware.  Therefore these two exceptions</span>
<span class="cm">	 * may have board specific handlers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">board_be_init</span><span class="p">)</span>
		<span class="n">board_be_init</span><span class="p">();</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rollback</span> <span class="o">?</span> <span class="n">rollback_handle_int</span> <span class="o">:</span> <span class="n">handle_int</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">handle_tlbm</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">handle_tlbl</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">handle_tlbs</span><span class="p">);</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">handle_adel</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">handle_ades</span><span class="p">);</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">handle_ibe</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">handle_dbe</span><span class="p">);</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">handle_sys</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">handle_bp</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">rdhwr_noopt</span> <span class="o">?</span> <span class="n">handle_ri</span> <span class="o">:</span>
			  <span class="p">(</span><span class="n">cpu_has_vtag_icache</span> <span class="o">?</span>
			   <span class="n">handle_ri_rdhwr_vivt</span> <span class="o">:</span> <span class="n">handle_ri_rdhwr</span><span class="p">));</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">handle_cpu</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">handle_ov</span><span class="p">);</span>
	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">handle_tr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CPU_R6000</span> <span class="o">||</span>
	    <span class="n">current_cpu_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CPU_R6000A</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The R6000 is the only R-series CPU that features a machine</span>
<span class="cm">		 * check exception (similar to the R4000 cache error) and</span>
<span class="cm">		 * unaligned ldc1/sdc1 exception.  The handlers have not been</span>
<span class="cm">		 * written yet.  Well, anyway there is no R6000 machine on the</span>
<span class="cm">		 * current list of targets for Linux/MIPS.</span>
<span class="cm">		 * (Duh, crap, there is someone with a triple R6k machine)</span>
<span class="cm">		 */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>set<em>except</em>vector(14, handle<em>mc);
set</em>except<em>vector(15, handle</em>ndc);</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">board_nmi_handler_setup</span><span class="p">)</span>
		<span class="n">board_nmi_handler_setup</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_fpu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_nofpuex</span><span class="p">)</span>
		<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">handle_fpe</span><span class="p">);</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="n">handle_mdmx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mcheck</span><span class="p">)</span>
		<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">handle_mcheck</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mipsmt</span><span class="p">)</span>
		<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="n">handle_mt</span><span class="p">);</span>

	<span class="n">set_except_vector</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="n">handle_dsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">board_cache_error_setup</span><span class="p">)</span>
		<span class="n">board_cache_error_setup</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vce</span><span class="p">)</span>
		<span class="cm">/* Special exception: R4[04]00 uses also the divec space. */</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">except_vec3_r4000</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_4kex</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">except_vec3_generic</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x080</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">except_vec3_generic</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>

	<span class="n">local_flush_icache_range</span><span class="p">(</span><span class="n">ebase</span><span class="p">,</span> <span class="n">ebase</span> <span class="o">+</span> <span class="mh">0x400</span><span class="p">);</span>
	<span class="n">flush_tlb_handlers</span><span class="p">();</span>

	<span class="n">sort_extable</span><span class="p">(</span><span class="n">__start___dbe_table</span><span class="p">,</span> <span class="n">__stop___dbe_table</span><span class="p">);</span>

	<span class="n">cu2_notifier</span><span class="p">(</span><span class="n">default_cu2_call</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>	<span class="cm">/* Run last  */</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
