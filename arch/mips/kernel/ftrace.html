<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › kernel › ftrace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ftrace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Code for replacing ftrace calls with jumps.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="cm"> * Copyright (C) 2009, 2010 DSLab, Lanzhou University, China</span>
<span class="cm"> * Author: Wu Zhangjin &lt;wuzhangjin@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks goes to Steven Rostedt for writing the original x86 version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>

<span class="cp">#include &lt;asm/asm.h&gt;</span>
<span class="cp">#include &lt;asm/asm-offsets.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/uasm.h&gt;</span>

<span class="cp">#include &lt;asm-generic/sections.h&gt;</span>

<span class="cp">#if defined(KBUILD_MCOUNT_RA_ADDRESS) &amp;&amp; defined(CONFIG_32BIT)</span>
<span class="cp">#define MCOUNT_OFFSET_INSNS 5</span>
<span class="cp">#else</span>
<span class="cp">#define MCOUNT_OFFSET_INSNS 4</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the address is in kernel space</span>
<span class="cm"> *</span>
<span class="cm"> * Clone core_kernel_text() from kernel/extable.c, but doesn&#39;t call</span>
<span class="cm"> * init_kernel_text() for Ftrace doesn&#39;t trace functions in init sections.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_kernel_space</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_stext</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ip</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_etext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>

<span class="cp">#define JAL 0x0c000000		</span><span class="cm">/* jump &amp; link: ip --&gt; ra, jump to target */</span><span class="cp"></span>
<span class="cp">#define ADDR_MASK 0x03ffffff	</span><span class="cm">/*  op_code|addr : 31...26|25 ....0 */</span><span class="cp"></span>
<span class="cp">#define JUMP_RANGE_MASK ((1UL &lt;&lt; 28) - 1)</span>

<span class="cp">#define INSN_NOP 0x00000000	</span><span class="cm">/* nop */</span><span class="cp"></span>
<span class="cp">#define INSN_JAL(addr)	\</span>
<span class="cp">	((unsigned int)(JAL | (((addr) &gt;&gt; 2) &amp; ADDR_MASK)))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn_jal_ftrace_caller</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn_lui_v1_hi16_mcount</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn_j_ftrace_graph_caller</span> <span class="n">__maybe_unused</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_dyn_arch_init_insns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v1</span><span class="p">;</span>

	<span class="cm">/* lui v1, hi16_mcount */</span>
	<span class="n">v1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">insn_lui_v1_hi16_mcount</span><span class="p">;</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">MCOUNT_ADDR</span><span class="p">);</span>

	<span class="cm">/* jal (ftrace_caller + 8), jump over the first two instruction */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">insn_jal_ftrace_caller</span><span class="p">;</span>
	<span class="n">uasm_i_jal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="n">FTRACE_ADDR</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">JUMP_RANGE_MASK</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="cm">/* j ftrace_graph_caller */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">insn_j_ftrace_graph_caller</span><span class="p">;</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ftrace_graph_caller</span> <span class="o">&amp;</span> <span class="n">JUMP_RANGE_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ftrace_modify_code</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">faulted</span><span class="p">;</span>

	<span class="cm">/* *(unsigned int *)ip = new_code; */</span>
	<span class="n">safe_store_code</span><span class="p">(</span><span class="n">new_code</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">faulted</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulted</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ip</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The details about the calling site of mcount on MIPS</span>
<span class="cm"> *</span>
<span class="cm"> * 1. For kernel:</span>
<span class="cm"> *</span>
<span class="cm"> * move at, ra</span>
<span class="cm"> * jal _mcount		--&gt; nop</span>
<span class="cm"> *</span>
<span class="cm"> * 2. For modules:</span>
<span class="cm"> *</span>
<span class="cm"> * 2.1 For KBUILD_MCOUNT_RA_ADDRESS and CONFIG_32BIT</span>
<span class="cm"> *</span>
<span class="cm"> * lui v1, hi_16bit_of_mcount        --&gt; b 1f (0x10000005)</span>
<span class="cm"> * addiu v1, v1, low_16bit_of_mcount</span>
<span class="cm"> * move at, ra</span>
<span class="cm"> * move $12, ra_address</span>
<span class="cm"> * jalr v1</span>
<span class="cm"> *  sub sp, sp, 8</span>
<span class="cm"> *                                  1: offset = 5 instructions</span>
<span class="cm"> * 2.2 For the Other situations</span>
<span class="cm"> *</span>
<span class="cm"> * lui v1, hi_16bit_of_mcount        --&gt; b 1f (0x10000004)</span>
<span class="cm"> * addiu v1, v1, low_16bit_of_mcount</span>
<span class="cm"> * move at, ra</span>
<span class="cm"> * jalr v1</span>
<span class="cm"> *  nop | move $12, ra_address | sub sp, sp, 8</span>
<span class="cm"> *                                  1: offset = 4 instructions</span>
<span class="cm"> */</span>

<span class="cp">#define INSN_B_1F (0x10000000 | MCOUNT_OFFSET_INSNS)</span>

<span class="kt">int</span> <span class="nf">ftrace_make_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If ip is in kernel space, no long call, otherwise, long call is</span>
<span class="cm">	 * needed.</span>
<span class="cm">	 */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">in_kernel_space</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span> <span class="n">INSN_NOP</span> <span class="o">:</span> <span class="n">INSN_B_1F</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ftrace_make_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">in_kernel_space</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span> <span class="n">insn_jal_ftrace_caller</span> <span class="o">:</span>
		<span class="n">insn_lui_v1_hi16_mcount</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define FTRACE_CALL_IP ((unsigned long)(&amp;ftrace_call))</span>

<span class="kt">int</span> <span class="nf">ftrace_update_ftrace_func</span><span class="p">(</span><span class="n">ftrace_func_t</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">INSN_JAL</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">func</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">FTRACE_CALL_IP</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">ftrace_dyn_arch_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Encode the instructions when booting */</span>
	<span class="n">ftrace_dyn_arch_init_insns</span><span class="p">();</span>

	<span class="cm">/* Remove &quot;b ftrace_stub&quot; to ensure ftrace_caller() is executed */</span>
	<span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">MCOUNT_ADDR</span><span class="p">,</span> <span class="n">INSN_NOP</span><span class="p">);</span>

	<span class="cm">/* The return code is retured via data */</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_DYNAMIC_FTRACE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_call</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#define FTRACE_GRAPH_CALL_IP	((unsigned long)(&amp;ftrace_graph_call))</span>

<span class="kt">int</span> <span class="nf">ftrace_enable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">FTRACE_GRAPH_CALL_IP</span><span class="p">,</span>
			<span class="n">insn_j_ftrace_graph_caller</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ftrace_disable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ftrace_modify_code</span><span class="p">(</span><span class="n">FTRACE_GRAPH_CALL_IP</span><span class="p">,</span> <span class="n">INSN_NOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_DYNAMIC_FTRACE */</span><span class="cp"></span>

<span class="cp">#ifndef KBUILD_MCOUNT_RA_ADDRESS</span>

<span class="cp">#define S_RA_SP	(0xafbf &lt;&lt; 16)	</span><span class="cm">/* s{d,w} ra, offset(sp) */</span><span class="cp"></span>
<span class="cp">#define S_R_SP	(0xafb0 &lt;&lt; 16)  </span><span class="cm">/* s{d,w} R, offset(sp) */</span><span class="cp"></span>
<span class="cp">#define OFFSET_MASK	0xffff	</span><span class="cm">/* stack offset range: 0 ~ PT_SIZE */</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ftrace_get_parent_ra_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">self_ra</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span>
		<span class="n">old_parent_ra</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ra_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">faulted</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For module, move the ip from the return address after the</span>
<span class="cm">	 * instruction &quot;lui v1, hi_16bit_of_mcount&quot;(offset is 24), but for</span>
<span class="cm">	 * kernel, move after the instruction &quot;move ra, at&quot;(offset is 16)</span>
<span class="cm">	 */</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="n">self_ra</span> <span class="o">-</span> <span class="p">(</span><span class="n">in_kernel_space</span><span class="p">(</span><span class="n">self_ra</span><span class="p">)</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">24</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * search the text until finding the non-store instruction or &quot;s{d,w}</span>
<span class="cm">	 * ra, offset(sp)&quot; instruction</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* get the code at &quot;ip&quot;: code = *(unsigned int *)ip; */</span>
		<span class="n">safe_load_code</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">faulted</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulted</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we hit the non-store instruction before finding where the</span>
<span class="cm">		 * ra is stored, then this is a leaf function and it does not</span>
<span class="cm">		 * store the ra on the stack</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">code</span> <span class="o">&amp;</span> <span class="n">S_R_SP</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S_R_SP</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">parent_ra_addr</span><span class="p">;</span>

		<span class="cm">/* Move to the next instruction */</span>
		<span class="n">ip</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">code</span> <span class="o">&amp;</span> <span class="n">S_RA_SP</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S_RA_SP</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">+</span> <span class="p">(</span><span class="n">code</span> <span class="o">&amp;</span> <span class="n">OFFSET_MASK</span><span class="p">);</span>

	<span class="cm">/* tmp = *(unsigned long *)sp; */</span>
	<span class="n">safe_load_stack</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">faulted</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulted</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">old_parent_ra</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* !KBUILD_MCOUNT_RA_ADDRESS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Hook the return address and push it in the stack of return addrs</span>
<span class="cm"> * in current thread info.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">prepare_ftrace_return</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">parent_ra_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">self_ra</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_parent_ra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_graph_ent</span> <span class="n">trace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">return_hooker</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
	    <span class="o">&amp;</span><span class="n">return_to_handler</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">faulted</span><span class="p">,</span> <span class="n">insns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tracing_graph_pause</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * &quot;parent_ra_addr&quot; is the stack address saved the return address of</span>
<span class="cm">	 * the caller of _mcount.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if the gcc &lt; 4.5, a leaf function does not save the return address</span>
<span class="cm">	 * in the stack address, so, we &quot;emulate&quot; one in _mcount&#39;s stack space,</span>
<span class="cm">	 * and hijack it directly, but for a non-leaf function, it save the</span>
<span class="cm">	 * return address to the its own stack space, we can not hijack it</span>
<span class="cm">	 * directly, but need to find the real stack address,</span>
<span class="cm">	 * ftrace_get_parent_addr() does it!</span>
<span class="cm">	 *</span>
<span class="cm">	 * if gcc&gt;= 4.5, with the new -mmcount-ra-address option, for a</span>
<span class="cm">	 * non-leaf function, the location of the return address will be saved</span>
<span class="cm">	 * to $12 for us, and for a leaf function, only put a zero into $12. we</span>
<span class="cm">	 * do it in ftrace_graph_caller of mcount.S.</span>
<span class="cm">	 */</span>

	<span class="cm">/* old_parent_ra = *parent_ra_addr; */</span>
	<span class="n">safe_load_stack</span><span class="p">(</span><span class="n">old_parent_ra</span><span class="p">,</span> <span class="n">parent_ra_addr</span><span class="p">,</span> <span class="n">faulted</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulted</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#ifndef KBUILD_MCOUNT_RA_ADDRESS</span>
	<span class="n">parent_ra_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ftrace_get_parent_ra_addr</span><span class="p">(</span><span class="n">self_ra</span><span class="p">,</span>
			<span class="n">old_parent_ra</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">parent_ra_addr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If fails when getting the stack address of the non-leaf function&#39;s</span>
<span class="cm">	 * ra, stop function graph tracer and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_ra_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* *parent_ra_addr = return_hooker; */</span>
	<span class="n">safe_store_stack</span><span class="p">(</span><span class="n">return_hooker</span><span class="p">,</span> <span class="n">parent_ra_addr</span><span class="p">,</span> <span class="n">faulted</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulted</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftrace_push_return_trace</span><span class="p">(</span><span class="n">old_parent_ra</span><span class="p">,</span> <span class="n">self_ra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
	    <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">parent_ra_addr</span> <span class="o">=</span> <span class="n">old_parent_ra</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the recorded ip of the current mcount calling site in the</span>
<span class="cm">	 * __mcount_loc section, which will be used to filter the function</span>
<span class="cm">	 * entries configured through the tracing/set_graph_function interface.</span>
<span class="cm">	 */</span>

	<span class="n">insns</span> <span class="o">=</span> <span class="n">in_kernel_space</span><span class="p">(</span><span class="n">self_ra</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">MCOUNT_OFFSET_INSNS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">self_ra</span> <span class="o">-</span> <span class="p">(</span><span class="n">MCOUNT_INSN_SIZE</span> <span class="o">*</span> <span class="n">insns</span><span class="p">);</span>

	<span class="cm">/* Only trace if the calling function expects to */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ftrace_graph_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span><span class="o">--</span><span class="p">;</span>
		<span class="o">*</span><span class="n">parent_ra_addr</span> <span class="o">=</span> <span class="n">old_parent_ra</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ftrace_graph_stop</span><span class="p">();</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
