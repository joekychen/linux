<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › kernel › smp-bmips.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smp-bmips.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 by Kevin Cernekee (cernekee@gmail.com)</span>
<span class="cm"> *</span>
<span class="cm"> * SMP support for BMIPS</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/bootinfo.h&gt;</span>
<span class="cp">#include &lt;asm/pmon.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/mipsregs.h&gt;</span>
<span class="cp">#include &lt;asm/bmips.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/barrier.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="n">max_cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* these may be configured by the platform code */</span>
<span class="kt">int</span> <span class="n">bmips_smp_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">bmips_cpu_offset</span><span class="p">;</span>
<span class="n">cpumask_t</span> <span class="n">bmips_booted_mask</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/* initial $sp, $gp - used by arch/mips/kernel/bmips_vec.S */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bmips_smp_boot_sp</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bmips_smp_boot_gp</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">bmips_send_ipi_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">bmips_ipi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/* SW interrupts 0,1 are used for interprocessor signaling */</span>
<span class="cp">#define IPI0_IRQ			(MIPS_CPU_IRQ_BASE + 0)</span>
<span class="cp">#define IPI1_IRQ			(MIPS_CPU_IRQ_BASE + 1)</span>

<span class="cp">#define CPUNUM(cpu, shift)		(((cpu) + bmips_cpu_offset) &lt;&lt; (shift))</span>
<span class="cp">#define ACTION_CLR_IPI(cpu, ipi)	(0x2000 | CPUNUM(cpu, 9) | ((ipi) &lt;&lt; 8))</span>
<span class="cp">#define ACTION_SET_IPI(cpu, ipi)	(0x3000 | CPUNUM(cpu, 9) | ((ipi) &lt;&lt; 8))</span>
<span class="cp">#define ACTION_BOOT_THREAD(cpu)		(0x08 | CPUNUM(cpu, 0))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">bmips_smp_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_CPU_BMIPS4350) || defined(CONFIG_CPU_BMIPS4380)</span>
	<span class="cm">/* arbitration priority */</span>
	<span class="n">clear_c0_brcm_cmt_ctrl</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>

	<span class="cm">/* NBK and weak order flags */</span>
	<span class="n">set_c0_brcm_config_0</span><span class="p">(</span><span class="mh">0x30000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * MIPS interrupts 0,1 (SW INT 0,1) cross over to the other thread</span>
<span class="cm">	 * MIPS interrupt 2 (HW INT 0) is the CPU0 L1 controller output</span>
<span class="cm">	 * MIPS interrupt 3 (HW INT 1) is the CPU1 L1 controller output</span>
<span class="cm">	 */</span>
	<span class="n">change_c0_brcm_cmt_intr</span><span class="p">(</span><span class="mh">0xf8018000</span><span class="p">,</span>
		<span class="p">(</span><span class="mh">0x02</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">));</span>

	<span class="cm">/* single core, 2 threads (2 pipelines) */</span>
	<span class="n">max_cpus</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_CPU_BMIPS5000)</span>
	<span class="cm">/* enable raceless SW interrupts */</span>
	<span class="n">set_c0_brcm_config</span><span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>

	<span class="cm">/* route HW interrupt 0 to CPU0, HW interrupt 1 to CPU1 */</span>
	<span class="n">change_c0_brcm_mode</span><span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">,</span> <span class="mh">0x02</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>

	<span class="cm">/* N cores, 2 threads per core */</span>
	<span class="n">max_cpus</span> <span class="o">=</span> <span class="p">(((</span><span class="n">read_c0_brcm_config</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* clear any pending SW interrupts */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cpus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_CLR_IPI</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_CLR_IPI</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bmips_smp_enabled</span><span class="p">)</span>
		<span class="n">max_cpus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* this can be overridden by the BSP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">board_ebase_setup</span><span class="p">)</span>
		<span class="n">board_ebase_setup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bmips_ebase_setup</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_cpus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__cpu_number_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__cpu_logical_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IPI IRQ setup - runs on CPU0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">IPI0_IRQ</span><span class="p">,</span> <span class="n">bmips_ipi_interrupt</span><span class="p">,</span> <span class="n">IRQF_PERCPU</span><span class="p">,</span>
			<span class="s">&quot;smp_ipi0&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t request IPI0 interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">IPI1_IRQ</span><span class="p">,</span> <span class="n">bmips_ipi_interrupt</span><span class="p">,</span> <span class="n">IRQF_PERCPU</span><span class="p">,</span>
			<span class="s">&quot;smp_ipi1&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t request IPI1 interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tell the hardware to boot CPUx - runs on CPU0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_boot_secondary</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bmips_smp_boot_sp</span> <span class="o">=</span> <span class="n">__KSTK_TOS</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="n">bmips_smp_boot_gp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initial boot sequence for secondary CPU:</span>
<span class="cm">	 *   bmips_reset_nmi_vec @ a000_0000 -&gt;</span>
<span class="cm">	 *   bmips_smp_entry -&gt;</span>
<span class="cm">	 *   plat_wired_tlb_setup (cached function call; optional) -&gt;</span>
<span class="cm">	 *   start_secondary (cached jump)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Warm restart sequence:</span>
<span class="cm">	 *   play_dead WAIT loop -&gt;</span>
<span class="cm">	 *   bmips_smp_int_vec @ BMIPS_WARM_RESTART_VEC -&gt;</span>
<span class="cm">	 *   eret to play_dead -&gt;</span>
<span class="cm">	 *   bmips_secondary_reentry -&gt;</span>
<span class="cm">	 *   start_secondary</span>
<span class="cm">	 */</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SMP: Booting CPU%d...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmips_booted_mask</span><span class="p">))</span>
		<span class="n">bmips_send_ipi_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_CPU_BMIPS4350) || defined(CONFIG_CPU_BMIPS4380)</span>
		<span class="n">set_c0_brcm_cmt_ctrl</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_CPU_BMIPS5000)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_BOOT_THREAD</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * core N thread 0 was already booted; just</span>
<span class="cm">			 * pulse the NMI line</span>
<span class="cm">			 */</span>
			<span class="n">bmips_write_zscm_reg</span><span class="p">(</span><span class="mh">0x210</span><span class="p">,</span> <span class="mh">0xc0000000</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">bmips_write_zscm_reg</span><span class="p">(</span><span class="mh">0x210</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmips_booted_mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Early setup - runs on secondary CPU after cache probe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_init_secondary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* move NMI vector to kseg0, in case XKS01 is enabled */</span>

<span class="cp">#if defined(CONFIG_CPU_BMIPS4350) || defined(CONFIG_CPU_BMIPS4380)</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cbr</span> <span class="o">=</span> <span class="n">BMIPS_GET_CBR</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_vec</span><span class="p">;</span>

	<span class="n">old_vec</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">cbr</span> <span class="o">+</span> <span class="n">BMIPS_RELO_VECTOR_CONTROL_1</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">old_vec</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x20000000</span><span class="p">,</span> <span class="n">cbr</span> <span class="o">+</span> <span class="n">BMIPS_RELO_VECTOR_CONTROL_1</span><span class="p">);</span>

	<span class="n">clear_c0_cause</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">?</span> <span class="n">C_SW1</span> <span class="o">:</span> <span class="n">C_SW0</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_CPU_BMIPS5000)</span>
	<span class="n">write_c0_brcm_bootvec</span><span class="p">(</span><span class="n">read_c0_brcm_bootvec</span><span class="p">()</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x01</span> <span class="o">?</span> <span class="o">~</span><span class="mh">0x20000000</span> <span class="o">:</span> <span class="o">~</span><span class="mh">0x2000</span><span class="p">));</span>

	<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_CLR_IPI</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="cm">/* make sure there won&#39;t be a timer interrupt for a little while */</span>
	<span class="n">write_c0_compare</span><span class="p">(</span><span class="n">read_c0_count</span><span class="p">()</span> <span class="o">+</span> <span class="n">mips_hpt_frequency</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">irq_enable_hazard</span><span class="p">();</span>
	<span class="n">set_c0_status</span><span class="p">(</span><span class="n">IE_SW0</span> <span class="o">|</span> <span class="n">IE_SW1</span> <span class="o">|</span> <span class="n">IE_IRQ1</span> <span class="o">|</span> <span class="n">IE_IRQ5</span> <span class="o">|</span> <span class="n">ST0_IE</span><span class="p">);</span>
	<span class="n">irq_enable_hazard</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Late setup - runs on secondary CPU before entering the idle loop</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_smp_finish</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SMP: CPU%d is running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Runs on CPU0 after all CPUs have been booted</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_cpus_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_CPU_BMIPS5000)</span>

<span class="cm">/*</span>
<span class="cm"> * BMIPS5000 raceless IPIs</span>
<span class="cm"> *</span>
<span class="cm"> * Each CPU has two inbound SW IRQs which are independent of all other CPUs.</span>
<span class="cm"> * IPI0 is used for SMP_RESCHEDULE_YOURSELF</span>
<span class="cm"> * IPI1 is used for SMP_CALL_FUNCTION</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_send_ipi_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_SET_IPI</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SMP_CALL_FUNCTION</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bmips_ipi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">irq</span> <span class="o">-</span> <span class="n">IPI0_IRQ</span><span class="p">;</span>

	<span class="n">write_c0_brcm_action</span><span class="p">(</span><span class="n">ACTION_CLR_IPI</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">action</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scheduler_ipi</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">smp_call_function_interrupt</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cm">/*</span>
<span class="cm"> * BMIPS43xx racey IPIs</span>
<span class="cm"> *</span>
<span class="cm"> * We use one inbound SW IRQ for each CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * A spinlock must be held in order to keep CPUx from accidentally clearing</span>
<span class="cm"> * an incoming IPI when it writes CP0 CAUSE to raise an IPI on CPUy.  The</span>
<span class="cm"> * same spinlock is used to protect the action masks.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ipi_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">ipi_action_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_send_ipi_single</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">set_c0_cause</span><span class="p">(</span><span class="n">cpu</span> <span class="o">?</span> <span class="n">C_SW1</span> <span class="o">:</span> <span class="n">C_SW0</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_action_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">|=</span> <span class="n">action</span><span class="p">;</span>
	<span class="n">irq_enable_hazard</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bmips_ipi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">irq</span> <span class="o">-</span> <span class="n">IPI0_IRQ</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">action</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">ipi_action_mask</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">ipi_action_mask</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_c0_cause</span><span class="p">(</span><span class="n">cpu</span> <span class="o">?</span> <span class="n">C_SW1</span> <span class="o">:</span> <span class="n">C_SW0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">SMP_RESCHEDULE_YOURSELF</span><span class="p">)</span>
		<span class="n">scheduler_ipi</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">SMP_CALL_FUNCTION</span><span class="p">)</span>
		<span class="n">smp_call_function_interrupt</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* BMIPS type */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_send_ipi_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">bmips_send_ipi_single</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bmips_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;SMP: CPU%d is offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">cpu_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_map</span><span class="p">);</span>

	<span class="n">local_flush_tlb_all</span><span class="p">();</span>
	<span class="n">local_flush_icache_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bmips_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>

	<span class="cm">/* flush data cache */</span>
	<span class="n">_dma_cache_wback_inv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wakeup is on SW0 or SW1; disable everything else</span>
<span class="cm">	 * Use BEV !IV (BMIPS_WARM_RESTART_VEC) to avoid the regular Linux</span>
<span class="cm">	 * IRQ handlers; this clears ST0_IE and returns immediately.</span>
<span class="cm">	 */</span>
	<span class="n">clear_c0_cause</span><span class="p">(</span><span class="n">CAUSEF_IV</span> <span class="o">|</span> <span class="n">C_SW0</span> <span class="o">|</span> <span class="n">C_SW1</span><span class="p">);</span>
	<span class="n">change_c0_status</span><span class="p">(</span><span class="n">IE_IRQ5</span> <span class="o">|</span> <span class="n">IE_IRQ1</span> <span class="o">|</span> <span class="n">IE_SW0</span> <span class="o">|</span> <span class="n">IE_SW1</span> <span class="o">|</span> <span class="n">ST0_IE</span> <span class="o">|</span> <span class="n">ST0_BEV</span><span class="p">,</span>
		<span class="n">IE_SW0</span> <span class="o">|</span> <span class="n">IE_SW1</span> <span class="o">|</span> <span class="n">ST0_IE</span> <span class="o">|</span> <span class="n">ST0_BEV</span><span class="p">);</span>
	<span class="n">irq_disable_hazard</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait for SW interrupt from bmips_boot_secondary(), then jump</span>
<span class="cm">	 * back to start_secondary()</span>
<span class="cm">	 */</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	wait</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	j	bmips_secondary_reentry</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">plat_smp_ops</span> <span class="n">bmips_smp_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">smp_setup</span>		<span class="o">=</span> <span class="n">bmips_smp_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare_cpus</span>		<span class="o">=</span> <span class="n">bmips_prepare_cpus</span><span class="p">,</span>
	<span class="p">.</span><span class="n">boot_secondary</span>		<span class="o">=</span> <span class="n">bmips_boot_secondary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">smp_finish</span>		<span class="o">=</span> <span class="n">bmips_smp_finish</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_secondary</span>		<span class="o">=</span> <span class="n">bmips_init_secondary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpus_done</span>		<span class="o">=</span> <span class="n">bmips_cpus_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_ipi_single</span>	<span class="o">=</span> <span class="n">bmips_send_ipi_single</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_ipi_mask</span>		<span class="o">=</span> <span class="n">bmips_send_ipi_mask</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="p">.</span><span class="n">cpu_disable</span>		<span class="o">=</span> <span class="n">bmips_cpu_disable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cpu_die</span>		<span class="o">=</span> <span class="n">bmips_cpu_die</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/***********************************************************************</span>
<span class="cm"> * BMIPS vector relocation</span>
<span class="cm"> * This is primarily used for SMP boot, but it is applicable to some</span>
<span class="cm"> * UP BMIPS systems as well.</span>
<span class="cm"> ***********************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">bmips_wr_vec</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">dma_cache_wback</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">local_flush_icache_range</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>
	<span class="n">instruction_hazard</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">bmips_nmi_handler_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bmips_wr_vec</span><span class="p">(</span><span class="n">BMIPS_NMI_RESET_VEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmips_reset_nmi_vec</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">bmips_reset_nmi_vec_end</span><span class="p">);</span>
	<span class="n">bmips_wr_vec</span><span class="p">(</span><span class="n">BMIPS_WARM_RESTART_VEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmips_smp_int_vec</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">bmips_smp_int_vec_end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">bmips_ebase_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_ebase</span> <span class="o">=</span> <span class="n">ebase</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__maybe_unused</span> <span class="o">*</span><span class="n">cbr</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ebase</span> <span class="o">!=</span> <span class="n">CKSEG0</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_CPU_BMIPS4350)</span>
	<span class="cm">/*</span>
<span class="cm">	 * BMIPS4350 cannot relocate the normal vectors, but it</span>
<span class="cm">	 * can relocate the BEV=1 vectors.  So CPU1 starts up at</span>
<span class="cm">	 * the relocated BEV=1, IV=0 general exception vector @</span>
<span class="cm">	 * 0xa000_0380.</span>
<span class="cm">	 *</span>
<span class="cm">	 * set_uncached_handler() is used here because:</span>
<span class="cm">	 *  - CPU1 will run this from uncached space</span>
<span class="cm">	 *  - None of the cacheflush functions are set up yet</span>
<span class="cm">	 */</span>
	<span class="n">set_uncached_handler</span><span class="p">(</span><span class="n">BMIPS_WARM_RESTART_VEC</span> <span class="o">-</span> <span class="n">CKSEG0</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">bmips_smp_int_vec</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">__sync</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_CPU_BMIPS4380)</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0x8000_0000: reset/NMI (initially in kseg1)</span>
<span class="cm">	 * 0x8000_0400: normal vectors</span>
<span class="cm">	 */</span>
	<span class="n">new_ebase</span> <span class="o">=</span> <span class="mh">0x80000400</span><span class="p">;</span>
	<span class="n">cbr</span> <span class="o">=</span> <span class="n">BMIPS_GET_CBR</span><span class="p">();</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mh">0x80080800</span><span class="p">,</span> <span class="n">cbr</span> <span class="o">+</span> <span class="n">BMIPS_RELO_VECTOR_CONTROL_0</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mh">0xa0080800</span><span class="p">,</span> <span class="n">cbr</span> <span class="o">+</span> <span class="n">BMIPS_RELO_VECTOR_CONTROL_1</span><span class="p">);</span>
<span class="cp">#elif defined(CONFIG_CPU_BMIPS5000)</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0x8000_0000: reset/NMI (initially in kseg1)</span>
<span class="cm">	 * 0x8000_1000: normal vectors</span>
<span class="cm">	 */</span>
	<span class="n">new_ebase</span> <span class="o">=</span> <span class="mh">0x80001000</span><span class="p">;</span>
	<span class="n">write_c0_brcm_bootvec</span><span class="p">(</span><span class="mh">0xa0088008</span><span class="p">);</span>
	<span class="n">write_c0_ebase</span><span class="p">(</span><span class="n">new_ebase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_cpus</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">bmips_write_zscm_reg</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xa008a008</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">board_nmi_handler_setup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bmips_nmi_handler_setup</span><span class="p">;</span>
	<span class="n">ebase</span> <span class="o">=</span> <span class="n">new_ebase</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__weak</span> <span class="nf">plat_wired_tlb_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Called when starting/restarting a secondary CPU.</span>
<span class="cm">	 * Kernel stacks and other important data might only be accessible</span>
<span class="cm">	 * once the wired entries are present.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
