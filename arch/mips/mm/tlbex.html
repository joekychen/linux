<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › mm › tlbex.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tlbex.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Synthesize TLB refill handlers at runtime.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004, 2005, 2006, 2008  Thiemo Seufer</span>
<span class="cm"> * Copyright (C) 2005, 2007, 2008, 2009  Maciej W. Rozycki</span>
<span class="cm"> * Copyright (C) 2006  Ralf Baechle (ralf@linux-mips.org)</span>
<span class="cm"> * Copyright (C) 2008, 2009 Cavium Networks, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * ... and the days got worse and worse and now you see</span>
<span class="cm"> * I&#39;ve gone completly out of my mind.</span>
<span class="cm"> *</span>
<span class="cm"> * They&#39;re coming to take me a away haha</span>
<span class="cm"> * they&#39;re coming to take me a away hoho hihi haha</span>
<span class="cm"> * to the funny farm where code is beautiful all the time ...</span>
<span class="cm"> *</span>
<span class="cm"> * (Condolences to Napoleon XIV)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/war.h&gt;</span>
<span class="cp">#include &lt;asm/uasm.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * TLB load/store/modify handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the fastpath gets synthesized at runtime, the slowpath for</span>
<span class="cm"> * do_page_fault remains normal asm.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tlb_do_page_fault_0</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tlb_do_page_fault_1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">work_registers</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">r1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r3</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tlb_reg_save</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tlb_reg_save</span> <span class="n">handler_reg_save</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r45k_bvahwbug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX: We should probe for the presence of this bug, but we don&#39;t. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">r4k_250MHZhwbug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX: We should probe for the presence of this bug, but we don&#39;t. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">bcm1250_m3_war</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">BCM1250_M3_WAR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">r10000_llsc_war</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">R10000_LLSC_WAR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">use_bbit_insns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_CAVIUM_OCTEON</span>:
	<span class="k">case</span> <span class="n">CPU_CAVIUM_OCTEON_PLUS</span>:
	<span class="k">case</span> <span class="n">CPU_CAVIUM_OCTEON2</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">use_lwx_insns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_CAVIUM_OCTEON2</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#if defined(CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE) &amp;&amp; \</span>
<span class="cp">    CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE &gt; 0</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">scratchpad_available</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scratchpad_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * CVMSEG starts at address -32768 and extends for</span>
<span class="cm">	 * CAVIUM_OCTEON_CVMSEG_SIZE 128 byte cache lines.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Kernel use starts at the top and works down. */</span>
	<span class="k">return</span> <span class="n">CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE</span> <span class="o">*</span> <span class="mi">128</span> <span class="o">-</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">32768</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">scratchpad_available</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scratchpad_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="cm">/* Really unreachable, but evidently some GCC want this. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * Found by experiment: At least some revisions of the 4kc throw under</span>
<span class="cm"> * some circumstances a machine check exception, triggered by invalid</span>
<span class="cm"> * values in the index register.  Delaying the tlbp instruction until</span>
<span class="cm"> * after the next branch,  plus adding an additional nop in front of</span>
<span class="cm"> * tlbwi/tlbwr avoids the invalid index register values. Nobody knows</span>
<span class="cm"> * why; it&#39;s not an issue caused by the core RTL.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">m4kc_tlbp_war</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">current_cpu_data</span><span class="p">.</span><span class="n">processor_id</span> <span class="o">&amp;</span> <span class="mh">0xffff00</span><span class="p">)</span> <span class="o">==</span>
	       <span class="p">(</span><span class="n">PRID_COMP_MIPS</span> <span class="o">|</span> <span class="n">PRID_IMP_4KC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle labels (which must be positive integers). */</span>
<span class="k">enum</span> <span class="n">label_id</span> <span class="p">{</span>
	<span class="n">label_second_part</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">label_leave</span><span class="p">,</span>
	<span class="n">label_vmalloc</span><span class="p">,</span>
	<span class="n">label_vmalloc_done</span><span class="p">,</span>
	<span class="n">label_tlbw_hazard</span><span class="p">,</span>
	<span class="n">label_split</span><span class="p">,</span>
	<span class="n">label_tlbl_goaround1</span><span class="p">,</span>
	<span class="n">label_tlbl_goaround2</span><span class="p">,</span>
	<span class="n">label_nopage_tlbl</span><span class="p">,</span>
	<span class="n">label_nopage_tlbs</span><span class="p">,</span>
	<span class="n">label_nopage_tlbm</span><span class="p">,</span>
	<span class="n">label_smp_pgtable_change</span><span class="p">,</span>
	<span class="n">label_r3000_write_probe_fail</span><span class="p">,</span>
	<span class="n">label_large_segbits_fault</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="n">label_tlb_huge_update</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_second_part</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_leave</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_vmalloc</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_vmalloc_done</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_tlbw_hazard</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_split</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_tlbl_goaround1</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_tlbl_goaround2</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_nopage_tlbl</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_nopage_tlbs</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_nopage_tlbm</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_smp_pgtable_change</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_r3000_write_probe_fail</span><span class="p">)</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_large_segbits_fault</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
<span class="n">UASM_L_LA</span><span class="p">(</span><span class="n">_tlb_huge_update</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * For debug purposes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">dump_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set push</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set noreorder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%p</span><span class="se">\t</span><span class="s">.word 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">handler</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set pop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The only general purpose registers allowed in TLB handlers. */</span>
<span class="cp">#define K0		26</span>
<span class="cp">#define K1		27</span>

<span class="cm">/* Some CP0 registers */</span>
<span class="cp">#define C0_INDEX	0, 0</span>
<span class="cp">#define C0_ENTRYLO0	2, 0</span>
<span class="cp">#define C0_TCBIND	2, 2</span>
<span class="cp">#define C0_ENTRYLO1	3, 0</span>
<span class="cp">#define C0_CONTEXT	4, 0</span>
<span class="cp">#define C0_PAGEMASK	5, 0</span>
<span class="cp">#define C0_BADVADDR	8, 0</span>
<span class="cp">#define C0_ENTRYHI	10, 0</span>
<span class="cp">#define C0_EPC		14, 0</span>
<span class="cp">#define C0_XCONTEXT	20, 0</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp"># define GET_CONTEXT(buf, reg) UASM_i_MFC0(buf, reg, C0_XCONTEXT)</span>
<span class="cp">#else</span>
<span class="cp"># define GET_CONTEXT(buf, reg) UASM_i_MFC0(buf, reg, C0_CONTEXT)</span>
<span class="cp">#endif</span>

<span class="cm">/* The worst case length of the handler is around 18 instructions for</span>
<span class="cm"> * R3000-style TLBs and up to 63 instructions for R4000-style TLBs.</span>
<span class="cm"> * Maximum space available is 32 instructions for R3000 and 64</span>
<span class="cm"> * instructions for R4000.</span>
<span class="cm"> *</span>
<span class="cm"> * We deliberately chose a buffer size of 128, so we won&#39;t scribble</span>
<span class="cm"> * over anything important on overflow before we panic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">tlb_handler</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="cm">/* simply assume worst case size for labels and relocs */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="n">labels</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="n">relocs</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_for_high_segbits</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">check_for_high_segbits</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kscratch_used_mask</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">allocate_kscratch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">kscratch_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">kscratch_used_mask</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">r</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* make it zero based */</span>

	<span class="n">kscratch_used_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">scratch_reg</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pgd_reg</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">vmalloc64_mode</span> <span class="p">{</span><span class="n">not_refill</span><span class="p">,</span> <span class="n">refill_scratch</span><span class="p">,</span> <span class="n">refill_noscratch</span><span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">work_registers</span> <span class="n">__cpuinit</span> <span class="nf">build_get_work_registers</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_registers</span> <span class="n">r</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">smp_processor_id_reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">smp_processor_id_sel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">smp_processor_id_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scratch_reg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Save in CPU local C0_KScratch? */</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">scratch_reg</span><span class="p">);</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r1</span> <span class="o">=</span> <span class="n">K0</span><span class="p">;</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r2</span> <span class="o">=</span> <span class="n">K1</span><span class="p">;</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_MIPS_PGD_C0_CONTEXT</span>
		<span class="n">smp_processor_id_shift</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span>
		<span class="n">smp_processor_id_reg</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="cm">/* XContext */</span>
		<span class="n">smp_processor_id_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp"># ifdef CONFIG_32BIT</span>
		<span class="n">smp_processor_id_shift</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
		<span class="n">smp_processor_id_reg</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* Context */</span>
		<span class="n">smp_processor_id_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp"># ifdef CONFIG_64BIT</span>
		<span class="n">smp_processor_id_shift</span> <span class="o">=</span> <span class="mi">26</span><span class="p">;</span>
		<span class="n">smp_processor_id_reg</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* Context */</span>
		<span class="n">smp_processor_id_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
		<span class="cm">/* Get smp_processor_id */</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">smp_processor_id_reg</span><span class="p">,</span> <span class="n">smp_processor_id_sel</span><span class="p">);</span>
		<span class="n">UASM_i_SRL_SAFE</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">smp_processor_id_shift</span><span class="p">);</span>

		<span class="cm">/* handler_reg_save index in K0 */</span>
		<span class="n">UASM_i_SLL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_reg_save</span><span class="p">)));</span>

		<span class="n">UASM_i_LA</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">handler_reg_save</span><span class="p">);</span>
		<span class="n">UASM_i_ADDU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">UASM_i_LA</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">handler_reg_save</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* K0 now points to save area, save $1 and $2  */</span>
	<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_reg_save</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_reg_save</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">K0</span><span class="p">);</span>

	<span class="n">r</span><span class="p">.</span><span class="n">r1</span> <span class="o">=</span> <span class="n">K1</span><span class="p">;</span>
	<span class="n">r</span><span class="p">.</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span><span class="p">.</span><span class="n">r3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_restore_work_registers</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scratch_reg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">scratch_reg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* K0 already points to save area, restore $1 and $2  */</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_reg_save</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_reg_save</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">K0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_MIPS_PGD_C0_CONTEXT</span>

<span class="cm">/*</span>
<span class="cm"> * CONFIG_MIPS_PGD_C0_CONTEXT implies 64 bit and lack of pgd_current,</span>
<span class="cm"> * we cannot do r3000 under these circumstances.</span>
<span class="cm"> *</span>
<span class="cm"> * Declare pgd_current here instead of including mmu_context.h to avoid type</span>
<span class="cm"> * conflicts for tlbmiss_handler_setup_pgd</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgd_current</span><span class="p">[];</span>

<span class="cm">/*</span>
<span class="cm"> * The R3000 TLB handler is simple.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r3000_tlb_refill_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">pgdc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pgd_current</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tlb_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlb_handler</span><span class="p">));</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">tlb_handler</span><span class="p">;</span>

	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
	<span class="n">uasm_i_lui</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">uasm_rel_hi</span><span class="p">(</span><span class="n">pgdc</span><span class="p">));</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">pgdc</span><span class="p">),</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">uasm_i_srl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">uasm_i_sll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mh">0xffc</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K0</span><span class="p">);</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">C0_EPC</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_tlbwr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">uasm_i_rfe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* branch delay */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">tlb_handler</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB refill handler space exceeded&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB refill handler (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ebase</span><span class="p">,</span> <span class="n">tlb_handler</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>

	<span class="n">dump_handler</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ebase</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_PGD_C0_CONTEXT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The R4000 TLB handler is much more complicated. We have two</span>
<span class="cm"> * consecutive handler areas with 32 instructions space each.</span>
<span class="cm"> * Since they aren&#39;t used at the same time, we can overflow in the</span>
<span class="cm"> * other one.To keep things simple, we first assume linear space,</span>
<span class="cm"> * then we relocate it to the final handler layout as needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">final_handler</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Hazards</span>
<span class="cm"> *</span>
<span class="cm"> * From the IDT errata for the QED RM5230 (Nevada), processor revision 1.0:</span>
<span class="cm"> * 2. A timing hazard exists for the TLBP instruction.</span>
<span class="cm"> *</span>
<span class="cm"> *      stalling_instruction</span>
<span class="cm"> *      TLBP</span>
<span class="cm"> *</span>
<span class="cm"> * The JTLB is being read for the TLBP throughout the stall generated by the</span>
<span class="cm"> * previous instruction. This is not really correct as the stalling instruction</span>
<span class="cm"> * can modify the address used to access the JTLB.  The failure symptom is that</span>
<span class="cm"> * the TLBP instruction will use an address created for the stalling instruction</span>
<span class="cm"> * and not the address held in C0_ENHI and thus report the wrong results.</span>
<span class="cm"> *</span>
<span class="cm"> * The software work-around is to not allow the instruction preceding the TLBP</span>
<span class="cm"> * to stall - make it an NOP or some other instruction guaranteed not to stall.</span>
<span class="cm"> *</span>
<span class="cm"> * Errata 2 will not be fixed.  This errata is also on the R5000.</span>
<span class="cm"> *</span>
<span class="cm"> * As if we MIPS hackers wouldn&#39;t know how to nop pipelines happy ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="n">__maybe_unused</span> <span class="nf">build_tlb_probe_entry</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="cm">/* Found by experiment: R4600 v2.0/R4700 needs this, too.  */</span>
	<span class="k">case</span> <span class="n">CPU_R4600</span>:
	<span class="k">case</span> <span class="n">CPU_R4700</span>:
	<span class="k">case</span> <span class="n">CPU_R5000</span>:
	<span class="k">case</span> <span class="n">CPU_R5000A</span>:
	<span class="k">case</span> <span class="n">CPU_NEVADA</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_tlbp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">uasm_i_tlbp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write random or indexed TLB entry, and care about the hazards from</span>
<span class="cm"> * the preceding mtc0 and for the following eret.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">tlb_write_entry</span> <span class="p">{</span> <span class="n">tlb_random</span><span class="p">,</span> <span class="n">tlb_indexed</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_tlb_write_entry</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">tlb_write_entry</span> <span class="n">wmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">tlbw</span><span class="p">)(</span><span class="n">u32</span> <span class="o">**</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">wmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">tlb_random</span>: <span class="n">tlbw</span> <span class="o">=</span> <span class="n">uasm_i_tlbwr</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">tlb_indexed</span>: <span class="n">tlbw</span> <span class="o">=</span> <span class="n">uasm_i_tlbwi</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mips_r2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_mips_r2_exec_hazard</span><span class="p">)</span>
			<span class="n">uasm_i_ehb</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_R4000PC</span>:
	<span class="k">case</span> <span class="n">CPU_R4000SC</span>:
	<span class="k">case</span> <span class="n">CPU_R4000MC</span>:
	<span class="k">case</span> <span class="n">CPU_R4400PC</span>:
	<span class="k">case</span> <span class="n">CPU_R4400SC</span>:
	<span class="k">case</span> <span class="n">CPU_R4400MC</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This branch uses up a mtc0 hazard nop slot and saves</span>
<span class="cm">		 * two nops after the tlbw instruction.</span>
<span class="cm">		 */</span>
		<span class="n">uasm_il_bgezl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label_tlbw_hazard</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_l_tlbw_hazard</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_R4600</span>:
	<span class="k">case</span> <span class="n">CPU_R4700</span>:
	<span class="k">case</span> <span class="n">CPU_R5000</span>:
	<span class="k">case</span> <span class="n">CPU_R5000A</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_R4300</span>:
	<span class="k">case</span> <span class="n">CPU_5KC</span>:
	<span class="k">case</span> <span class="n">CPU_TX49XX</span>:
	<span class="k">case</span> <span class="n">CPU_PR4450</span>:
	<span class="k">case</span> <span class="n">CPU_XLR</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_R10000</span>:
	<span class="k">case</span> <span class="n">CPU_R12000</span>:
	<span class="k">case</span> <span class="n">CPU_R14000</span>:
	<span class="k">case</span> <span class="n">CPU_4KC</span>:
	<span class="k">case</span> <span class="n">CPU_4KEC</span>:
	<span class="k">case</span> <span class="n">CPU_SB1</span>:
	<span class="k">case</span> <span class="n">CPU_SB1A</span>:
	<span class="k">case</span> <span class="n">CPU_4KSC</span>:
	<span class="k">case</span> <span class="n">CPU_20KC</span>:
	<span class="k">case</span> <span class="n">CPU_25KF</span>:
	<span class="k">case</span> <span class="n">CPU_BMIPS32</span>:
	<span class="k">case</span> <span class="n">CPU_BMIPS3300</span>:
	<span class="k">case</span> <span class="n">CPU_BMIPS4350</span>:
	<span class="k">case</span> <span class="n">CPU_BMIPS4380</span>:
	<span class="k">case</span> <span class="n">CPU_BMIPS5000</span>:
	<span class="k">case</span> <span class="n">CPU_LOONGSON2</span>:
	<span class="k">case</span> <span class="n">CPU_R5500</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">m4kc_tlbp_war</span><span class="p">())</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CPU_ALCHEMY</span>:
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_NEVADA</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* QED specifies 2 nops hazard */</span>
		<span class="cm">/*</span>
<span class="cm">		 * This branch uses up a mtc0 hazard nop slot and saves</span>
<span class="cm">		 * a nop after the tlbw instruction.</span>
<span class="cm">		 */</span>
		<span class="n">uasm_il_bgezl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">label_tlbw_hazard</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_l_tlbw_hazard</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_RM7000</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_RM9000</span>:
		<span class="cm">/*</span>
<span class="cm">		 * When the JTLB is updated by tlbwi or tlbwr, a subsequent</span>
<span class="cm">		 * use of the JTLB for instructions should not occur for 4</span>
<span class="cm">		 * cpu cycles and use for data translations should not occur</span>
<span class="cm">		 * for 3 cpu cycles.</span>
<span class="cm">		 */</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_ssnop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_VR4111</span>:
	<span class="k">case</span> <span class="n">CPU_VR4121</span>:
	<span class="k">case</span> <span class="n">CPU_VR4122</span>:
	<span class="k">case</span> <span class="n">CPU_VR4181</span>:
	<span class="k">case</span> <span class="n">CPU_VR4181A</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_VR4131</span>:
	<span class="k">case</span> <span class="n">CPU_VR4133</span>:
	<span class="k">case</span> <span class="n">CPU_R5432</span>:
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_JZRISC</span>:
		<span class="n">tlbw</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No TLB refill handler yet (CPU type: %d)&quot;</span><span class="p">,</span>
		      <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">cputype</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="n">__maybe_unused</span> <span class="kt">void</span> <span class="nf">build_convert_pte_to_entrylo</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
								  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">UASM_i_ROTR</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT_PHYS_ADDR</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">build_restore_pagemask</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
					     <span class="k">enum</span> <span class="n">label_id</span> <span class="n">lid</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">restore_scratch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restore_scratch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset default page size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PM_DEFAULT_MASK</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PM_DEFAULT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span><span class="p">);</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scratch_reg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">scratch_reg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset default page size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PM_DEFAULT_MASK</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PM_DEFAULT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PM_DEFAULT_MASK</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
			<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">build_huge_tlb_write_entry</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
						 <span class="k">enum</span> <span class="n">tlb_write_entry</span> <span class="n">wmode</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">restore_scratch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set huge page tlb entry size */</span>
	<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_HUGE_MASK</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PM_HUGE_MASK</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_PAGEMASK</span><span class="p">);</span>

	<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">wmode</span><span class="p">);</span>

	<span class="n">build_restore_pagemask</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">label_leave</span><span class="p">,</span> <span class="n">restore_scratch</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if Huge PTE is present, if so then jump to LABEL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_is_huge_pte</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">uasm_il_bbit1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_HUGE</span><span class="p">),</span> <span class="n">lid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">_PAGE_HUGE</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">build_huge_update_entries</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">small_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A huge PTE describes an area the size of the</span>
<span class="cm">	 * configured huge page size. This is twice the</span>
<span class="cm">	 * of the large TLB entry size we intend to use.</span>
<span class="cm">	 * A TLB entry half the size of the configured</span>
<span class="cm">	 * huge page size is configured into entrylo0</span>
<span class="cm">	 * and entrylo1 to cover the contiguous huge PTE</span>
<span class="cm">	 * address space.</span>
<span class="cm">	 */</span>
	<span class="n">small_sequence</span> <span class="o">=</span> <span class="p">(</span><span class="n">HPAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span>

	<span class="cm">/* We can clobber tmp.  It isn&#39;t used after this.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">small_sequence</span><span class="p">)</span>
		<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">HPAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">16</span><span class="p">));</span>

	<span class="n">build_convert_pte_to_entrylo</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
	<span class="cm">/* convert to entrylo1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">small_sequence</span><span class="p">)</span>
		<span class="n">UASM_i_ADDIU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">HPAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">UASM_i_ADDU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span> <span class="cm">/* load it */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">build_huge_handler_tail</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">UASM_i_SC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">label_tlb_huge_update</span><span class="p">);</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* Needed because SC killed our PTE */</span>
<span class="cp">#else</span>
	<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">build_huge_update_entries</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">build_huge_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">tlb_indexed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cm">/*</span>
<span class="cm"> * TMP and PTR are scratch.</span>
<span class="cm"> * TMP will be clobbered, PTR will hold the pmd entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_get_pmde64</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_MIPS_PGD_C0_CONTEXT</span>
	<span class="kt">long</span> <span class="n">pgdc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pgd_current</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * The vmalloc handling is not in the hotpath.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_for_high_segbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The kernel currently implicitely assumes that the</span>
<span class="cm">		 * MIPS SEGBITS parameter for the processor is</span>
<span class="cm">		 * (PGDIR_SHIFT+PGDIR_BITS) or less, and will never</span>
<span class="cm">		 * allocate virtual addresses outside the maximum</span>
<span class="cm">		 * range for SEGBITS = (PGDIR_SHIFT+PGDIR_BITS). But</span>
<span class="cm">		 * that doesn&#39;t prevent user code from accessing the</span>
<span class="cm">		 * higher xuseg addresses.  Here, we make sure that</span>
<span class="cm">		 * everything but the lower xuseg addresses goes down</span>
<span class="cm">		 * the module_alloc/vmalloc path.</span>
<span class="cm">		 */</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span> <span class="o">+</span> <span class="n">PGD_ORDER</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">label_vmalloc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_il_bltz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">label_vmalloc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* No uasm_i_nop needed here, since the next insn doesn&#39;t touch TMP. */</span>

<span class="cp">#ifdef CONFIG_MIPS_PGD_C0_CONTEXT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pgd is in pgd_reg */</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">pgd_reg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &amp;pgd &lt;&lt; 11 stored in CONTEXT [23..63].</span>
<span class="cm">		 */</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>

		<span class="cm">/* Clear lower 23 bits of context. */</span>
		<span class="n">uasm_i_dins</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>

		<span class="cm">/* 1 0  1 0 1  &lt;&lt; 6  xkphys cached */</span>
		<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mh">0x540</span><span class="p">);</span>
		<span class="n">uasm_i_drotr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#elif defined(CONFIG_SMP)</span>
<span class="cp"># ifdef  CONFIG_MIPS_MT_SMTC</span>
	<span class="cm">/*</span>
<span class="cm">	 * SMTC uses TCBind value as &quot;CPU&quot; index</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_TCBIND</span><span class="p">);</span>
	<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
<span class="cp"># else</span>
	<span class="cm">/*</span>
<span class="cm">	 * 64 bit SMP running in XKPHYS has smp_processor_id() &lt;&lt; 3</span>
<span class="cm">	 * stored in CONTEXT.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>
	<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
<span class="cp"># endif</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pgdc</span><span class="p">);</span>
	<span class="n">uasm_i_daddu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
	<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">pgdc</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">pgdc</span><span class="p">);</span>
	<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">pgdc</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uasm_l_vmalloc_done</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* get pgd offset in bytes */</span>
	<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">PTRS_PER_PGD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">uasm_i_daddu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* add in pgd offset */</span>
<span class="cp">#ifndef __PAGETABLE_PMD_FOLDED</span>
	<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span> <span class="cm">/* get faulting address */</span>
	<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* get pmd pointer */</span>
	<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PMD_SHIFT</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="cm">/* get pmd offset in bytes */</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">uasm_i_daddu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* add in pmd offset */</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * BVADDR is the faulting address, PTR is scratch.</span>
<span class="cm"> * PTR will hold the pgd for vmalloc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_get_pgd_vmalloc64</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bvaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">vmalloc64_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">swpd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">swapper_pg_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">single_insn_swpd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_vmalloc_branch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">single_insn_swpd</span> <span class="o">=</span> <span class="n">uasm_in_compat_space_p</span><span class="p">(</span><span class="n">swpd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">swpd</span><span class="p">);</span>

	<span class="n">uasm_l_vmalloc</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">not_refill</span> <span class="o">&amp;&amp;</span> <span class="n">check_for_high_segbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">single_insn_swpd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uasm_il_bltz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">bvaddr</span><span class="p">,</span> <span class="n">label_vmalloc_done</span><span class="p">);</span>
			<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_hi</span><span class="p">(</span><span class="n">swpd</span><span class="p">));</span>
			<span class="n">did_vmalloc_branch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_il_bgez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">bvaddr</span><span class="p">,</span> <span class="n">label_large_segbits_fault</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">did_vmalloc_branch</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uasm_in_compat_space_p</span><span class="p">(</span><span class="n">swpd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">swpd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">label_vmalloc_done</span><span class="p">);</span>
			<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_hi</span><span class="p">(</span><span class="n">swpd</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">swpd</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">label_vmalloc_done</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uasm_in_compat_space_p</span><span class="p">(</span><span class="n">swpd</span><span class="p">))</span>
				<span class="n">uasm_i_addiu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">swpd</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">uasm_i_daddiu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">swpd</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">not_refill</span> <span class="o">&amp;&amp;</span> <span class="n">check_for_high_segbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uasm_l_large_segbits_fault</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We get here if we are an xsseg address, or if we are</span>
<span class="cm">		 * an xuseg address above (PGDIR_SHIFT+PGDIR_BITS) boundary.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Ignoring xsseg (assume disabled so would generate</span>
<span class="cm">		 * (address errors?), the only remaining possibility</span>
<span class="cm">		 * is the upper xuseg addresses.  On processors with</span>
<span class="cm">		 * TLB_SEGBITS &lt;= PGDIR_SHIFT+PGDIR_BITS, these</span>
<span class="cm">		 * addresses would have taken an address error. We try</span>
<span class="cm">		 * to mimic that here by taking a load/istream page</span>
<span class="cm">		 * fault.</span>
<span class="cm">		 */</span>
		<span class="n">UASM_i_LA</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_0</span><span class="p">);</span>
		<span class="n">uasm_i_jr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">refill_scratch</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scratch_reg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">scratch_reg</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * TMP and PTR are scratch.</span>
<span class="cm"> * TMP will be clobbered, PTR will hold the pgd entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="n">__maybe_unused</span>
<span class="nf">build_get_pgde32</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">pgdc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pgd_current</span><span class="p">;</span>

	<span class="cm">/* 32 bit SMP has smp_processor_id() stored in CONTEXT. */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#ifdef  CONFIG_MIPS_MT_SMTC</span>
	<span class="cm">/*</span>
<span class="cm">	 * SMTC uses TCBind value as &quot;CPU&quot; index</span>
<span class="cm">	 */</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_TCBIND</span><span class="p">);</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pgdc</span><span class="p">);</span>
	<span class="n">uasm_i_srl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * smp_processor_id() &lt;&lt; 3 is stored in CONTEXT.</span>
<span class="cm">         */</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pgdc</span><span class="p">);</span>
	<span class="n">uasm_i_srl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">UASM_i_LA_mostly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">pgdc</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span> <span class="cm">/* get faulting address */</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">pgdc</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">uasm_i_srl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span><span class="p">);</span> <span class="cm">/* get pgd only bits */</span>
	<span class="n">uasm_i_sll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGD_T_LOG2</span><span class="p">);</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* add in pgd offset */</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_64BIT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_adjust_context</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">PTE_T_LOG2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">12</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PTE_T_LOG2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_VR41XX</span>:
	<span class="k">case</span> <span class="n">CPU_VR4111</span>:
	<span class="k">case</span> <span class="n">CPU_VR4121</span>:
	<span class="k">case</span> <span class="n">CPU_VR4122</span>:
	<span class="k">case</span> <span class="n">CPU_VR4131</span>:
	<span class="k">case</span> <span class="n">CPU_VR4181</span>:
	<span class="k">case</span> <span class="n">CPU_VR4181A</span>:
	<span class="k">case</span> <span class="n">CPU_VR4133</span>:
		<span class="n">shift</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_get_ptep</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bug workaround for the Nevada. It seems as if under certain</span>
<span class="cm">	 * circumstances the move from cp0_context might produce a</span>
<span class="cm">	 * bogus result when the mfc0 instruction and its consumer are</span>
<span class="cm">	 * in a different cacheline or a load instruction, probably any</span>
<span class="cm">	 * memory reference, is between them.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_NEVADA</span>:
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">GET_CONTEXT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* get context reg */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">GET_CONTEXT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* get context reg */</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">build_adjust_context</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">UASM_i_ADDU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* add in offset */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_update_entries</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * 64bit address support (36bit on a 32bit CPU) in a 32bit</span>
<span class="cm">	 * Kernel is a special case. Only a few CPUs use it.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_64bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get even pte */</span>
		<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get odd pte */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
			<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
			<span class="n">UASM_i_ROTR</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
			<span class="n">UASM_i_ROTR</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span> <span class="cm">/* convert to entrylo0 */</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
			<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span> <span class="cm">/* convert to entrylo1 */</span>
		<span class="p">}</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span> <span class="cm">/* load it */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pte_off_even</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pte_off_odd</span> <span class="o">=</span> <span class="n">pte_off_even</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">);</span>

		<span class="cm">/* The pte entries are pre-shifted */</span>
		<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">pte_off_even</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get even pte */</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
		<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte_off_odd</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get odd pte */</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span> <span class="cm">/* load it */</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get even pte */</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span> <span class="n">ptep</span><span class="p">);</span> <span class="cm">/* get odd pte */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r45k_bvahwbug</span><span class="p">())</span>
		<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">UASM_i_ROTR</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r4k_250MHZhwbug</span><span class="p">())</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
		<span class="n">UASM_i_ROTR</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span> <span class="cm">/* convert to entrylo0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r4k_250MHZhwbug</span><span class="p">())</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
		<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span> <span class="cm">/* convert to entrylo1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r45k_bvahwbug</span><span class="p">())</span>
			<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_INDEX</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r4k_250MHZhwbug</span><span class="p">())</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span>
	<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span> <span class="cm">/* load it */</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mips_huge_tlb_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">huge_pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">restore_scratch</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mips_huge_tlb_info</span> <span class="n">__cpuinit</span>
<span class="nf">build_fast_tlb_refill_handler</span> <span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c0_scratch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mips_huge_tlb_info</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">even</span><span class="p">,</span> <span class="n">odd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vmalloc_branch_delay_filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">scratch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Our extra working register */</span>

	<span class="n">rv</span><span class="p">.</span><span class="n">huge_pte</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>
	<span class="n">rv</span><span class="p">.</span><span class="n">restore_scratch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_for_high_segbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">pgd_reg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c0_scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">c0_scratch</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span>
				 <span class="n">PGDIR_SHIFT</span> <span class="o">+</span> <span class="n">PGD_ORDER</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">label_vmalloc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmalloc_branch_delay_filled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Clear lower 23 bits of context. */</span>
			<span class="n">uasm_i_dins</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">pgd_reg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>

		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c0_scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">c0_scratch</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* Clear lower 23 bits of context. */</span>
			<span class="n">uasm_i_dins</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>

		<span class="n">uasm_il_bltz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">label_vmalloc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vmalloc_branch_delay_filled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* 1 0  1 0 1  &lt;&lt; 6  xkphys cached */</span>
		<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mh">0x540</span><span class="p">);</span>
		<span class="n">uasm_i_drotr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef __PAGETABLE_PMD_FOLDED</span>
<span class="cp">#define LOC_PTEP scratch</span>
<span class="cp">#else</span>
<span class="cp">#define LOC_PTEP ptr</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmalloc_branch_delay_filled</span><span class="p">)</span>
		<span class="cm">/* get pgd offset in bytes */</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">uasm_l_vmalloc_done</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *                         tmp          ptr</span>
<span class="cm">	 * fall-through case =   badvaddr  *pgd_current</span>
<span class="cm">	 * vmalloc case      =   badvaddr  swapper_pg_dir</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmalloc_branch_delay_filled</span><span class="p">)</span>
		<span class="cm">/* get pgd offset in bytes */</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PGDIR_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>

<span class="cp">#ifdef __PAGETABLE_PMD_FOLDED</span>
	<span class="n">GET_CONTEXT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* get context reg */</span>
<span class="cp">#endif</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="p">(</span><span class="n">PTRS_PER_PGD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_lwx_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">UASM_i_LWX</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">LOC_PTEP</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_i_daddu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span> <span class="cm">/* add in pgd offset */</span>
		<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">LOC_PTEP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* get pmd pointer */</span>
	<span class="p">}</span>

<span class="cp">#ifndef __PAGETABLE_PMD_FOLDED</span>
	<span class="cm">/* get pmd offset in bytes */</span>
	<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PMD_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">GET_CONTEXT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* get context reg */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_lwx_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">UASM_i_LWX</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_i_daddu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">scratch</span><span class="p">);</span> <span class="cm">/* add in pmd offset */</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Adjust the context during the load latency. */</span>
	<span class="n">build_adjust_context</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="n">uasm_il_bbit1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_HUGE</span><span class="p">),</span> <span class="n">label_tlb_huge_update</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The in the LWX case we don&#39;t want to do the load in the</span>
<span class="cm">	 * delay slot.  It cannot issue in the same cycle and may be</span>
<span class="cm">	 * speculative and unneeded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_lwx_insns</span><span class="p">())</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HUGETLB_PAGE */</span><span class="cp"></span>


	<span class="cm">/* build_update_entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_lwx_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">even</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">odd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">UASM_i_LWX</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">UASM_i_ADDIU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">));</span>
		<span class="n">UASM_i_LWX</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">UASM_i_ADDU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span> <span class="cm">/* add in offset */</span>
		<span class="n">even</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">odd</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* get even pte */</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* get odd pte */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">uasm_i_drotr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span>
			     <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
		<span class="n">uasm_i_drotr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span>
			     <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_NO_EXEC</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">even</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* load it */</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_GLOBAL</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">odd</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span> <span class="cm">/* load it */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c0_scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">c0_scratch</span><span class="p">);</span>
		<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tlb_random</span><span class="p">);</span>
		<span class="n">uasm_l_leave</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="n">rv</span><span class="p">.</span><span class="n">restore_scratch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">||</span> <span class="n">PAGE_SHIFT</span> <span class="o">==</span> <span class="mi">13</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tlb_random</span><span class="p">);</span>
		<span class="n">uasm_l_leave</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">scratchpad_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tlb_random</span><span class="p">);</span>
		<span class="n">uasm_l_leave</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="n">rv</span><span class="p">.</span><span class="n">restore_scratch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uasm_i_eret</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* return from trap */</span>

	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For a 64-bit kernel, we are using the 64-bit XTLB refill exception</span>
<span class="cm"> * because EXL == 0.  If we wrap, we can also use the 32 instruction</span>
<span class="cm"> * slots before the XTLB refill exception handler which belong to the</span>
<span class="cm"> * unused TLB refill exception.</span>
<span class="cm"> */</span>
<span class="cp">#define MIPS64_REFILL_INSNS 32</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r4000_tlb_refill_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tlb_handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">final_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mips_huge_tlb_info</span> <span class="n">htlb_info</span> <span class="n">__maybe_unused</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">vmalloc64_mode</span> <span class="n">vmalloc_mode</span> <span class="n">__maybe_unused</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tlb_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlb_handler</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">final_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">final_handler</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">scratch_reg</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">scratchpad_available</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">htlb_info</span> <span class="o">=</span> <span class="n">build_fast_tlb_refill_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span>
							  <span class="n">scratch_reg</span><span class="p">);</span>
		<span class="n">vmalloc_mode</span> <span class="o">=</span> <span class="n">refill_scratch</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">htlb_info</span><span class="p">.</span><span class="n">huge_pte</span> <span class="o">=</span> <span class="n">K0</span><span class="p">;</span>
		<span class="n">htlb_info</span><span class="p">.</span><span class="n">restore_scratch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">vmalloc_mode</span> <span class="o">=</span> <span class="n">refill_noscratch</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * create the plain linear handler</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcm1250_m3_war</span><span class="p">())</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segbits</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span>

			<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
			<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">C0_ENTRYHI</span><span class="p">);</span>
			<span class="n">uasm_i_xor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
			<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>
			<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">uasm_i_dsll_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">64</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">segbits</span><span class="p">);</span>
			<span class="n">uasm_i_or</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
			<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">label_leave</span><span class="p">);</span>
			<span class="cm">/* No need for uasm_i_nop */</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
		<span class="n">build_get_pmde64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span> <span class="cm">/* get pmd in K1 */</span>
<span class="cp">#else</span>
		<span class="n">build_get_pgde32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span> <span class="cm">/* get pgd in K1 */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
		<span class="n">build_is_huge_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">label_tlb_huge_update</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">build_get_ptep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
		<span class="n">build_update_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
		<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">tlb_random</span><span class="p">);</span>
		<span class="n">uasm_l_leave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_eret</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* return from trap */</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="n">uasm_l_tlb_huge_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">build_huge_update_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">htlb_info</span><span class="p">.</span><span class="n">huge_pte</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_huge_tlb_write_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">tlb_random</span><span class="p">,</span>
				   <span class="n">htlb_info</span><span class="p">.</span><span class="n">restore_scratch</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">build_get_pgd_vmalloc64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">vmalloc_mode</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Overflow check: For the 64bit handler, we need at least one</span>
<span class="cm">	 * free instruction slot for the wrap-around branch. In worst</span>
<span class="cm">	 * case, if the intended insertion point is a delay slot, we</span>
<span class="cm">	 * need three, with the second nop&#39;ed and the third being</span>
<span class="cm">	 * unused.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Loongson2 ebase is different than r4k, we have more space */</span>
<span class="cp">#if defined(CONFIG_32BIT) || defined(CONFIG_CPU_LOONGSON2)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB refill handler space exceeded&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MIPS64_REFILL_INSNS</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(((</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MIPS64_REFILL_INSNS</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">uasm_insn_has_bdelay</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span>
					<span class="n">tlb_handler</span> <span class="o">+</span> <span class="n">MIPS64_REFILL_INSNS</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB refill handler space exceeded&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now fold the handler in the TLB refill handler space.</span>
<span class="cm">	 */</span>
<span class="cp">#if defined(CONFIG_32BIT) || defined(CONFIG_CPU_LOONGSON2)</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">final_handler</span><span class="p">;</span>
	<span class="cm">/* Simplest case, just copy the handler. */</span>
	<span class="n">uasm_copy_handler</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">tlb_handler</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="n">final_len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">final_handler</span> <span class="o">+</span> <span class="n">MIPS64_REFILL_INSNS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MIPS64_REFILL_INSNS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Just copy the handler. */</span>
		<span class="n">uasm_copy_handler</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">tlb_handler</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">final_len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_HUGETLB_PAGE)</span>
		<span class="k">const</span> <span class="k">enum</span> <span class="n">label_id</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">label_tlb_huge_update</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">const</span> <span class="k">enum</span> <span class="n">label_id</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">label_vmalloc</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lab</span> <span class="o">!=</span> <span class="n">ls</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
		<span class="n">split</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * See if we have overflown one way or the other.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">&gt;</span> <span class="n">tlb_handler</span> <span class="o">+</span> <span class="n">MIPS64_REFILL_INSNS</span> <span class="o">||</span>
		    <span class="n">split</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">-</span> <span class="n">MIPS64_REFILL_INSNS</span><span class="p">)</span>
			<span class="n">ov</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ov</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Split two instructions before the end.  One</span>
<span class="cm">			 * for the branch and one for the instruction</span>
<span class="cm">			 * in the delay slot.</span>
<span class="cm">			 */</span>
			<span class="n">split</span> <span class="o">=</span> <span class="n">tlb_handler</span> <span class="o">+</span> <span class="n">MIPS64_REFILL_INSNS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the branch would fall in a delay slot,</span>
<span class="cm">			 * we must back up an additional instruction</span>
<span class="cm">			 * so that it is no longer in a delay slot.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uasm_insn_has_bdelay</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">split</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">split</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Copy first part of the handler. */</span>
		<span class="n">uasm_copy_handler</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">tlb_handler</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">f</span> <span class="o">+=</span> <span class="n">split</span> <span class="o">-</span> <span class="n">tlb_handler</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ov</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Insert branch. */</span>
			<span class="n">uasm_l_split</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">final_handler</span><span class="p">);</span>
			<span class="n">uasm_il_b</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">label_split</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uasm_insn_has_bdelay</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">split</span><span class="p">))</span>
				<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">uasm_copy_handler</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span>
						  <span class="n">split</span><span class="p">,</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
				<span class="n">uasm_move_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">f</span><span class="o">++</span><span class="p">;</span>
				<span class="n">split</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Copy the rest of the handler. */</span>
		<span class="n">uasm_copy_handler</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">final_handler</span><span class="p">);</span>
		<span class="n">final_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="p">(</span><span class="n">final_handler</span> <span class="o">+</span> <span class="n">MIPS64_REFILL_INSNS</span><span class="p">))</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">split</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB refill handler (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">final_len</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ebase</span><span class="p">,</span> <span class="n">final_handler</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

	<span class="n">dump_handler</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ebase</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 128 instructions for the fastpath handler is generous and should</span>
<span class="cm"> * never be exceeded.</span>
<span class="cm"> */</span>
<span class="cp">#define FASTPATH_SIZE 128</span>

<span class="n">u32</span> <span class="n">handle_tlbl</span><span class="p">[</span><span class="n">FASTPATH_SIZE</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>
<span class="n">u32</span> <span class="n">handle_tlbs</span><span class="p">[</span><span class="n">FASTPATH_SIZE</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>
<span class="n">u32</span> <span class="n">handle_tlbm</span><span class="p">[</span><span class="n">FASTPATH_SIZE</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MIPS_PGD_C0_CONTEXT</span>
<span class="n">u32</span> <span class="n">tlbmiss_handler_setup_pgd</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">__cacheline_aligned</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r4000_setup_pgd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tlbmiss_handler_setup_pgd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">pgd_reg</span> <span class="o">=</span> <span class="n">allocate_kscratch</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PGD &lt;&lt; 11 in c0_Context */</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it is a ckseg0 address, convert to a physical</span>
<span class="cm">		 * address.  Shifting right by 29 and adding 4 will</span>
<span class="cm">		 * result in zero for these addresses.</span>
<span class="cm">		 *</span>
<span class="cm">		 */</span>
		<span class="n">UASM_i_SRA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">UASM_i_ADDIU</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">label_tlbl_goaround1</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">uasm_i_dinsm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">64</span> <span class="o">-</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">uasm_l_tlbl_goaround1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">UASM_i_SLL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
		<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* PGD in c0_KScratch */</span>
		<span class="n">uasm_i_jr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">UASM_i_MTC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="n">pgd_reg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlbmiss_handler_setup_pgd</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;tlbmiss_handler_setup_pgd space exceeded&quot;</span><span class="p">);</span>
	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote tlbmiss_handler_setup_pgd (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">tlbmiss_handler_setup_pgd</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">,</span>
		     <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">iPTE_LW</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_64bits</span><span class="p">)</span>
		<span class="n">uasm_i_lld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp"># endif</span>
		<span class="n">UASM_i_LL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_64bits</span><span class="p">)</span>
		<span class="n">uasm_i_ld</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp"># endif</span>
		<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">iPTE_SW</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwmode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_64bits</span><span class="p">)</span>
		<span class="n">uasm_i_scd</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp"># endif</span>
		<span class="n">UASM_i_SC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r10000_llsc_war</span><span class="p">())</span>
		<span class="n">uasm_il_beqzl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">label_smp_pgtable_change</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">label_smp_pgtable_change</span><span class="p">);</span>

<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_64bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no uasm_i_nop needed */</span>
		<span class="n">uasm_i_ll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">);</span>
		<span class="n">uasm_i_sc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">label_smp_pgtable_change</span><span class="p">);</span>
		<span class="cm">/* no uasm_i_nop needed */</span>
		<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp"># else</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp"># endif</span>
<span class="cp">#else</span>
<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_64bits</span><span class="p">)</span>
		<span class="n">uasm_i_sd</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp"># endif</span>
		<span class="n">UASM_i_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

<span class="cp"># ifdef CONFIG_64BIT_PHYS_ADDR</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_64bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">hwmode</span><span class="p">);</span>
		<span class="n">uasm_i_sw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if PTE is present, if not then jump to LABEL. PTR points to</span>
<span class="cm"> * the page table where this PTE is located, PTE will be re-loaded</span>
<span class="cm"> * with it&#39;s original value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_pte_present</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scratch</span><span class="p">,</span> <span class="k">enum</span> <span class="n">label_id</span> <span class="n">lid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">scratch</span> <span class="o">:</span> <span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_PRESENT</span><span class="p">),</span> <span class="n">lid</span><span class="p">);</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">_PAGE_PRESENT</span><span class="p">);</span>
			<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
				<span class="cm">/* You lose the SMP race :-(*/</span>
				<span class="n">iPTE_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_READ</span><span class="p">);</span>
		<span class="n">uasm_i_xori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_READ</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
			<span class="cm">/* You lose the SMP race :-(*/</span>
			<span class="n">iPTE_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Make PTE valid, store result in PTR. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_make_valid</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span>

	<span class="n">iPTE_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if PTE can be written to, if not branch to LABEL. Regardless</span>
<span class="cm"> * restore PTE with value from PTR when done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_pte_writable</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scratch</span><span class="p">,</span>
		   <span class="k">enum</span> <span class="n">label_id</span> <span class="n">lid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">scratch</span> <span class="o">:</span> <span class="n">pte</span><span class="p">;</span>

	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_WRITE</span><span class="p">);</span>
	<span class="n">uasm_i_xori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_PAGE_PRESENT</span> <span class="o">|</span> <span class="n">_PAGE_WRITE</span><span class="p">);</span>
	<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
		<span class="cm">/* You lose the SMP race :-(*/</span>
		<span class="n">iPTE_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Make PTE writable, update software status bits as well, then store</span>
<span class="cm"> * at PTR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_make_write</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_MODIFIED</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span>
			     <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">);</span>

	<span class="n">iPTE_SW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if PTE can be modified, if not branch to LABEL. Regardless</span>
<span class="cm"> * restore PTE with value from PTR when done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_pte_modifiable</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scratch</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">label_id</span> <span class="n">lid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_WRITE</span><span class="p">),</span> <span class="n">lid</span><span class="p">);</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">scratch</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">scratch</span> <span class="o">:</span> <span class="n">pte</span><span class="p">;</span>
		<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">_PAGE_WRITE</span><span class="p">);</span>
		<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
			<span class="cm">/* You lose the SMP race :-(*/</span>
			<span class="n">iPTE_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_MIPS_PGD_C0_CONTEXT</span>


<span class="cm">/*</span>
<span class="cm"> * R3000 style TLB load/store/modify handlers.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This places the pte into ENTRYLO0 and writes it with tlbwi.</span>
<span class="cm"> * Then it returns.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_r3000_pte_reload_tlbwi</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_EPC</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_tlbwi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">uasm_i_rfe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* branch delay */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This places the pte into ENTRYLO0 and writes it with tlbwi</span>
<span class="cm"> * or tlbwr as appropriate.  This is because the index register</span>
<span class="cm"> * may have the probe fail bit set as a result of a trap on a</span>
<span class="cm"> * kseg2 access, i.e. without refill.  Then it returns.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_r3000_tlb_reload_write</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_INDEX</span><span class="p">);</span>
	<span class="n">uasm_i_mtc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_il_bltz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">label_r3000_write_probe_fail</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">C0_EPC</span><span class="p">);</span> <span class="cm">/* branch delay */</span>
	<span class="n">uasm_i_tlbwi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">uasm_i_rfe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* branch delay */</span>
	<span class="n">uasm_l_r3000_write_probe_fail</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_tlbwr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_jr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">uasm_i_rfe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* branch delay */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_r3000_tlbchange_handler_head</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pte</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">pgdc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">pgd_current</span><span class="p">;</span>

	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
	<span class="n">uasm_i_lui</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_hi</span><span class="p">(</span><span class="n">pgdc</span><span class="p">));</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">uasm_rel_lo</span><span class="p">(</span><span class="n">pgdc</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">uasm_i_srl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">uasm_i_sll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">uasm_i_mfc0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">C0_CONTEXT</span><span class="p">);</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="cm">/* cp0 delay */</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mh">0xffc</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">uasm_i_addu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="n">uasm_i_lw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">uasm_i_tlbp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* load delay */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r3000_tlb_load_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">build_r3000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_pte_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">build_make_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_r3000_tlb_reload_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>

	<span class="n">uasm_l_nopage_tlbl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_0</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB load handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB load handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbl</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r3000_tlb_store_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">build_r3000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_pte_writable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_nopage_tlbs</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">build_make_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_r3000_tlb_reload_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>

	<span class="n">uasm_l_nopage_tlbs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_1</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB store handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB store handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbs</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r3000_tlb_modify_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">build_r3000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_pte_modifiable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_nopage_tlbm</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* load delay */</span>
	<span class="n">build_make_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
	<span class="n">build_r3000_pte_reload_tlbwi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>

	<span class="n">uasm_l_nopage_tlbm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_1</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB modify handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB modify handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbm</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_PGD_C0_CONTEXT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * R4000 style TLB load/store/modify handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">work_registers</span> <span class="n">__cpuinit</span>
<span class="nf">build_r4000_tlbchange_handler_head</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_registers</span> <span class="n">wr</span> <span class="o">=</span> <span class="n">build_get_work_registers</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">build_get_pmde64</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span> <span class="cm">/* get pmd in ptr */</span>
<span class="cp">#else</span>
	<span class="n">build_get_pgde32</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span> <span class="cm">/* get pgd in ptr */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="cm">/*</span>
<span class="cm">	 * For huge tlb entries, pmd doesn&#39;t contain an address but</span>
<span class="cm">	 * instead contains the tlb pte. Check the PAGE_HUGE bit and</span>
<span class="cm">	 * see if we need to jump to huge tlb processing.</span>
<span class="cm">	 */</span>
	<span class="n">build_is_huge_pte</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">label_tlb_huge_update</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
	<span class="n">UASM_i_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">UASM_i_SRL</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">PTE_ORDER</span> <span class="o">-</span> <span class="n">PTE_T_LOG2</span><span class="p">);</span>
	<span class="n">uasm_i_andi</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="p">(</span><span class="n">PTRS_PER_PTE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PTE_T_LOG2</span><span class="p">);</span>
	<span class="n">UASM_i_ADDU</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">uasm_l_smp_pgtable_change</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">iPTE_LW</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span> <span class="cm">/* get even pte */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m4kc_tlbp_war</span><span class="p">())</span>
		<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span>
<span class="nf">build_r4000_tlbchange_handler_tail</span><span class="p">(</span><span class="n">u32</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">**</span><span class="n">l</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">**</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">));</span>
	<span class="n">uasm_i_xori</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">));</span>
	<span class="n">build_update_entries</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">build_tlb_write_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tlb_indexed</span><span class="p">);</span>
	<span class="n">uasm_l_leave</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="n">build_restore_work_registers</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_eret</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* return from trap */</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">build_get_pgd_vmalloc64</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">not_refill</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r4000_tlb_load_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_registers</span> <span class="n">wr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bcm1250_m3_war</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segbits</span> <span class="o">=</span> <span class="mi">44</span><span class="p">;</span>

		<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">C0_BADVADDR</span><span class="p">);</span>
		<span class="n">uasm_i_dmfc0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">C0_ENTRYHI</span><span class="p">);</span>
		<span class="n">uasm_i_xor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>
		<span class="n">uasm_i_dsrl_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">uasm_i_dsll_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="mi">64</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">segbits</span><span class="p">);</span>
		<span class="n">uasm_i_or</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">);</span>
		<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">label_leave</span><span class="p">);</span>
		<span class="cm">/* No need for uasm_i_nop */</span>
	<span class="p">}</span>

	<span class="n">wr</span> <span class="o">=</span> <span class="n">build_r4000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="n">build_pte_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m4kc_tlbp_war</span><span class="p">())</span>
		<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the page is not _PAGE_VALID, RI or XI could not</span>
<span class="cm">		 * have triggered it.  Skip the expensive test..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_VALID</span><span class="p">),</span>
				      <span class="n">label_tlbl_goaround1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">_PAGE_VALID</span><span class="p">);</span>
			<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_tlbl_goaround1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

		<span class="n">uasm_i_tlbr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/* Examine  entrylo 0 or 1 based on ptr. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_i_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">));</span>
			<span class="n">uasm_i_beqz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* load it in the delay slot*/</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span>
		<span class="cm">/* load it if ptr is odd */</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the entryLo (now in wr.r3) is valid (bit 1), RI or</span>
<span class="cm">		 * XI must have triggered it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_il_bbit1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">);</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
			<span class="n">uasm_l_tlbl_goaround1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">uasm_il_bnez</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">);</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">uasm_l_tlbl_goaround1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">build_make_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_r4000_tlbchange_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is the entry point when build_r4000_tlbchange_handler_head</span>
<span class="cm">	 * spots a huge page.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_l_tlb_huge_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">iPTE_LW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_pte_present</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">);</span>
	<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_uses_smartmips_rixi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the page is not _PAGE_VALID, RI or XI could not</span>
<span class="cm">		 * have triggered it.  Skip the expensive test..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">_PAGE_VALID</span><span class="p">),</span>
				      <span class="n">label_tlbl_goaround2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">_PAGE_VALID</span><span class="p">);</span>
			<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_tlbl_goaround2</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

		<span class="n">uasm_i_tlbr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/* Examine  entrylo 0 or 1 based on ptr. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_i_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">)),</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pte_t</span><span class="p">));</span>
			<span class="n">uasm_i_beqz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* load it in the delay slot*/</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">C0_ENTRYLO0</span><span class="p">);</span>
		<span class="cm">/* load it if ptr is odd */</span>
		<span class="n">UASM_i_MFC0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">C0_ENTRYLO1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the entryLo (now in wr.r3) is valid (bit 1), RI or</span>
<span class="cm">		 * XI must have triggered it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_bbit_insns</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">uasm_il_bbit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label_tlbl_goaround2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uasm_i_andi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">uasm_il_beqz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_tlbl_goaround2</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PM_DEFAULT_MASK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We clobbered C0_PAGEMASK, restore it.  On the other branch</span>
<span class="cm">		 * it is restored in build_huge_tlb_write_entry.</span>
<span class="cm">		 */</span>
		<span class="n">build_restore_pagemask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">uasm_l_tlbl_goaround2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="p">(</span><span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span><span class="p">));</span>
	<span class="n">build_huge_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uasm_l_nopage_tlbl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">build_restore_work_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_0</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB load handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB load handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbl</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r4000_tlb_store_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_registers</span> <span class="n">wr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">wr</span> <span class="o">=</span> <span class="n">build_r4000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="n">build_pte_writable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m4kc_tlbp_war</span><span class="p">())</span>
		<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">build_make_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_r4000_tlbchange_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is the entry point when</span>
<span class="cm">	 * build_r4000_tlbchange_handler_head spots a huge page.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_l_tlb_huge_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">iPTE_LW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_pte_writable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbs</span><span class="p">);</span>
	<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span>
		   <span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_MODIFIED</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">);</span>
	<span class="n">build_huge_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uasm_l_nopage_tlbs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">build_restore_work_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_1</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB store handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB store handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbs</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_r4000_tlb_modify_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">handle_tlbm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_label</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uasm_reloc</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">relocs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_registers</span> <span class="n">wr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">labels</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">relocs</span><span class="p">));</span>

	<span class="n">wr</span> <span class="o">=</span> <span class="n">build_r4000_tlbchange_handler_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="n">build_pte_modifiable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m4kc_tlbp_war</span><span class="p">())</span>
		<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* Present and writable bits set, set accessed and dirty bits. */</span>
	<span class="n">build_make_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_r4000_tlbchange_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is the entry point when</span>
<span class="cm">	 * build_r4000_tlbchange_handler_head spots a huge page.</span>
<span class="cm">	 */</span>
	<span class="n">uasm_l_tlb_huge_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">iPTE_LW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
	<span class="n">build_pte_modifiable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">,</span>  <span class="n">wr</span><span class="p">.</span><span class="n">r3</span><span class="p">,</span> <span class="n">label_nopage_tlbm</span><span class="p">);</span>
	<span class="n">build_tlb_probe_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_ori</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span>
		   <span class="n">_PAGE_ACCESSED</span> <span class="o">|</span> <span class="n">_PAGE_MODIFIED</span> <span class="o">|</span> <span class="n">_PAGE_VALID</span> <span class="o">|</span> <span class="n">_PAGE_DIRTY</span><span class="p">);</span>
	<span class="n">build_huge_handler_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r1</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">r2</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uasm_l_nopage_tlbm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">build_restore_work_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">uasm_i_j</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlb_do_page_fault_1</span> <span class="o">&amp;</span> <span class="mh">0x0fffffff</span><span class="p">);</span>
	<span class="n">uasm_i_nop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FASTPATH_SIZE</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TLB modify handler fastpath space exceeded&quot;</span><span class="p">);</span>

	<span class="n">uasm_resolve_relocs</span><span class="p">(</span><span class="n">relocs</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Wrote TLB modify handler fastpath (%u instructions).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">handle_tlbm</span><span class="p">));</span>

	<span class="n">dump_handler</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">build_tlb_refill_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The refill handler is generated per-CPU, multi-node systems</span>
<span class="cm">	 * may have local storage for it. The other handlers are only</span>
<span class="cm">	 * needed once.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">run_once</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_64BIT</span>
	<span class="n">check_for_high_segbits</span> <span class="o">=</span> <span class="n">current_cpu_data</span><span class="p">.</span><span class="n">vmbits</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PGDIR_SHIFT</span> <span class="o">+</span> <span class="n">PGD_ORDER</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_cpu_type</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_R2000</span>:
	<span class="k">case</span> <span class="n">CPU_R3000</span>:
	<span class="k">case</span> <span class="n">CPU_R3000A</span>:
	<span class="k">case</span> <span class="n">CPU_R3081E</span>:
	<span class="k">case</span> <span class="n">CPU_TX3912</span>:
	<span class="k">case</span> <span class="n">CPU_TX3922</span>:
	<span class="k">case</span> <span class="n">CPU_TX3927</span>:
<span class="cp">#ifndef CONFIG_MIPS_PGD_C0_CONTEXT</span>
		<span class="n">build_r3000_tlb_refill_handler</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_once</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">build_r3000_tlb_load_handler</span><span class="p">();</span>
			<span class="n">build_r3000_tlb_store_handler</span><span class="p">();</span>
			<span class="n">build_r3000_tlb_modify_handler</span><span class="p">();</span>
			<span class="n">run_once</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No R3000 TLB refill handler&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_R6000</span>:
	<span class="k">case</span> <span class="n">CPU_R6000A</span>:
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No R6000 TLB refill handler yet&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_R8000</span>:
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No R8000 TLB refill handler yet&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_once</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scratch_reg</span> <span class="o">=</span> <span class="n">allocate_kscratch</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_MIPS_PGD_C0_CONTEXT</span>
			<span class="n">build_r4000_setup_pgd</span><span class="p">();</span>
<span class="cp">#endif</span>
			<span class="n">build_r4000_tlb_load_handler</span><span class="p">();</span>
			<span class="n">build_r4000_tlb_store_handler</span><span class="p">();</span>
			<span class="n">build_r4000_tlb_modify_handler</span><span class="p">();</span>
			<span class="n">run_once</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">build_r4000_tlb_refill_handler</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">flush_tlb_handlers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbl</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbl</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbl</span><span class="p">));</span>
	<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbs</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbs</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbs</span><span class="p">));</span>
	<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbm</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">handle_tlbm</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_MIPS_PGD_C0_CONTEXT</span>
	<span class="n">local_flush_icache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlbmiss_handler_setup_pgd</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tlbmiss_handler_setup_pgd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">handle_tlbm</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
