<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › mipsregs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mipsregs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1994, 1995, 1996, 1997, 2000, 2001 by Ralf Baechle</span>
<span class="cm"> * Copyright (C) 2000 Silicon Graphics, Inc.</span>
<span class="cm"> * Modified for further R[236]000 support by Paul M. Antoine, 1996.</span>
<span class="cm"> * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com</span>
<span class="cm"> * Copyright (C) 2000, 07 MIPS Technologies, Inc.</span>
<span class="cm"> * Copyright (C) 2003, 2004  Maciej W. Rozycki</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_MIPSREGS_H</span>
<span class="cp">#define _ASM_MIPSREGS_H</span>

<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;asm/hazards.h&gt;</span>
<span class="cp">#include &lt;asm/war.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The following macros are especially useful for __asm__</span>
<span class="cm"> * inline assembler.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __STR</span>
<span class="cp">#define __STR(x) #x</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef STR</span>
<span class="cp">#define STR(x) __STR(x)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Configure language</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __ASSEMBLY__</span>
<span class="cp">#define _ULCAST_</span>
<span class="cp">#else</span>
<span class="cp">#define _ULCAST_ (unsigned long)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Coprocessor 0 register names</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_INDEX $0</span>
<span class="cp">#define CP0_RANDOM $1</span>
<span class="cp">#define CP0_ENTRYLO0 $2</span>
<span class="cp">#define CP0_ENTRYLO1 $3</span>
<span class="cp">#define CP0_CONF $3</span>
<span class="cp">#define CP0_CONTEXT $4</span>
<span class="cp">#define CP0_PAGEMASK $5</span>
<span class="cp">#define CP0_WIRED $6</span>
<span class="cp">#define CP0_INFO $7</span>
<span class="cp">#define CP0_BADVADDR $8</span>
<span class="cp">#define CP0_COUNT $9</span>
<span class="cp">#define CP0_ENTRYHI $10</span>
<span class="cp">#define CP0_COMPARE $11</span>
<span class="cp">#define CP0_STATUS $12</span>
<span class="cp">#define CP0_CAUSE $13</span>
<span class="cp">#define CP0_EPC $14</span>
<span class="cp">#define CP0_PRID $15</span>
<span class="cp">#define CP0_CONFIG $16</span>
<span class="cp">#define CP0_LLADDR $17</span>
<span class="cp">#define CP0_WATCHLO $18</span>
<span class="cp">#define CP0_WATCHHI $19</span>
<span class="cp">#define CP0_XCONTEXT $20</span>
<span class="cp">#define CP0_FRAMEMASK $21</span>
<span class="cp">#define CP0_DIAGNOSTIC $22</span>
<span class="cp">#define CP0_DEBUG $23</span>
<span class="cp">#define CP0_DEPC $24</span>
<span class="cp">#define CP0_PERFORMANCE $25</span>
<span class="cp">#define CP0_ECC $26</span>
<span class="cp">#define CP0_CACHEERR $27</span>
<span class="cp">#define CP0_TAGLO $28</span>
<span class="cp">#define CP0_TAGHI $29</span>
<span class="cp">#define CP0_ERROREPC $30</span>
<span class="cp">#define CP0_DESAVE $31</span>

<span class="cm">/*</span>
<span class="cm"> * R4640/R4650 cp0 register names.  These registers are listed</span>
<span class="cm"> * here only for completeness; without MMU these CPUs are not useable</span>
<span class="cm"> * by Linux.  A future ELKS port might take make Linux run on them</span>
<span class="cm"> * though ...</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_IBASE $0</span>
<span class="cp">#define CP0_IBOUND $1</span>
<span class="cp">#define CP0_DBASE $2</span>
<span class="cp">#define CP0_DBOUND $3</span>
<span class="cp">#define CP0_CALG $17</span>
<span class="cp">#define CP0_IWATCH $18</span>
<span class="cp">#define CP0_DWATCH $19</span>

<span class="cm">/*</span>
<span class="cm"> * Coprocessor 0 Set 1 register names</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_S1_DERRADDR0  $26</span>
<span class="cp">#define CP0_S1_DERRADDR1  $27</span>
<span class="cp">#define CP0_S1_INTCONTROL $20</span>

<span class="cm">/*</span>
<span class="cm"> * Coprocessor 0 Set 2 register names</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_S2_SRSCTL	  $12	</span><span class="cm">/* MIPSR2 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Coprocessor 0 Set 3 register names</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_S3_SRSMAP	  $12	</span><span class="cm">/* MIPSR2 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  TX39 Series</span>
<span class="cm"> */</span>
<span class="cp">#define CP0_TX39_CACHE	$7</span>

<span class="cm">/*</span>
<span class="cm"> * Coprocessor 1 (FPU) register names</span>
<span class="cm"> */</span>
<span class="cp">#define CP1_REVISION   $0</span>
<span class="cp">#define CP1_STATUS     $31</span>

<span class="cm">/*</span>
<span class="cm"> * FPU Status Register Values</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Status Register Values</span>
<span class="cm"> */</span>

<span class="cp">#define FPU_CSR_FLUSH   0x01000000      </span><span class="cm">/* flush denormalised results to 0 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND    0x00800000      </span><span class="cm">/* $fcc0 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND0   0x00800000      </span><span class="cm">/* $fcc0 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND1   0x02000000      </span><span class="cm">/* $fcc1 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND2   0x04000000      </span><span class="cm">/* $fcc2 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND3   0x08000000      </span><span class="cm">/* $fcc3 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND4   0x10000000      </span><span class="cm">/* $fcc4 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND5   0x20000000      </span><span class="cm">/* $fcc5 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND6   0x40000000      </span><span class="cm">/* $fcc6 */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_COND7   0x80000000      </span><span class="cm">/* $fcc7 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bits 18 - 20 of the FPU Status Register will be read as 0,</span>
<span class="cm"> * and should be written as zero.</span>
<span class="cm"> */</span>
<span class="cp">#define FPU_CSR_RSVD	0x001c0000</span>

<span class="cm">/*</span>
<span class="cm"> * X the exception cause indicator</span>
<span class="cm"> * E the exception enable</span>
<span class="cm"> * S the sticky/flag bit</span>
<span class="cm">*/</span>
<span class="cp">#define FPU_CSR_ALL_X   0x0003f000</span>
<span class="cp">#define FPU_CSR_UNI_X   0x00020000</span>
<span class="cp">#define FPU_CSR_INV_X   0x00010000</span>
<span class="cp">#define FPU_CSR_DIV_X   0x00008000</span>
<span class="cp">#define FPU_CSR_OVF_X   0x00004000</span>
<span class="cp">#define FPU_CSR_UDF_X   0x00002000</span>
<span class="cp">#define FPU_CSR_INE_X   0x00001000</span>

<span class="cp">#define FPU_CSR_ALL_E   0x00000f80</span>
<span class="cp">#define FPU_CSR_INV_E   0x00000800</span>
<span class="cp">#define FPU_CSR_DIV_E   0x00000400</span>
<span class="cp">#define FPU_CSR_OVF_E   0x00000200</span>
<span class="cp">#define FPU_CSR_UDF_E   0x00000100</span>
<span class="cp">#define FPU_CSR_INE_E   0x00000080</span>

<span class="cp">#define FPU_CSR_ALL_S   0x0000007c</span>
<span class="cp">#define FPU_CSR_INV_S   0x00000040</span>
<span class="cp">#define FPU_CSR_DIV_S   0x00000020</span>
<span class="cp">#define FPU_CSR_OVF_S   0x00000010</span>
<span class="cp">#define FPU_CSR_UDF_S   0x00000008</span>
<span class="cp">#define FPU_CSR_INE_S   0x00000004</span>

<span class="cm">/* Bits 0 and 1 of FPU Status Register specify the rounding mode */</span>
<span class="cp">#define FPU_CSR_RM	0x00000003</span>
<span class="cp">#define FPU_CSR_RN      0x0     </span><span class="cm">/* nearest */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_RZ      0x1     </span><span class="cm">/* towards zero */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_RU      0x2     </span><span class="cm">/* towards +Infinity */</span><span class="cp"></span>
<span class="cp">#define FPU_CSR_RD      0x3     </span><span class="cm">/* towards -Infinity */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Values for PageMask register</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CPU_VR41XX</span>

<span class="cm">/* Why doesn&#39;t stupidity hurt ... */</span>

<span class="cp">#define PM_1K		0x00000000</span>
<span class="cp">#define PM_4K		0x00001800</span>
<span class="cp">#define PM_16K		0x00007800</span>
<span class="cp">#define PM_64K		0x0001f800</span>
<span class="cp">#define PM_256K		0x0007f800</span>

<span class="cp">#else</span>

<span class="cp">#define PM_4K		0x00000000</span>
<span class="cp">#define PM_8K		0x00002000</span>
<span class="cp">#define PM_16K		0x00006000</span>
<span class="cp">#define PM_32K		0x0000e000</span>
<span class="cp">#define PM_64K		0x0001e000</span>
<span class="cp">#define PM_128K		0x0003e000</span>
<span class="cp">#define PM_256K		0x0007e000</span>
<span class="cp">#define PM_512K		0x000fe000</span>
<span class="cp">#define PM_1M		0x001fe000</span>
<span class="cp">#define PM_2M		0x003fe000</span>
<span class="cp">#define PM_4M		0x007fe000</span>
<span class="cp">#define PM_8M		0x00ffe000</span>
<span class="cp">#define PM_16M		0x01ffe000</span>
<span class="cp">#define PM_32M		0x03ffe000</span>
<span class="cp">#define PM_64M		0x07ffe000</span>
<span class="cp">#define PM_256M		0x1fffe000</span>
<span class="cp">#define PM_1G		0x7fffe000</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Default page size for a given kernel configuration</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PAGE_SIZE_4KB</span>
<span class="cp">#define PM_DEFAULT_MASK	PM_4K</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_8KB)</span>
<span class="cp">#define PM_DEFAULT_MASK	PM_8K</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_16KB)</span>
<span class="cp">#define PM_DEFAULT_MASK	PM_16K</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_32KB)</span>
<span class="cp">#define PM_DEFAULT_MASK	PM_32K</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_64KB)</span>
<span class="cp">#define PM_DEFAULT_MASK	PM_64K</span>
<span class="cp">#else</span>
<span class="cp">#error Bad page size configuration!</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Default huge tlb size for a given kernel configuration</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PAGE_SIZE_4KB</span>
<span class="cp">#define PM_HUGE_MASK	PM_1M</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_8KB)</span>
<span class="cp">#define PM_HUGE_MASK	PM_4M</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_16KB)</span>
<span class="cp">#define PM_HUGE_MASK	PM_16M</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_32KB)</span>
<span class="cp">#define PM_HUGE_MASK	PM_64M</span>
<span class="cp">#elif defined(CONFIG_PAGE_SIZE_64KB)</span>
<span class="cp">#define PM_HUGE_MASK	PM_256M</span>
<span class="cp">#elif defined(CONFIG_HUGETLB_PAGE)</span>
<span class="cp">#error Bad page size configuration for hugetlbfs!</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Values used for computation of new tlb entries</span>
<span class="cm"> */</span>
<span class="cp">#define PL_4K		12</span>
<span class="cp">#define PL_16K		14</span>
<span class="cp">#define PL_64K		16</span>
<span class="cp">#define PL_256K		18</span>
<span class="cp">#define PL_1M		20</span>
<span class="cp">#define PL_4M		22</span>
<span class="cp">#define PL_16M		24</span>
<span class="cp">#define PL_64M		26</span>
<span class="cp">#define PL_256M		28</span>

<span class="cm">/*</span>
<span class="cm"> * PageGrain bits</span>
<span class="cm"> */</span>
<span class="cp">#define PG_RIE		(_ULCAST_(1) &lt;&lt;  31)</span>
<span class="cp">#define PG_XIE		(_ULCAST_(1) &lt;&lt;  30)</span>
<span class="cp">#define PG_ELPA		(_ULCAST_(1) &lt;&lt;  29)</span>
<span class="cp">#define PG_ESP		(_ULCAST_(1) &lt;&lt;  28)</span>

<span class="cm">/*</span>
<span class="cm"> * R4x00 interrupt enable / cause bits</span>
<span class="cm"> */</span>
<span class="cp">#define IE_SW0          (_ULCAST_(1) &lt;&lt;  8)</span>
<span class="cp">#define IE_SW1          (_ULCAST_(1) &lt;&lt;  9)</span>
<span class="cp">#define IE_IRQ0         (_ULCAST_(1) &lt;&lt; 10)</span>
<span class="cp">#define IE_IRQ1         (_ULCAST_(1) &lt;&lt; 11)</span>
<span class="cp">#define IE_IRQ2         (_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define IE_IRQ3         (_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define IE_IRQ4         (_ULCAST_(1) &lt;&lt; 14)</span>
<span class="cp">#define IE_IRQ5         (_ULCAST_(1) &lt;&lt; 15)</span>

<span class="cm">/*</span>
<span class="cm"> * R4x00 interrupt cause bits</span>
<span class="cm"> */</span>
<span class="cp">#define C_SW0           (_ULCAST_(1) &lt;&lt;  8)</span>
<span class="cp">#define C_SW1           (_ULCAST_(1) &lt;&lt;  9)</span>
<span class="cp">#define C_IRQ0          (_ULCAST_(1) &lt;&lt; 10)</span>
<span class="cp">#define C_IRQ1          (_ULCAST_(1) &lt;&lt; 11)</span>
<span class="cp">#define C_IRQ2          (_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define C_IRQ3          (_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define C_IRQ4          (_ULCAST_(1) &lt;&lt; 14)</span>
<span class="cp">#define C_IRQ5          (_ULCAST_(1) &lt;&lt; 15)</span>

<span class="cm">/*</span>
<span class="cm"> * Bitfields in the R4xx0 cp0 status register</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_IE			0x00000001</span>
<span class="cp">#define ST0_EXL			0x00000002</span>
<span class="cp">#define ST0_ERL			0x00000004</span>
<span class="cp">#define ST0_KSU			0x00000018</span>
<span class="cp">#  define KSU_USER		0x00000010</span>
<span class="cp">#  define KSU_SUPERVISOR	0x00000008</span>
<span class="cp">#  define KSU_KERNEL		0x00000000</span>
<span class="cp">#define ST0_UX			0x00000020</span>
<span class="cp">#define ST0_SX			0x00000040</span>
<span class="cp">#define ST0_KX 			0x00000080</span>
<span class="cp">#define ST0_DE			0x00010000</span>
<span class="cp">#define ST0_CE			0x00020000</span>

<span class="cm">/*</span>
<span class="cm"> * Setting c0_status.co enables Hit_Writeback and Hit_Writeback_Invalidate</span>
<span class="cm"> * cacheops in userspace.  This bit exists only on RM7000 and RM9000</span>
<span class="cm"> * processors.</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_CO			0x08000000</span>

<span class="cm">/*</span>
<span class="cm"> * Bitfields in the R[23]000 cp0 status register.</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_IEC                 0x00000001</span>
<span class="cp">#define ST0_KUC			0x00000002</span>
<span class="cp">#define ST0_IEP			0x00000004</span>
<span class="cp">#define ST0_KUP			0x00000008</span>
<span class="cp">#define ST0_IEO			0x00000010</span>
<span class="cp">#define ST0_KUO			0x00000020</span>
<span class="cm">/* bits 6 &amp; 7 are reserved on R[23]000 */</span>
<span class="cp">#define ST0_ISC			0x00010000</span>
<span class="cp">#define ST0_SWC			0x00020000</span>
<span class="cp">#define ST0_CM			0x00080000</span>

<span class="cm">/*</span>
<span class="cm"> * Bits specific to the R4640/R4650</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_UM			(_ULCAST_(1) &lt;&lt;  4)</span>
<span class="cp">#define ST0_IL			(_ULCAST_(1) &lt;&lt; 23)</span>
<span class="cp">#define ST0_DL			(_ULCAST_(1) &lt;&lt; 24)</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the MIPS MDMX and DSP ASEs</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_MX			0x01000000</span>

<span class="cm">/*</span>
<span class="cm"> * Bitfields in the TX39 family CP0 Configuration Register 3</span>
<span class="cm"> */</span>
<span class="cp">#define TX39_CONF_ICS_SHIFT	19</span>
<span class="cp">#define TX39_CONF_ICS_MASK	0x00380000</span>
<span class="cp">#define TX39_CONF_ICS_1KB 	0x00000000</span>
<span class="cp">#define TX39_CONF_ICS_2KB 	0x00080000</span>
<span class="cp">#define TX39_CONF_ICS_4KB 	0x00100000</span>
<span class="cp">#define TX39_CONF_ICS_8KB 	0x00180000</span>
<span class="cp">#define TX39_CONF_ICS_16KB 	0x00200000</span>

<span class="cp">#define TX39_CONF_DCS_SHIFT	16</span>
<span class="cp">#define TX39_CONF_DCS_MASK	0x00070000</span>
<span class="cp">#define TX39_CONF_DCS_1KB 	0x00000000</span>
<span class="cp">#define TX39_CONF_DCS_2KB 	0x00010000</span>
<span class="cp">#define TX39_CONF_DCS_4KB 	0x00020000</span>
<span class="cp">#define TX39_CONF_DCS_8KB 	0x00030000</span>
<span class="cp">#define TX39_CONF_DCS_16KB 	0x00040000</span>

<span class="cp">#define TX39_CONF_CWFON 	0x00004000</span>
<span class="cp">#define TX39_CONF_WBON  	0x00002000</span>
<span class="cp">#define TX39_CONF_RF_SHIFT	10</span>
<span class="cp">#define TX39_CONF_RF_MASK	0x00000c00</span>
<span class="cp">#define TX39_CONF_DOZE		0x00000200</span>
<span class="cp">#define TX39_CONF_HALT		0x00000100</span>
<span class="cp">#define TX39_CONF_LOCK		0x00000080</span>
<span class="cp">#define TX39_CONF_ICE		0x00000020</span>
<span class="cp">#define TX39_CONF_DCE		0x00000010</span>
<span class="cp">#define TX39_CONF_IRSIZE_SHIFT	2</span>
<span class="cp">#define TX39_CONF_IRSIZE_MASK	0x0000000c</span>
<span class="cp">#define TX39_CONF_DRSIZE_SHIFT	0</span>
<span class="cp">#define TX39_CONF_DRSIZE_MASK	0x00000003</span>

<span class="cm">/*</span>
<span class="cm"> * Status register bits available in all MIPS CPUs.</span>
<span class="cm"> */</span>
<span class="cp">#define ST0_IM			0x0000ff00</span>
<span class="cp">#define  STATUSB_IP0		8</span>
<span class="cp">#define  STATUSF_IP0		(_ULCAST_(1) &lt;&lt;  8)</span>
<span class="cp">#define  STATUSB_IP1		9</span>
<span class="cp">#define  STATUSF_IP1		(_ULCAST_(1) &lt;&lt;  9)</span>
<span class="cp">#define  STATUSB_IP2		10</span>
<span class="cp">#define  STATUSF_IP2		(_ULCAST_(1) &lt;&lt; 10)</span>
<span class="cp">#define  STATUSB_IP3		11</span>
<span class="cp">#define  STATUSF_IP3		(_ULCAST_(1) &lt;&lt; 11)</span>
<span class="cp">#define  STATUSB_IP4		12</span>
<span class="cp">#define  STATUSF_IP4		(_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define  STATUSB_IP5		13</span>
<span class="cp">#define  STATUSF_IP5		(_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define  STATUSB_IP6		14</span>
<span class="cp">#define  STATUSF_IP6		(_ULCAST_(1) &lt;&lt; 14)</span>
<span class="cp">#define  STATUSB_IP7		15</span>
<span class="cp">#define  STATUSF_IP7		(_ULCAST_(1) &lt;&lt; 15)</span>
<span class="cp">#define  STATUSB_IP8		0</span>
<span class="cp">#define  STATUSF_IP8		(_ULCAST_(1) &lt;&lt;  0)</span>
<span class="cp">#define  STATUSB_IP9		1</span>
<span class="cp">#define  STATUSF_IP9		(_ULCAST_(1) &lt;&lt;  1)</span>
<span class="cp">#define  STATUSB_IP10		2</span>
<span class="cp">#define  STATUSF_IP10		(_ULCAST_(1) &lt;&lt;  2)</span>
<span class="cp">#define  STATUSB_IP11		3</span>
<span class="cp">#define  STATUSF_IP11		(_ULCAST_(1) &lt;&lt;  3)</span>
<span class="cp">#define  STATUSB_IP12		4</span>
<span class="cp">#define  STATUSF_IP12		(_ULCAST_(1) &lt;&lt;  4)</span>
<span class="cp">#define  STATUSB_IP13		5</span>
<span class="cp">#define  STATUSF_IP13		(_ULCAST_(1) &lt;&lt;  5)</span>
<span class="cp">#define  STATUSB_IP14		6</span>
<span class="cp">#define  STATUSF_IP14		(_ULCAST_(1) &lt;&lt;  6)</span>
<span class="cp">#define  STATUSB_IP15		7</span>
<span class="cp">#define  STATUSF_IP15		(_ULCAST_(1) &lt;&lt;  7)</span>
<span class="cp">#define ST0_CH			0x00040000</span>
<span class="cp">#define ST0_NMI			0x00080000</span>
<span class="cp">#define ST0_SR			0x00100000</span>
<span class="cp">#define ST0_TS			0x00200000</span>
<span class="cp">#define ST0_BEV			0x00400000</span>
<span class="cp">#define ST0_RE			0x02000000</span>
<span class="cp">#define ST0_FR			0x04000000</span>
<span class="cp">#define ST0_CU			0xf0000000</span>
<span class="cp">#define ST0_CU0			0x10000000</span>
<span class="cp">#define ST0_CU1			0x20000000</span>
<span class="cp">#define ST0_CU2			0x40000000</span>
<span class="cp">#define ST0_CU3			0x80000000</span>
<span class="cp">#define ST0_XX			0x80000000	</span><span class="cm">/* MIPS IV naming */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Bitfields and bit numbers in the coprocessor 0 IntCtl register. (MIPSR2)</span>
<span class="cm"> *</span>
<span class="cm"> * Refer to your MIPS R4xx0 manual, chapter 5 for explanation.</span>
<span class="cm"> */</span>
<span class="cp">#define INTCTLB_IPPCI		26</span>
<span class="cp">#define INTCTLF_IPPCI		(_ULCAST_(7) &lt;&lt; INTCTLB_IPPCI)</span>
<span class="cp">#define INTCTLB_IPTI		29</span>
<span class="cp">#define INTCTLF_IPTI		(_ULCAST_(7) &lt;&lt; INTCTLB_IPTI)</span>

<span class="cm">/*</span>
<span class="cm"> * Bitfields and bit numbers in the coprocessor 0 cause register.</span>
<span class="cm"> *</span>
<span class="cm"> * Refer to your MIPS R4xx0 manual, chapter 5 for explanation.</span>
<span class="cm"> */</span>
<span class="cp">#define  CAUSEB_EXCCODE		2</span>
<span class="cp">#define  CAUSEF_EXCCODE		(_ULCAST_(31)  &lt;&lt;  2)</span>
<span class="cp">#define  CAUSEB_IP		8</span>
<span class="cp">#define  CAUSEF_IP		(_ULCAST_(255) &lt;&lt;  8)</span>
<span class="cp">#define  CAUSEB_IP0		8</span>
<span class="cp">#define  CAUSEF_IP0		(_ULCAST_(1)   &lt;&lt;  8)</span>
<span class="cp">#define  CAUSEB_IP1		9</span>
<span class="cp">#define  CAUSEF_IP1		(_ULCAST_(1)   &lt;&lt;  9)</span>
<span class="cp">#define  CAUSEB_IP2		10</span>
<span class="cp">#define  CAUSEF_IP2		(_ULCAST_(1)   &lt;&lt; 10)</span>
<span class="cp">#define  CAUSEB_IP3		11</span>
<span class="cp">#define  CAUSEF_IP3		(_ULCAST_(1)   &lt;&lt; 11)</span>
<span class="cp">#define  CAUSEB_IP4		12</span>
<span class="cp">#define  CAUSEF_IP4		(_ULCAST_(1)   &lt;&lt; 12)</span>
<span class="cp">#define  CAUSEB_IP5		13</span>
<span class="cp">#define  CAUSEF_IP5		(_ULCAST_(1)   &lt;&lt; 13)</span>
<span class="cp">#define  CAUSEB_IP6		14</span>
<span class="cp">#define  CAUSEF_IP6		(_ULCAST_(1)   &lt;&lt; 14)</span>
<span class="cp">#define  CAUSEB_IP7		15</span>
<span class="cp">#define  CAUSEF_IP7		(_ULCAST_(1)   &lt;&lt; 15)</span>
<span class="cp">#define  CAUSEB_IV		23</span>
<span class="cp">#define  CAUSEF_IV		(_ULCAST_(1)   &lt;&lt; 23)</span>
<span class="cp">#define  CAUSEB_CE		28</span>
<span class="cp">#define  CAUSEF_CE		(_ULCAST_(3)   &lt;&lt; 28)</span>
<span class="cp">#define  CAUSEB_TI		30</span>
<span class="cp">#define  CAUSEF_TI		(_ULCAST_(1)   &lt;&lt; 30)</span>
<span class="cp">#define  CAUSEB_BD		31</span>
<span class="cp">#define  CAUSEF_BD		(_ULCAST_(1)   &lt;&lt; 31)</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in the coprocessor 0 config register.</span>
<span class="cm"> */</span>
<span class="cm">/* Generic bits.  */</span>
<span class="cp">#define CONF_CM_CACHABLE_NO_WA		0</span>
<span class="cp">#define CONF_CM_CACHABLE_WA		1</span>
<span class="cp">#define CONF_CM_UNCACHED		2</span>
<span class="cp">#define CONF_CM_CACHABLE_NONCOHERENT	3</span>
<span class="cp">#define CONF_CM_CACHABLE_CE		4</span>
<span class="cp">#define CONF_CM_CACHABLE_COW		5</span>
<span class="cp">#define CONF_CM_CACHABLE_CUW		6</span>
<span class="cp">#define CONF_CM_CACHABLE_ACCELERATED	7</span>
<span class="cp">#define CONF_CM_CMASK			7</span>
<span class="cp">#define CONF_BE			(_ULCAST_(1) &lt;&lt; 15)</span>

<span class="cm">/* Bits common to various processors.  */</span>
<span class="cp">#define CONF_CU			(_ULCAST_(1) &lt;&lt;  3)</span>
<span class="cp">#define CONF_DB			(_ULCAST_(1) &lt;&lt;  4)</span>
<span class="cp">#define CONF_IB			(_ULCAST_(1) &lt;&lt;  5)</span>
<span class="cp">#define CONF_DC			(_ULCAST_(7) &lt;&lt;  6)</span>
<span class="cp">#define CONF_IC			(_ULCAST_(7) &lt;&lt;  9)</span>
<span class="cp">#define CONF_EB			(_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define CONF_EM			(_ULCAST_(1) &lt;&lt; 14)</span>
<span class="cp">#define CONF_SM			(_ULCAST_(1) &lt;&lt; 16)</span>
<span class="cp">#define CONF_SC			(_ULCAST_(1) &lt;&lt; 17)</span>
<span class="cp">#define CONF_EW			(_ULCAST_(3) &lt;&lt; 18)</span>
<span class="cp">#define CONF_EP			(_ULCAST_(15)&lt;&lt; 24)</span>
<span class="cp">#define CONF_EC			(_ULCAST_(7) &lt;&lt; 28)</span>
<span class="cp">#define CONF_CM			(_ULCAST_(1) &lt;&lt; 31)</span>

<span class="cm">/* Bits specific to the R4xx0.  */</span>
<span class="cp">#define R4K_CONF_SW		(_ULCAST_(1) &lt;&lt; 20)</span>
<span class="cp">#define R4K_CONF_SS		(_ULCAST_(1) &lt;&lt; 21)</span>
<span class="cp">#define R4K_CONF_SB		(_ULCAST_(3) &lt;&lt; 22)</span>

<span class="cm">/* Bits specific to the R5000.  */</span>
<span class="cp">#define R5K_CONF_SE		(_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define R5K_CONF_SS		(_ULCAST_(3) &lt;&lt; 20)</span>

<span class="cm">/* Bits specific to the RM7000.  */</span>
<span class="cp">#define RM7K_CONF_SE		(_ULCAST_(1) &lt;&lt;  3)</span>
<span class="cp">#define RM7K_CONF_TE		(_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define RM7K_CONF_CLK		(_ULCAST_(1) &lt;&lt; 16)</span>
<span class="cp">#define RM7K_CONF_TC		(_ULCAST_(1) &lt;&lt; 17)</span>
<span class="cp">#define RM7K_CONF_SI		(_ULCAST_(3) &lt;&lt; 20)</span>
<span class="cp">#define RM7K_CONF_SC		(_ULCAST_(1) &lt;&lt; 31)</span>

<span class="cm">/* Bits specific to the R10000.  */</span>
<span class="cp">#define R10K_CONF_DN		(_ULCAST_(3) &lt;&lt;  3)</span>
<span class="cp">#define R10K_CONF_CT		(_ULCAST_(1) &lt;&lt;  5)</span>
<span class="cp">#define R10K_CONF_PE		(_ULCAST_(1) &lt;&lt;  6)</span>
<span class="cp">#define R10K_CONF_PM		(_ULCAST_(3) &lt;&lt;  7)</span>
<span class="cp">#define R10K_CONF_EC		(_ULCAST_(15)&lt;&lt;  9)</span>
<span class="cp">#define R10K_CONF_SB		(_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define R10K_CONF_SK		(_ULCAST_(1) &lt;&lt; 14)</span>
<span class="cp">#define R10K_CONF_SS		(_ULCAST_(7) &lt;&lt; 16)</span>
<span class="cp">#define R10K_CONF_SC		(_ULCAST_(7) &lt;&lt; 19)</span>
<span class="cp">#define R10K_CONF_DC		(_ULCAST_(7) &lt;&lt; 26)</span>
<span class="cp">#define R10K_CONF_IC		(_ULCAST_(7) &lt;&lt; 29)</span>

<span class="cm">/* Bits specific to the VR41xx.  */</span>
<span class="cp">#define VR41_CONF_CS		(_ULCAST_(1) &lt;&lt; 12)</span>
<span class="cp">#define VR41_CONF_P4K		(_ULCAST_(1) &lt;&lt; 13)</span>
<span class="cp">#define VR41_CONF_BP		(_ULCAST_(1) &lt;&lt; 16)</span>
<span class="cp">#define VR41_CONF_M16		(_ULCAST_(1) &lt;&lt; 20)</span>
<span class="cp">#define VR41_CONF_AD		(_ULCAST_(1) &lt;&lt; 23)</span>

<span class="cm">/* Bits specific to the R30xx.  */</span>
<span class="cp">#define R30XX_CONF_FDM		(_ULCAST_(1) &lt;&lt; 19)</span>
<span class="cp">#define R30XX_CONF_REV		(_ULCAST_(1) &lt;&lt; 22)</span>
<span class="cp">#define R30XX_CONF_AC		(_ULCAST_(1) &lt;&lt; 23)</span>
<span class="cp">#define R30XX_CONF_RF		(_ULCAST_(1) &lt;&lt; 24)</span>
<span class="cp">#define R30XX_CONF_HALT		(_ULCAST_(1) &lt;&lt; 25)</span>
<span class="cp">#define R30XX_CONF_FPINT	(_ULCAST_(7) &lt;&lt; 26)</span>
<span class="cp">#define R30XX_CONF_DBR		(_ULCAST_(1) &lt;&lt; 29)</span>
<span class="cp">#define R30XX_CONF_SB		(_ULCAST_(1) &lt;&lt; 30)</span>
<span class="cp">#define R30XX_CONF_LOCK		(_ULCAST_(1) &lt;&lt; 31)</span>

<span class="cm">/* Bits specific to the TX49.  */</span>
<span class="cp">#define TX49_CONF_DC		(_ULCAST_(1) &lt;&lt; 16)</span>
<span class="cp">#define TX49_CONF_IC		(_ULCAST_(1) &lt;&lt; 17)  </span><span class="cm">/* conflict with CONF_SC */</span><span class="cp"></span>
<span class="cp">#define TX49_CONF_HALT		(_ULCAST_(1) &lt;&lt; 18)</span>
<span class="cp">#define TX49_CONF_CWFON		(_ULCAST_(1) &lt;&lt; 27)</span>

<span class="cm">/* Bits specific to the MIPS32/64 PRA.  */</span>
<span class="cp">#define MIPS_CONF_MT		(_ULCAST_(7) &lt;&lt;  7)</span>
<span class="cp">#define MIPS_CONF_AR		(_ULCAST_(7) &lt;&lt; 10)</span>
<span class="cp">#define MIPS_CONF_AT		(_ULCAST_(3) &lt;&lt; 13)</span>
<span class="cp">#define MIPS_CONF_M		(_ULCAST_(1) &lt;&lt; 31)</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in the MIPS32/64 PRA coprocessor 0 config registers 1 and above.</span>
<span class="cm"> */</span>
<span class="cp">#define MIPS_CONF1_FP		(_ULCAST_(1) &lt;&lt;  0)</span>
<span class="cp">#define MIPS_CONF1_EP		(_ULCAST_(1) &lt;&lt;  1)</span>
<span class="cp">#define MIPS_CONF1_CA		(_ULCAST_(1) &lt;&lt;  2)</span>
<span class="cp">#define MIPS_CONF1_WR		(_ULCAST_(1) &lt;&lt;  3)</span>
<span class="cp">#define MIPS_CONF1_PC		(_ULCAST_(1) &lt;&lt;  4)</span>
<span class="cp">#define MIPS_CONF1_MD		(_ULCAST_(1) &lt;&lt;  5)</span>
<span class="cp">#define MIPS_CONF1_C2		(_ULCAST_(1) &lt;&lt;  6)</span>
<span class="cp">#define MIPS_CONF1_DA		(_ULCAST_(7) &lt;&lt;  7)</span>
<span class="cp">#define MIPS_CONF1_DL		(_ULCAST_(7) &lt;&lt; 10)</span>
<span class="cp">#define MIPS_CONF1_DS		(_ULCAST_(7) &lt;&lt; 13)</span>
<span class="cp">#define MIPS_CONF1_IA		(_ULCAST_(7) &lt;&lt; 16)</span>
<span class="cp">#define MIPS_CONF1_IL		(_ULCAST_(7) &lt;&lt; 19)</span>
<span class="cp">#define MIPS_CONF1_IS		(_ULCAST_(7) &lt;&lt; 22)</span>
<span class="cp">#define MIPS_CONF1_TLBS		(_ULCAST_(63)&lt;&lt; 25)</span>

<span class="cp">#define MIPS_CONF2_SA		(_ULCAST_(15)&lt;&lt;  0)</span>
<span class="cp">#define MIPS_CONF2_SL		(_ULCAST_(15)&lt;&lt;  4)</span>
<span class="cp">#define MIPS_CONF2_SS		(_ULCAST_(15)&lt;&lt;  8)</span>
<span class="cp">#define MIPS_CONF2_SU		(_ULCAST_(15)&lt;&lt; 12)</span>
<span class="cp">#define MIPS_CONF2_TA		(_ULCAST_(15)&lt;&lt; 16)</span>
<span class="cp">#define MIPS_CONF2_TL		(_ULCAST_(15)&lt;&lt; 20)</span>
<span class="cp">#define MIPS_CONF2_TS		(_ULCAST_(15)&lt;&lt; 24)</span>
<span class="cp">#define MIPS_CONF2_TU		(_ULCAST_(7) &lt;&lt; 28)</span>

<span class="cp">#define MIPS_CONF3_TL		(_ULCAST_(1) &lt;&lt;  0)</span>
<span class="cp">#define MIPS_CONF3_SM		(_ULCAST_(1) &lt;&lt;  1)</span>
<span class="cp">#define MIPS_CONF3_MT		(_ULCAST_(1) &lt;&lt;  2)</span>
<span class="cp">#define MIPS_CONF3_SP		(_ULCAST_(1) &lt;&lt;  4)</span>
<span class="cp">#define MIPS_CONF3_VINT		(_ULCAST_(1) &lt;&lt;  5)</span>
<span class="cp">#define MIPS_CONF3_VEIC		(_ULCAST_(1) &lt;&lt;  6)</span>
<span class="cp">#define MIPS_CONF3_LPA		(_ULCAST_(1) &lt;&lt;  7)</span>
<span class="cp">#define MIPS_CONF3_DSP		(_ULCAST_(1) &lt;&lt; 10)</span>
<span class="cp">#define MIPS_CONF3_ULRI		(_ULCAST_(1) &lt;&lt; 13)</span>

<span class="cp">#define MIPS_CONF4_MMUSIZEEXT	(_ULCAST_(255) &lt;&lt; 0)</span>
<span class="cp">#define MIPS_CONF4_MMUEXTDEF	(_ULCAST_(3) &lt;&lt; 14)</span>
<span class="cp">#define MIPS_CONF4_MMUEXTDEF_MMUSIZEEXT (_ULCAST_(1) &lt;&lt; 14)</span>

<span class="cp">#define MIPS_CONF7_WII		(_ULCAST_(1) &lt;&lt; 31)</span>

<span class="cp">#define MIPS_CONF7_RPS		(_ULCAST_(1) &lt;&lt; 2)</span>


<span class="cm">/*</span>
<span class="cm"> * Bits in the MIPS32/64 coprocessor 1 (FPU) revision register.</span>
<span class="cm"> */</span>
<span class="cp">#define MIPS_FPIR_S		(_ULCAST_(1) &lt;&lt; 16)</span>
<span class="cp">#define MIPS_FPIR_D		(_ULCAST_(1) &lt;&lt; 17)</span>
<span class="cp">#define MIPS_FPIR_PS		(_ULCAST_(1) &lt;&lt; 18)</span>
<span class="cp">#define MIPS_FPIR_3D		(_ULCAST_(1) &lt;&lt; 19)</span>
<span class="cp">#define MIPS_FPIR_W		(_ULCAST_(1) &lt;&lt; 20)</span>
<span class="cp">#define MIPS_FPIR_L		(_ULCAST_(1) &lt;&lt; 21)</span>
<span class="cp">#define MIPS_FPIR_F64		(_ULCAST_(1) &lt;&lt; 22)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/*</span>
<span class="cm"> * Functions to access the R10000 performance counters.  These are basically</span>
<span class="cm"> * mfc0 and mtc0 instructions from and to coprocessor register with a 5-bit</span>
<span class="cm"> * performance counter number encoded into bits 1 ... 5 of the instruction.</span>
<span class="cm"> * Only performance counters 0 to 1 actually exist, so for a non-R10000 aware</span>
<span class="cm"> * disassembler these will look like an access to sel 0 or 1.</span>
<span class="cm"> */</span>
<span class="cp">#define read_r10k_perf_cntr(counter)				\</span>
<span class="cp">({								\</span>
<span class="cp">	unsigned int __res;					\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;mfpc\t%0, %1&quot;						\</span>
<span class="cp">        : &quot;=r&quot; (__res)						\</span>
<span class="cp">	: &quot;i&quot; (counter));					\</span>
<span class="cp">								\</span>
<span class="cp">        __res;							\</span>
<span class="cp">})</span>

<span class="cp">#define write_r10k_perf_cntr(counter,val)                       \</span>
<span class="cp">do {								\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;mtpc\t%0, %1&quot;						\</span>
<span class="cp">	:							\</span>
<span class="cp">	: &quot;r&quot; (val), &quot;i&quot; (counter));				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define read_r10k_perf_event(counter)				\</span>
<span class="cp">({								\</span>
<span class="cp">	unsigned int __res;					\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;mfps\t%0, %1&quot;						\</span>
<span class="cp">        : &quot;=r&quot; (__res)						\</span>
<span class="cp">	: &quot;i&quot; (counter));					\</span>
<span class="cp">								\</span>
<span class="cp">        __res;							\</span>
<span class="cp">})</span>

<span class="cp">#define write_r10k_perf_cntl(counter,val)                       \</span>
<span class="cp">do {								\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;mtps\t%0, %1&quot;						\</span>
<span class="cp">	:							\</span>
<span class="cp">	: &quot;r&quot; (val), &quot;i&quot; (counter));				\</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Macros to access the system control coprocessor</span>
<span class="cm"> */</span>

<span class="cp">#define __read_32bit_c0_register(source, sel)				\</span>
<span class="cp">({ int __res;								\</span>
<span class="cp">	if (sel == 0)							\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;mfc0\t%0, &quot; #source &quot;\n\t&quot;			\</span>
<span class="cp">			: &quot;=r&quot; (__res));				\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips32\n\t&quot;				\</span>
<span class="cp">			&quot;mfc0\t%0, &quot; #source &quot;, &quot; #sel &quot;\n\t&quot;		\</span>
<span class="cp">			&quot;.set\tmips0\n\t&quot;				\</span>
<span class="cp">			: &quot;=r&quot; (__res));				\</span>
<span class="cp">	__res;								\</span>
<span class="cp">})</span>

<span class="cp">#define __read_64bit_c0_register(source, sel)				\</span>
<span class="cp">({ unsigned long long __res;						\</span>
<span class="cp">	if (sizeof(unsigned long) == 4)					\</span>
<span class="cp">		__res = __read_64bit_c0_split(source, sel);		\</span>
<span class="cp">	else if (sel == 0)						\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips3\n\t&quot;				\</span>
<span class="cp">			&quot;dmfc0\t%0, &quot; #source &quot;\n\t&quot;			\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: &quot;=r&quot; (__res));				\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dmfc0\t%0, &quot; #source &quot;, &quot; #sel &quot;\n\t&quot;		\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: &quot;=r&quot; (__res));				\</span>
<span class="cp">	__res;								\</span>
<span class="cp">})</span>

<span class="cp">#define __write_32bit_c0_register(register, sel, value)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (sel == 0)							\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;mtc0\t%z0, &quot; #register &quot;\n\t&quot;			\</span>
<span class="cp">			: : &quot;Jr&quot; ((unsigned int)(value)));		\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips32\n\t&quot;				\</span>
<span class="cp">			&quot;mtc0\t%z0, &quot; #register &quot;, &quot; #sel &quot;\n\t&quot;	\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: : &quot;Jr&quot; ((unsigned int)(value)));		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __write_64bit_c0_register(register, sel, value)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (sizeof(unsigned long) == 4)					\</span>
<span class="cp">		__write_64bit_c0_split(register, sel, value);		\</span>
<span class="cp">	else if (sel == 0)						\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips3\n\t&quot;				\</span>
<span class="cp">			&quot;dmtc0\t%z0, &quot; #register &quot;\n\t&quot;			\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: : &quot;Jr&quot; (value));				\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dmtc0\t%z0, &quot; #register &quot;, &quot; #sel &quot;\n\t&quot;	\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: : &quot;Jr&quot; (value));				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __read_ulong_c0_register(reg, sel)				\</span>
<span class="cp">	((sizeof(unsigned long) == 4) ?					\</span>
<span class="cp">	(unsigned long) __read_32bit_c0_register(reg, sel) :		\</span>
<span class="cp">	(unsigned long) __read_64bit_c0_register(reg, sel))</span>

<span class="cp">#define __write_ulong_c0_register(reg, sel, val)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (sizeof(unsigned long) == 4)					\</span>
<span class="cp">		__write_32bit_c0_register(reg, sel, val);		\</span>
<span class="cp">	else								\</span>
<span class="cp">		__write_64bit_c0_register(reg, sel, val);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * On RM7000/RM9000 these are uses to access cop0 set 1 registers</span>
<span class="cm"> */</span>
<span class="cp">#define __read_32bit_c0_ctrl_register(source)				\</span>
<span class="cp">({ int __res;								\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">		&quot;cfc0\t%0, &quot; #source &quot;\n\t&quot;				\</span>
<span class="cp">		: &quot;=r&quot; (__res));					\</span>
<span class="cp">	__res;								\</span>
<span class="cp">})</span>

<span class="cp">#define __write_32bit_c0_ctrl_register(register, value)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">		&quot;ctc0\t%z0, &quot; #register &quot;\n\t&quot;				\</span>
<span class="cp">		: : &quot;Jr&quot; ((unsigned int)(value)));			\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * These versions are only needed for systems with more than 38 bits of</span>
<span class="cm"> * physical address space running the 32-bit kernel.  That&#39;s none atm :-)</span>
<span class="cm"> */</span>
<span class="cp">#define __read_64bit_c0_split(source, sel)				\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long long __val;					\</span>
<span class="cp">	unsigned long __flags;						\</span>
<span class="cp">									\</span>
<span class="cp">	local_irq_save(__flags);					\</span>
<span class="cp">	if (sel == 0)							\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dmfc0\t%M0, &quot; #source &quot;\n\t&quot;			\</span>
<span class="cp">			&quot;dsll\t%L0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsra\t%M0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsra\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: &quot;=r&quot; (__val));				\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dmfc0\t%M0, &quot; #source &quot;, &quot; #sel &quot;\n\t&quot;		\</span>
<span class="cp">			&quot;dsll\t%L0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsra\t%M0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsra\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: &quot;=r&quot; (__val));				\</span>
<span class="cp">	local_irq_restore(__flags);					\</span>
<span class="cp">									\</span>
<span class="cp">	__val;								\</span>
<span class="cp">})</span>

<span class="cp">#define __write_64bit_c0_split(source, sel, val)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	unsigned long __flags;						\</span>
<span class="cp">									\</span>
<span class="cp">	local_irq_save(__flags);					\</span>
<span class="cp">	if (sel == 0)							\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dsll\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsrl\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsll\t%M0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;or\t%L0, %L0, %M0\n\t&quot;				\</span>
<span class="cp">			&quot;dmtc0\t%L0, &quot; #source &quot;\n\t&quot;			\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: : &quot;r&quot; (val));					\</span>
<span class="cp">	else								\</span>
<span class="cp">		__asm__ __volatile__(					\</span>
<span class="cp">			&quot;.set\tmips64\n\t&quot;				\</span>
<span class="cp">			&quot;dsll\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsrl\t%L0, %L0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;dsll\t%M0, %M0, 32\n\t&quot;			\</span>
<span class="cp">			&quot;or\t%L0, %L0, %M0\n\t&quot;				\</span>
<span class="cp">			&quot;dmtc0\t%L0, &quot; #source &quot;, &quot; #sel &quot;\n\t&quot;		\</span>
<span class="cp">			&quot;.set\tmips0&quot;					\</span>
<span class="cp">			: : &quot;r&quot; (val));					\</span>
<span class="cp">	local_irq_restore(__flags);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define read_c0_index()		__read_32bit_c0_register($0, 0)</span>
<span class="cp">#define write_c0_index(val)	__write_32bit_c0_register($0, 0, val)</span>

<span class="cp">#define read_c0_random()	__read_32bit_c0_register($1, 0)</span>
<span class="cp">#define write_c0_random(val)	__write_32bit_c0_register($1, 0, val)</span>

<span class="cp">#define read_c0_entrylo0()	__read_ulong_c0_register($2, 0)</span>
<span class="cp">#define write_c0_entrylo0(val)	__write_ulong_c0_register($2, 0, val)</span>

<span class="cp">#define read_c0_entrylo1()	__read_ulong_c0_register($3, 0)</span>
<span class="cp">#define write_c0_entrylo1(val)	__write_ulong_c0_register($3, 0, val)</span>

<span class="cp">#define read_c0_conf()		__read_32bit_c0_register($3, 0)</span>
<span class="cp">#define write_c0_conf(val)	__write_32bit_c0_register($3, 0, val)</span>

<span class="cp">#define read_c0_context()	__read_ulong_c0_register($4, 0)</span>
<span class="cp">#define write_c0_context(val)	__write_ulong_c0_register($4, 0, val)</span>

<span class="cp">#define read_c0_userlocal()	__read_ulong_c0_register($4, 2)</span>
<span class="cp">#define write_c0_userlocal(val)	__write_ulong_c0_register($4, 2, val)</span>

<span class="cp">#define read_c0_pagemask()	__read_32bit_c0_register($5, 0)</span>
<span class="cp">#define write_c0_pagemask(val)	__write_32bit_c0_register($5, 0, val)</span>

<span class="cp">#define read_c0_pagegrain()	__read_32bit_c0_register($5, 1)</span>
<span class="cp">#define write_c0_pagegrain(val)	__write_32bit_c0_register($5, 1, val)</span>

<span class="cp">#define read_c0_wired()		__read_32bit_c0_register($6, 0)</span>
<span class="cp">#define write_c0_wired(val)	__write_32bit_c0_register($6, 0, val)</span>

<span class="cp">#define read_c0_info()		__read_32bit_c0_register($7, 0)</span>

<span class="cp">#define read_c0_cache()		__read_32bit_c0_register($7, 0)	</span><span class="cm">/* TX39xx */</span><span class="cp"></span>
<span class="cp">#define write_c0_cache(val)	__write_32bit_c0_register($7, 0, val)</span>

<span class="cp">#define read_c0_badvaddr()	__read_ulong_c0_register($8, 0)</span>
<span class="cp">#define write_c0_badvaddr(val)	__write_ulong_c0_register($8, 0, val)</span>

<span class="cp">#define read_c0_count()		__read_32bit_c0_register($9, 0)</span>
<span class="cp">#define write_c0_count(val)	__write_32bit_c0_register($9, 0, val)</span>

<span class="cp">#define read_c0_count2()	__read_32bit_c0_register($9, 6) </span><span class="cm">/* pnx8550 */</span><span class="cp"></span>
<span class="cp">#define write_c0_count2(val)	__write_32bit_c0_register($9, 6, val)</span>

<span class="cp">#define read_c0_count3()	__read_32bit_c0_register($9, 7) </span><span class="cm">/* pnx8550 */</span><span class="cp"></span>
<span class="cp">#define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)</span>

<span class="cp">#define read_c0_entryhi()	__read_ulong_c0_register($10, 0)</span>
<span class="cp">#define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)</span>

<span class="cp">#define read_c0_compare()	__read_32bit_c0_register($11, 0)</span>
<span class="cp">#define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)</span>

<span class="cp">#define read_c0_compare2()	__read_32bit_c0_register($11, 6) </span><span class="cm">/* pnx8550 */</span><span class="cp"></span>
<span class="cp">#define write_c0_compare2(val)	__write_32bit_c0_register($11, 6, val)</span>

<span class="cp">#define read_c0_compare3()	__read_32bit_c0_register($11, 7) </span><span class="cm">/* pnx8550 */</span><span class="cp"></span>
<span class="cp">#define write_c0_compare3(val)	__write_32bit_c0_register($11, 7, val)</span>

<span class="cp">#define read_c0_status()	__read_32bit_c0_register($12, 0)</span>
<span class="cp">#ifdef CONFIG_MIPS_MT_SMTC</span>
<span class="cp">#define write_c0_status(val)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	__write_32bit_c0_register($12, 0, val);				\</span>
<span class="cp">	__ehb();							\</span>
<span class="cp">} while (0)</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Legacy non-SMTC code, which may be hazardous</span>
<span class="cm"> * but which might not support EHB</span>
<span class="cm"> */</span>
<span class="cp">#define write_c0_status(val)	__write_32bit_c0_register($12, 0, val)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT_SMTC */</span><span class="cp"></span>

<span class="cp">#define read_c0_cause()		__read_32bit_c0_register($13, 0)</span>
<span class="cp">#define write_c0_cause(val)	__write_32bit_c0_register($13, 0, val)</span>

<span class="cp">#define read_c0_epc()		__read_ulong_c0_register($14, 0)</span>
<span class="cp">#define write_c0_epc(val)	__write_ulong_c0_register($14, 0, val)</span>

<span class="cp">#define read_c0_prid()		__read_32bit_c0_register($15, 0)</span>

<span class="cp">#define read_c0_config()	__read_32bit_c0_register($16, 0)</span>
<span class="cp">#define read_c0_config1()	__read_32bit_c0_register($16, 1)</span>
<span class="cp">#define read_c0_config2()	__read_32bit_c0_register($16, 2)</span>
<span class="cp">#define read_c0_config3()	__read_32bit_c0_register($16, 3)</span>
<span class="cp">#define read_c0_config4()	__read_32bit_c0_register($16, 4)</span>
<span class="cp">#define read_c0_config5()	__read_32bit_c0_register($16, 5)</span>
<span class="cp">#define read_c0_config6()	__read_32bit_c0_register($16, 6)</span>
<span class="cp">#define read_c0_config7()	__read_32bit_c0_register($16, 7)</span>
<span class="cp">#define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)</span>
<span class="cp">#define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)</span>
<span class="cp">#define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)</span>
<span class="cp">#define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)</span>
<span class="cp">#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)</span>
<span class="cp">#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)</span>
<span class="cp">#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)</span>
<span class="cp">#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)</span>

<span class="cm">/*</span>
<span class="cm"> * The WatchLo register.  There may be up to 8 of them.</span>
<span class="cm"> */</span>
<span class="cp">#define read_c0_watchlo0()	__read_ulong_c0_register($18, 0)</span>
<span class="cp">#define read_c0_watchlo1()	__read_ulong_c0_register($18, 1)</span>
<span class="cp">#define read_c0_watchlo2()	__read_ulong_c0_register($18, 2)</span>
<span class="cp">#define read_c0_watchlo3()	__read_ulong_c0_register($18, 3)</span>
<span class="cp">#define read_c0_watchlo4()	__read_ulong_c0_register($18, 4)</span>
<span class="cp">#define read_c0_watchlo5()	__read_ulong_c0_register($18, 5)</span>
<span class="cp">#define read_c0_watchlo6()	__read_ulong_c0_register($18, 6)</span>
<span class="cp">#define read_c0_watchlo7()	__read_ulong_c0_register($18, 7)</span>
<span class="cp">#define write_c0_watchlo0(val)	__write_ulong_c0_register($18, 0, val)</span>
<span class="cp">#define write_c0_watchlo1(val)	__write_ulong_c0_register($18, 1, val)</span>
<span class="cp">#define write_c0_watchlo2(val)	__write_ulong_c0_register($18, 2, val)</span>
<span class="cp">#define write_c0_watchlo3(val)	__write_ulong_c0_register($18, 3, val)</span>
<span class="cp">#define write_c0_watchlo4(val)	__write_ulong_c0_register($18, 4, val)</span>
<span class="cp">#define write_c0_watchlo5(val)	__write_ulong_c0_register($18, 5, val)</span>
<span class="cp">#define write_c0_watchlo6(val)	__write_ulong_c0_register($18, 6, val)</span>
<span class="cp">#define write_c0_watchlo7(val)	__write_ulong_c0_register($18, 7, val)</span>

<span class="cm">/*</span>
<span class="cm"> * The WatchHi register.  There may be up to 8 of them.</span>
<span class="cm"> */</span>
<span class="cp">#define read_c0_watchhi0()	__read_32bit_c0_register($19, 0)</span>
<span class="cp">#define read_c0_watchhi1()	__read_32bit_c0_register($19, 1)</span>
<span class="cp">#define read_c0_watchhi2()	__read_32bit_c0_register($19, 2)</span>
<span class="cp">#define read_c0_watchhi3()	__read_32bit_c0_register($19, 3)</span>
<span class="cp">#define read_c0_watchhi4()	__read_32bit_c0_register($19, 4)</span>
<span class="cp">#define read_c0_watchhi5()	__read_32bit_c0_register($19, 5)</span>
<span class="cp">#define read_c0_watchhi6()	__read_32bit_c0_register($19, 6)</span>
<span class="cp">#define read_c0_watchhi7()	__read_32bit_c0_register($19, 7)</span>

<span class="cp">#define write_c0_watchhi0(val)	__write_32bit_c0_register($19, 0, val)</span>
<span class="cp">#define write_c0_watchhi1(val)	__write_32bit_c0_register($19, 1, val)</span>
<span class="cp">#define write_c0_watchhi2(val)	__write_32bit_c0_register($19, 2, val)</span>
<span class="cp">#define write_c0_watchhi3(val)	__write_32bit_c0_register($19, 3, val)</span>
<span class="cp">#define write_c0_watchhi4(val)	__write_32bit_c0_register($19, 4, val)</span>
<span class="cp">#define write_c0_watchhi5(val)	__write_32bit_c0_register($19, 5, val)</span>
<span class="cp">#define write_c0_watchhi6(val)	__write_32bit_c0_register($19, 6, val)</span>
<span class="cp">#define write_c0_watchhi7(val)	__write_32bit_c0_register($19, 7, val)</span>

<span class="cp">#define read_c0_xcontext()	__read_ulong_c0_register($20, 0)</span>
<span class="cp">#define write_c0_xcontext(val)	__write_ulong_c0_register($20, 0, val)</span>

<span class="cp">#define read_c0_intcontrol()	__read_32bit_c0_ctrl_register($20)</span>
<span class="cp">#define write_c0_intcontrol(val) __write_32bit_c0_ctrl_register($20, val)</span>

<span class="cp">#define read_c0_framemask()	__read_32bit_c0_register($21, 0)</span>
<span class="cp">#define write_c0_framemask(val)	__write_32bit_c0_register($21, 0, val)</span>

<span class="cm">/* RM9000 PerfControl performance counter control register */</span>
<span class="cp">#define read_c0_perfcontrol()	__read_32bit_c0_register($22, 0)</span>
<span class="cp">#define write_c0_perfcontrol(val) __write_32bit_c0_register($22, 0, val)</span>

<span class="cp">#define read_c0_diag()		__read_32bit_c0_register($22, 0)</span>
<span class="cp">#define write_c0_diag(val)	__write_32bit_c0_register($22, 0, val)</span>

<span class="cp">#define read_c0_diag1()		__read_32bit_c0_register($22, 1)</span>
<span class="cp">#define write_c0_diag1(val)	__write_32bit_c0_register($22, 1, val)</span>

<span class="cp">#define read_c0_diag2()		__read_32bit_c0_register($22, 2)</span>
<span class="cp">#define write_c0_diag2(val)	__write_32bit_c0_register($22, 2, val)</span>

<span class="cp">#define read_c0_diag3()		__read_32bit_c0_register($22, 3)</span>
<span class="cp">#define write_c0_diag3(val)	__write_32bit_c0_register($22, 3, val)</span>

<span class="cp">#define read_c0_diag4()		__read_32bit_c0_register($22, 4)</span>
<span class="cp">#define write_c0_diag4(val)	__write_32bit_c0_register($22, 4, val)</span>

<span class="cp">#define read_c0_diag5()		__read_32bit_c0_register($22, 5)</span>
<span class="cp">#define write_c0_diag5(val)	__write_32bit_c0_register($22, 5, val)</span>

<span class="cp">#define read_c0_debug()		__read_32bit_c0_register($23, 0)</span>
<span class="cp">#define write_c0_debug(val)	__write_32bit_c0_register($23, 0, val)</span>

<span class="cp">#define read_c0_depc()		__read_ulong_c0_register($24, 0)</span>
<span class="cp">#define write_c0_depc(val)	__write_ulong_c0_register($24, 0, val)</span>

<span class="cm">/*</span>
<span class="cm"> * MIPS32 / MIPS64 performance counters</span>
<span class="cm"> */</span>
<span class="cp">#define read_c0_perfctrl0()	__read_32bit_c0_register($25, 0)</span>
<span class="cp">#define write_c0_perfctrl0(val)	__write_32bit_c0_register($25, 0, val)</span>
<span class="cp">#define read_c0_perfcntr0()	__read_32bit_c0_register($25, 1)</span>
<span class="cp">#define write_c0_perfcntr0(val)	__write_32bit_c0_register($25, 1, val)</span>
<span class="cp">#define read_c0_perfcntr0_64()	__read_64bit_c0_register($25, 1)</span>
<span class="cp">#define write_c0_perfcntr0_64(val) __write_64bit_c0_register($25, 1, val)</span>
<span class="cp">#define read_c0_perfctrl1()	__read_32bit_c0_register($25, 2)</span>
<span class="cp">#define write_c0_perfctrl1(val)	__write_32bit_c0_register($25, 2, val)</span>
<span class="cp">#define read_c0_perfcntr1()	__read_32bit_c0_register($25, 3)</span>
<span class="cp">#define write_c0_perfcntr1(val)	__write_32bit_c0_register($25, 3, val)</span>
<span class="cp">#define read_c0_perfcntr1_64()	__read_64bit_c0_register($25, 3)</span>
<span class="cp">#define write_c0_perfcntr1_64(val) __write_64bit_c0_register($25, 3, val)</span>
<span class="cp">#define read_c0_perfctrl2()	__read_32bit_c0_register($25, 4)</span>
<span class="cp">#define write_c0_perfctrl2(val)	__write_32bit_c0_register($25, 4, val)</span>
<span class="cp">#define read_c0_perfcntr2()	__read_32bit_c0_register($25, 5)</span>
<span class="cp">#define write_c0_perfcntr2(val)	__write_32bit_c0_register($25, 5, val)</span>
<span class="cp">#define read_c0_perfcntr2_64()	__read_64bit_c0_register($25, 5)</span>
<span class="cp">#define write_c0_perfcntr2_64(val) __write_64bit_c0_register($25, 5, val)</span>
<span class="cp">#define read_c0_perfctrl3()	__read_32bit_c0_register($25, 6)</span>
<span class="cp">#define write_c0_perfctrl3(val)	__write_32bit_c0_register($25, 6, val)</span>
<span class="cp">#define read_c0_perfcntr3()	__read_32bit_c0_register($25, 7)</span>
<span class="cp">#define write_c0_perfcntr3(val)	__write_32bit_c0_register($25, 7, val)</span>
<span class="cp">#define read_c0_perfcntr3_64()	__read_64bit_c0_register($25, 7)</span>
<span class="cp">#define write_c0_perfcntr3_64(val) __write_64bit_c0_register($25, 7, val)</span>

<span class="cm">/* RM9000 PerfCount performance counter register */</span>
<span class="cp">#define read_c0_perfcount()	__read_64bit_c0_register($25, 0)</span>
<span class="cp">#define write_c0_perfcount(val)	__write_64bit_c0_register($25, 0, val)</span>

<span class="cp">#define read_c0_ecc()		__read_32bit_c0_register($26, 0)</span>
<span class="cp">#define write_c0_ecc(val)	__write_32bit_c0_register($26, 0, val)</span>

<span class="cp">#define read_c0_derraddr0()	__read_ulong_c0_register($26, 1)</span>
<span class="cp">#define write_c0_derraddr0(val)	__write_ulong_c0_register($26, 1, val)</span>

<span class="cp">#define read_c0_cacheerr()	__read_32bit_c0_register($27, 0)</span>

<span class="cp">#define read_c0_derraddr1()	__read_ulong_c0_register($27, 1)</span>
<span class="cp">#define write_c0_derraddr1(val)	__write_ulong_c0_register($27, 1, val)</span>

<span class="cp">#define read_c0_taglo()		__read_32bit_c0_register($28, 0)</span>
<span class="cp">#define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)</span>

<span class="cp">#define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)</span>
<span class="cp">#define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)</span>

<span class="cp">#define read_c0_ddatalo()	__read_32bit_c0_register($28, 3)</span>
<span class="cp">#define write_c0_ddatalo(val)	__write_32bit_c0_register($28, 3, val)</span>

<span class="cp">#define read_c0_staglo()	__read_32bit_c0_register($28, 4)</span>
<span class="cp">#define write_c0_staglo(val)	__write_32bit_c0_register($28, 4, val)</span>

<span class="cp">#define read_c0_taghi()		__read_32bit_c0_register($29, 0)</span>
<span class="cp">#define write_c0_taghi(val)	__write_32bit_c0_register($29, 0, val)</span>

<span class="cp">#define read_c0_errorepc()	__read_ulong_c0_register($30, 0)</span>
<span class="cp">#define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)</span>

<span class="cm">/* MIPSR2 */</span>
<span class="cp">#define read_c0_hwrena()	__read_32bit_c0_register($7, 0)</span>
<span class="cp">#define write_c0_hwrena(val)	__write_32bit_c0_register($7, 0, val)</span>

<span class="cp">#define read_c0_intctl()	__read_32bit_c0_register($12, 1)</span>
<span class="cp">#define write_c0_intctl(val)	__write_32bit_c0_register($12, 1, val)</span>

<span class="cp">#define read_c0_srsctl()	__read_32bit_c0_register($12, 2)</span>
<span class="cp">#define write_c0_srsctl(val)	__write_32bit_c0_register($12, 2, val)</span>

<span class="cp">#define read_c0_srsmap()	__read_32bit_c0_register($12, 3)</span>
<span class="cp">#define write_c0_srsmap(val)	__write_32bit_c0_register($12, 3, val)</span>

<span class="cp">#define read_c0_ebase()		__read_32bit_c0_register($15, 1)</span>
<span class="cp">#define write_c0_ebase(val)	__write_32bit_c0_register($15, 1, val)</span>


<span class="cm">/* Cavium OCTEON (cnMIPS) */</span>
<span class="cp">#define read_c0_cvmcount()	__read_ulong_c0_register($9, 6)</span>
<span class="cp">#define write_c0_cvmcount(val)	__write_ulong_c0_register($9, 6, val)</span>

<span class="cp">#define read_c0_cvmctl()	__read_64bit_c0_register($9, 7)</span>
<span class="cp">#define write_c0_cvmctl(val)	__write_64bit_c0_register($9, 7, val)</span>

<span class="cp">#define read_c0_cvmmemctl()	__read_64bit_c0_register($11, 7)</span>
<span class="cp">#define write_c0_cvmmemctl(val)	__write_64bit_c0_register($11, 7, val)</span>
<span class="cm">/*</span>
<span class="cm"> * The cacheerr registers are not standardized.  On OCTEON, they are</span>
<span class="cm"> * 64 bits wide.</span>
<span class="cm"> */</span>
<span class="cp">#define read_octeon_c0_icacheerr()	__read_64bit_c0_register($27, 0)</span>
<span class="cp">#define write_octeon_c0_icacheerr(val)	__write_64bit_c0_register($27, 0, val)</span>

<span class="cp">#define read_octeon_c0_dcacheerr()	__read_64bit_c0_register($27, 1)</span>
<span class="cp">#define write_octeon_c0_dcacheerr(val)	__write_64bit_c0_register($27, 1, val)</span>

<span class="cm">/* BMIPS3300 */</span>
<span class="cp">#define read_c0_brcm_config_0()		__read_32bit_c0_register($22, 0)</span>
<span class="cp">#define write_c0_brcm_config_0(val)	__write_32bit_c0_register($22, 0, val)</span>

<span class="cp">#define read_c0_brcm_bus_pll()		__read_32bit_c0_register($22, 4)</span>
<span class="cp">#define write_c0_brcm_bus_pll(val)	__write_32bit_c0_register($22, 4, val)</span>

<span class="cp">#define read_c0_brcm_reset()		__read_32bit_c0_register($22, 5)</span>
<span class="cp">#define write_c0_brcm_reset(val)	__write_32bit_c0_register($22, 5, val)</span>

<span class="cm">/* BMIPS43xx */</span>
<span class="cp">#define read_c0_brcm_cmt_intr()		__read_32bit_c0_register($22, 1)</span>
<span class="cp">#define write_c0_brcm_cmt_intr(val)	__write_32bit_c0_register($22, 1, val)</span>

<span class="cp">#define read_c0_brcm_cmt_ctrl()		__read_32bit_c0_register($22, 2)</span>
<span class="cp">#define write_c0_brcm_cmt_ctrl(val)	__write_32bit_c0_register($22, 2, val)</span>

<span class="cp">#define read_c0_brcm_cmt_local()	__read_32bit_c0_register($22, 3)</span>
<span class="cp">#define write_c0_brcm_cmt_local(val)	__write_32bit_c0_register($22, 3, val)</span>

<span class="cp">#define read_c0_brcm_config_1()		__read_32bit_c0_register($22, 5)</span>
<span class="cp">#define write_c0_brcm_config_1(val)	__write_32bit_c0_register($22, 5, val)</span>

<span class="cp">#define read_c0_brcm_cbr()		__read_32bit_c0_register($22, 6)</span>
<span class="cp">#define write_c0_brcm_cbr(val)		__write_32bit_c0_register($22, 6, val)</span>

<span class="cm">/* BMIPS5000 */</span>
<span class="cp">#define read_c0_brcm_config()		__read_32bit_c0_register($22, 0)</span>
<span class="cp">#define write_c0_brcm_config(val)	__write_32bit_c0_register($22, 0, val)</span>

<span class="cp">#define read_c0_brcm_mode()		__read_32bit_c0_register($22, 1)</span>
<span class="cp">#define write_c0_brcm_mode(val)		__write_32bit_c0_register($22, 1, val)</span>

<span class="cp">#define read_c0_brcm_action()		__read_32bit_c0_register($22, 2)</span>
<span class="cp">#define write_c0_brcm_action(val)	__write_32bit_c0_register($22, 2, val)</span>

<span class="cp">#define read_c0_brcm_edsp()		__read_32bit_c0_register($22, 3)</span>
<span class="cp">#define write_c0_brcm_edsp(val)		__write_32bit_c0_register($22, 3, val)</span>

<span class="cp">#define read_c0_brcm_bootvec()		__read_32bit_c0_register($22, 4)</span>
<span class="cp">#define write_c0_brcm_bootvec(val)	__write_32bit_c0_register($22, 4, val)</span>

<span class="cp">#define read_c0_brcm_sleepcount()	__read_32bit_c0_register($22, 7)</span>
<span class="cp">#define write_c0_brcm_sleepcount(val)	__write_32bit_c0_register($22, 7, val)</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to access the floating point coprocessor control registers</span>
<span class="cm"> */</span>
<span class="cp">#define read_32bit_cp1_register(source)                         \</span>
<span class="cp">({ int __res;                                                   \</span>
<span class="cp">	__asm__ __volatile__(                                   \</span>
<span class="cp">	&quot;.set\tpush\n\t&quot;					\</span>
<span class="cp">	&quot;.set\treorder\n\t&quot;					\</span>
<span class="cp">	</span><span class="cm">/* gas fails to assemble cfc1 for some archs (octeon).*/</span><span class="cp"> \</span>
<span class="cp">	&quot;.set\tmips1\n\t&quot;					\</span>
<span class="cp">        &quot;cfc1\t%0,&quot;STR(source)&quot;\n\t&quot;                            \</span>
<span class="cp">	&quot;.set\tpop&quot;						\</span>
<span class="cp">        : &quot;=r&quot; (__res));                                        \</span>
<span class="cp">        __res;})</span>

<span class="cp">#define rddsp(mask)							\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned int __res;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push				\n&quot;		\</span>
<span class="cp">	&quot;	.set	noat				\n&quot;		\</span>
<span class="cp">	&quot;	# rddsp $1, %x1				\n&quot;		\</span>
<span class="cp">	&quot;	.word	0x7c000cb8 | (%x1 &lt;&lt; 16)	\n&quot;		\</span>
<span class="cp">	&quot;	move	%0, $1				\n&quot;		\</span>
<span class="cp">	&quot;	.set	pop				\n&quot;		\</span>
<span class="cp">	: &quot;=r&quot; (__res)							\</span>
<span class="cp">	: &quot;i&quot; (mask));							\</span>
<span class="cp">	__res;								\</span>
<span class="cp">})</span>

<span class="cp">#define wrdsp(val, mask)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# wrdsp $1, %x1					\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x7c2004f8 | (%x1 &lt;&lt; 11)		\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">        :								\</span>
<span class="cp">	: &quot;r&quot; (val), &quot;i&quot; (mask));					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#if 0</span><span class="c">	/* Need DSP ASE capable assembler ... */</span>
<span class="c">#define mflo0() ({ long mflo0; __asm__(&quot;mflo %0, $ac0&quot; : &quot;=r&quot; (mflo0)); mflo0;})</span>
<span class="c">#define mflo1() ({ long mflo1; __asm__(&quot;mflo %0, $ac1&quot; : &quot;=r&quot; (mflo1)); mflo1;})</span>
<span class="c">#define mflo2() ({ long mflo2; __asm__(&quot;mflo %0, $ac2&quot; : &quot;=r&quot; (mflo2)); mflo2;})</span>
<span class="c">#define mflo3() ({ long mflo3; __asm__(&quot;mflo %0, $ac3&quot; : &quot;=r&quot; (mflo3)); mflo3;})</span>

<span class="c">#define mfhi0() ({ long mfhi0; __asm__(&quot;mfhi %0, $ac0&quot; : &quot;=r&quot; (mfhi0)); mfhi0;})</span>
<span class="c">#define mfhi1() ({ long mfhi1; __asm__(&quot;mfhi %0, $ac1&quot; : &quot;=r&quot; (mfhi1)); mfhi1;})</span>
<span class="c">#define mfhi2() ({ long mfhi2; __asm__(&quot;mfhi %0, $ac2&quot; : &quot;=r&quot; (mfhi2)); mfhi2;})</span>
<span class="c">#define mfhi3() ({ long mfhi3; __asm__(&quot;mfhi %0, $ac3&quot; : &quot;=r&quot; (mfhi3)); mfhi3;})</span>

<span class="c">#define mtlo0(x) __asm__(&quot;mtlo %0, $ac0&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mtlo1(x) __asm__(&quot;mtlo %0, $ac1&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mtlo2(x) __asm__(&quot;mtlo %0, $ac2&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mtlo3(x) __asm__(&quot;mtlo %0, $ac3&quot; ::&quot;r&quot; (x))</span>

<span class="c">#define mthi0(x) __asm__(&quot;mthi %0, $ac0&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mthi1(x) __asm__(&quot;mthi %0, $ac1&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mthi2(x) __asm__(&quot;mthi %0, $ac2&quot; ::&quot;r&quot; (x))</span>
<span class="c">#define mthi3(x) __asm__(&quot;mthi %0, $ac3&quot; ::&quot;r&quot; (x))</span>

<span class="cp">#else</span>

<span class="cp">#define mfhi0()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mfhi	%0, $ac0		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00000810		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mfhi1()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mfhi	%0, $ac1		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00200810		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mfhi2()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mfhi	%0, $ac2		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00400810		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mfhi3()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mfhi	%0, $ac3		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00600810		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mflo0()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mflo	%0, $ac0		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00000812		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mflo1()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mflo	%0, $ac1		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00200812		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mflo2()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mflo	%0, $ac2		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00400812		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mflo3()								\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __treg;						\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push			\n&quot;			\</span>
<span class="cp">	&quot;	.set	noat			\n&quot;			\</span>
<span class="cp">	&quot;	# mflo	%0, $ac3		\n&quot;			\</span>
<span class="cp">	&quot;	.word	0x00600812		\n&quot;			\</span>
<span class="cp">	&quot;	move	%0, $1			\n&quot;			\</span>
<span class="cp">	&quot;	.set	pop			\n&quot;			\</span>
<span class="cp">	: &quot;=r&quot; (__treg));						\</span>
<span class="cp">	__treg;								\</span>
<span class="cp">})</span>

<span class="cp">#define mthi0(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mthi	$1, $ac0				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00200011				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mthi1(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mthi	$1, $ac1				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00200811				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mthi2(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mthi	$1, $ac2				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00201011				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mthi3(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mthi	$1, $ac3				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00201811				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mtlo0(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mtlo	$1, $ac0				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00200013				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mtlo1(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mtlo	$1, $ac1				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00200813				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mtlo2(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mtlo	$1, $ac2				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00201013				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mtlo3(x)							\</span>
<span class="cp">do {									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noat					\n&quot;	\</span>
<span class="cp">	&quot;	move	$1, %0					\n&quot;	\</span>
<span class="cp">	&quot;	# mtlo	$1, $ac3				\n&quot;	\</span>
<span class="cp">	&quot;	.word	0x00201813				\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;r&quot; (x));							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * TLB operations.</span>
<span class="cm"> *</span>
<span class="cm"> * It is responsibility of the caller to take care of any TLB hazards.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;.set noreorder</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tlbp</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.set reorder&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if MIPS34K_MISSED_ITLB_WAR</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	noreorder				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	noat					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips32r2				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.word	0x41610001		# dvpe $1	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	move	%0, $1					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	ehb						</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">));</span>

	<span class="n">instruction_hazard</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;.set noreorder</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tlbr</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.set reorder&quot;</span><span class="p">);</span>

<span class="cp">#if MIPS34K_MISSED_ITLB_WAR</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">&amp;</span> <span class="n">_ULCAST_</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.set	noreorder			</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.set	noat				</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.set	mips32r2			</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.word	0x41600021	# evpe		</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	ehb					</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_write_indexed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;.set noreorder</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tlbwi</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.set reorder&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_write_random</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;.set noreorder</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;tlbwr</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;.set reorder&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Manipulate bits in a c0 register.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_MIPS_MT_SMTC</span>
<span class="cm">/*</span>
<span class="cm"> * SMTC Linux requires shutting-down microthread scheduling</span>
<span class="cm"> * during CP0 register read-modify-write sequences.</span>
<span class="cm"> */</span>
<span class="cp">#define __BUILD_SET_C0(name)					\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">set_c0_##name(unsigned int set)					\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res, new;					\</span>
<span class="cp">								\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res | set;					\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}								\</span>
<span class="cp">								\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">clear_c0_##name(unsigned int clear)				\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res, new;					\</span>
<span class="cp">								\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res &amp; ~clear;					\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}								\</span>
<span class="cp">								\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">change_c0_##name(unsigned int change, unsigned int val)		\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res, new;					\</span>
<span class="cp">								\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res &amp; ~change;					\</span>
<span class="cp">	new |= (val &amp; change);					\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}</span>

<span class="cp">#else </span><span class="cm">/* SMTC versions that manage MT scheduling */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/irqflags.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is a duplicate of dmt() in mipsmtregs.h to avoid problems with</span>
<span class="cm"> * header file recursion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__dmt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push						</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips32r2					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	noat						</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.word	0x41610BC1			# dmt $1	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	ehb							</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	move	%0, $1						</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop						</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">));</span>

	<span class="n">instruction_hazard</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __VPECONTROL_TE_SHIFT	15</span>
<span class="cp">#define __VPECONTROL_TE		(1UL &lt;&lt; __VPECONTROL_TE_SHIFT)</span>

<span class="cp">#define __EMT_ENABLE		__VPECONTROL_TE</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__emt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">previous</span> <span class="o">&amp;</span> <span class="n">__EMT_ENABLE</span><span class="p">))</span>
		<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;	.set	mips32r2				</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.word	0x41600be1		# emt		</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	ehb						</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	.set	mips0					</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ehb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	mips32r2					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	ehb							</span><span class="se">\n</span><span class="s">&quot;</span>		<span class="s">&quot;	.set	mips0						</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note that local_irq_save/restore affect TC-specific IXMT state,</span>
<span class="cm"> * not Status.IE as in non-SMTC kernel.</span>
<span class="cm"> */</span>

<span class="cp">#define __BUILD_SET_C0(name)					\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">set_c0_##name(unsigned int set)					\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res;					\</span>
<span class="cp">	unsigned int new;					\</span>
<span class="cp">	unsigned int omt;					\</span>
<span class="cp">	unsigned long flags;					\</span>
<span class="cp">								\</span>
<span class="cp">	local_irq_save(flags);					\</span>
<span class="cp">	omt = __dmt();						\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res | set;					\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">	__emt(omt);						\</span>
<span class="cp">	local_irq_restore(flags);				\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}								\</span>
<span class="cp">								\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">clear_c0_##name(unsigned int clear)				\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res;					\</span>
<span class="cp">	unsigned int new;					\</span>
<span class="cp">	unsigned int omt;					\</span>
<span class="cp">	unsigned long flags;					\</span>
<span class="cp">								\</span>
<span class="cp">	local_irq_save(flags);					\</span>
<span class="cp">	omt = __dmt();						\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res &amp; ~clear;					\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">	__emt(omt);						\</span>
<span class="cp">	local_irq_restore(flags);				\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}								\</span>
<span class="cp">								\</span>
<span class="cp">static inline unsigned int					\</span>
<span class="cp">change_c0_##name(unsigned int change, unsigned int newbits)	\</span>
<span class="cp">{								\</span>
<span class="cp">	unsigned int res;					\</span>
<span class="cp">	unsigned int new;					\</span>
<span class="cp">	unsigned int omt;					\</span>
<span class="cp">	unsigned long flags;					\</span>
<span class="cp">								\</span>
<span class="cp">	local_irq_save(flags);					\</span>
<span class="cp">								\</span>
<span class="cp">	omt = __dmt();						\</span>
<span class="cp">	res = read_c0_##name();					\</span>
<span class="cp">	new = res &amp; ~change;					\</span>
<span class="cp">	new |= (newbits &amp; change);				\</span>
<span class="cp">	write_c0_##name(new);					\</span>
<span class="cp">	__emt(omt);						\</span>
<span class="cp">	local_irq_restore(flags);				\</span>
<span class="cp">								\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}</span>
<span class="cp">#endif</span>

<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">cause</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">intcontrol</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">intctl</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">srsmap</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_config_0</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_bus_pll</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_reset</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_cmt_intr</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_cmt_ctrl</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_config</span><span class="p">)</span>
<span class="n">__BUILD_SET_C0</span><span class="p">(</span><span class="n">brcm_mode</span><span class="p">)</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_MIPSREGS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
