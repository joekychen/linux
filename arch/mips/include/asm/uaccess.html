<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › uaccess.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uaccess.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996, 1997, 1998, 1999, 2000, 03, 04 by Ralf Baechle</span>
<span class="cm"> * Copyright (C) 1999, 2000 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (C) 2007  Maciej W. Rozycki</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_UACCESS_H</span>
<span class="cp">#define _ASM_UACCESS_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The fs value determines whether argument validity checking should be</span>
<span class="cm"> * performed or not.  If get_fs() == USER_DS, checking is performed, with</span>
<span class="cm"> * get_fs() == KERNEL_DS, checking is bypassed.</span>
<span class="cm"> *</span>
<span class="cm"> * For historical reasons, these macros are grossly misnamed.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_32BIT</span>

<span class="cp">#define __UA_LIMIT	0x80000000UL</span>

<span class="cp">#define __UA_ADDR	&quot;.word&quot;</span>
<span class="cp">#define __UA_LA		&quot;la&quot;</span>
<span class="cp">#define __UA_ADDU	&quot;addu&quot;</span>
<span class="cp">#define __UA_t0		&quot;$8&quot;</span>
<span class="cp">#define __UA_t1		&quot;$9&quot;</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_32BIT */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_64BIT</span>

<span class="k">extern</span> <span class="n">u64</span> <span class="n">__ua_limit</span><span class="p">;</span>

<span class="cp">#define __UA_LIMIT	__ua_limit</span>

<span class="cp">#define __UA_ADDR	&quot;.dword&quot;</span>
<span class="cp">#define __UA_LA		&quot;dla&quot;</span>
<span class="cp">#define __UA_ADDU	&quot;daddu&quot;</span>
<span class="cp">#define __UA_t0		&quot;$12&quot;</span>
<span class="cp">#define __UA_t1		&quot;$13&quot;</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_64BIT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * USER_DS is a bitmask that has the bits set that may not be set in a valid</span>
<span class="cm"> * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but</span>
<span class="cm"> * the arithmetic we&#39;re doing only works if the limit is a power of two, so</span>
<span class="cm"> * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid</span>
<span class="cm"> * address in this range it&#39;s the process&#39;s problem, not ours :-)</span>
<span class="cm"> */</span>

<span class="cp">#define KERNEL_DS	((mm_segment_t) { 0UL })</span>
<span class="cp">#define USER_DS		((mm_segment_t) { __UA_LIMIT })</span>

<span class="cp">#define VERIFY_READ    0</span>
<span class="cp">#define VERIFY_WRITE   1</span>

<span class="cp">#define get_ds()	(KERNEL_DS)</span>
<span class="cp">#define get_fs()	(current_thread_info()-&gt;addr_limit)</span>
<span class="cp">#define set_fs(x)	(current_thread_info()-&gt;addr_limit = (x))</span>

<span class="cp">#define segment_eq(a, b)	((a).seg == (b).seg)</span>


<span class="cm">/*</span>
<span class="cm"> * Is a address valid? This does a straighforward calculation rather</span>
<span class="cm"> * than tests.</span>
<span class="cm"> *</span>
<span class="cm"> * Address valid if:</span>
<span class="cm"> *  - &quot;addr&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - AND &quot;addr+size&quot; doesn&#39;t have any high-bits set</span>
<span class="cm"> *  - OR we are in kernel mode.</span>
<span class="cm"> *</span>
<span class="cm"> * __ua_size() is a trick to avoid runtime checking of positive constant</span>
<span class="cm"> * sizes; for those we already know at compile time that the size is ok.</span>
<span class="cm"> */</span>
<span class="cp">#define __ua_size(size)							\</span>
<span class="cp">	((__builtin_constant_p(size) &amp;&amp; (signed long) (size) &gt; 0) ? 0 : (size))</span>

<span class="cm">/*</span>
<span class="cm"> * access_ok: - Checks if a user space pointer is valid</span>
<span class="cm"> * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that</span>
<span class="cm"> *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe</span>
<span class="cm"> *        to write to a block, it is always safe to read from it.</span>
<span class="cm"> * @addr: User space pointer to start of block to check</span>
<span class="cm"> * @size: Size of block to check</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks if a pointer to a block of memory in user space is valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true (nonzero) if the memory block may be valid, false (zero)</span>
<span class="cm"> * if it is definitely invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, depending on architecture, this function probably just</span>
<span class="cm"> * checks that the pointer is in the user space range - after calling</span>
<span class="cm"> * this function, memory access functions may still return -EFAULT.</span>
<span class="cm"> */</span>

<span class="cp">#define __access_mask get_fs().seg</span>

<span class="cp">#define __access_ok(addr, size, mask)					\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned long __addr = (unsigned long) (addr);			\</span>
<span class="cp">	unsigned long __size = size;					\</span>
<span class="cp">	unsigned long __mask = mask;					\</span>
<span class="cp">	unsigned long __ok;						\</span>
<span class="cp">									\</span>
<span class="cp">	__chk_user_ptr(addr);						\</span>
<span class="cp">	__ok = (signed long)(__mask &amp; (__addr | (__addr + __size) |	\</span>
<span class="cp">		__ua_size(__size)));					\</span>
<span class="cp">	__ok == 0;							\</span>
<span class="cp">})</span>

<span class="cp">#define access_ok(type, addr, size)					\</span>
<span class="cp">	likely(__access_ok((addr), (size), __access_mask))</span>

<span class="cm">/*</span>
<span class="cm"> * put_user: - Write a simple value into user space.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define put_user(x,ptr)	\</span>
<span class="cp">	__put_user_check((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * get_user: - Get a simple variable from user space.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define get_user(x,ptr) \</span>
<span class="cp">	__get_user_check((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __put_user: - Write a simple value into user space, with less checking.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user(x,ptr) \</span>
<span class="cp">	__put_user_nocheck((x), (ptr), sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __get_user: - Get a simple variable from user space, with less checking.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user(x,ptr) \</span>
<span class="cp">	__get_user_nocheck((x), (ptr), sizeof(*(ptr)))</span>

<span class="k">struct</span> <span class="n">__large_struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="p">};</span>
<span class="cp">#define __m(x) (*(struct __large_struct __user *)(x))</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_32BIT</span>
<span class="cp">#define __GET_USER_DW(val, ptr) __get_user_asm_ll32(val, ptr)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define __GET_USER_DW(val, ptr) __get_user_asm(val, &quot;ld&quot;, ptr)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__get_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_common(val, size, ptr)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __get_user_asm(val, &quot;lb&quot;, ptr); break;			\</span>
<span class="cp">	case 2: __get_user_asm(val, &quot;lh&quot;, ptr); break;			\</span>
<span class="cp">	case 4: __get_user_asm(val, &quot;lw&quot;, ptr); break;			\</span>
<span class="cp">	case 8: __GET_USER_DW(val, ptr); break;				\</span>
<span class="cp">	default: __get_user_unknown(); break;				\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __get_user_nocheck(x, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	int __gu_err;							\</span>
<span class="cp">									\</span>
<span class="cp">	__chk_user_ptr(ptr);						\</span>
<span class="cp">	__get_user_common((x), size, ptr);				\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_check(x, ptr, size)					\</span>
<span class="cp">({									\</span>
<span class="cp">	int __gu_err = -EFAULT;						\</span>
<span class="cp">	const __typeof__(*(ptr)) __user * __gu_ptr = (ptr);		\</span>
<span class="cp">									\</span>
<span class="cp">	might_fault();							\</span>
<span class="cp">	if (likely(access_ok(VERIFY_READ,  __gu_ptr, size)))		\</span>
<span class="cp">		__get_user_common((x), size, __gu_ptr);			\</span>
<span class="cp">									\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_asm(val, insn, addr)					\</span>
<span class="cp">{									\</span>
<span class="cp">	long __gu_tmp;							\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	&quot; insn &quot;	%1, %3				\n&quot;	\</span>
<span class="cp">	&quot;2:							\n&quot;	\</span>
<span class="cp">	&quot;	.section .fixup,\&quot;ax\&quot;				\n&quot;	\</span>
<span class="cp">	&quot;3:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	2b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section __ex_table,\&quot;a\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;	&quot;__UA_ADDR &quot;\t1b, 3b				\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__gu_err), &quot;=r&quot; (__gu_tmp)				\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;o&quot; (__m(addr)), &quot;i&quot; (-EFAULT));			\</span>
<span class="cp">									\</span>
<span class="cp">	(val) = (__typeof__(*(addr))) __gu_tmp;				\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a long long 64 using 32 bit registers.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user_asm_ll32(val, addr)					\</span>
<span class="cp">{									\</span>
<span class="cp">	union {								\</span>
<span class="cp">		unsigned long long	l;				\</span>
<span class="cp">		__typeof__(*(addr))	t;				\</span>
<span class="cp">	} __gu_tmp;							\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	lw	%1, (%3)				\n&quot;	\</span>
<span class="cp">	&quot;2:	lw	%D1, 4(%3)				\n&quot;	\</span>
<span class="cp">	&quot;3:	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;4:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	move	%1, $0					\n&quot;	\</span>
<span class="cp">	&quot;	move	%D1, $0					\n&quot;	\</span>
<span class="cp">	&quot;	j	3b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__gu_err), &quot;=&amp;r&quot; (__gu_tmp.l)				\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;r&quot; (addr), &quot;i&quot; (-EFAULT));				\</span>
<span class="cp">									\</span>
<span class="cp">	(val) = __gu_tmp.t;						\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_32BIT</span>
<span class="cp">#define __PUT_USER_DW(ptr) __put_user_asm_ll32(ptr)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define __PUT_USER_DW(ptr) __put_user_asm(&quot;sd&quot;, ptr)</span>
<span class="cp">#endif</span>

<span class="cp">#define __put_user_nocheck(x, ptr, size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val;					\</span>
<span class="cp">	int __pu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	__chk_user_ptr(ptr);						\</span>
<span class="cp">	__pu_val = (x);							\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __put_user_asm(&quot;sb&quot;, ptr); break;			\</span>
<span class="cp">	case 2: __put_user_asm(&quot;sh&quot;, ptr); break;			\</span>
<span class="cp">	case 4: __put_user_asm(&quot;sw&quot;, ptr); break;			\</span>
<span class="cp">	case 8: __PUT_USER_DW(ptr); break;				\</span>
<span class="cp">	default: __put_user_unknown(); break;				\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_check(x, ptr, size)					\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val = (x);				\</span>
<span class="cp">	int __pu_err = -EFAULT;						\</span>
<span class="cp">									\</span>
<span class="cp">	might_fault();							\</span>
<span class="cp">	if (likely(access_ok(VERIFY_WRITE,  __pu_addr, size))) {	\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		case 1: __put_user_asm(&quot;sb&quot;, __pu_addr); break;		\</span>
<span class="cp">		case 2: __put_user_asm(&quot;sh&quot;, __pu_addr); break;		\</span>
<span class="cp">		case 4: __put_user_asm(&quot;sw&quot;, __pu_addr); break;		\</span>
<span class="cp">		case 8: __PUT_USER_DW(__pu_addr); break;		\</span>
<span class="cp">		default: __put_user_unknown(); break;			\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_asm(insn, ptr)					\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	&quot; insn &quot;	%z2, %3		# __put_user_asm\n&quot;	\</span>
<span class="cp">	&quot;2:							\n&quot;	\</span>
<span class="cp">	&quot;	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;3:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	2b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 3b				\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__pu_err)						\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;Jr&quot; (__pu_val), &quot;o&quot; (__m(ptr)),			\</span>
<span class="cp">	  &quot;i&quot; (-EFAULT));						\</span>
<span class="cp">}</span>

<span class="cp">#define __put_user_asm_ll32(ptr)					\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	sw	%2, (%3)	# __put_user_asm_ll32	\n&quot;	\</span>
<span class="cp">	&quot;2:	sw	%D2, 4(%3)				\n&quot;	\</span>
<span class="cp">	&quot;3:							\n&quot;	\</span>
<span class="cp">	&quot;	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;4:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	3b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	.previous&quot;						\</span>
<span class="cp">	: &quot;=r&quot; (__pu_err)						\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;r&quot; (__pu_val), &quot;r&quot; (ptr),				\</span>
<span class="cp">	  &quot;i&quot; (-EFAULT));						\</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_user_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * put_user_unaligned: - Write a simple value into user space.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define put_user_unaligned(x,ptr)	\</span>
<span class="cp">	__put_user_unaligned_check((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * get_user_unaligned: - Get a simple variable from user space.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define get_user_unaligned(x,ptr) \</span>
<span class="cp">	__get_user_unaligned_check((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __put_user_unaligned: - Write a simple value into user space, with less checking.</span>
<span class="cm"> * @x:   Value to copy to user space.</span>
<span class="cm"> * @ptr: Destination address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple value from kernel space to user</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and @x must be assignable</span>
<span class="cm"> * to the result of dereferencing @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> */</span>
<span class="cp">#define __put_user_unaligned(x,ptr) \</span>
<span class="cp">	__put_user_unaligned_nocheck((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * __get_user_unaligned: - Get a simple variable from user space, with less checking.</span>
<span class="cm"> * @x:   Variable to store result.</span>
<span class="cm"> * @ptr: Source address, in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * This macro copies a single simple variable from user space to kernel</span>
<span class="cm"> * space.  It supports simple types like char and int, but not larger</span>
<span class="cm"> * data types like structures or arrays.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptr must have pointer-to-simple-variable type, and the result of</span>
<span class="cm"> * dereferencing @ptr must be assignable to @x without a cast.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must check the pointer with access_ok() before calling this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or -EFAULT on error.</span>
<span class="cm"> * On error, the variable @x is set to zero.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user_unaligned(x,ptr) \</span>
<span class="cp">	__get_user__unalignednocheck((x),(ptr),sizeof(*(ptr)))</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_32BIT</span>
<span class="cp">#define __GET_USER_UNALIGNED_DW(val, ptr)				\</span>
<span class="cp">	__get_user_unaligned_asm_ll32(val, ptr)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define __GET_USER_UNALIGNED_DW(val, ptr)				\</span>
<span class="cp">	__get_user_unaligned_asm(val, &quot;uld&quot;, ptr)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__get_user_unaligned_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define __get_user_unaligned_common(val, size, ptr)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __get_user_asm(val, &quot;lb&quot;, ptr); break;			\</span>
<span class="cp">	case 2: __get_user_unaligned_asm(val, &quot;ulh&quot;, ptr); break;	\</span>
<span class="cp">	case 4: __get_user_unaligned_asm(val, &quot;ulw&quot;, ptr); break;	\</span>
<span class="cp">	case 8: __GET_USER_UNALIGNED_DW(val, ptr); break;		\</span>
<span class="cp">	default: __get_user_unaligned_unknown(); break;			\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __get_user_unaligned_nocheck(x,ptr,size)			\</span>
<span class="cp">({									\</span>
<span class="cp">	int __gu_err;							\</span>
<span class="cp">									\</span>
<span class="cp">	__get_user_unaligned_common((x), size, ptr);			\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_unaligned_check(x,ptr,size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	int __gu_err = -EFAULT;						\</span>
<span class="cp">	const __typeof__(*(ptr)) __user * __gu_ptr = (ptr);		\</span>
<span class="cp">									\</span>
<span class="cp">	if (likely(access_ok(VERIFY_READ,  __gu_ptr, size)))		\</span>
<span class="cp">		__get_user_unaligned_common((x), size, __gu_ptr);	\</span>
<span class="cp">									\</span>
<span class="cp">	__gu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __get_user_unaligned_asm(val, insn, addr)			\</span>
<span class="cp">{									\</span>
<span class="cp">	long __gu_tmp;							\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	&quot; insn &quot;	%1, %3				\n&quot;	\</span>
<span class="cp">	&quot;2:							\n&quot;	\</span>
<span class="cp">	&quot;	.section .fixup,\&quot;ax\&quot;				\n&quot;	\</span>
<span class="cp">	&quot;3:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	2b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section __ex_table,\&quot;a\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;	&quot;__UA_ADDR &quot;\t1b, 3b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot;__UA_ADDR &quot;\t1b + 4, 3b			\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__gu_err), &quot;=r&quot; (__gu_tmp)				\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;o&quot; (__m(addr)), &quot;i&quot; (-EFAULT));			\</span>
<span class="cp">									\</span>
<span class="cp">	(val) = (__typeof__(*(addr))) __gu_tmp;				\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a long long 64 using 32 bit registers.</span>
<span class="cm"> */</span>
<span class="cp">#define __get_user_unaligned_asm_ll32(val, addr)			\</span>
<span class="cp">{									\</span>
<span class="cp">        unsigned long long __gu_tmp;					\</span>
<span class="cp">									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	ulw	%1, (%3)				\n&quot;	\</span>
<span class="cp">	&quot;2:	ulw	%D1, 4(%3)				\n&quot;	\</span>
<span class="cp">	&quot;	move	%0, $0					\n&quot;	\</span>
<span class="cp">	&quot;3:	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;4:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	move	%1, $0					\n&quot;	\</span>
<span class="cp">	&quot;	move	%D1, $0					\n&quot;	\</span>
<span class="cp">	&quot;	j	3b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b + 4, 4b			\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b + 4, 4b			\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__gu_err), &quot;=&amp;r&quot; (__gu_tmp)				\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;r&quot; (addr), &quot;i&quot; (-EFAULT));				\</span>
<span class="cp">	(val) = (__typeof__(*(addr))) __gu_tmp;				\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Yuck.  We need two variants, one for 64bit operation and one</span>
<span class="cm"> * for 32 bit mode and old iron.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_32BIT</span>
<span class="cp">#define __PUT_USER_UNALIGNED_DW(ptr) __put_user_unaligned_asm_ll32(ptr)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp">#define __PUT_USER_UNALIGNED_DW(ptr) __put_user_unaligned_asm(&quot;usd&quot;, ptr)</span>
<span class="cp">#endif</span>

<span class="cp">#define __put_user_unaligned_nocheck(x,ptr,size)			\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val;					\</span>
<span class="cp">	int __pu_err = 0;						\</span>
<span class="cp">									\</span>
<span class="cp">	__pu_val = (x);							\</span>
<span class="cp">	switch (size) {							\</span>
<span class="cp">	case 1: __put_user_asm(&quot;sb&quot;, ptr); break;			\</span>
<span class="cp">	case 2: __put_user_unaligned_asm(&quot;ush&quot;, ptr); break;		\</span>
<span class="cp">	case 4: __put_user_unaligned_asm(&quot;usw&quot;, ptr); break;		\</span>
<span class="cp">	case 8: __PUT_USER_UNALIGNED_DW(ptr); break;			\</span>
<span class="cp">	default: __put_user_unaligned_unknown(); break;			\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_unaligned_check(x,ptr,size)				\</span>
<span class="cp">({									\</span>
<span class="cp">	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\</span>
<span class="cp">	__typeof__(*(ptr)) __pu_val = (x);				\</span>
<span class="cp">	int __pu_err = -EFAULT;						\</span>
<span class="cp">									\</span>
<span class="cp">	if (likely(access_ok(VERIFY_WRITE,  __pu_addr, size))) {	\</span>
<span class="cp">		switch (size) {						\</span>
<span class="cp">		case 1: __put_user_asm(&quot;sb&quot;, __pu_addr); break;		\</span>
<span class="cp">		case 2: __put_user_unaligned_asm(&quot;ush&quot;, __pu_addr); break; \</span>
<span class="cp">		case 4: __put_user_unaligned_asm(&quot;usw&quot;, __pu_addr); break; \</span>
<span class="cp">		case 8: __PUT_USER_UNALGINED_DW(__pu_addr); break;	\</span>
<span class="cp">		default: __put_user_unaligned_unknown(); break;		\</span>
<span class="cp">		}							\</span>
<span class="cp">	}								\</span>
<span class="cp">	__pu_err;							\</span>
<span class="cp">})</span>

<span class="cp">#define __put_user_unaligned_asm(insn, ptr)				\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	&quot; insn &quot;	%z2, %3		# __put_user_unaligned_asm\n&quot; \</span>
<span class="cp">	&quot;2:							\n&quot;	\</span>
<span class="cp">	&quot;	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;3:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	2b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 3b				\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (__pu_err)						\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;Jr&quot; (__pu_val), &quot;o&quot; (__m(ptr)),			\</span>
<span class="cp">	  &quot;i&quot; (-EFAULT));						\</span>
<span class="cp">}</span>

<span class="cp">#define __put_user_unaligned_asm_ll32(ptr)				\</span>
<span class="cp">{									\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;1:	sw	%2, (%3)	# __put_user_unaligned_asm_ll32	\n&quot; \</span>
<span class="cp">	&quot;2:	sw	%D2, 4(%3)				\n&quot;	\</span>
<span class="cp">	&quot;3:							\n&quot;	\</span>
<span class="cp">	&quot;	.section	.fixup,\&quot;ax\&quot;			\n&quot;	\</span>
<span class="cp">	&quot;4:	li	%0, %4					\n&quot;	\</span>
<span class="cp">	&quot;	j	3b					\n&quot;	\</span>
<span class="cp">	&quot;	.previous					\n&quot;	\</span>
<span class="cp">	&quot;	.section	__ex_table,\&quot;a\&quot;		\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	1b + 4, 4b			\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b, 4b				\n&quot;	\</span>
<span class="cp">	&quot;	&quot; __UA_ADDR &quot;	2b + 4, 4b			\n&quot;	\</span>
<span class="cp">	&quot;	.previous&quot;						\</span>
<span class="cp">	: &quot;=r&quot; (__pu_err)						\</span>
<span class="cp">	: &quot;0&quot; (0), &quot;r&quot; (__pu_val), &quot;r&quot; (ptr),				\</span>
<span class="cp">	  &quot;i&quot; (-EFAULT));						\</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_user_unaligned_unknown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re generating jump to subroutines which will be outside the range of</span>
<span class="cm"> * jump instructions</span>
<span class="cm"> */</span>
<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __MODULE_JAL(destination)					\</span>
<span class="cp">	&quot;.set\tnoat\n\t&quot;						\</span>
<span class="cp">	__UA_LA &quot;\t$1, &quot; #destination &quot;\n\t&quot; 				\</span>
<span class="cp">	&quot;jalr\t$1\n\t&quot;							\</span>
<span class="cp">	&quot;.set\tat\n\t&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __MODULE_JAL(destination)					\</span>
<span class="cp">	&quot;jal\t&quot; #destination &quot;\n\t&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_CPU_DADDI_WORKAROUNDS</span>
<span class="cp">#define DADDI_SCRATCH &quot;$0&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define DADDI_SCRATCH &quot;$3&quot;</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">__copy_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__n</span><span class="p">);</span>

<span class="cp">#define __invoke_copy_to_user(to, from, n)				\</span>
<span class="cp">({									\</span>
<span class="cp">	register void __user *__cu_to_r __asm__(&quot;$4&quot;);			\</span>
<span class="cp">	register const void *__cu_from_r __asm__(&quot;$5&quot;);			\</span>
<span class="cp">	register long __cu_len_r __asm__(&quot;$6&quot;);				\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to_r = (to);						\</span>
<span class="cp">	__cu_from_r = (from);						\</span>
<span class="cp">	__cu_len_r = (n);						\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	__MODULE_JAL(__copy_user)					\</span>
<span class="cp">	: &quot;+r&quot; (__cu_to_r), &quot;+r&quot; (__cu_from_r), &quot;+r&quot; (__cu_len_r)	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;$8&quot;, &quot;$9&quot;, &quot;$10&quot;, &quot;$11&quot;, &quot;$12&quot;, &quot;$15&quot;, &quot;$24&quot;, &quot;$31&quot;,		\</span>
<span class="cp">	  DADDI_SCRATCH, &quot;memory&quot;);					\</span>
<span class="cp">	__cu_len_r;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * __copy_to_user: - Copy a block of data into user space, with less checking.</span>
<span class="cm"> * @to:   Destination address, in user space.</span>
<span class="cm"> * @from: Source address, in kernel space.</span>
<span class="cm"> * @n:    Number of bytes to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy data from kernel space to user space.  Caller must check</span>
<span class="cm"> * the specified block with access_ok() before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be copied.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> */</span>
<span class="cp">#define __copy_to_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user *__cu_to;						\</span>
<span class="cp">	const void *__cu_from;						\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	might_fault();							\</span>
<span class="cp">	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);	\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">__copy_user_inatomic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__n</span><span class="p">);</span>

<span class="cp">#define __copy_to_user_inatomic(to, from, n)				\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user *__cu_to;						\</span>
<span class="cp">	const void *__cu_from;						\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	__cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len);	\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cp">#define __copy_from_user_inatomic(to, from, n)				\</span>
<span class="cp">({									\</span>
<span class="cp">	void *__cu_to;							\</span>
<span class="cp">	const void __user *__cu_from;					\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	__cu_len = __invoke_copy_from_user_inatomic(__cu_to, __cu_from,	\</span>
<span class="cp">	                                            __cu_len);		\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * copy_to_user: - Copy a block of data into user space.</span>
<span class="cm"> * @to:   Destination address, in user space.</span>
<span class="cm"> * @from: Source address, in kernel space.</span>
<span class="cm"> * @n:    Number of bytes to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy data from kernel space to user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be copied.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> */</span>
<span class="cp">#define copy_to_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user *__cu_to;						\</span>
<span class="cp">	const void *__cu_from;						\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) {		\</span>
<span class="cp">		might_fault();						\</span>
<span class="cp">		__cu_len = __invoke_copy_to_user(__cu_to, __cu_from,	\</span>
<span class="cp">		                                 __cu_len);		\</span>
<span class="cp">	}								\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cp">#define __invoke_copy_from_user(to, from, n)				\</span>
<span class="cp">({									\</span>
<span class="cp">	register void *__cu_to_r __asm__(&quot;$4&quot;);				\</span>
<span class="cp">	register const void __user *__cu_from_r __asm__(&quot;$5&quot;);		\</span>
<span class="cp">	register long __cu_len_r __asm__(&quot;$6&quot;);				\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to_r = (to);						\</span>
<span class="cp">	__cu_from_r = (from);						\</span>
<span class="cp">	__cu_len_r = (n);						\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;.set\tnoreorder\n\t&quot;						\</span>
<span class="cp">	__MODULE_JAL(__copy_user)					\</span>
<span class="cp">	&quot;.set\tnoat\n\t&quot;						\</span>
<span class="cp">	__UA_ADDU &quot;\t$1, %1, %2\n\t&quot;					\</span>
<span class="cp">	&quot;.set\tat\n\t&quot;							\</span>
<span class="cp">	&quot;.set\treorder&quot;							\</span>
<span class="cp">	: &quot;+r&quot; (__cu_to_r), &quot;+r&quot; (__cu_from_r), &quot;+r&quot; (__cu_len_r)	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;$8&quot;, &quot;$9&quot;, &quot;$10&quot;, &quot;$11&quot;, &quot;$12&quot;, &quot;$15&quot;, &quot;$24&quot;, &quot;$31&quot;,		\</span>
<span class="cp">	  DADDI_SCRATCH, &quot;memory&quot;);					\</span>
<span class="cp">	__cu_len_r;							\</span>
<span class="cp">})</span>

<span class="cp">#define __invoke_copy_from_user_inatomic(to, from, n)			\</span>
<span class="cp">({									\</span>
<span class="cp">	register void *__cu_to_r __asm__(&quot;$4&quot;);				\</span>
<span class="cp">	register const void __user *__cu_from_r __asm__(&quot;$5&quot;);		\</span>
<span class="cp">	register long __cu_len_r __asm__(&quot;$6&quot;);				\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to_r = (to);						\</span>
<span class="cp">	__cu_from_r = (from);						\</span>
<span class="cp">	__cu_len_r = (n);						\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;.set\tnoreorder\n\t&quot;						\</span>
<span class="cp">	__MODULE_JAL(__copy_user_inatomic)				\</span>
<span class="cp">	&quot;.set\tnoat\n\t&quot;						\</span>
<span class="cp">	__UA_ADDU &quot;\t$1, %1, %2\n\t&quot;					\</span>
<span class="cp">	&quot;.set\tat\n\t&quot;							\</span>
<span class="cp">	&quot;.set\treorder&quot;							\</span>
<span class="cp">	: &quot;+r&quot; (__cu_to_r), &quot;+r&quot; (__cu_from_r), &quot;+r&quot; (__cu_len_r)	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;$8&quot;, &quot;$9&quot;, &quot;$10&quot;, &quot;$11&quot;, &quot;$12&quot;, &quot;$15&quot;, &quot;$24&quot;, &quot;$31&quot;,		\</span>
<span class="cp">	  DADDI_SCRATCH, &quot;memory&quot;);					\</span>
<span class="cp">	__cu_len_r;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * __copy_from_user: - Copy a block of data from user space, with less checking.</span>
<span class="cm"> * @to:   Destination address, in kernel space.</span>
<span class="cm"> * @from: Source address, in user space.</span>
<span class="cm"> * @n:    Number of bytes to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy data from user space to kernel space.  Caller must check</span>
<span class="cm"> * the specified block with access_ok() before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be copied.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> *</span>
<span class="cm"> * If some data could not be copied, this function will pad the copied</span>
<span class="cm"> * data to the requested size using zero bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define __copy_from_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void *__cu_to;							\</span>
<span class="cp">	const void __user *__cu_from;					\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	might_fault();							\</span>
<span class="cp">	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\</span>
<span class="cp">	                                   __cu_len);			\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * copy_from_user: - Copy a block of data from user space.</span>
<span class="cm"> * @to:   Destination address, in kernel space.</span>
<span class="cm"> * @from: Source address, in user space.</span>
<span class="cm"> * @n:    Number of bytes to copy.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy data from user space to kernel space.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be copied.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> *</span>
<span class="cm"> * If some data could not be copied, this function will pad the copied</span>
<span class="cm"> * data to the requested size using zero bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define copy_from_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void *__cu_to;							\</span>
<span class="cp">	const void __user *__cu_from;					\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	if (access_ok(VERIFY_READ, __cu_from, __cu_len)) {		\</span>
<span class="cp">		might_fault();						\</span>
<span class="cp">		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\</span>
<span class="cp">		                                   __cu_len);		\</span>
<span class="cp">	}								\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cp">#define __copy_in_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user *__cu_to;						\</span>
<span class="cp">	const void __user *__cu_from;					\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	might_fault();							\</span>
<span class="cp">	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\</span>
<span class="cp">	                                   __cu_len);			\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cp">#define copy_in_user(to, from, n)					\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user *__cu_to;						\</span>
<span class="cp">	const void __user *__cu_from;					\</span>
<span class="cp">	long __cu_len;							\</span>
<span class="cp">									\</span>
<span class="cp">	__cu_to = (to);							\</span>
<span class="cp">	__cu_from = (from);						\</span>
<span class="cp">	__cu_len = (n);							\</span>
<span class="cp">	if (likely(access_ok(VERIFY_READ, __cu_from, __cu_len) &amp;&amp;	\</span>
<span class="cp">	           access_ok(VERIFY_WRITE, __cu_to, __cu_len))) {	\</span>
<span class="cp">		might_fault();						\</span>
<span class="cp">		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\</span>
<span class="cp">		                                   __cu_len);		\</span>
<span class="cp">	}								\</span>
<span class="cp">	__cu_len;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * __clear_user: - Zero a block of memory in user space, with less checking.</span>
<span class="cm"> * @to:   Destination address, in user space.</span>
<span class="cm"> * @n:    Number of bytes to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Zero a block of memory in user space.  Caller must check</span>
<span class="cm"> * the specified block with access_ok() before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of bytes that could not be cleared.</span>
<span class="cm"> * On success, this will be zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__kernel_size_t</span>
<span class="nf">__clear_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">__kernel_size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__kernel_size_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$5, $0</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$6, %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__bzero</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $6&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="s">&quot;$5&quot;</span><span class="p">,</span> <span class="s">&quot;$6&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="n">__UA_t1</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define clear_user(addr,n)						\</span>
<span class="cp">({									\</span>
<span class="cp">	void __user * __cl_addr = (addr);				\</span>
<span class="cp">	unsigned long __cl_size = (n);					\</span>
<span class="cp">	if (__cl_size &amp;&amp; access_ok(VERIFY_WRITE,			\</span>
<span class="cp">					__cl_addr, __cl_size))		\</span>
<span class="cp">		__cl_size = __clear_user(__cl_addr, __cl_size);		\</span>
<span class="cp">	__cl_size;							\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.</span>
<span class="cm"> * @dst:   Destination address, in kernel space.  This buffer must be at</span>
<span class="cm"> *         least @count bytes long.</span>
<span class="cm"> * @src:   Source address, in user space.</span>
<span class="cm"> * @count: Maximum number of bytes to copy, including the trailing NUL.</span>
<span class="cm"> *</span>
<span class="cm"> * Copies a NUL-terminated string from userspace to kernel space.</span>
<span class="cm"> * Caller must check the specified block with access_ok() before calling</span>
<span class="cm"> * this function.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns the length of the string (not including the trailing</span>
<span class="cm"> * NUL).</span>
<span class="cm"> *</span>
<span class="cm"> * If access to userspace fails, returns -EFAULT (some data may have been</span>
<span class="cm"> * copied).</span>
<span class="cm"> *</span>
<span class="cm"> * If @count is smaller than the length of the string, copies @count bytes</span>
<span class="cm"> * and returns @count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">__strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$5, %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$6, %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strncpy_from_user_nocheck_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__to</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__from</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__len</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$3&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="s">&quot;$5&quot;</span><span class="p">,</span> <span class="s">&quot;$6&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * strncpy_from_user: - Copy a NUL terminated string from userspace.</span>
<span class="cm"> * @dst:   Destination address, in kernel space.  This buffer must be at</span>
<span class="cm"> *         least @count bytes long.</span>
<span class="cm"> * @src:   Source address, in user space.</span>
<span class="cm"> * @count: Maximum number of bytes to copy, including the trailing NUL.</span>
<span class="cm"> *</span>
<span class="cm"> * Copies a NUL-terminated string from userspace to kernel space.</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns the length of the string (not including the trailing</span>
<span class="cm"> * NUL).</span>
<span class="cm"> *</span>
<span class="cm"> * If access to userspace fails, returns -EFAULT (some data may have been</span>
<span class="cm"> * copied).</span>
<span class="cm"> *</span>
<span class="cm"> * If @count is smaller than the length of the string, copies @count bytes</span>
<span class="cm"> * and returns @count.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span>
<span class="nf">strncpy_from_user</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$5, %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$6, %3</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strncpy_from_user_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__to</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__from</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">__len</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$3&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="s">&quot;$5&quot;</span><span class="p">,</span> <span class="s">&quot;$6&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns: 0 if bad, string length+1 (memory size) of string if ok */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">__strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strlen_user_nocheck_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * strlen_user: - Get the size of a string in user space.</span>
<span class="cm"> * @str: The string to measure.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Get the size of a NUL-terminated string in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of the string INCLUDING the terminating NUL.</span>
<span class="cm"> * On exception, returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is a limit on the length of a valid string, you may wish to</span>
<span class="cm"> * consider using strnlen_user() instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strlen_user_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns: 0 if bad, string length+1 (memory size) of string if ok */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">__strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$5, %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strnlen_user_nocheck_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="s">&quot;$5&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * strlen_user: - Get the size of a string in user space.</span>
<span class="cm"> * @str: The string to measure.</span>
<span class="cm"> *</span>
<span class="cm"> * Context: User context only.  This function may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Get the size of a NUL-terminated string in user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of the string INCLUDING the terminating NUL.</span>
<span class="cm"> * On exception, returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is a limit on the length of a valid string, you may wish to</span>
<span class="cm"> * consider using strnlen_user() instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">strnlen_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">might_fault</span><span class="p">();</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$4, %1</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">$5, %2</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="n">__MODULE_JAL</span><span class="p">(</span><span class="n">__strnlen_user_asm</span><span class="p">)</span>
		<span class="s">&quot;move</span><span class="se">\t</span><span class="s">%0, $2&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="o">:</span> <span class="s">&quot;$2&quot;</span><span class="p">,</span> <span class="s">&quot;$4&quot;</span><span class="p">,</span> <span class="s">&quot;$5&quot;</span><span class="p">,</span> <span class="n">__UA_t0</span><span class="p">,</span> <span class="s">&quot;$31&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">exception_table_entry</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nextinsn</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">fixup_exception</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_UACCESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
