<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › r4kcache.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>r4kcache.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Inline assembly cache operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996 David S. Miller (davem@davemloft.net)</span>
<span class="cm"> * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)</span>
<span class="cm"> * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_R4KCACHE_H</span>
<span class="cp">#define _ASM_R4KCACHE_H</span>

<span class="cp">#include &lt;asm/asm.h&gt;</span>
<span class="cp">#include &lt;asm/cacheops.h&gt;</span>
<span class="cp">#include &lt;asm/cpu-features.h&gt;</span>
<span class="cp">#include &lt;asm/mipsmtregs.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This macro return a properly sign-extended address suitable as base address</span>
<span class="cm"> * for indexed cache operations.  Two issues here:</span>
<span class="cm"> *</span>
<span class="cm"> *  - The MIPS32 and MIPS64 specs permit an implementation to directly derive</span>
<span class="cm"> *    the index bits from the virtual address.  This breaks with tradition</span>
<span class="cm"> *    set by the R4000.  To keep unpleasant surprises from happening we pick</span>
<span class="cm"> *    an address in KSEG0 / CKSEG0.</span>
<span class="cm"> *  - We need a properly sign extended address for 64-bit code.  To get away</span>
<span class="cm"> *    without ifdefs we let the compiler do it by a type cast.</span>
<span class="cm"> */</span>
<span class="cp">#define INDEX_BASE	CKSEG0</span>

<span class="cp">#define cache_op(op,addr)						\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set	push					\n&quot;	\</span>
<span class="cp">	&quot;	.set	noreorder				\n&quot;	\</span>
<span class="cp">	&quot;	.set	mips3\n\t				\n&quot;	\</span>
<span class="cp">	&quot;	cache	%0, %1					\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop					\n&quot;	\</span>
<span class="cp">	:								\</span>
<span class="cp">	: &quot;i&quot; (op), &quot;R&quot; (*(unsigned char *)(addr)))</span>

<span class="cp">#ifdef CONFIG_MIPS_MT</span>
<span class="cm">/*</span>
<span class="cm"> * Temporary hacks for SMTC debug. Optionally force single-threaded</span>
<span class="cm"> * execution during I-cache flushes.</span>
<span class="cm"> */</span>

<span class="cp">#define PROTECT_CACHE_FLUSHES 1</span>

<span class="cp">#ifdef PROTECT_CACHE_FLUSHES</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mt_protiflush</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mt_protdflush</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mt_cflush_lockdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mt_cflush_release</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define BEGIN_MT_IPROT \</span>
<span class="cp">	unsigned long flags = 0;			\</span>
<span class="cp">	unsigned long mtflags = 0;			\</span>
<span class="cp">	if(mt_protiflush) {				\</span>
<span class="cp">		local_irq_save(flags);			\</span>
<span class="cp">		ehb();					\</span>
<span class="cp">		mtflags = dvpe();			\</span>
<span class="cp">		mt_cflush_lockdown();			\</span>
<span class="cp">	}</span>

<span class="cp">#define END_MT_IPROT \</span>
<span class="cp">	if(mt_protiflush) {				\</span>
<span class="cp">		mt_cflush_release();			\</span>
<span class="cp">		evpe(mtflags);				\</span>
<span class="cp">		local_irq_restore(flags);		\</span>
<span class="cp">	}</span>

<span class="cp">#define BEGIN_MT_DPROT \</span>
<span class="cp">	unsigned long flags = 0;			\</span>
<span class="cp">	unsigned long mtflags = 0;			\</span>
<span class="cp">	if(mt_protdflush) {				\</span>
<span class="cp">		local_irq_save(flags);			\</span>
<span class="cp">		ehb();					\</span>
<span class="cp">		mtflags = dvpe();			\</span>
<span class="cp">		mt_cflush_lockdown();			\</span>
<span class="cp">	}</span>

<span class="cp">#define END_MT_DPROT \</span>
<span class="cp">	if(mt_protdflush) {				\</span>
<span class="cp">		mt_cflush_release();			\</span>
<span class="cp">		evpe(mtflags);				\</span>
<span class="cp">		local_irq_restore(flags);		\</span>
<span class="cp">	}</span>

<span class="cp">#else</span>

<span class="cp">#define BEGIN_MT_IPROT</span>
<span class="cp">#define BEGIN_MT_DPROT</span>
<span class="cp">#define END_MT_IPROT</span>
<span class="cp">#define END_MT_DPROT</span>

<span class="cp">#endif </span><span class="cm">/* PROTECT_CACHE_FLUSHES */</span><span class="cp"></span>

<span class="cp">#define __iflush_prologue						\</span>
<span class="cp">	unsigned long redundance;					\</span>
<span class="cp">	extern int mt_n_iflushes;					\</span>
<span class="cp">	BEGIN_MT_IPROT							\</span>
<span class="cp">	for (redundance = 0; redundance &lt; mt_n_iflushes; redundance++) {</span>

<span class="cp">#define __iflush_epilogue						\</span>
<span class="cp">	END_MT_IPROT							\</span>
<span class="cp">	}</span>

<span class="cp">#define __dflush_prologue						\</span>
<span class="cp">	unsigned long redundance;					\</span>
<span class="cp">	extern int mt_n_dflushes;					\</span>
<span class="cp">	BEGIN_MT_DPROT							\</span>
<span class="cp">	for (redundance = 0; redundance &lt; mt_n_dflushes; redundance++) {</span>

<span class="cp">#define __dflush_epilogue \</span>
<span class="cp">	END_MT_DPROT	 \</span>
<span class="cp">	}</span>

<span class="cp">#define __inv_dflush_prologue __dflush_prologue</span>
<span class="cp">#define __inv_dflush_epilogue __dflush_epilogue</span>
<span class="cp">#define __sflush_prologue {</span>
<span class="cp">#define __sflush_epilogue }</span>
<span class="cp">#define __inv_sflush_prologue __sflush_prologue</span>
<span class="cp">#define __inv_sflush_epilogue __sflush_epilogue</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_MIPS_MT */</span><span class="cp"></span>

<span class="cp">#define __iflush_prologue {</span>
<span class="cp">#define __iflush_epilogue }</span>
<span class="cp">#define __dflush_prologue {</span>
<span class="cp">#define __dflush_epilogue }</span>
<span class="cp">#define __inv_dflush_prologue {</span>
<span class="cp">#define __inv_dflush_epilogue }</span>
<span class="cp">#define __sflush_prologue {</span>
<span class="cp">#define __sflush_epilogue }</span>
<span class="cp">#define __inv_sflush_prologue {</span>
<span class="cp">#define __inv_sflush_epilogue }</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MIPS_MT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_icache_line_indexed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__iflush_prologue</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Index_Invalidate_I</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__iflush_epilogue</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_dcache_line_indexed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dflush_prologue</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__dflush_epilogue</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_scache_line_indexed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_icache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__iflush_prologue</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__iflush_epilogue</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_dcache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dflush_prologue</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__dflush_epilogue</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_dcache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dflush_prologue</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Hit_Invalidate_D</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">__dflush_epilogue</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_scache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_scache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define protected_cache_op(op,addr)				\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;	.set	push			\n&quot;		\</span>
<span class="cp">	&quot;	.set	noreorder		\n&quot;		\</span>
<span class="cp">	&quot;	.set	mips3			\n&quot;		\</span>
<span class="cp">	&quot;1:	cache	%0, (%1)		\n&quot;		\</span>
<span class="cp">	&quot;2:	.set	pop			\n&quot;		\</span>
<span class="cp">	&quot;	.section __ex_table,\&quot;a\&quot;	\n&quot;		\</span>
<span class="cp">	&quot;	&quot;STR(PTR)&quot; 1b, 2b		\n&quot;		\</span>
<span class="cp">	&quot;	.previous&quot;					\</span>
<span class="cp">	:							\</span>
<span class="cp">	: &quot;i&quot; (op), &quot;r&quot; (addr))</span>

<span class="cm">/*</span>
<span class="cm"> * The next two are for badland addresses like signal trampolines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">protected_flush_icache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">protected_cache_op</span><span class="p">(</span><span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * R10000 / R12000 hazard - these processors don&#39;t support the Hit_Writeback_D</span>
<span class="cm"> * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style</span>
<span class="cm"> * caches.  We&#39;re talking about one cacheline unnecessarily getting invalidated</span>
<span class="cm"> * here so the penalty isn&#39;t overly hard.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">protected_writeback_dcache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">protected_cache_op</span><span class="p">(</span><span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">protected_writeback_scache_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">protected_cache_op</span><span class="p">(</span><span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This one is RM7000-specific</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_tcache_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cache_op</span><span class="p">(</span><span class="n">Page_Invalidate_T</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cache16_unroll32(base,op)					\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set push					\n&quot;	\</span>
<span class="cp">	&quot;	.set noreorder					\n&quot;	\</span>
<span class="cp">	&quot;	.set mips3					\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x000(%0); cache %1, 0x010(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x020(%0); cache %1, 0x030(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x040(%0); cache %1, 0x050(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x060(%0); cache %1, 0x070(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x080(%0); cache %1, 0x090(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x0a0(%0); cache %1, 0x0b0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x0c0(%0); cache %1, 0x0d0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x0e0(%0); cache %1, 0x0f0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x100(%0); cache %1, 0x110(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x120(%0); cache %1, 0x130(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x140(%0); cache %1, 0x150(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x160(%0); cache %1, 0x170(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x180(%0); cache %1, 0x190(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x1a0(%0); cache %1, 0x1b0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x1c0(%0); cache %1, 0x1d0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x1e0(%0); cache %1, 0x1f0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	.set pop					\n&quot;	\</span>
<span class="cp">		:							\</span>
<span class="cp">		: &quot;r&quot; (base),						\</span>
<span class="cp">		  &quot;i&quot; (op));</span>

<span class="cp">#define cache32_unroll32(base,op)					\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set push					\n&quot;	\</span>
<span class="cp">	&quot;	.set noreorder					\n&quot;	\</span>
<span class="cp">	&quot;	.set mips3					\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x000(%0); cache %1, 0x020(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x040(%0); cache %1, 0x060(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x080(%0); cache %1, 0x0a0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x0c0(%0); cache %1, 0x0e0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x100(%0); cache %1, 0x120(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x140(%0); cache %1, 0x160(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x180(%0); cache %1, 0x1a0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x1c0(%0); cache %1, 0x1e0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x200(%0); cache %1, 0x220(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x240(%0); cache %1, 0x260(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x280(%0); cache %1, 0x2a0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x2c0(%0); cache %1, 0x2e0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x300(%0); cache %1, 0x320(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x340(%0); cache %1, 0x360(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x380(%0); cache %1, 0x3a0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x3c0(%0); cache %1, 0x3e0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	.set pop					\n&quot;	\</span>
<span class="cp">		:							\</span>
<span class="cp">		: &quot;r&quot; (base),						\</span>
<span class="cp">		  &quot;i&quot; (op));</span>

<span class="cp">#define cache64_unroll32(base,op)					\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set push					\n&quot;	\</span>
<span class="cp">	&quot;	.set noreorder					\n&quot;	\</span>
<span class="cp">	&quot;	.set mips3					\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x000(%0); cache %1, 0x040(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x080(%0); cache %1, 0x0c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x100(%0); cache %1, 0x140(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x180(%0); cache %1, 0x1c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x200(%0); cache %1, 0x240(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x280(%0); cache %1, 0x2c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x300(%0); cache %1, 0x340(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x380(%0); cache %1, 0x3c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x400(%0); cache %1, 0x440(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x480(%0); cache %1, 0x4c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x500(%0); cache %1, 0x540(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x580(%0); cache %1, 0x5c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x600(%0); cache %1, 0x640(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x680(%0); cache %1, 0x6c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x700(%0); cache %1, 0x740(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x780(%0); cache %1, 0x7c0(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	.set pop					\n&quot;	\</span>
<span class="cp">		:							\</span>
<span class="cp">		: &quot;r&quot; (base),						\</span>
<span class="cp">		  &quot;i&quot; (op));</span>

<span class="cp">#define cache128_unroll32(base,op)					\</span>
<span class="cp">	__asm__ __volatile__(						\</span>
<span class="cp">	&quot;	.set push					\n&quot;	\</span>
<span class="cp">	&quot;	.set noreorder					\n&quot;	\</span>
<span class="cp">	&quot;	.set mips3					\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x100(%0); cache %1, 0x180(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x200(%0); cache %1, 0x280(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x300(%0); cache %1, 0x380(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x400(%0); cache %1, 0x480(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x500(%0); cache %1, 0x580(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x600(%0); cache %1, 0x680(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x700(%0); cache %1, 0x780(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x800(%0); cache %1, 0x880(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0x900(%0); cache %1, 0x980(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xa00(%0); cache %1, 0xa80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xb00(%0); cache %1, 0xb80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xc00(%0); cache %1, 0xc80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xd00(%0); cache %1, 0xd80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xe00(%0); cache %1, 0xe80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	cache %1, 0xf00(%0); cache %1, 0xf80(%0)	\n&quot;	\</span>
<span class="cp">	&quot;	.set pop					\n&quot;	\</span>
<span class="cp">		:							\</span>
<span class="cp">		: &quot;r&quot; (base),						\</span>
<span class="cp">		  &quot;i&quot; (op));</span>

<span class="cm">/* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */</span>
<span class="cp">#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \</span>
<span class="cp">static inline void blast_##pfx##cache##lsize(void)			\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long start = INDEX_BASE;				\</span>
<span class="cp">	unsigned long end = start + current_cpu_data.desc.waysize;	\</span>
<span class="cp">	unsigned long ws_inc = 1UL &lt;&lt; current_cpu_data.desc.waybit;	\</span>
<span class="cp">	unsigned long ws_end = current_cpu_data.desc.ways &lt;&lt;		\</span>
<span class="cp">	                       current_cpu_data.desc.waybit;		\</span>
<span class="cp">	unsigned long ws, addr;						\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_prologue						\</span>
<span class="cp">									\</span>
<span class="cp">	for (ws = 0; ws &lt; ws_end; ws += ws_inc)				\</span>
<span class="cp">		for (addr = start; addr &lt; end; addr += lsize * 32)	\</span>
<span class="cp">			cache##lsize##_unroll32(addr|ws, indexop);	\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_epilogue						\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline void blast_##pfx##cache##lsize##_page(unsigned long page)	\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long start = page;					\</span>
<span class="cp">	unsigned long end = page + PAGE_SIZE;				\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_prologue						\</span>
<span class="cp">									\</span>
<span class="cp">	do {								\</span>
<span class="cp">		cache##lsize##_unroll32(start, hitop);			\</span>
<span class="cp">		start += lsize * 32;					\</span>
<span class="cp">	} while (start &lt; end);						\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_epilogue						\</span>
<span class="cp">}									\</span>
<span class="cp">									\</span>
<span class="cp">static inline void blast_##pfx##cache##lsize##_page_indexed(unsigned long page) \</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long indexmask = current_cpu_data.desc.waysize - 1;	\</span>
<span class="cp">	unsigned long start = INDEX_BASE + (page &amp; indexmask);		\</span>
<span class="cp">	unsigned long end = start + PAGE_SIZE;				\</span>
<span class="cp">	unsigned long ws_inc = 1UL &lt;&lt; current_cpu_data.desc.waybit;	\</span>
<span class="cp">	unsigned long ws_end = current_cpu_data.desc.ways &lt;&lt;		\</span>
<span class="cp">	                       current_cpu_data.desc.waybit;		\</span>
<span class="cp">	unsigned long ws, addr;						\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_prologue						\</span>
<span class="cp">									\</span>
<span class="cp">	for (ws = 0; ws &lt; ws_end; ws += ws_inc)				\</span>
<span class="cp">		for (addr = start; addr &lt; end; addr += lsize * 32)	\</span>
<span class="cp">			cache##lsize##_unroll32(addr|ws, indexop);	\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_epilogue						\</span>
<span class="cp">}</span>

<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">icache</span><span class="p">,</span> <span class="n">Index_Invalidate_I</span><span class="p">,</span> <span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">icache</span><span class="p">,</span> <span class="n">Index_Invalidate_I</span><span class="p">,</span> <span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">icache</span><span class="p">,</span> <span class="n">Index_Invalidate_I</span><span class="p">,</span> <span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>

<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">Hit_Invalidate_D</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_D</span><span class="p">,</span> <span class="n">Hit_Invalidate_D</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE</span><span class="p">(</span><span class="n">inv_s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Index_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>

<span class="cm">/* build blast_xxx_range, protected_blast_xxx_range */</span>
<span class="cp">#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \</span>
<span class="cp">static inline void prot##blast_##pfx##cache##_range(unsigned long start, \</span>
<span class="cp">						    unsigned long end)	\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long lsize = cpu_##desc##_line_size();			\</span>
<span class="cp">	unsigned long addr = start &amp; ~(lsize - 1);			\</span>
<span class="cp">	unsigned long aend = (end - 1) &amp; ~(lsize - 1);			\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_prologue						\</span>
<span class="cp">									\</span>
<span class="cp">	while (1) {							\</span>
<span class="cp">		prot##cache_op(hitop, addr);				\</span>
<span class="cp">		if (addr == aend)					\</span>
<span class="cp">			break;						\</span>
<span class="cp">		addr += lsize;						\</span>
<span class="cp">	}								\</span>
<span class="cp">									\</span>
<span class="cp">	__##pfx##flush_epilogue						\</span>
<span class="cp">}</span>

<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="n">protected_</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="n">protected_</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">icache</span><span class="p">,</span> <span class="n">Hit_Invalidate_I</span><span class="p">,</span> <span class="n">protected_</span><span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_D</span><span class="p">,</span> <span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Hit_Writeback_Inv_SD</span><span class="p">,</span> <span class="p">)</span>
<span class="cm">/* blast_inv_dcache_range */</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">inv_d</span><span class="p">,</span> <span class="n">dcache</span><span class="p">,</span> <span class="n">Hit_Invalidate_D</span><span class="p">,</span> <span class="p">)</span>
<span class="n">__BUILD_BLAST_CACHE_RANGE</span><span class="p">(</span><span class="n">inv_s</span><span class="p">,</span> <span class="n">scache</span><span class="p">,</span> <span class="n">Hit_Invalidate_SD</span><span class="p">,</span> <span class="p">)</span>

<span class="cp">#endif </span><span class="cm">/* _ASM_R4KCACHE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
