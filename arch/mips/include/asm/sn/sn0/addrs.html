<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › sn › sn0 › addrs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../../index.html"></a><h1>addrs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Derived from IRIX &lt;sys/SN/SN0/addrs.h&gt;, revision 1.126.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (C) 1999 by Ralf Baechle</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_SN_SN0_ADDRS_H</span>
<span class="cp">#define _ASM_SN_SN0_ADDRS_H</span>


<span class="cm">/*</span>
<span class="cm"> * SN0 (on a T5) Address map</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains a set of definitions and macros which are used</span>
<span class="cm"> * to reference into the major address spaces (CAC, HSPEC, IO, MSPEC,</span>
<span class="cm"> * and UNCAC) used by the SN0 architecture.  It also contains addresses</span>
<span class="cm"> * for &quot;major&quot; statically locatable PROM/Kernel data structures, such as</span>
<span class="cm"> * the partition table, the configuration data structure, etc.</span>
<span class="cm"> * We make an implicit assumption that the processor using this file</span>
<span class="cm"> * follows the R10K&#39;s provisions for specifying uncached attributes;</span>
<span class="cm"> * should this change, the base registers may very well become processor-</span>
<span class="cm"> * dependent.</span>
<span class="cm"> *</span>
<span class="cm"> * For more information on the address spaces, see the &quot;Local Resources&quot;</span>
<span class="cm"> * chapter of the Hub specification.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This header file is included both by C and by assembler source</span>
<span class="cm"> *	 files.  Please bracket any language-dependent definitions</span>
<span class="cm"> *	 appropriately.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Some of the macros here need to be casted to appropriate types when used</span>
<span class="cm"> * from C.  They definitely must not be casted from assembly language so we</span>
<span class="cm"> * use some new ANSI preprocessor stuff to paste these on where needed.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The following couple of definitions will eventually need to be variables,</span>
<span class="cm"> * since the amount of address space assigned to each node depends on</span>
<span class="cm"> * whether the system is running in N-mode (more nodes with less memory)</span>
<span class="cm"> * or M-mode (fewer nodes with more memory).  We expect that it will</span>
<span class="cm"> * be a while before we need to make this decision dynamically, though,</span>
<span class="cm"> * so for now we just use defines bracketed by an ifdef.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SGI_SN_N_MODE</span>

<span class="cp">#define NODE_SIZE_BITS		31</span>
<span class="cp">#define BWIN_SIZE_BITS		28</span>

<span class="cp">#define NASID_BITS		9</span>
<span class="cp">#define NASID_BITMASK		(0x1ffLL)</span>
<span class="cp">#define NASID_SHFT		31</span>
<span class="cp">#define NASID_META_BITS		5</span>
<span class="cp">#define NASID_LOCAL_BITS	4</span>

<span class="cp">#define BDDIR_UPPER_MASK	(UINT64_CAST 0x7ffff &lt;&lt; 10)</span>
<span class="cp">#define BDECC_UPPER_MASK	(UINT64_CAST 0x3ffffff &lt;&lt; 3)</span>

<span class="cp">#else </span><span class="cm">/* !defined(CONFIG_SGI_SN_N_MODE), assume that M-mode is desired */</span><span class="cp"></span>

<span class="cp">#define NODE_SIZE_BITS		32</span>
<span class="cp">#define BWIN_SIZE_BITS		29</span>

<span class="cp">#define NASID_BITMASK		(0xffLL)</span>
<span class="cp">#define NASID_BITS		8</span>
<span class="cp">#define NASID_SHFT		32</span>
<span class="cp">#define NASID_META_BITS		4</span>
<span class="cp">#define NASID_LOCAL_BITS	4</span>

<span class="cp">#define BDDIR_UPPER_MASK	(UINT64_CAST 0xfffff &lt;&lt; 10)</span>
<span class="cp">#define BDECC_UPPER_MASK	(UINT64_CAST 0x7ffffff &lt;&lt; 3)</span>

<span class="cp">#endif </span><span class="cm">/* !defined(CONFIG_SGI_SN_N_MODE) */</span><span class="cp"></span>

<span class="cp">#define NODE_ADDRSPACE_SIZE	(UINT64_CAST 1 &lt;&lt; NODE_SIZE_BITS)</span>

<span class="cp">#define NASID_MASK		(UINT64_CAST NASID_BITMASK &lt;&lt; NASID_SHFT)</span>
<span class="cp">#define NASID_GET(_pa)		(int) ((UINT64_CAST (_pa) &gt;&gt;		\</span>
<span class="cp">					NASID_SHFT) &amp; NASID_BITMASK)</span>

<span class="cp">#if !defined(__ASSEMBLY__)</span>

<span class="cp">#define NODE_SWIN_BASE(nasid, widget)					\</span>
<span class="cp">	((widget == 0) ? NODE_BWIN_BASE((nasid), SWIN0_BIGWIN)		\</span>
<span class="cp">	: RAW_NODE_SWIN_BASE(nasid, widget))</span>
<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#define NODE_SWIN_BASE(nasid, widget) \</span>
<span class="cp">     (NODE_IO_BASE(nasid) + (UINT64_CAST(widget) &lt;&lt; SWIN_SIZE_BITS))</span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following definitions pertain to the IO special address</span>
<span class="cm"> * space.  They define the location of the big and little windows</span>
<span class="cm"> * of any given node.</span>
<span class="cm"> */</span>

<span class="cp">#define BWIN_INDEX_BITS		3</span>
<span class="cp">#define BWIN_SIZE		(UINT64_CAST 1 &lt;&lt; BWIN_SIZE_BITS)</span>
<span class="cp">#define	BWIN_SIZEMASK		(BWIN_SIZE - 1)</span>
<span class="cp">#define	BWIN_WIDGET_MASK	0x7</span>
<span class="cp">#define NODE_BWIN_BASE0(nasid)	(NODE_IO_BASE(nasid) + BWIN_SIZE)</span>
<span class="cp">#define NODE_BWIN_BASE(nasid, bigwin)	(NODE_BWIN_BASE0(nasid) + 	\</span>
<span class="cp">			(UINT64_CAST(bigwin) &lt;&lt; BWIN_SIZE_BITS))</span>

<span class="cp">#define	BWIN_WIDGETADDR(addr)	((addr) &amp; BWIN_SIZEMASK)</span>
<span class="cp">#define	BWIN_WINDOWNUM(addr)	(((addr) &gt;&gt; BWIN_SIZE_BITS) &amp; BWIN_WIDGET_MASK)</span>
<span class="cm">/*</span>
<span class="cm"> * Verify if addr belongs to large window address of node with &quot;nasid&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: &quot;addr&quot; is expected to be XKPHYS address, and NOT physical</span>
<span class="cm"> * address</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define	NODE_BWIN_ADDR(nasid, addr)	\</span>
<span class="cp">		(((addr) &gt;= NODE_BWIN_BASE0(nasid)) &amp;&amp; \</span>
<span class="cp">		 ((addr) &lt; (NODE_BWIN_BASE(nasid, HUB_NUM_BIG_WINDOW) + \</span>
<span class="cp">				BWIN_SIZE)))</span>

<span class="cm">/*</span>
<span class="cm"> * The following define the major position-independent aliases used</span>
<span class="cm"> * in SN0.</span>
<span class="cm"> *	CALIAS -- Varies in size, points to the first n bytes of memory</span>
<span class="cm"> *		  	on the reader&#39;s node.</span>
<span class="cm"> */</span>

<span class="cp">#define CALIAS_BASE		CAC_BASE</span>



<span class="cp">#define BRIDGE_REG_PTR(_base, _off)	((volatile bridgereg_t *) \</span>
<span class="cp">	((__psunsigned_t)(_base) + (__psunsigned_t)(_off)))</span>

<span class="cp">#define SN0_WIDGET_BASE(_nasid, _wid)	(NODE_SWIN_BASE((_nasid), (_wid)))</span>

<span class="cm">/* Turn on sable logging for the processors whose bits are set. */</span>
<span class="cp">#define SABLE_LOG_TRIGGER(_map)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#define KERN_NMI_ADDR(nasid, slice)					\</span>
<span class="cp">                    TO_NODE_UNCAC((nasid), IP27_NMI_KREGS_OFFSET + 	\</span>
<span class="cp">				  (IP27_NMI_KREGS_CPU_SIZE * (slice)))</span>
<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#ifdef PROM</span>

<span class="cp">#define MISC_PROM_BASE		PHYS_TO_K0(0x01300000)</span>
<span class="cp">#define MISC_PROM_SIZE		0x200000</span>

<span class="cp">#define DIAG_BASE		PHYS_TO_K0(0x01500000)</span>
<span class="cp">#define DIAG_SIZE		0x300000</span>

<span class="cp">#define ROUTE_BASE		PHYS_TO_K0(0x01800000)</span>
<span class="cp">#define ROUTE_SIZE		0x200000</span>

<span class="cp">#define IP27PROM_FLASH_HDR	PHYS_TO_K0(0x01300000)</span>
<span class="cp">#define IP27PROM_FLASH_DATA	PHYS_TO_K0(0x01301000)</span>
<span class="cp">#define IP27PROM_CORP_MAX	32</span>
<span class="cp">#define IP27PROM_CORP		PHYS_TO_K0(0x01800000)</span>
<span class="cp">#define IP27PROM_CORP_SIZE	0x10000</span>
<span class="cp">#define IP27PROM_CORP_STK	PHYS_TO_K0(0x01810000)</span>
<span class="cp">#define IP27PROM_CORP_STKSIZE	0x2000</span>
<span class="cp">#define IP27PROM_DECOMP_BUF	PHYS_TO_K0(0x01900000)</span>
<span class="cp">#define IP27PROM_DECOMP_SIZE	0xfff00</span>

<span class="cp">#define IP27PROM_BASE		PHYS_TO_K0(0x01a00000)</span>
<span class="cp">#define IP27PROM_BASE_MAPPED	(UNCAC_BASE | 0x1fc00000)</span>
<span class="cp">#define IP27PROM_SIZE_MAX	0x100000</span>

<span class="cp">#define IP27PROM_PCFG		PHYS_TO_K0(0x01b00000)</span>
<span class="cp">#define IP27PROM_PCFG_SIZE	0xd0000</span>
<span class="cp">#define IP27PROM_ERRDMP		PHYS_TO_K1(0x01bd0000)</span>
<span class="cp">#define IP27PROM_ERRDMP_SIZE	0xf000</span>

<span class="cp">#define IP27PROM_INIT_START	PHYS_TO_K1(0x01bd0000)</span>
<span class="cp">#define IP27PROM_CONSOLE	PHYS_TO_K1(0x01bdf000)</span>
<span class="cp">#define IP27PROM_CONSOLE_SIZE	0x200</span>
<span class="cp">#define IP27PROM_NETUART	PHYS_TO_K1(0x01bdf200)</span>
<span class="cp">#define IP27PROM_NETUART_SIZE	0x100</span>
<span class="cp">#define IP27PROM_UNUSED1	PHYS_TO_K1(0x01bdf300)</span>
<span class="cp">#define IP27PROM_UNUSED1_SIZE	0x500</span>
<span class="cp">#define IP27PROM_ELSC_BASE_A	PHYS_TO_K0(0x01bdf800)</span>
<span class="cp">#define IP27PROM_ELSC_BASE_B	PHYS_TO_K0(0x01bdfc00)</span>
<span class="cp">#define IP27PROM_STACK_A	PHYS_TO_K0(0x01be0000)</span>
<span class="cp">#define IP27PROM_STACK_B	PHYS_TO_K0(0x01bf0000)</span>
<span class="cp">#define IP27PROM_STACK_SHFT	16</span>
<span class="cp">#define IP27PROM_STACK_SIZE	(1 &lt;&lt; IP27PROM_STACK_SHFT)</span>
<span class="cp">#define IP27PROM_INIT_END	PHYS_TO_K0(0x01c00000)</span>

<span class="cp">#define SLAVESTACK_BASE		PHYS_TO_K0(0x01580000)</span>
<span class="cp">#define SLAVESTACK_SIZE		0x40000</span>

<span class="cp">#define ENETBUFS_BASE		PHYS_TO_K0(0x01f80000)</span>
<span class="cp">#define ENETBUFS_SIZE		0x20000</span>

<span class="cp">#define IO6PROM_BASE		PHYS_TO_K0(0x01c00000)</span>
<span class="cp">#define IO6PROM_SIZE		0x400000</span>
<span class="cp">#define	IO6PROM_BASE_MAPPED	(UNCAC_BASE | 0x11c00000)</span>
<span class="cp">#define IO6DPROM_BASE		PHYS_TO_K0(0x01c00000)</span>
<span class="cp">#define IO6DPROM_SIZE		0x200000</span>

<span class="cp">#define NODEBUGUNIX_ADDR	PHYS_TO_K0(0x00019000)</span>
<span class="cp">#define DEBUGUNIX_ADDR		PHYS_TO_K0(0x00100000)</span>

<span class="cp">#define IP27PROM_INT_LAUNCH	10	</span><span class="cm">/* and 11 */</span><span class="cp"></span>
<span class="cp">#define IP27PROM_INT_NETUART	12	</span><span class="cm">/* through 17 */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* PROM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * needed by symmon so it needs to be outside #if PROM</span>
<span class="cm"> */</span>
<span class="cp">#define IP27PROM_ELSC_SHFT	10</span>
<span class="cp">#define IP27PROM_ELSC_SIZE	(1 &lt;&lt; IP27PROM_ELSC_SHFT)</span>

<span class="cm">/*</span>
<span class="cm"> * This address is used by IO6PROM to build MemoryDescriptors of</span>
<span class="cm"> * free memory. This address is important since unix gets loaded</span>
<span class="cm"> * at this address, and this memory has to be FREE if unix is to</span>
<span class="cm"> * be loaded.</span>
<span class="cm"> */</span>

<span class="cp">#define FREEMEM_BASE		PHYS_TO_K0(0x2000000)</span>

<span class="cp">#define IO6PROM_STACK_SHFT	14	</span><span class="cm">/* stack per cpu */</span><span class="cp"></span>
<span class="cp">#define IO6PROM_STACK_SIZE	(1 &lt;&lt; IO6PROM_STACK_SHFT)</span>

<span class="cm">/*</span>
<span class="cm"> * IP27 PROM vectors</span>
<span class="cm"> */</span>

<span class="cp">#define IP27PROM_ENTRY		PHYS_TO_COMPATK1(0x1fc00000)</span>
<span class="cp">#define IP27PROM_RESTART	PHYS_TO_COMPATK1(0x1fc00008)</span>
<span class="cp">#define IP27PROM_SLAVELOOP	PHYS_TO_COMPATK1(0x1fc00010)</span>
<span class="cp">#define IP27PROM_PODMODE	PHYS_TO_COMPATK1(0x1fc00018)</span>
<span class="cp">#define IP27PROM_IOC3UARTPOD	PHYS_TO_COMPATK1(0x1fc00020)</span>
<span class="cp">#define IP27PROM_FLASHLEDS	PHYS_TO_COMPATK1(0x1fc00028)</span>
<span class="cp">#define IP27PROM_REPOD		PHYS_TO_COMPATK1(0x1fc00030)</span>
<span class="cp">#define IP27PROM_LAUNCHSLAVE	PHYS_TO_COMPATK1(0x1fc00038)</span>
<span class="cp">#define IP27PROM_WAITSLAVE	PHYS_TO_COMPATK1(0x1fc00040)</span>
<span class="cp">#define IP27PROM_POLLSLAVE	PHYS_TO_COMPATK1(0x1fc00048)</span>

<span class="cp">#define KL_UART_BASE	LOCAL_HUB_ADDR(MD_UREG0_0)	</span><span class="cm">/* base of UART regs */</span><span class="cp"></span>
<span class="cp">#define KL_UART_CMD	LOCAL_HUB_ADDR(MD_UREG0_0)	</span><span class="cm">/* UART command reg */</span><span class="cp"></span>
<span class="cp">#define KL_UART_DATA	LOCAL_HUB_ADDR(MD_UREG0_1)	</span><span class="cm">/* UART data reg */</span><span class="cp"></span>
<span class="cp">#define KL_I2C_REG	MD_UREG0_0			</span><span class="cm">/* I2C reg */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* Address 0x400 to 0x1000 ualias points to cache error eframe + misc</span>
<span class="cm"> * CACHE_ERR_SP_PTR could either contain an address to the stack, or</span>
<span class="cm"> * the stack could start at CACHE_ERR_SP_PTR</span>
<span class="cm"> */</span>
<span class="cp">#if defined(HUB_ERR_STS_WAR)</span>
<span class="cp">#define CACHE_ERR_EFRAME	0x480</span>
<span class="cp">#else </span><span class="cm">/* HUB_ERR_STS_WAR */</span><span class="cp"></span>
<span class="cp">#define CACHE_ERR_EFRAME	0x400</span>
<span class="cp">#endif </span><span class="cm">/* HUB_ERR_STS_WAR */</span><span class="cp"></span>

<span class="cp">#define CACHE_ERR_ECCFRAME	(CACHE_ERR_EFRAME + EF_SIZE)</span>
<span class="cp">#define CACHE_ERR_SP_PTR	(0x1000 - 32)	</span><span class="cm">/* why -32? TBD */</span><span class="cp"></span>
<span class="cp">#define CACHE_ERR_IBASE_PTR	(0x1000 - 40)</span>
<span class="cp">#define CACHE_ERR_SP		(CACHE_ERR_SP_PTR - 16)</span>
<span class="cp">#define CACHE_ERR_AREA_SIZE	(ARCS_SPB_OFFSET - CACHE_ERR_EFRAME)</span>

<span class="cp">#endif	</span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define _ARCSPROM</span>

<span class="cp">#if defined(HUB_ERR_STS_WAR)</span>

<span class="cp">#define ERR_STS_WAR_REGISTER	IIO_IIBUSERR</span>
<span class="cp">#define ERR_STS_WAR_ADDR	LOCAL_HUB_ADDR(IIO_IIBUSERR)</span>
<span class="cp">#define ERR_STS_WAR_PHYSADDR	TO_PHYS((__psunsigned_t)ERR_STS_WAR_ADDR)</span>
				<span class="cm">/* Used to match addr in error reg. */</span>
<span class="cp">#define OLD_ERR_STS_WAR_OFFSET	((MD_MEM_BANKS * MD_BANK_SIZE) - 0x100)</span>

<span class="cp">#endif </span><span class="cm">/* HUB_ERR_STS_WAR */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _ASM_SN_SN0_ADDRS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:6}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../../javascript/docco.min.js"></script>
</html>
