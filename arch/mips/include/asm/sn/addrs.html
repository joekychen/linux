<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › sn › addrs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>addrs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992 - 1997, 1999, 2000 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (C) 1999, 2000 by Ralf Baechle</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _ASM_SN_ADDRS_H</span>
<span class="cp">#define _ASM_SN_ADDRS_H</span>


<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#include &lt;asm/addrspace.h&gt;</span>
<span class="cp">#include &lt;asm/sn/kldir.h&gt;</span>

<span class="cp">#if defined(CONFIG_SGI_IP27)</span>
<span class="cp">#include &lt;asm/sn/sn0/addrs.h&gt;</span>
<span class="cp">#elif defined(CONFIG_SGI_IP35)</span>
<span class="cp">#include &lt;asm/sn/sn1/addrs.h&gt;</span>
<span class="cp">#endif</span>


<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define PS_UINT_CAST		(unsigned long)</span>
<span class="cp">#define UINT64_CAST		(unsigned long)</span>

<span class="cp">#define HUBREG_CAST		(volatile hubreg_t *)</span>

<span class="cp">#else </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#define PS_UINT_CAST</span>
<span class="cp">#define UINT64_CAST</span>
<span class="cp">#define HUBREG_CAST</span>

<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>


<span class="cp">#define NASID_GET_META(_n)	((_n) &gt;&gt; NASID_LOCAL_BITS)</span>
<span class="cp">#ifdef CONFIG_SGI_IP27</span>
<span class="cp">#define NASID_GET_LOCAL(_n)	((_n) &amp; 0xf)</span>
<span class="cp">#endif</span>
<span class="cp">#define NASID_MAKE(_m, _l)	(((_m) &lt;&lt; NASID_LOCAL_BITS) | (_l))</span>

<span class="cp">#define NODE_ADDRSPACE_MASK	(NODE_ADDRSPACE_SIZE - 1)</span>
<span class="cp">#define TO_NODE_ADDRSPACE(_pa)	(UINT64_CAST (_pa) &amp; NODE_ADDRSPACE_MASK)</span>

<span class="cp">#define CHANGE_ADDR_NASID(_pa, _nasid)	\</span>
<span class="cp">		((UINT64_CAST(_pa) &amp; ~NASID_MASK) | \</span>
<span class="cp">		 (UINT64_CAST(_nasid) &lt;&lt;  NASID_SHFT))</span>


<span class="cm">/*</span>
<span class="cm"> * The following macros are used to index to the beginning of a specific</span>
<span class="cm"> * node&#39;s address space.</span>
<span class="cm"> */</span>

<span class="cp">#define NODE_OFFSET(_n)		(UINT64_CAST (_n) &lt;&lt; NODE_SIZE_BITS)</span>

<span class="cp">#define NODE_CAC_BASE(_n)	(CAC_BASE   + NODE_OFFSET(_n))</span>
<span class="cp">#define NODE_HSPEC_BASE(_n)	(HSPEC_BASE + NODE_OFFSET(_n))</span>
<span class="cp">#define NODE_IO_BASE(_n)	(IO_BASE    + NODE_OFFSET(_n))</span>
<span class="cp">#define NODE_MSPEC_BASE(_n)	(MSPEC_BASE + NODE_OFFSET(_n))</span>
<span class="cp">#define NODE_UNCAC_BASE(_n)	(UNCAC_BASE + NODE_OFFSET(_n))</span>

<span class="cp">#define TO_NODE(_n, _x)		(NODE_OFFSET(_n)     | ((_x)		   ))</span>
<span class="cp">#define TO_NODE_CAC(_n, _x)	(NODE_CAC_BASE(_n)   | ((_x) &amp; TO_PHYS_MASK))</span>
<span class="cp">#define TO_NODE_UNCAC(_n, _x)	(NODE_UNCAC_BASE(_n) | ((_x) &amp; TO_PHYS_MASK))</span>
<span class="cp">#define TO_NODE_MSPEC(_n, _x)	(NODE_MSPEC_BASE(_n) | ((_x) &amp; TO_PHYS_MASK))</span>
<span class="cp">#define TO_NODE_HSPEC(_n, _x)	(NODE_HSPEC_BASE(_n) | ((_x) &amp; TO_PHYS_MASK))</span>


<span class="cp">#define RAW_NODE_SWIN_BASE(nasid, widget)				\</span>
<span class="cp">	(NODE_IO_BASE(nasid) + (UINT64_CAST(widget) &lt;&lt; SWIN_SIZE_BITS))</span>

<span class="cp">#define WIDGETID_GET(addr)	((unsigned char)((addr &gt;&gt; SWIN_SIZE_BITS) &amp; 0xff))</span>

<span class="cm">/*</span>
<span class="cm"> * The following definitions pertain to the IO special address</span>
<span class="cm"> * space.  They define the location of the big and little windows</span>
<span class="cm"> * of any given node.</span>
<span class="cm"> */</span>

<span class="cp">#define SWIN_SIZE_BITS		24</span>
<span class="cp">#define SWIN_SIZE		(UINT64_CAST 1 &lt;&lt; 24)</span>
<span class="cp">#define	SWIN_SIZEMASK		(SWIN_SIZE - 1)</span>
<span class="cp">#define	SWIN_WIDGET_MASK	0xF</span>

<span class="cm">/*</span>
<span class="cm"> * Convert smallwindow address to xtalk address.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;addr&#39; can be physical or virtual address, but will be converted</span>
<span class="cm"> * to Xtalk address in the range 0 -&gt; SWINZ_SIZEMASK</span>
<span class="cm"> */</span>
<span class="cp">#define	SWIN_WIDGETADDR(addr)	((addr) &amp; SWIN_SIZEMASK)</span>
<span class="cp">#define	SWIN_WIDGETNUM(addr)	(((addr)  &gt;&gt; SWIN_SIZE_BITS) &amp; SWIN_WIDGET_MASK)</span>
<span class="cm">/*</span>
<span class="cm"> * Verify if addr belongs to small window address on node with &quot;nasid&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: &quot;addr&quot; is expected to be XKPHYS address, and NOT physical</span>
<span class="cm"> * address</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define	NODE_SWIN_ADDR(nasid, addr)	\</span>
<span class="cp">		(((addr) &gt;= NODE_SWIN_BASE(nasid, 0))  &amp;&amp; \</span>
<span class="cp">		 ((addr) &lt;  (NODE_SWIN_BASE(nasid, HUB_NUM_WIDGET) + SWIN_SIZE)\</span>
<span class="cp">		 ))</span>

<span class="cm">/*</span>
<span class="cm"> * The following define the major position-independent aliases used</span>
<span class="cm"> * in SN.</span>
<span class="cm"> *	UALIAS -- 256MB in size, reads in the UALIAS result in</span>
<span class="cm"> *			uncached references to the memory of the reader&#39;s node.</span>
<span class="cm"> *	CPU_UALIAS -- 128kb in size, the bottom part of UALIAS is flipped</span>
<span class="cm"> *			depending on which CPU does the access to provide</span>
<span class="cm"> *			all CPUs with unique uncached memory at low addresses.</span>
<span class="cm"> *	LBOOT  -- 256MB in size, reads in the LBOOT area result in</span>
<span class="cm"> *			uncached references to the local hub&#39;s boot prom and</span>
<span class="cm"> *			other directory-bus connected devices.</span>
<span class="cm"> *	IALIAS -- 8MB in size, reads in the IALIAS result in uncached</span>
<span class="cm"> *			references to the local hub&#39;s registers.</span>
<span class="cm"> */</span>

<span class="cp">#define UALIAS_BASE		HSPEC_BASE</span>
<span class="cp">#define UALIAS_SIZE		0x10000000	</span><span class="cm">/* 256 Megabytes */</span><span class="cp"></span>
<span class="cp">#define UALIAS_LIMIT		(UALIAS_BASE + UALIAS_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * The bottom of ualias space is flipped depending on whether you&#39;re</span>
<span class="cm"> * processor 0 or 1 within a node.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SGI_IP27</span>
<span class="cp">#define UALIAS_FLIP_BASE	UALIAS_BASE</span>
<span class="cp">#define UALIAS_FLIP_SIZE	0x20000</span>
<span class="cp">#define UALIAS_FLIP_BIT		0x10000</span>
<span class="cp">#define UALIAS_FLIP_ADDR(_x)	(cputoslice(smp_processor_id()) ? \</span>
<span class="cp">				 (_x) ^ UALIAS_FLIP_BIT : (_x))</span>

<span class="cp">#define LBOOT_BASE		(HSPEC_BASE + 0x10000000)</span>
<span class="cp">#define LBOOT_SIZE		0x10000000</span>
<span class="cp">#define LBOOT_LIMIT		(LBOOT_BASE + LBOOT_SIZE)</span>
<span class="cp">#define LBOOT_STRIDE		0		</span><span class="cm">/* IP27 has only one CPU PROM */</span><span class="cp"></span>

<span class="cp">#endif</span>

<span class="cp">#define	HUB_REGISTER_WIDGET	1</span>
<span class="cp">#define IALIAS_BASE		NODE_SWIN_BASE(0, HUB_REGISTER_WIDGET)</span>
<span class="cp">#define IALIAS_SIZE		0x800000	</span><span class="cm">/* 8 Megabytes */</span><span class="cp"></span>
<span class="cp">#define IS_IALIAS(_a)		(((_a) &gt;= IALIAS_BASE) &amp;&amp;		\</span>
<span class="cp">				 ((_a) &lt; (IALIAS_BASE + IALIAS_SIZE)))</span>

<span class="cm">/*</span>
<span class="cm"> * Macro for referring to Hub&#39;s RBOOT space</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SGI_IP27</span>
<span class="cp">#define RBOOT_SIZE		0x10000000	</span><span class="cm">/* 256 Megabytes */</span><span class="cp"></span>
<span class="cp">#define NODE_RBOOT_BASE(_n)	(NODE_HSPEC_BASE(_n) + 0x30000000)</span>
<span class="cp">#define NODE_RBOOT_LIMIT(_n)	(NODE_RBOOT_BASE(_n) + RBOOT_SIZE)</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Macros for referring the Hub&#39;s back door space</span>
<span class="cm"> *</span>
<span class="cm"> *   These macros correctly process addresses in any node&#39;s space.</span>
<span class="cm"> *   WARNING: They won&#39;t work in assembler.</span>
<span class="cm"> *</span>
<span class="cm"> *   BDDIR_ENTRY_LO returns the address of the low double-word of the dir</span>
<span class="cm"> *                  entry corresponding to a physical (Cac or Uncac) address.</span>
<span class="cm"> *   BDDIR_ENTRY_HI returns the address of the high double-word of the entry.</span>
<span class="cm"> *   BDPRT_ENTRY    returns the address of the double-word protection entry</span>
<span class="cm"> *                  corresponding to the page containing the physical address.</span>
<span class="cm"> *   BDPRT_ENTRY_S  Stores the value into the protection entry.</span>
<span class="cm"> *   BDPRT_ENTRY_L  Load the value from the protection entry.</span>
<span class="cm"> *   BDECC_ENTRY    returns the address of the ECC byte corresponding to a</span>
<span class="cm"> *                  double-word at a specified physical address.</span>
<span class="cm"> *   BDECC_ENTRY_H  returns the address of the two ECC bytes corresponding to a</span>
<span class="cm"> *                  quad-word at a specified physical address.</span>
<span class="cm"> */</span>
<span class="cp">#define NODE_BDOOR_BASE(_n)	(NODE_HSPEC_BASE(_n) + (NODE_ADDRSPACE_SIZE/2))</span>

<span class="cp">#define NODE_BDECC_BASE(_n)	(NODE_BDOOR_BASE(_n))</span>
<span class="cp">#define NODE_BDDIR_BASE(_n)	(NODE_BDOOR_BASE(_n) + (NODE_ADDRSPACE_SIZE/4))</span>
<span class="cp">#ifdef CONFIG_SGI_IP27</span>
<span class="cp">#define BDDIR_ENTRY_LO(_pa)	((HSPEC_BASE +				      \</span>
<span class="cp">				  NODE_ADDRSPACE_SIZE * 3 / 4 +		      \</span>
<span class="cp">				  0x200)				    | \</span>
<span class="cp">				 UINT64_CAST(_pa)	 &amp; NASID_MASK	    | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 2 &amp; BDDIR_UPPER_MASK  | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 3 &amp; 0x1f &lt;&lt; 4)</span>

<span class="cp">#define BDDIR_ENTRY_HI(_pa)	((HSPEC_BASE +				      \</span>
<span class="cp">				  NODE_ADDRSPACE_SIZE * 3 / 4 +		      \</span>
<span class="cp">				  0x208)				    | \</span>
<span class="cp">				 UINT64_CAST(_pa)	 &amp; NASID_MASK	    | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 2 &amp; BDDIR_UPPER_MASK  | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 3 &amp; 0x1f &lt;&lt; 4)</span>

<span class="cp">#define BDPRT_ENTRY(_pa, _rgn)	((HSPEC_BASE +				      \</span>
<span class="cp">				  NODE_ADDRSPACE_SIZE * 3 / 4)		    | \</span>
<span class="cp">				 UINT64_CAST(_pa)	 &amp; NASID_MASK	    | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 2 &amp; BDDIR_UPPER_MASK  | \</span>
<span class="cp">				 (_rgn) &lt;&lt; 3)</span>
<span class="cp">#define BDPRT_ENTRY_ADDR(_pa, _rgn) (BDPRT_ENTRY((_pa), (_rgn)))</span>
<span class="cp">#define BDPRT_ENTRY_S(_pa, _rgn, _val) (*(__psunsigned_t *)BDPRT_ENTRY((_pa), (_rgn))=(_val))</span>
<span class="cp">#define BDPRT_ENTRY_L(_pa, _rgn)	(*(__psunsigned_t *)BDPRT_ENTRY((_pa), (_rgn)))</span>

<span class="cp">#define BDECC_ENTRY(_pa)	((HSPEC_BASE +				      \</span>
<span class="cp">				  NODE_ADDRSPACE_SIZE / 2)		    | \</span>
<span class="cp">				 UINT64_CAST(_pa)	 &amp; NASID_MASK	    | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 2 &amp; BDECC_UPPER_MASK  | \</span>
<span class="cp">				 UINT64_CAST(_pa) &gt;&gt; 3 &amp; 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro to convert a back door directory or protection address into the</span>
<span class="cm"> *   raw physical address of the associated cache line or protection page.</span>
<span class="cm"> */</span>
<span class="cp">#define BDADDR_IS_DIR(_ba)	((UINT64_CAST  (_ba) &amp; 0x200) != 0)</span>
<span class="cp">#define BDADDR_IS_PRT(_ba)	((UINT64_CAST  (_ba) &amp; 0x200) == 0)</span>

<span class="cp">#define BDDIR_TO_MEM(_ba)	(UINT64_CAST (_ba) &amp; NASID_MASK            | \</span>
<span class="cp">				 (UINT64_CAST(_ba) &amp; BDDIR_UPPER_MASK)&lt;&lt;2  | \</span>
<span class="cp">				 (UINT64_CAST(_ba) &amp; 0x1f &lt;&lt; 4) &lt;&lt; 3)</span>

<span class="cp">#define BDPRT_TO_MEM(_ba) 	(UINT64_CAST (_ba) &amp; NASID_MASK	    | \</span>
<span class="cp">				 (UINT64_CAST(_ba) &amp; BDDIR_UPPER_MASK)&lt;&lt;2)</span>

<span class="cp">#define BDECC_TO_MEM(_ba)	(UINT64_CAST (_ba) &amp; NASID_MASK	    | \</span>
<span class="cp">				 (UINT64_CAST(_ba) &amp; BDECC_UPPER_MASK)&lt;&lt;2  | \</span>
<span class="cp">				 (UINT64_CAST(_ba) &amp; 3) &lt;&lt; 3)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SGI_IP27 */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * The following macros produce the correct base virtual address for</span>
<span class="cm"> * the hub registers.  The LOCAL_HUB_* macros produce the appropriate</span>
<span class="cm"> * address for the local registers.  The REMOTE_HUB_* macro produce</span>
<span class="cm"> * the address for the specified hub&#39;s registers.  The intent is</span>
<span class="cm"> * that the appropriate PI, MD, NI, or II register would be substituted</span>
<span class="cm"> * for _x.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * WARNING:</span>
<span class="cm"> *	When certain Hub chip workaround are defined, it&#39;s not sufficient</span>
<span class="cm"> *	to dereference the *_HUB_ADDR() macros.  You should instead use</span>
<span class="cm"> *	HUB_L() and HUB_S() if you must deal with pointers to hub registers.</span>
<span class="cm"> *	Otherwise, the recommended approach is to use *_HUB_L() and *_HUB_S().</span>
<span class="cm"> *	They&#39;re always safe.</span>
<span class="cm"> */</span>
<span class="cp">#define LOCAL_HUB_ADDR(_x)	(HUBREG_CAST (IALIAS_BASE + (_x)))</span>
<span class="cp">#define REMOTE_HUB_ADDR(_n, _x)	(HUBREG_CAST (NODE_SWIN_BASE(_n, 1) +	\</span>
<span class="cp">					      0x800000 + (_x)))</span>
<span class="cp">#ifdef CONFIG_SGI_IP27</span>
<span class="cp">#define REMOTE_HUB_PI_ADDR(_n, _sn, _x)	(HUBREG_CAST (NODE_SWIN_BASE(_n, 1) +	\</span>
<span class="cp">					      0x800000 + (_x)))</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SGI_IP27 */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define HUB_L(_a)			*(_a)</span>
<span class="cp">#define	HUB_S(_a, _d)			*(_a) = (_d)</span>

<span class="cp">#define LOCAL_HUB_L(_r)			HUB_L(LOCAL_HUB_ADDR(_r))</span>
<span class="cp">#define LOCAL_HUB_S(_r, _d)		HUB_S(LOCAL_HUB_ADDR(_r), (_d))</span>
<span class="cp">#define REMOTE_HUB_L(_n, _r)		HUB_L(REMOTE_HUB_ADDR((_n), (_r)))</span>
<span class="cp">#define REMOTE_HUB_S(_n, _r, _d)	HUB_S(REMOTE_HUB_ADDR((_n), (_r)), (_d))</span>
<span class="cp">#define REMOTE_HUB_PI_L(_n, _sn, _r)	HUB_L(REMOTE_HUB_PI_ADDR((_n), (_sn), (_r)))</span>
<span class="cp">#define REMOTE_HUB_PI_S(_n, _sn, _r, _d) HUB_S(REMOTE_HUB_PI_ADDR((_n), (_sn), (_r)), (_d))</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following macros are used to get to a hub/bridge register, given</span>
<span class="cm"> * the base of the register space.</span>
<span class="cm"> */</span>
<span class="cp">#define HUB_REG_PTR(_base, _off)	\</span>
<span class="cp">	(HUBREG_CAST((__psunsigned_t)(_base) + (__psunsigned_t)(_off)))</span>

<span class="cp">#define HUB_REG_PTR_L(_base, _off)	\</span>
<span class="cp">	HUB_L(HUB_REG_PTR((_base), (_off)))</span>

<span class="cp">#define HUB_REG_PTR_S(_base, _off, _data)	\</span>
<span class="cp">	HUB_S(HUB_REG_PTR((_base), (_off)), (_data))</span>

<span class="cm">/*</span>
<span class="cm"> * Software structure locations -- permanently fixed</span>
<span class="cm"> *    See diagram in kldir.h</span>
<span class="cm"> */</span>

<span class="cp">#define PHYS_RAMBASE		0x0</span>
<span class="cp">#define K0_RAMBASE		PHYS_TO_K0(PHYS_RAMBASE)</span>

<span class="cp">#define EX_HANDLER_OFFSET(slice) ((slice) &lt;&lt; 16)</span>
<span class="cp">#define EX_HANDLER_ADDR(nasid, slice)					\</span>
<span class="cp">	PHYS_TO_K0(NODE_OFFSET(nasid) | EX_HANDLER_OFFSET(slice))</span>
<span class="cp">#define EX_HANDLER_SIZE		0x0400</span>

<span class="cp">#define EX_FRAME_OFFSET(slice)	((slice) &lt;&lt; 16 | 0x400)</span>
<span class="cp">#define EX_FRAME_ADDR(nasid, slice)					\</span>
<span class="cp">	PHYS_TO_K0(NODE_OFFSET(nasid) | EX_FRAME_OFFSET(slice))</span>
<span class="cp">#define EX_FRAME_SIZE		0x0c00</span>

<span class="cp">#define ARCS_SPB_OFFSET		0x1000</span>
<span class="cp">#define ARCS_SPB_ADDR(nasid)						\</span>
<span class="cp">	PHYS_TO_K0(NODE_OFFSET(nasid) | ARCS_SPB_OFFSET)</span>
<span class="cp">#define ARCS_SPB_SIZE		0x0400</span>

<span class="cp">#define KLDIR_OFFSET		0x2000</span>
<span class="cp">#define KLDIR_ADDR(nasid)						\</span>
<span class="cp">	TO_NODE_UNCAC((nasid), KLDIR_OFFSET)</span>
<span class="cp">#define KLDIR_SIZE		0x0400</span>


<span class="cm">/*</span>
<span class="cm"> * Software structure locations -- indirected through KLDIR</span>
<span class="cm"> *    See diagram in kldir.h</span>
<span class="cm"> *</span>
<span class="cm"> * Important:	All low memory structures must only be accessed</span>
<span class="cm"> *		uncached, except for the symmon stacks.</span>
<span class="cm"> */</span>

<span class="cp">#define KLI_LAUNCH		0		</span><span class="cm">/* Dir. entries */</span><span class="cp"></span>
<span class="cp">#define KLI_KLCONFIG		1</span>
<span class="cp">#define	KLI_NMI			2</span>
<span class="cp">#define KLI_GDA			3</span>
<span class="cp">#define KLI_FREEMEM		4</span>
<span class="cp">#define	KLI_SYMMON_STK		5</span>
<span class="cp">#define KLI_PI_ERROR		6</span>
<span class="cp">#define KLI_KERN_VARS		7</span>
<span class="cp">#define	KLI_KERN_XP		8</span>
<span class="cp">#define	KLI_KERN_PARTID		9</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define KLD_BASE(nasid)		((kldir_ent_t *) KLDIR_ADDR(nasid))</span>
<span class="cp">#define KLD_LAUNCH(nasid)	(KLD_BASE(nasid) + KLI_LAUNCH)</span>
<span class="cp">#define KLD_NMI(nasid)		(KLD_BASE(nasid) + KLI_NMI)</span>
<span class="cp">#define KLD_KLCONFIG(nasid)	(KLD_BASE(nasid) + KLI_KLCONFIG)</span>
<span class="cp">#define KLD_PI_ERROR(nasid)	(KLD_BASE(nasid) + KLI_PI_ERROR)</span>
<span class="cp">#define KLD_GDA(nasid)		(KLD_BASE(nasid) + KLI_GDA)</span>
<span class="cp">#define KLD_SYMMON_STK(nasid)	(KLD_BASE(nasid) + KLI_SYMMON_STK)</span>
<span class="cp">#define KLD_FREEMEM(nasid)	(KLD_BASE(nasid) + KLI_FREEMEM)</span>
<span class="cp">#define KLD_KERN_VARS(nasid)	(KLD_BASE(nasid) + KLI_KERN_VARS)</span>
<span class="cp">#define	KLD_KERN_XP(nasid)	(KLD_BASE(nasid) + KLI_KERN_XP)</span>
<span class="cp">#define	KLD_KERN_PARTID(nasid)	(KLD_BASE(nasid) + KLI_KERN_PARTID)</span>

<span class="cp">#define LAUNCH_OFFSET(nasid, slice)					\</span>
<span class="cp">	(KLD_LAUNCH(nasid)-&gt;offset +					\</span>
<span class="cp">	 KLD_LAUNCH(nasid)-&gt;stride * (slice))</span>
<span class="cp">#define LAUNCH_ADDR(nasid, slice)					\</span>
<span class="cp">	TO_NODE_UNCAC((nasid), LAUNCH_OFFSET(nasid, slice))</span>
<span class="cp">#define LAUNCH_SIZE(nasid)	KLD_LAUNCH(nasid)-&gt;size</span>

<span class="cp">#define SN_NMI_OFFSET(nasid, slice)					\</span>
<span class="cp">	(KLD_NMI(nasid)-&gt;offset +					\</span>
<span class="cp">	 KLD_NMI(nasid)-&gt;stride * (slice))</span>
<span class="cp">#define NMI_ADDR(nasid, slice)						\</span>
<span class="cp">	TO_NODE_UNCAC((nasid), SN_NMI_OFFSET(nasid, slice))</span>
<span class="cp">#define NMI_SIZE(nasid)	KLD_NMI(nasid)-&gt;size</span>

<span class="cp">#define KLCONFIG_OFFSET(nasid)	KLD_KLCONFIG(nasid)-&gt;offset</span>
<span class="cp">#define KLCONFIG_ADDR(nasid)						\</span>
<span class="cp">	TO_NODE_UNCAC((nasid), KLCONFIG_OFFSET(nasid))</span>
<span class="cp">#define KLCONFIG_SIZE(nasid)	KLD_KLCONFIG(nasid)-&gt;size</span>

<span class="cp">#define GDA_ADDR(nasid)		KLD_GDA(nasid)-&gt;pointer</span>
<span class="cp">#define GDA_SIZE(nasid)		KLD_GDA(nasid)-&gt;size</span>

<span class="cp">#define SYMMON_STK_OFFSET(nasid, slice)					\</span>
<span class="cp">	(KLD_SYMMON_STK(nasid)-&gt;offset +				\</span>
<span class="cp">	 KLD_SYMMON_STK(nasid)-&gt;stride * (slice))</span>
<span class="cp">#define SYMMON_STK_STRIDE(nasid)	KLD_SYMMON_STK(nasid)-&gt;stride</span>

<span class="cp">#define SYMMON_STK_ADDR(nasid, slice)					\</span>
<span class="cp">	TO_NODE_CAC((nasid), SYMMON_STK_OFFSET(nasid, slice))</span>

<span class="cp">#define SYMMON_STK_SIZE(nasid)	KLD_SYMMON_STK(nasid)-&gt;stride</span>

<span class="cp">#define SYMMON_STK_END(nasid)	(SYMMON_STK_ADDR(nasid, 0) + KLD_SYMMON_STK(nasid)-&gt;size)</span>

<span class="cm">/* loading symmon 4k below UNIX. the arcs loader needs the topaddr for a</span>
<span class="cm"> * relocatable program</span>
<span class="cm"> */</span>
<span class="cp">#define	UNIX_DEBUG_LOADADDR	0x300000</span>
<span class="cp">#define	SYMMON_LOADADDR(nasid)						\</span>
<span class="cp">	TO_NODE(nasid, PHYS_TO_K0(UNIX_DEBUG_LOADADDR - 0x1000))</span>

<span class="cp">#define FREEMEM_OFFSET(nasid)	KLD_FREEMEM(nasid)-&gt;offset</span>
<span class="cp">#define FREEMEM_ADDR(nasid)	SYMMON_STK_END(nasid)</span>
<span class="cm">/*</span>
<span class="cm"> * XXX</span>
<span class="cm"> * Fix this. FREEMEM_ADDR should be aware of if symmon is loaded.</span>
<span class="cm"> * Also, it should take into account what prom thinks to be a safe</span>
<span class="cm"> * address</span>
<span class="cm">	PHYS_TO_K0(NODE_OFFSET(nasid) + FREEMEM_OFFSET(nasid))</span>
<span class="cm"> */</span>
<span class="cp">#define FREEMEM_SIZE(nasid)	KLD_FREEMEM(nasid)-&gt;size</span>

<span class="cp">#define PI_ERROR_OFFSET(nasid)	KLD_PI_ERROR(nasid)-&gt;offset</span>
<span class="cp">#define PI_ERROR_ADDR(nasid)						\</span>
<span class="cp">	TO_NODE_UNCAC((nasid), PI_ERROR_OFFSET(nasid))</span>
<span class="cp">#define PI_ERROR_SIZE(nasid)	KLD_PI_ERROR(nasid)-&gt;size</span>

<span class="cp">#define NODE_OFFSET_TO_K0(_nasid, _off)					\</span>
<span class="cp">	PHYS_TO_K0((NODE_OFFSET(_nasid) + (_off)) | CAC_BASE)</span>
<span class="cp">#define NODE_OFFSET_TO_K1(_nasid, _off)					\</span>
<span class="cp">	TO_UNCAC((NODE_OFFSET(_nasid) + (_off)) | UNCAC_BASE)</span>
<span class="cp">#define K0_TO_NODE_OFFSET(_k0addr)					\</span>
<span class="cp">	((__psunsigned_t)(_k0addr) &amp; NODE_ADDRSPACE_MASK)</span>

<span class="cp">#define KERN_VARS_ADDR(nasid)	KLD_KERN_VARS(nasid)-&gt;pointer</span>
<span class="cp">#define KERN_VARS_SIZE(nasid)	KLD_KERN_VARS(nasid)-&gt;size</span>

<span class="cp">#define	KERN_XP_ADDR(nasid)	KLD_KERN_XP(nasid)-&gt;pointer</span>
<span class="cp">#define	KERN_XP_SIZE(nasid)	KLD_KERN_XP(nasid)-&gt;size</span>

<span class="cp">#define GPDA_ADDR(nasid)	TO_NODE_CAC(nasid, GPDA_OFFSET)</span>

<span class="cp">#endif </span><span class="cm">/* !__ASSEMBLY__ */</span><span class="cp"></span>


<span class="cp">#endif </span><span class="cm">/* _ASM_SN_ADDRS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
