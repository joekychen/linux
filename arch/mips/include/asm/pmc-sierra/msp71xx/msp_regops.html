<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › pmc-sierra › msp71xx › msp_regops.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../../index.html"></a><h1>msp_regops.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SMP/VPE-safe functions to access &quot;registers&quot; (see note).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES:</span>
<span class="cm">* - These macros use ll/sc instructions, so it is your responsibility to</span>
<span class="cm"> * ensure these are available on your platform before including this file.</span>
<span class="cm"> * - The MIPS32 spec states that ll/sc results are undefined for uncached</span>
<span class="cm"> * accesses. This means they can&#39;t be used on HW registers accessed</span>
<span class="cm"> * through kseg1. Code which requires these macros for this purpose must</span>
<span class="cm"> * front-end the registers with cached memory &quot;registers&quot; and have a single</span>
<span class="cm"> * thread update the actual HW registers.</span>
<span class="cm"> * - A maximum of 2k of code can be inserted between ll and sc. Every</span>
<span class="cm"> * memory accesses between the instructions will increase the chance of</span>
<span class="cm"> * sc failing and having to loop.</span>
<span class="cm"> * - When using custom_read_reg32/custom_write_reg32 only perform the</span>
<span class="cm"> * necessary logical operations on the register value in between these</span>
<span class="cm"> * two calls. All other logic should be performed before the first call.</span>
<span class="cm">  * - There is a bug on the R10000 chips which has a workaround. If you</span>
<span class="cm"> * are affected by this bug, make sure to define the symbol &#39;R10000_LLSC_WAR&#39;</span>
<span class="cm"> * to be non-zero.  If you are using this header from within linux, you may</span>
<span class="cm"> * include &lt;asm/war.h&gt; before including this file to have this defined</span>
<span class="cm"> * appropriately for you.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2005-2007 PMC-Sierra, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> *  under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> *  Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> *  option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&#39;&#39; AND   ANY  EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO</span>
<span class="cm"> *  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,</span>
<span class="cm"> *  DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> *  THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<span class="cm"> *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the  GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write  to the Free Software Foundation, Inc., 675</span>
<span class="cm"> *  Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ASM_REGOPS_H__</span>
<span class="cp">#define __ASM_REGOPS_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/war.h&gt;</span>

<span class="cp">#ifndef R10000_LLSC_WAR</span>
<span class="cp">#define R10000_LLSC_WAR 0</span>
<span class="cp">#endif</span>

<span class="cp">#if R10000_LLSC_WAR == 1</span>
<span class="cp">#define __beqz	&quot;beqzl	&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __beqz	&quot;beqz	&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef _LINUX_TYPES_H</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u32</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Sets all the masked bits to the corresponding value bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_value_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">,</span>
					<span class="n">u32</span> <span class="k">const</span> <span class="n">mask</span><span class="p">,</span>
					<span class="n">u32</span> <span class="k">const</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips3				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;1:	ll	%0, %1	# set_value_reg32	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	and	%0, %2				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	or	%0, %3				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	sc	%0, %1				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	&quot;</span><span class="n">__beqz</span><span class="s">&quot;%0, 1b				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	nop					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets all the masked bits to &#39;1&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="k">const</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips3				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;1:	ll	%0, %1		# set_reg32	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	or	%0, %2				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	sc	%0, %1				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	&quot;</span><span class="n">__beqz</span><span class="s">&quot;%0, 1b				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	nop					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets all the masked bits to &#39;0&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="k">const</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips3				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;1:	ll	%0, %1		# clear_reg32	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	and	%0, %2				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	sc	%0, %1				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	&quot;</span><span class="n">__beqz</span><span class="s">&quot;%0, 1b				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	nop					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Toggles all masked bits from &#39;0&#39; to &#39;1&#39; and &#39;1&#39; to &#39;0&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">toggle_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="k">const</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	mips3				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;1:	ll	%0, %1		# toggle_reg32	</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	xor	%0, %2				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	sc	%0, %1				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	&quot;</span><span class="n">__beqz</span><span class="s">&quot;%0, 1b				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	nop					</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read all masked bits others are returned as &#39;0&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">read_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">u32</span> <span class="k">const</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	noreorder			</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	lw	%0, %1		# read		</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	and	%0, %2		# mask		</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="n">mask</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * blocking_read_reg32 - Read address with blocking load</span>
<span class="cm"> *</span>
<span class="cm"> * Uncached writes need to be read back to ensure they reach RAM.</span>
<span class="cm"> * The returned value must be &#39;used&#39; to prevent from becoming a</span>
<span class="cm"> * non-blocking load.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">blocking_read_reg32</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="k">const</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
	<span class="s">&quot;	.set	push				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	noreorder			</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	lw	%0, %1		# read		</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	move	%0, %0		# block		</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;	.set	pop				</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span>
	<span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For special strange cases only:</span>
<span class="cm"> *</span>
<span class="cm"> * If you need custom processing within a ll/sc loop, use the following macros</span>
<span class="cm"> * VERY CAREFULLY:</span>
<span class="cm"> *</span>
<span class="cm"> *   u32 tmp;				&lt;-- Define a variable to hold the data</span>
<span class="cm"> *</span>
<span class="cm"> *   custom_read_reg32(address, tmp);	&lt;-- Reads the address and put the value</span>
<span class="cm"> *						in the &#39;tmp&#39; variable given</span>
<span class="cm"> *</span>
<span class="cm"> *	From here on out, you are (basically) atomic, so don&#39;t do anything too</span>
<span class="cm"> *	fancy!</span>
<span class="cm"> *	Also, this code may loop if the end of this block fails to write</span>
<span class="cm"> *	everything back safely due do the other CPU, so do NOT do anything</span>
<span class="cm"> *	with side-effects!</span>
<span class="cm"> *</span>
<span class="cm"> *   custom_write_reg32(address, tmp);	&lt;-- Writes back &#39;tmp&#39; safely.</span>
<span class="cm"> */</span>
<span class="cp">#define custom_read_reg32(address, tmp)				\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;	.set	push				\n&quot;	\</span>
<span class="cp">	&quot;	.set	mips3				\n&quot;	\</span>
<span class="cp">	&quot;1:	ll	%0, %1	#custom_read_reg32	\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop				\n&quot;	\</span>
<span class="cp">	: &quot;=r&quot; (tmp), &quot;=m&quot; (*address)				\</span>
<span class="cp">	: &quot;m&quot; (*address))</span>

<span class="cp">#define custom_write_reg32(address, tmp)			\</span>
<span class="cp">	__asm__ __volatile__(					\</span>
<span class="cp">	&quot;	.set	push				\n&quot;	\</span>
<span class="cp">	&quot;	.set	mips3				\n&quot;	\</span>
<span class="cp">	&quot;	sc	%0, %1	#custom_write_reg32	\n&quot;	\</span>
<span class="cp">	&quot;	&quot;__beqz&quot;%0, 1b				\n&quot;	\</span>
<span class="cp">	&quot;	nop					\n&quot;	\</span>
<span class="cp">	&quot;	.set	pop				\n&quot;	\</span>
<span class="cp">	: &quot;=&amp;r&quot; (tmp), &quot;=m&quot; (*address)				\</span>
<span class="cp">	: &quot;0&quot; (tmp), &quot;m&quot; (*address))</span>

<span class="cp">#endif  </span><span class="cm">/* __ASM_REGOPS_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:6}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../../javascript/docco.min.js"></script>
</html>
