<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › sibyte › sb1250_defs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>sb1250_defs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*  *********************************************************************</span>
<span class="cm">    *  SB1250 Board Support Package</span>
<span class="cm">    *</span>
<span class="cm">    *  Global constants and macros		File: sb1250_defs.h</span>
<span class="cm">    *</span>
<span class="cm">    *  This file contains macros and definitions used by the other</span>
<span class="cm">    *  include files.</span>
<span class="cm">    *</span>
<span class="cm">    *  SB1250 specification level:  User&#39;s manual 1/02/02</span>
<span class="cm">    *</span>
<span class="cm">    *********************************************************************</span>
<span class="cm">    *</span>
<span class="cm">    *  Copyright 2000,2001,2002,2003</span>
<span class="cm">    *  Broadcom Corporation. All rights reserved.</span>
<span class="cm">    *</span>
<span class="cm">    *  This program is free software; you can redistribute it and/or</span>
<span class="cm">    *  modify it under the terms of the GNU General Public License as</span>
<span class="cm">    *  published by the Free Software Foundation; either version 2 of</span>
<span class="cm">    *  the License, or (at your option) any later version.</span>
<span class="cm">    *</span>
<span class="cm">    *  This program is distributed in the hope that it will be useful,</span>
<span class="cm">    *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    *  GNU General Public License for more details.</span>
<span class="cm">    *</span>
<span class="cm">    *  You should have received a copy of the GNU General Public License</span>
<span class="cm">    *  along with this program; if not, write to the Free Software</span>
<span class="cm">    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm">    *  MA 02111-1307 USA</span>
<span class="cm">    ********************************************************************* */</span>

<span class="cp">#ifndef _SB1250_DEFS_H</span>
<span class="cp">#define _SB1250_DEFS_H</span>

<span class="cm">/*</span>
<span class="cm"> * These headers require ANSI C89 string concatenation, and GCC or other</span>
<span class="cm"> * &#39;long long&#39; (64-bit integer) support.</span>
<span class="cm"> */</span>
<span class="cp">#if !defined(__STDC__) &amp;&amp; !defined(_MSC_VER)</span>
<span class="cp">#error SiByte headers require ANSI C89 support</span>
<span class="cp">#endif</span>


<span class="cm">/*  *********************************************************************</span>
<span class="cm">    *  Macros for feature tests, used to enable include file features</span>
<span class="cm">    *  for chip features only present in certain chip revisions.</span>
<span class="cm">    *</span>
<span class="cm">    *  SIBYTE_HDR_FEATURES may be defined to be the mask value chip/revision</span>
<span class="cm">    *  which is to be exposed by the headers.  If undefined, it defaults to</span>
<span class="cm">    *  &quot;all features.&quot;</span>
<span class="cm">    *</span>
<span class="cm">    *  Use like:</span>
<span class="cm">    *</span>
<span class="cm">    *    #define SIBYTE_HDR_FEATURES	SIBYTE_HDR_FMASK_112x_PASS1</span>
<span class="cm">    *</span>
<span class="cm">    *		Generate defines only for that revision of chip.</span>
<span class="cm">    *</span>
<span class="cm">    *    #if SIBYTE_HDR_FEATURE(chip,pass)</span>
<span class="cm">    *</span>
<span class="cm">    *		True if header features for that revision or later of</span>
<span class="cm">    *	        that particular chip type are enabled in SIBYTE_HDR_FEATURES.</span>
<span class="cm">    *	        (Use this to bracket #defines for features present in a given</span>
<span class="cm">    *		revision and later.)</span>
<span class="cm">    *</span>
<span class="cm">    *		Note that there is no implied ordering between chip types.</span>
<span class="cm">    *</span>
<span class="cm">    *		Note also that &#39;chip&#39; and &#39;pass&#39; must textually exactly</span>
<span class="cm">    *		match the defines below.  So, for example,</span>
<span class="cm">    *		SIBYTE_HDR_FEATURE(112x, PASS1) is OK, but</span>
<span class="cm">    *		SIBYTE_HDR_FEATURE(1120, pass1) is not (for two reasons).</span>
<span class="cm">    *</span>
<span class="cm">    *    #if SIBYTE_HDR_FEATURE_UP_TO(chip,pass)</span>
<span class="cm">    *</span>
<span class="cm">    *		Same as SIBYTE_HDR_FEATURE, but true for the named revision</span>
<span class="cm">    *		and earlier revisions of the named chip type.</span>
<span class="cm">    *</span>
<span class="cm">    *    #if SIBYTE_HDR_FEATURE_EXACT(chip,pass)</span>
<span class="cm">    *</span>
<span class="cm">    *		Same as SIBYTE_HDR_FEATURE, but only true for the named</span>
<span class="cm">    *		revision of the named chip type.  (Note that this CANNOT</span>
<span class="cm">    *		be used to verify that you&#39;re compiling only for that</span>
<span class="cm">    *		particular chip/revision.  It will be true any time this</span>
<span class="cm">    *		chip/revision is included in SIBYTE_HDR_FEATURES.)</span>
<span class="cm">    *</span>
<span class="cm">    *    #if SIBYTE_HDR_FEATURE_CHIP(chip)</span>
<span class="cm">    *</span>
<span class="cm">    *		True if header features for (any revision of) that chip type</span>
<span class="cm">    *		are enabled in SIBYTE_HDR_FEATURES.  (Use this to bracket</span>
<span class="cm">    *		#defines for features specific to a given chip type.)</span>
<span class="cm">    *</span>
<span class="cm">    *  Mask values currently include room for additional revisions of each</span>
<span class="cm">    *  chip type, but can be renumbered at will.  Note that they MUST fit</span>
<span class="cm">    *  into 31 bits and may not include C type constructs, for safe use in</span>
<span class="cm">    *  CPP conditionals.  Bit positions within chip types DO indicate</span>
<span class="cm">    *  ordering, so be careful when adding support for new minor revs.</span>
<span class="cm">    ********************************************************************* */</span>

<span class="cp">#define	SIBYTE_HDR_FMASK_1250_ALL		0x000000ff</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_1250_PASS1		0x00000001</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_1250_PASS2		0x00000002</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_1250_PASS3		0x00000004</span>

<span class="cp">#define	SIBYTE_HDR_FMASK_112x_ALL		0x00000f00</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_112x_PASS1		0x00000100</span>

<span class="cp">#define SIBYTE_HDR_FMASK_1480_ALL		0x0000f000</span>
<span class="cp">#define SIBYTE_HDR_FMASK_1480_PASS1		0x00001000</span>
<span class="cp">#define SIBYTE_HDR_FMASK_1480_PASS2		0x00002000</span>

<span class="cm">/* Bit mask for chip/revision.  (use _ALL for all revisions of a chip).  */</span>
<span class="cp">#define	SIBYTE_HDR_FMASK(chip, pass)					\</span>
<span class="cp">    (SIBYTE_HDR_FMASK_ ## chip ## _ ## pass)</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_ALLREVS(chip)					\</span>
<span class="cp">    (SIBYTE_HDR_FMASK_ ## chip ## _ALL)</span>

<span class="cm">/* Default constant value for all chips, all revisions */</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_ALL						\</span>
<span class="cp">    (SIBYTE_HDR_FMASK_1250_ALL | SIBYTE_HDR_FMASK_112x_ALL		\</span>
<span class="cp">     | SIBYTE_HDR_FMASK_1480_ALL)</span>

<span class="cm">/* This one is used for the &quot;original&quot; BCM1250/BCM112x chips.  We use this</span>
<span class="cm">   to weed out constants and macros that do not exist on later chips like</span>
<span class="cm">   the BCM1480  */</span>
<span class="cp">#define SIBYTE_HDR_FMASK_1250_112x_ALL					\</span>
<span class="cp">    (SIBYTE_HDR_FMASK_1250_ALL | SIBYTE_HDR_FMASK_112x_ALL)</span>
<span class="cp">#define SIBYTE_HDR_FMASK_1250_112x SIBYTE_HDR_FMASK_1250_112x_ALL</span>

<span class="cp">#ifndef SIBYTE_HDR_FEATURES</span>
<span class="cp">#define	SIBYTE_HDR_FEATURES			SIBYTE_HDR_FMASK_ALL</span>
<span class="cp">#endif</span>


<span class="cm">/* Bit mask for revisions of chip exclusively before the named revision.  */</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_BEFORE(chip, pass)				\</span>
<span class="cp">    ((SIBYTE_HDR_FMASK(chip, pass) - 1) &amp; SIBYTE_HDR_FMASK_ALLREVS(chip))</span>

<span class="cm">/* Bit mask for revisions of chip exclusively after the named revision.  */</span>
<span class="cp">#define	SIBYTE_HDR_FMASK_AFTER(chip, pass)				\</span>
<span class="cp">    (~(SIBYTE_HDR_FMASK(chip, pass)					\</span>
<span class="cp">     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) &amp; SIBYTE_HDR_FMASK_ALLREVS(chip))</span>


<span class="cm">/* True if header features enabled for (any revision of) that chip type.  */</span>
<span class="cp">#define SIBYTE_HDR_FEATURE_CHIP(chip)					\</span>
<span class="cp">    (!! (SIBYTE_HDR_FMASK_ALLREVS(chip) &amp; SIBYTE_HDR_FEATURES))</span>

<span class="cm">/* True for all versions of the BCM1250 and BCM1125, but not true for</span>
<span class="cm">   anything else */</span>
<span class="cp">#define SIBYTE_HDR_FEATURE_1250_112x \</span>
<span class="cp">      (SIBYTE_HDR_FEATURE_CHIP(1250) || SIBYTE_HDR_FEATURE_CHIP(112x))</span>
<span class="cm">/*    (!!  (SIBYTE_HDR_FEATURES &amp; SIBYHTE_HDR_FMASK_1250_112x)) */</span>

<span class="cm">/* True if header features enabled for that rev or later, inclusive.  */</span>
<span class="cp">#define SIBYTE_HDR_FEATURE(chip, pass)					\</span>
<span class="cp">    (!! ((SIBYTE_HDR_FMASK(chip, pass)					\</span>
<span class="cp">	  | SIBYTE_HDR_FMASK_AFTER(chip, pass)) &amp; SIBYTE_HDR_FEATURES))</span>

<span class="cm">/* True if header features enabled for exactly that rev.  */</span>
<span class="cp">#define SIBYTE_HDR_FEATURE_EXACT(chip, pass)				\</span>
<span class="cp">    (!! (SIBYTE_HDR_FMASK(chip, pass) &amp; SIBYTE_HDR_FEATURES))</span>

<span class="cm">/* True if header features enabled for that rev or before, inclusive.  */</span>
<span class="cp">#define SIBYTE_HDR_FEATURE_UP_TO(chip, pass)				\</span>
<span class="cp">    (!! ((SIBYTE_HDR_FMASK(chip, pass)					\</span>
<span class="cp">	 | SIBYTE_HDR_FMASK_BEFORE(chip, pass)) &amp; SIBYTE_HDR_FEATURES))</span>


<span class="cm">/*  *********************************************************************</span>
<span class="cm">    *  Naming schemes for constants in these files:</span>
<span class="cm">    *</span>
<span class="cm">    *  M_xxx           MASK constant (identifies bits in a register).</span>
<span class="cm">    *                  For multi-bit fields, all bits in the field will</span>
<span class="cm">    *                  be set.</span>
<span class="cm">    *</span>
<span class="cm">    *  K_xxx           &quot;Code&quot; constant (value for data in a multi-bit</span>
<span class="cm">    *                  field).  The value is right justified.</span>
<span class="cm">    *</span>
<span class="cm">    *  V_xxx           &quot;Value&quot; constant.  This is the same as the</span>
<span class="cm">    *                  corresponding &quot;K_xxx&quot; constant, except it is</span>
<span class="cm">    *                  shifted to the correct position in the register.</span>
<span class="cm">    *</span>
<span class="cm">    *  S_xxx           SHIFT constant.  This is the number of bits that</span>
<span class="cm">    *                  a field value (code) needs to be shifted</span>
<span class="cm">    *                  (towards the left) to put the value in the right</span>
<span class="cm">    *                  position for the register.</span>
<span class="cm">    *</span>
<span class="cm">    *  A_xxx           ADDRESS constant.  This will be a physical</span>
<span class="cm">    *                  address.  Use the PHYS_TO_K1 macro to generate</span>
<span class="cm">    *                  a K1SEG address.</span>
<span class="cm">    *</span>
<span class="cm">    *  R_xxx           RELATIVE offset constant.  This is an offset from</span>
<span class="cm">    *                  an A_xxx constant (usually the first register in</span>
<span class="cm">    *                  a group).</span>
<span class="cm">    *</span>
<span class="cm">    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field</span>
<span class="cm">    *                  from a register, masks it, and shifts it to</span>
<span class="cm">    *                  the bottom of the register (retrieving a K_xxx</span>
<span class="cm">    *                  value, for example).</span>
<span class="cm">    *</span>
<span class="cm">    *  V_xxx(X)        VALUE.  This macro computes the value of a</span>
<span class="cm">    *                  K_xxx constant shifted to the correct position</span>
<span class="cm">    *                  in the register.</span>
<span class="cm">    ********************************************************************* */</span>




<span class="cm">/*</span>
<span class="cm"> * Cast to 64-bit number.  Presumably the syntax is different in</span>
<span class="cm"> * assembly language.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: you&#39;ll need to define uint32_t and uint64_t in your headers.</span>
<span class="cm"> */</span>

<span class="cp">#if !defined(__ASSEMBLY__)</span>
<span class="cp">#define _SB_MAKE64(x) ((uint64_t)(x))</span>
<span class="cp">#define _SB_MAKE32(x) ((uint32_t)(x))</span>
<span class="cp">#else</span>
<span class="cp">#define _SB_MAKE64(x) (x)</span>
<span class="cp">#define _SB_MAKE32(x) (x)</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Make a mask for 1 bit at position &#39;n&#39;</span>
<span class="cm"> */</span>

<span class="cp">#define _SB_MAKEMASK1(n) (_SB_MAKE64(1) &lt;&lt; _SB_MAKE64(n))</span>
<span class="cp">#define _SB_MAKEMASK1_32(n) (_SB_MAKE32(1) &lt;&lt; _SB_MAKE32(n))</span>

<span class="cm">/*</span>
<span class="cm"> * Make a mask for &#39;v&#39; bits at position &#39;n&#39;</span>
<span class="cm"> */</span>

<span class="cp">#define _SB_MAKEMASK(v, n) (_SB_MAKE64((_SB_MAKE64(1)&lt;&lt;(v))-1) &lt;&lt; _SB_MAKE64(n))</span>
<span class="cp">#define _SB_MAKEMASK_32(v, n) (_SB_MAKE32((_SB_MAKE32(1)&lt;&lt;(v))-1) &lt;&lt; _SB_MAKE32(n))</span>

<span class="cm">/*</span>
<span class="cm"> * Make a value at &#39;v&#39; at bit position &#39;n&#39;</span>
<span class="cm"> */</span>

<span class="cp">#define _SB_MAKEVALUE(v, n) (_SB_MAKE64(v) &lt;&lt; _SB_MAKE64(n))</span>
<span class="cp">#define _SB_MAKEVALUE_32(v, n) (_SB_MAKE32(v) &lt;&lt; _SB_MAKE32(n))</span>

<span class="cp">#define _SB_GETVALUE(v, n, m) ((_SB_MAKE64(v) &amp; _SB_MAKE64(m)) &gt;&gt; _SB_MAKE64(n))</span>
<span class="cp">#define _SB_GETVALUE_32(v, n, m) ((_SB_MAKE32(v) &amp; _SB_MAKE32(m)) &gt;&gt; _SB_MAKE32(n))</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to read/write on-chip registers</span>
<span class="cm"> * XXX should we do the PHYS_TO_K1 here?</span>
<span class="cm"> */</span>


<span class="cp">#if defined(__mips64) &amp;&amp; !defined(__ASSEMBLY__)</span>
<span class="cp">#define SBWRITECSR(csr, val) *((volatile uint64_t *) PHYS_TO_K1(csr)) = (val)</span>
<span class="cp">#define SBREADCSR(csr) (*((volatile uint64_t *) PHYS_TO_K1(csr)))</span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
