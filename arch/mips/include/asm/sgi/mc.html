<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › sgi › mc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>mc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License. See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * mc.h: Definitions for SGI Memory Controller</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996 David S. Miller</span>
<span class="cm"> * Copyright (C) 1999 Ralf Baechle</span>
<span class="cm"> * Copyright (C) 1999 Silicon Graphics, Inc.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SGI_MC_H</span>
<span class="cp">#define _SGI_MC_H</span>

<span class="k">struct</span> <span class="n">sgimc_regs</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">_unused0</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cpuctrl0</span><span class="p">;</span>	<span class="cm">/* CPU control register 0, readwrite */</span>
<span class="cp">#define SGIMC_CCTRL0_REFS	0x0000000f </span><span class="cm">/* REFS mask */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EREFRESH	0x00000010 </span><span class="cm">/* Memory refresh enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EPERRGIO	0x00000020 </span><span class="cm">/* GIO parity error enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EPERRMEM	0x00000040 </span><span class="cm">/* Main mem parity error enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EPERRCPU	0x00000080 </span><span class="cm">/* CPU bus parity error enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_WDOG	0x00000100 </span><span class="cm">/* Watchdog timer enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_SYSINIT	0x00000200 </span><span class="cm">/* System init bit */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_GFXRESET	0x00000400 </span><span class="cm">/* Graphics interface reset */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EISALOCK	0x00000800 </span><span class="cm">/* Lock CPU from memory for EISA */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EPERRSCMD	0x00001000 </span><span class="cm">/* SysCMD bus parity error enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_IENAB	0x00002000 </span><span class="cm">/* Allow interrupts from MC */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_ESNOOP	0x00004000 </span><span class="cm">/* Snooping I/O enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_EPROMWR	0x00008000 </span><span class="cm">/* Prom writes from cpu enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_WRESETPMEM	0x00010000 </span><span class="cm">/* Perform warm reset, preserves mem */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_LENDIAN	0x00020000 </span><span class="cm">/* Put MC in little-endian mode */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_WRESETDMEM	0x00040000 </span><span class="cm">/* Warm reset, destroys mem contents */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_CMEMBADPAR	0x02000000 </span><span class="cm">/* Generate bad perr from cpu to mem */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_R4KNOCHKPARR 0x04000000 </span><span class="cm">/* Don&#39;t chk parity on mem data reads */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL0_GIOBTOB	0x08000000 </span><span class="cm">/* Allow GIO back to back writes */</span><span class="cp"></span>
	<span class="n">u32</span> <span class="n">_unused1</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cpuctrl1</span><span class="p">;</span>	<span class="cm">/* CPU control register 1, readwrite */</span>
<span class="cp">#define SGIMC_CCTRL1_EGIOTIMEO	0x00000010 </span><span class="cm">/* GIO bus timeout enable */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_FIXEDEHPC	0x00001000 </span><span class="cm">/* Fixed HPC endianness */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_LITTLEHPC	0x00002000 </span><span class="cm">/* Little endian HPC */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_FIXEDEEXP0	0x00004000 </span><span class="cm">/* Fixed EXP0 endianness */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_LITTLEEXP0	0x00008000 </span><span class="cm">/* Little endian EXP0 */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_FIXEDEEXP1	0x00010000 </span><span class="cm">/* Fixed EXP1 endianness */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CCTRL1_LITTLEEXP1	0x00020000 </span><span class="cm">/* Little endian EXP1 */</span><span class="cp"></span>

	<span class="n">u32</span> <span class="n">_unused2</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">watchdogt</span><span class="p">;</span>	<span class="cm">/* Watchdog reg rdonly, write clears */</span>

	<span class="n">u32</span> <span class="n">_unused3</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">systemid</span><span class="p">;</span>	<span class="cm">/* MC system ID register, readonly */</span>
<span class="cp">#define SGIMC_SYSID_MASKREV	0x0000000f </span><span class="cm">/* Revision of MC controller */</span><span class="cp"></span>
<span class="cp">#define SGIMC_SYSID_EPRESENT	0x00000010 </span><span class="cm">/* Indicates presence of EISA bus */</span><span class="cp"></span>

	<span class="n">u32</span> <span class="n">_unused4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">divider</span><span class="p">;</span>	<span class="cm">/* Divider reg for RPSS */</span>

	<span class="n">u32</span> <span class="n">_unused5</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eeprom</span><span class="p">;</span>		<span class="cm">/* EEPROM byte reg for r4k */</span>
<span class="cp">#define SGIMC_EEPROM_PRE	0x00000001 </span><span class="cm">/* eeprom chip PRE pin assertion */</span><span class="cp"></span>
<span class="cp">#define SGIMC_EEPROM_CSEL	0x00000002 </span><span class="cm">/* Active high, eeprom chip select */</span><span class="cp"></span>
<span class="cp">#define SGIMC_EEPROM_SECLOCK	0x00000004 </span><span class="cm">/* EEPROM serial clock */</span><span class="cp"></span>
<span class="cp">#define SGIMC_EEPROM_SDATAO	0x00000008 </span><span class="cm">/* Serial EEPROM data-out */</span><span class="cp"></span>
<span class="cp">#define SGIMC_EEPROM_SDATAI	0x00000010 </span><span class="cm">/* Serial EEPROM data-in */</span><span class="cp"></span>

	<span class="n">u32</span> <span class="n">_unused6</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">rcntpre</span><span class="p">;</span>	<span class="cm">/* Preload refresh counter */</span>

	<span class="n">u32</span> <span class="n">_unused7</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">rcounter</span><span class="p">;</span>	<span class="cm">/* Readonly refresh counter */</span>

	<span class="n">u32</span> <span class="n">_unused8</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">giopar</span><span class="p">;</span>	<span class="cm">/* Parameter word for GIO64 */</span>
<span class="cp">#define SGIMC_GIOPAR_HPC64	0x00000001 </span><span class="cm">/* HPC talks to GIO using 64-bits */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_GFX64	0x00000002 </span><span class="cm">/* GFX talks to GIO using 64-bits */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_EXP064	0x00000004 </span><span class="cm">/* EXP(slot0) talks using 64-bits */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_EXP164	0x00000008 </span><span class="cm">/* EXP(slot1) talks using 64-bits */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_EISA64	0x00000010 </span><span class="cm">/* EISA bus talks 64-bits to GIO */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_HPC264	0x00000020 </span><span class="cm">/* 2nd HPX talks 64-bits to GIO */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_RTIMEGFX	0x00000040 </span><span class="cm">/* GFX device has realtime attr */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_RTIMEEXP0	0x00000080 </span><span class="cm">/* EXP(slot0) has realtime attr */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_RTIMEEXP1	0x00000100 </span><span class="cm">/* EXP(slot1) has realtime attr */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_MASTEREISA	0x00000200 </span><span class="cm">/* EISA bus can act as bus master */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_ONEBUS	0x00000400 </span><span class="cm">/* Exists one GIO64 pipelined bus */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_MASTERGFX	0x00000800 </span><span class="cm">/* GFX can act as a bus master */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_MASTEREXP0	0x00001000 </span><span class="cm">/* EXP(slot0) can bus master */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_MASTEREXP1	0x00002000 </span><span class="cm">/* EXP(slot1) can bus master */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_PLINEEXP0	0x00004000 </span><span class="cm">/* EXP(slot0) has pipeline attr */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GIOPAR_PLINEEXP1	0x00008000 </span><span class="cm">/* EXP(slot1) has pipeline attr */</span><span class="cp"></span>

	<span class="n">u32</span> <span class="n">_unused9</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cputp</span><span class="p">;</span>	<span class="cm">/* CPU bus arb time period */</span>

	<span class="n">u32</span> <span class="n">_unused10</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">lbursttp</span><span class="p">;</span>	<span class="cm">/* Time period for long bursts */</span>

	<span class="cm">/* MC chip can drive up to 4 bank 4 SIMMs each. All SIMMs in bank must</span>
<span class="cm">	 * be the same size. The size encoding for supported SIMMs is bellow */</span>
	<span class="n">u32</span> <span class="n">_unused11</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">mconfig0</span><span class="p">;</span>	<span class="cm">/* Memory config register zero */</span>
	<span class="n">u32</span> <span class="n">_unused12</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">mconfig1</span><span class="p">;</span>	<span class="cm">/* Memory config register one */</span>
<span class="cp">#define SGIMC_MCONFIG_BASEADDR	0x000000ff </span><span class="cm">/* Base address of bank*/</span><span class="cp"></span>
<span class="cp">#define SGIMC_MCONFIG_RMASK	0x00001f00 </span><span class="cm">/* Ram config bitmask */</span><span class="cp"></span>
<span class="cp">#define SGIMC_MCONFIG_BVALID	0x00002000 </span><span class="cm">/* Bank is valid */</span><span class="cp"></span>
<span class="cp">#define SGIMC_MCONFIG_SBANKS	0x00004000 </span><span class="cm">/* Number of subbanks */</span><span class="cp"></span>

	<span class="n">u32</span> <span class="n">_unused13</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cmacc</span><span class="p">;</span>        <span class="cm">/* Mem access config for CPU */</span>
	<span class="n">u32</span> <span class="n">_unused14</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gmacc</span><span class="p">;</span>        <span class="cm">/* Mem access config for GIO */</span>

	<span class="cm">/* This define applies to both cmacc and gmacc registers above. */</span>
<span class="cp">#define SGIMC_MACC_ALIASBIG	0x20000000 </span><span class="cm">/* 512MB home for alias */</span><span class="cp"></span>

	<span class="cm">/* Error address/status regs from GIO and CPU perspectives. */</span>
	<span class="n">u32</span> <span class="n">_unused15</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cerr</span><span class="p">;</span>	<span class="cm">/* Error address reg for CPU */</span>
	<span class="n">u32</span> <span class="n">_unused16</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">cstat</span><span class="p">;</span>	<span class="cm">/* Status reg for CPU */</span>
<span class="cp">#define SGIMC_CSTAT_RD		0x00000100 </span><span class="cm">/* read parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_PAR		0x00000200 </span><span class="cm">/* CPU parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_ADDR	0x00000400 </span><span class="cm">/* memory bus error bad addr */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_SYSAD_PAR	0x00000800 </span><span class="cm">/* sysad parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_SYSCMD_PAR	0x00001000 </span><span class="cm">/* syscmd parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_BAD_DATA	0x00002000 </span><span class="cm">/* bad data identifier */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_PAR_MASK	0x00001f00 </span><span class="cm">/* parity error mask */</span><span class="cp"></span>
<span class="cp">#define SGIMC_CSTAT_RD_PAR	(SGIMC_CSTAT_RD | SGIMC_CSTAT_PAR)</span>

	<span class="n">u32</span> <span class="n">_unused17</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gerr</span><span class="p">;</span>	<span class="cm">/* Error address reg for GIO */</span>
	<span class="n">u32</span> <span class="n">_unused18</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gstat</span><span class="p">;</span>	<span class="cm">/* Status reg for GIO */</span>
<span class="cp">#define SGIMC_GSTAT_RD		0x00000100 </span><span class="cm">/* read parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_WR		0x00000200 </span><span class="cm">/* write parity error */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_TIME	0x00000400 </span><span class="cm">/* GIO bus timed out */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_PROM	0x00000800 </span><span class="cm">/* write to PROM when PROM_EN not set */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_ADDR	0x00001000 </span><span class="cm">/* parity error on addr cycle */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_BC		0x00002000 </span><span class="cm">/* parity error on byte count cycle */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_PIO_RD	0x00004000 </span><span class="cm">/* read data parity on pio */</span><span class="cp"></span>
<span class="cp">#define SGIMC_GSTAT_PIO_WR	0x00008000 </span><span class="cm">/* write data parity on pio */</span><span class="cp"></span>

	<span class="cm">/* Special hard bus locking registers. */</span>
	<span class="n">u32</span> <span class="n">_unused19</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">syssembit</span><span class="p">;</span>		<span class="cm">/* Uni-bit system semaphore */</span>
	<span class="n">u32</span> <span class="n">_unused20</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">mlock</span><span class="p">;</span>		<span class="cm">/* Global GIO memory access lock */</span>
	<span class="n">u32</span> <span class="n">_unused21</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">elock</span><span class="p">;</span>		<span class="cm">/* Locks EISA from GIO accesses */</span>

	<span class="cm">/* GIO dma control registers. */</span>
	<span class="n">u32</span> <span class="n">_unused22</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gio_dma_trans</span><span class="p">;</span>	<span class="cm">/* DMA mask to translation GIO addrs */</span>
	<span class="n">u32</span> <span class="n">_unused23</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gio_dma_sbits</span><span class="p">;</span>	<span class="cm">/* DMA GIO addr substitution bits */</span>
	<span class="n">u32</span> <span class="n">_unused24</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dma_intr_cause</span><span class="p">;</span>	<span class="cm">/* DMA IRQ cause indicator bits */</span>
	<span class="n">u32</span> <span class="n">_unused25</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dma_ctrl</span><span class="p">;</span>		<span class="cm">/* Main DMA control reg */</span>

	<span class="cm">/* DMA TLB entry 0 */</span>
	<span class="n">u32</span> <span class="n">_unused26</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_hi0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_unused27</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_lo0</span><span class="p">;</span>

	<span class="cm">/* DMA TLB entry 1 */</span>
	<span class="n">u32</span> <span class="n">_unused28</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_hi1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_unused29</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_lo1</span><span class="p">;</span>

	<span class="cm">/* DMA TLB entry 2 */</span>
	<span class="n">u32</span> <span class="n">_unused30</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_hi2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_unused31</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_lo2</span><span class="p">;</span>

	<span class="cm">/* DMA TLB entry 3 */</span>
	<span class="n">u32</span> <span class="n">_unused32</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_hi3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">_unused33</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dtlb_lo3</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">_unused34</span><span class="p">[</span><span class="mh">0x0392</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">_unused35</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">rpsscounter</span><span class="p">;</span>	<span class="cm">/* Chirps at 100ns */</span>

	<span class="n">u32</span> <span class="n">_unused36</span><span class="p">[</span><span class="mh">0x1000</span><span class="o">/</span><span class="mi">4</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">_unused37</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">maddronly</span><span class="p">;</span>		<span class="cm">/* Address DMA goes at */</span>
	<span class="n">u32</span> <span class="n">_unused38</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">maddrpdeflts</span><span class="p">;</span>	<span class="cm">/* Same as above, plus set defaults */</span>
	<span class="n">u32</span> <span class="n">_unused39</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmasz</span><span class="p">;</span>		<span class="cm">/* DMA count */</span>
	<span class="n">u32</span> <span class="n">_unused40</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">ssize</span><span class="p">;</span>		<span class="cm">/* DMA stride size */</span>
	<span class="n">u32</span> <span class="n">_unused41</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">gmaddronly</span><span class="p">;</span>	<span class="cm">/* Set GIO DMA but don&#39;t start trans */</span>
	<span class="n">u32</span> <span class="n">_unused42</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmaddnpgo</span><span class="p">;</span>		<span class="cm">/* Set GIO DMA addr + start transfer */</span>
	<span class="n">u32</span> <span class="n">_unused43</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmamode</span><span class="p">;</span>		<span class="cm">/* DMA mode config bit settings */</span>
	<span class="n">u32</span> <span class="n">_unused44</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmaccount</span><span class="p">;</span>		<span class="cm">/* Zoom and byte count for DMA */</span>
	<span class="n">u32</span> <span class="n">_unused45</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmastart</span><span class="p">;</span>		<span class="cm">/* Pedal to the metal. */</span>
	<span class="n">u32</span> <span class="n">_unused46</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">dmarunning</span><span class="p">;</span>	<span class="cm">/* DMA op is in progress */</span>
	<span class="n">u32</span> <span class="n">_unused47</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">maddrdefstart</span><span class="p">;</span>	<span class="cm">/* Set dma addr, defaults, and kick it */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sgimc_regs</span> <span class="o">*</span><span class="n">sgimc</span><span class="p">;</span>
<span class="cp">#define SGIMC_BASE		0x1fa00000	</span><span class="cm">/* physical */</span><span class="cp"></span>

<span class="cm">/* Base location of the two ram banks found in IP2[0268] machines. */</span>
<span class="cp">#define SGIMC_SEG0_BADDR	0x08000000</span>
<span class="cp">#define SGIMC_SEG1_BADDR	0x20000000</span>

<span class="cm">/* Maximum size of the above banks are per machine. */</span>
<span class="cp">#define SGIMC_SEG0_SIZE_ALL		0x10000000 </span><span class="cm">/* 256MB */</span><span class="cp"></span>
<span class="cp">#define SGIMC_SEG1_SIZE_IP20_IP22	0x08000000 </span><span class="cm">/* 128MB */</span><span class="cp"></span>
<span class="cp">#define SGIMC_SEG1_SIZE_IP26_IP28	0x20000000 </span><span class="cm">/* 512MB */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sgimc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _SGI_MC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
