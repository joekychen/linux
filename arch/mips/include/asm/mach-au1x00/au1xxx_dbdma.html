<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › mach-au1x00 › au1xxx_dbdma.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>au1xxx_dbdma.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * BRIEF MODULE DESCRIPTION</span>
<span class="cm"> *	Include file for Alchemy Semiconductor&#39;s Au1550 Descriptor</span>
<span class="cm"> *	Based DMA Controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2004 Embedded Edge, LLC</span>
<span class="cm"> *	dan@embeddededge.com</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> *  under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> *  Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> *  option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&#39;&#39; AND   ANY  EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN</span>
<span class="cm"> *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<span class="cm"> *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF</span>
<span class="cm"> *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<span class="cm"> *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<span class="cm"> *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the  GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write  to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Specifics for the Au1xxx Descriptor-Based DMA Controller,</span>
<span class="cm"> * first seen in the AU1550 part.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _AU1000_DBDMA_H_</span>
<span class="cp">#define _AU1000_DBDMA_H_</span>

<span class="cp">#ifndef _LANGUAGE_ASSEMBLY</span>

<span class="k">typedef</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">dbdma_global</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">ddma_config</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">ddma_intstat</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">ddma_throttle</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">ddma_inten</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dbdma_global_t</span><span class="p">;</span>

<span class="cm">/* General Configuration. */</span>
<span class="cp">#define DDMA_CONFIG_AF		(1 &lt;&lt; 2)</span>
<span class="cp">#define DDMA_CONFIG_AH		(1 &lt;&lt; 1)</span>
<span class="cp">#define DDMA_CONFIG_AL		(1 &lt;&lt; 0)</span>

<span class="cp">#define DDMA_THROTTLE_EN	(1 &lt;&lt; 31)</span>

<span class="cm">/* The structure of a DMA Channel. */</span>
<span class="k">typedef</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">au1xxx_dma_channel</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">ddma_cfg</span><span class="p">;</span>	<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">ddma_desptr</span><span class="p">;</span>	<span class="cm">/* 32-byte aligned pointer to descriptor */</span>
	<span class="n">u32</span>	<span class="n">ddma_statptr</span><span class="p">;</span>	<span class="cm">/* word aligned pointer to status word */</span>
	<span class="n">u32</span>	<span class="n">ddma_dbell</span><span class="p">;</span>	<span class="cm">/* A write activates channel operation */</span>
	<span class="n">u32</span>	<span class="n">ddma_irq</span><span class="p">;</span>	<span class="cm">/* If bit 0 set, interrupt pending */</span>
	<span class="n">u32</span>	<span class="n">ddma_stat</span><span class="p">;</span>	<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">ddma_bytecnt</span><span class="p">;</span>	<span class="cm">/* Byte count, valid only when chan idle */</span>
	<span class="cm">/* Remainder, up to the 256 byte boundary, is reserved. */</span>
<span class="p">}</span> <span class="n">au1x_dma_chan_t</span><span class="p">;</span>

<span class="cp">#define DDMA_CFG_SED	(1 &lt;&lt; 9)	</span><span class="cm">/* source DMA level/edge detect */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_SP	(1 &lt;&lt; 8)	</span><span class="cm">/* source DMA polarity */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_DED	(1 &lt;&lt; 7)	</span><span class="cm">/* destination DMA level/edge detect */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_DP	(1 &lt;&lt; 6)	</span><span class="cm">/* destination DMA polarity */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_SYNC	(1 &lt;&lt; 5)	</span><span class="cm">/* Sync static bus controller */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_PPR	(1 &lt;&lt; 4)	</span><span class="cm">/* PCI posted read/write control */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_DFN	(1 &lt;&lt; 3)	</span><span class="cm">/* Descriptor fetch non-coherent */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_SBE	(1 &lt;&lt; 2)	</span><span class="cm">/* Source big endian */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_DBE	(1 &lt;&lt; 1)	</span><span class="cm">/* Destination big endian */</span><span class="cp"></span>
<span class="cp">#define DDMA_CFG_EN	(1 &lt;&lt; 0)	</span><span class="cm">/* Channel enable */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Always set when descriptor processing done, regardless of</span>
<span class="cm"> * interrupt enable state.  Reflected in global intstat, don&#39;t</span>
<span class="cm"> * clear this until global intstat is read/used.</span>
<span class="cm"> */</span>
<span class="cp">#define DDMA_IRQ_IN	(1 &lt;&lt; 0)</span>

<span class="cp">#define DDMA_STAT_DB	(1 &lt;&lt; 2)	</span><span class="cm">/* Doorbell pushed */</span><span class="cp"></span>
<span class="cp">#define DDMA_STAT_V	(1 &lt;&lt; 1)	</span><span class="cm">/* Descriptor valid */</span><span class="cp"></span>
<span class="cp">#define DDMA_STAT_H	(1 &lt;&lt; 0)	</span><span class="cm">/* Channel Halted */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * &quot;Standard&quot; DDMA Descriptor.</span>
<span class="cm"> * Must be 32-byte aligned.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">au1xxx_ddma_desc</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dscr_cmd0</span><span class="p">;</span>		<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">dscr_cmd1</span><span class="p">;</span>		<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">dscr_source0</span><span class="p">;</span>		<span class="cm">/* source phys address */</span>
	<span class="n">u32</span>	<span class="n">dscr_source1</span><span class="p">;</span>		<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">dscr_dest0</span><span class="p">;</span>		<span class="cm">/* Destination address */</span>
	<span class="n">u32</span>	<span class="n">dscr_dest1</span><span class="p">;</span>		<span class="cm">/* See below */</span>
	<span class="n">u32</span>	<span class="n">dscr_stat</span><span class="p">;</span>		<span class="cm">/* completion status */</span>
	<span class="n">u32</span>	<span class="n">dscr_nxtptr</span><span class="p">;</span>		<span class="cm">/* Next descriptor pointer (mostly) */</span>
	<span class="cm">/*</span>
<span class="cm">	 * First 32 bytes are HW specific!!!</span>
<span class="cm">	 * Lets have some SW data following -- make sure it&#39;s 32 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>	<span class="n">sw_status</span><span class="p">;</span>
	<span class="n">u32</span> 	<span class="n">sw_context</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">sw_reserved</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">}</span> <span class="n">au1x_ddma_desc_t</span><span class="p">;</span>

<span class="cp">#define DSCR_CMD0_V		(1 &lt;&lt; 31)	</span><span class="cm">/* Descriptor valid */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_MEM		(1 &lt;&lt; 30)	</span><span class="cm">/* mem-mem transfer */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_SID_MASK	(0x1f &lt;&lt; 25)	</span><span class="cm">/* Source ID */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_DID_MASK	(0x1f &lt;&lt; 20)	</span><span class="cm">/* Destination ID */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_SW_MASK	(0x3 &lt;&lt; 18)	</span><span class="cm">/* Source Width */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_DW_MASK	(0x3 &lt;&lt; 16)	</span><span class="cm">/* Destination Width */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_ARB		(0x1 &lt;&lt; 15)	</span><span class="cm">/* Set for Hi Pri */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_DT_MASK	(0x3 &lt;&lt; 13)	</span><span class="cm">/* Descriptor Type */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_SN		(0x1 &lt;&lt; 12)	</span><span class="cm">/* Source non-coherent */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_DN		(0x1 &lt;&lt; 11)	</span><span class="cm">/* Destination non-coherent */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_SM		(0x1 &lt;&lt; 10)	</span><span class="cm">/* Stride mode */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_IE		(0x1 &lt;&lt; 8)	</span><span class="cm">/* Interrupt Enable */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_SP		(0x1 &lt;&lt; 4)	</span><span class="cm">/* Status pointer select */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_CV		(0x1 &lt;&lt; 2)	</span><span class="cm">/* Clear Valid when done */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_ST_MASK	(0x3 &lt;&lt; 0)	</span><span class="cm">/* Status instruction */</span><span class="cp"></span>

<span class="cp">#define SW_STATUS_INUSE 	(1 &lt;&lt; 0)</span>

<span class="cm">/* Command 0 device IDs. */</span>
<span class="cp">#define AU1550_DSCR_CMD0_UART0_TX	0</span>
<span class="cp">#define AU1550_DSCR_CMD0_UART0_RX	1</span>
<span class="cp">#define AU1550_DSCR_CMD0_UART3_TX	2</span>
<span class="cp">#define AU1550_DSCR_CMD0_UART3_RX	3</span>
<span class="cp">#define AU1550_DSCR_CMD0_DMA_REQ0	4</span>
<span class="cp">#define AU1550_DSCR_CMD0_DMA_REQ1	5</span>
<span class="cp">#define AU1550_DSCR_CMD0_DMA_REQ2	6</span>
<span class="cp">#define AU1550_DSCR_CMD0_DMA_REQ3	7</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_RX0	8</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_TX0	9</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_TX1	10</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_TX2	11</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_RX3	12</span>
<span class="cp">#define AU1550_DSCR_CMD0_USBDEV_RX4	13</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC0_TX	14</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC0_RX	15</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC1_TX	16</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC1_RX	17</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC2_TX	18</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC2_RX	19</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC3_TX	20</span>
<span class="cp">#define AU1550_DSCR_CMD0_PSC3_RX	21</span>
<span class="cp">#define AU1550_DSCR_CMD0_PCI_WRITE	22</span>
<span class="cp">#define AU1550_DSCR_CMD0_NAND_FLASH	23</span>
<span class="cp">#define AU1550_DSCR_CMD0_MAC0_RX	24</span>
<span class="cp">#define AU1550_DSCR_CMD0_MAC0_TX	25</span>
<span class="cp">#define AU1550_DSCR_CMD0_MAC1_RX	26</span>
<span class="cp">#define AU1550_DSCR_CMD0_MAC1_TX	27</span>

<span class="cp">#define AU1200_DSCR_CMD0_UART0_TX	0</span>
<span class="cp">#define AU1200_DSCR_CMD0_UART0_RX	1</span>
<span class="cp">#define AU1200_DSCR_CMD0_UART1_TX	2</span>
<span class="cp">#define AU1200_DSCR_CMD0_UART1_RX	3</span>
<span class="cp">#define AU1200_DSCR_CMD0_DMA_REQ0	4</span>
<span class="cp">#define AU1200_DSCR_CMD0_DMA_REQ1	5</span>
<span class="cp">#define AU1200_DSCR_CMD0_MAE_BE		6</span>
<span class="cp">#define AU1200_DSCR_CMD0_MAE_FE		7</span>
<span class="cp">#define AU1200_DSCR_CMD0_SDMS_TX0	8</span>
<span class="cp">#define AU1200_DSCR_CMD0_SDMS_RX0	9</span>
<span class="cp">#define AU1200_DSCR_CMD0_SDMS_TX1	10</span>
<span class="cp">#define AU1200_DSCR_CMD0_SDMS_RX1	11</span>
<span class="cp">#define AU1200_DSCR_CMD0_AES_TX		13</span>
<span class="cp">#define AU1200_DSCR_CMD0_AES_RX		12</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC0_TX	14</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC0_RX	15</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC1_TX	16</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC1_RX	17</span>
<span class="cp">#define AU1200_DSCR_CMD0_CIM_RXA	18</span>
<span class="cp">#define AU1200_DSCR_CMD0_CIM_RXB	19</span>
<span class="cp">#define AU1200_DSCR_CMD0_CIM_RXC	20</span>
<span class="cp">#define AU1200_DSCR_CMD0_MAE_BOTH	21</span>
<span class="cp">#define AU1200_DSCR_CMD0_LCD		22</span>
<span class="cp">#define AU1200_DSCR_CMD0_NAND_FLASH	23</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC0_SYNC	24</span>
<span class="cp">#define AU1200_DSCR_CMD0_PSC1_SYNC	25</span>
<span class="cp">#define AU1200_DSCR_CMD0_CIM_SYNC	26</span>

<span class="cp">#define AU1300_DSCR_CMD0_UART0_TX      0</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART0_RX      1</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART1_TX      2</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART1_RX      3</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART2_TX      4</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART2_RX      5</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART3_TX      6</span>
<span class="cp">#define AU1300_DSCR_CMD0_UART3_RX      7</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_TX0      8</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_RX0      9</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_TX1      10</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_RX1      11</span>
<span class="cp">#define AU1300_DSCR_CMD0_AES_TX        12</span>
<span class="cp">#define AU1300_DSCR_CMD0_AES_RX        13</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC0_TX       14</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC0_RX       15</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC1_TX       16</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC1_RX       17</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC2_TX       18</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC2_RX       19</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC3_TX       20</span>
<span class="cp">#define AU1300_DSCR_CMD0_PSC3_RX       21</span>
<span class="cp">#define AU1300_DSCR_CMD0_LCD           22</span>
<span class="cp">#define AU1300_DSCR_CMD0_NAND_FLASH    23</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_TX2      24</span>
<span class="cp">#define AU1300_DSCR_CMD0_SDMS_RX2      25</span>
<span class="cp">#define AU1300_DSCR_CMD0_CIM_SYNC      26</span>
<span class="cp">#define AU1300_DSCR_CMD0_UDMA          27</span>
<span class="cp">#define AU1300_DSCR_CMD0_DMA_REQ0      28</span>
<span class="cp">#define AU1300_DSCR_CMD0_DMA_REQ1      29</span>

<span class="cp">#define DSCR_CMD0_THROTTLE	30</span>
<span class="cp">#define DSCR_CMD0_ALWAYS	31</span>
<span class="cp">#define DSCR_NDEV_IDS		32</span>
<span class="cm">/* This macro is used to find/create custom device types */</span>
<span class="cp">#define DSCR_DEV2CUSTOM_ID(x, d) (((((x) &amp; 0xFFFF) &lt;&lt; 8) | 0x32000000) | \</span>
<span class="cp">				  ((d) &amp; 0xFF))</span>
<span class="cp">#define DSCR_CUSTOM2DEV_ID(x)	((x) &amp; 0xFF)</span>

<span class="cp">#define DSCR_CMD0_SID(x)	(((x) &amp; 0x1f) &lt;&lt; 25)</span>
<span class="cp">#define DSCR_CMD0_DID(x)	(((x) &amp; 0x1f) &lt;&lt; 20)</span>

<span class="cm">/* Source/Destination transfer width. */</span>
<span class="cp">#define DSCR_CMD0_BYTE		0</span>
<span class="cp">#define DSCR_CMD0_HALFWORD	1</span>
<span class="cp">#define DSCR_CMD0_WORD		2</span>

<span class="cp">#define DSCR_CMD0_SW(x)		(((x) &amp; 0x3) &lt;&lt; 18)</span>
<span class="cp">#define DSCR_CMD0_DW(x)		(((x) &amp; 0x3) &lt;&lt; 16)</span>

<span class="cm">/* DDMA Descriptor Type. */</span>
<span class="cp">#define DSCR_CMD0_STANDARD	0</span>
<span class="cp">#define DSCR_CMD0_LITERAL	1</span>
<span class="cp">#define DSCR_CMD0_CMP_BRANCH	2</span>

<span class="cp">#define DSCR_CMD0_DT(x)		(((x) &amp; 0x3) &lt;&lt; 13)</span>

<span class="cm">/* Status Instruction. */</span>
<span class="cp">#define DSCR_CMD0_ST_NOCHANGE	0	</span><span class="cm">/* Don&#39;t change */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_ST_CURRENT	1	</span><span class="cm">/* Write current status */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_ST_CMD0	2	</span><span class="cm">/* Write cmd0 with V cleared */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD0_ST_BYTECNT	3	</span><span class="cm">/* Write remaining byte count */</span><span class="cp"></span>

<span class="cp">#define DSCR_CMD0_ST(x)		(((x) &amp; 0x3) &lt;&lt; 0)</span>

<span class="cm">/* Descriptor Command 1. */</span>
<span class="cp">#define DSCR_CMD1_SUPTR_MASK	(0xf &lt;&lt; 28)	</span><span class="cm">/* upper 4 bits of src addr */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD1_DUPTR_MASK	(0xf &lt;&lt; 24)	</span><span class="cm">/* upper 4 bits of dest addr */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD1_FL_MASK	(0x3 &lt;&lt; 22)	</span><span class="cm">/* Flag bits */</span><span class="cp"></span>
<span class="cp">#define DSCR_CMD1_BC_MASK	(0x3fffff)	</span><span class="cm">/* Byte count */</span><span class="cp"></span>

<span class="cm">/* Flag description. */</span>
<span class="cp">#define DSCR_CMD1_FL_MEM_STRIDE0	0</span>
<span class="cp">#define DSCR_CMD1_FL_MEM_STRIDE1	1</span>
<span class="cp">#define DSCR_CMD1_FL_MEM_STRIDE2	2</span>

<span class="cp">#define DSCR_CMD1_FL(x)		(((x) &amp; 0x3) &lt;&lt; 22)</span>

<span class="cm">/* Source1, 1-dimensional stride. */</span>
<span class="cp">#define DSCR_SRC1_STS_MASK	(3 &lt;&lt; 30)	</span><span class="cm">/* Src xfer size */</span><span class="cp"></span>
<span class="cp">#define DSCR_SRC1_SAM_MASK	(3 &lt;&lt; 28)	</span><span class="cm">/* Src xfer movement */</span><span class="cp"></span>
<span class="cp">#define DSCR_SRC1_SB_MASK	(0x3fff &lt;&lt; 14)	</span><span class="cm">/* Block size */</span><span class="cp"></span>
<span class="cp">#define DSCR_SRC1_SB(x)		(((x) &amp; 0x3fff) &lt;&lt; 14)</span>
<span class="cp">#define DSCR_SRC1_SS_MASK	(0x3fff &lt;&lt; 0)	</span><span class="cm">/* Stride */</span><span class="cp"></span>
<span class="cp">#define DSCR_SRC1_SS(x)		(((x) &amp; 0x3fff) &lt;&lt; 0)</span>

<span class="cm">/* Dest1, 1-dimensional stride. */</span>
<span class="cp">#define DSCR_DEST1_DTS_MASK	(3 &lt;&lt; 30)	</span><span class="cm">/* Dest xfer size */</span><span class="cp"></span>
<span class="cp">#define DSCR_DEST1_DAM_MASK	(3 &lt;&lt; 28)	</span><span class="cm">/* Dest xfer movement */</span><span class="cp"></span>
<span class="cp">#define DSCR_DEST1_DB_MASK	(0x3fff &lt;&lt; 14)	</span><span class="cm">/* Block size */</span><span class="cp"></span>
<span class="cp">#define DSCR_DEST1_DB(x)	(((x) &amp; 0x3fff) &lt;&lt; 14)</span>
<span class="cp">#define DSCR_DEST1_DS_MASK	(0x3fff &lt;&lt; 0)	</span><span class="cm">/* Stride */</span><span class="cp"></span>
<span class="cp">#define DSCR_DEST1_DS(x)	(((x) &amp; 0x3fff) &lt;&lt; 0)</span>

<span class="cp">#define DSCR_xTS_SIZE1		0</span>
<span class="cp">#define DSCR_xTS_SIZE2		1</span>
<span class="cp">#define DSCR_xTS_SIZE4		2</span>
<span class="cp">#define DSCR_xTS_SIZE8		3</span>
<span class="cp">#define DSCR_SRC1_STS(x)	(((x) &amp; 3) &lt;&lt; 30)</span>
<span class="cp">#define DSCR_DEST1_DTS(x)	(((x) &amp; 3) &lt;&lt; 30)</span>

<span class="cp">#define DSCR_xAM_INCREMENT	0</span>
<span class="cp">#define DSCR_xAM_DECREMENT	1</span>
<span class="cp">#define DSCR_xAM_STATIC		2</span>
<span class="cp">#define DSCR_xAM_BURST		3</span>
<span class="cp">#define DSCR_SRC1_SAM(x)	(((x) &amp; 3) &lt;&lt; 28)</span>
<span class="cp">#define DSCR_DEST1_DAM(x)	(((x) &amp; 3) &lt;&lt; 28)</span>

<span class="cm">/* The next descriptor pointer. */</span>
<span class="cp">#define DSCR_NXTPTR_MASK	(0x07ffffff)</span>
<span class="cp">#define DSCR_NXTPTR(x)		((x) &gt;&gt; 5)</span>
<span class="cp">#define DSCR_GET_NXTPTR(x)	((x) &lt;&lt; 5)</span>
<span class="cp">#define DSCR_NXTPTR_MS		(1 &lt;&lt; 27)</span>

<span class="cm">/* The number of DBDMA channels. */</span>
<span class="cp">#define NUM_DBDMA_CHANS	16</span>

<span class="cm">/*</span>
<span class="cm"> * DDMA API definitions</span>
<span class="cm"> * FIXME: may not fit to this header file</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dbdma_device_table</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dev_flags</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dev_tsize</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dev_devwidth</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dev_physaddr</span><span class="p">;</span>		<span class="cm">/* If FIFO */</span>
	<span class="n">u32</span>	<span class="n">dev_intlevel</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dev_intpolarity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dbdev_tab_t</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dbdma_chan_config</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>      <span class="n">lock</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">chan_flags</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">chan_index</span><span class="p">;</span>
	<span class="n">dbdev_tab_t</span>		<span class="o">*</span><span class="n">chan_src</span><span class="p">;</span>
	<span class="n">dbdev_tab_t</span>		<span class="o">*</span><span class="n">chan_dest</span><span class="p">;</span>
	<span class="n">au1x_dma_chan_t</span>		<span class="o">*</span><span class="n">chan_ptr</span><span class="p">;</span>
	<span class="n">au1x_ddma_desc_t</span>	<span class="o">*</span><span class="n">chan_desc_base</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">cdb_membase</span><span class="p">;</span> <span class="cm">/* kmalloc base of above */</span>
	<span class="n">au1x_ddma_desc_t</span>	<span class="o">*</span><span class="n">get_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">put_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">cur_ptr</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">chan_callparam</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">chan_callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">chan_tab_t</span><span class="p">;</span>

<span class="cp">#define DEV_FLAGS_INUSE		(1 &lt;&lt; 0)</span>
<span class="cp">#define DEV_FLAGS_ANYUSE	(1 &lt;&lt; 1)</span>
<span class="cp">#define DEV_FLAGS_OUT		(1 &lt;&lt; 2)</span>
<span class="cp">#define DEV_FLAGS_IN		(1 &lt;&lt; 3)</span>
<span class="cp">#define DEV_FLAGS_BURSTABLE	(1 &lt;&lt; 4)</span>
<span class="cp">#define DEV_FLAGS_SYNC		(1 &lt;&lt; 5)</span>
<span class="cm">/* end DDMA API definitions */</span>

<span class="cm">/*</span>
<span class="cm"> * External functions for drivers to use.</span>
<span class="cm"> * Use this to allocate a DBDMA channel.  The device IDs are one of</span>
<span class="cm"> * the DSCR_CMD0 devices IDs, which is usually redefined to a more</span>
<span class="cm"> * meaningful name.  The &#39;callback&#39; is called during DMA completion</span>
<span class="cm"> * interrupt.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">au1xxx_dbdma_chan_alloc</span><span class="p">(</span><span class="n">u32</span> <span class="n">srcid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">destid</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">callparam</span><span class="p">);</span>

<span class="cp">#define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS</span>

<span class="cm">/* Set the device width of an in/out FIFO. */</span>
<span class="n">u32</span> <span class="n">au1xxx_dbdma_set_devwidth</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">);</span>

<span class="cm">/* Allocate a ring of descriptors for DBDMA. */</span>
<span class="n">u32</span> <span class="n">au1xxx_dbdma_ring_alloc</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entries</span><span class="p">);</span>

<span class="cm">/* Put buffers on source/destination descriptors. */</span>
<span class="n">u32</span> <span class="n">au1xxx_dbdma_put_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">au1xxx_dbdma_put_dest</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Get a buffer from the destination descriptor. */</span>
<span class="n">u32</span> <span class="n">au1xxx_dbdma_get_dest</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nbytes</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">au1xxx_dbdma_stop</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">au1xxx_dbdma_start</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">au1xxx_dbdma_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">au1xxx_get_dma_residue</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">au1xxx_dbdma_chan_free</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">au1xxx_dbdma_dump</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">au1xxx_dbdma_put_dscr</span><span class="p">(</span><span class="n">u32</span> <span class="n">chanid</span><span class="p">,</span> <span class="n">au1x_ddma_desc_t</span> <span class="o">*</span><span class="n">dscr</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">au1xxx_ddma_add_device</span><span class="p">(</span><span class="n">dbdev_tab_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">au1xxx_ddma_del_device</span><span class="p">(</span><span class="n">u32</span> <span class="n">devid</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">au1xxx_ddma_get_nextptr_virt</span><span class="p">(</span><span class="n">au1x_ddma_desc_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Flags for the put_source/put_dest functions.</span>
<span class="cm"> */</span>
<span class="cp">#define DDMA_FLAGS_IE	(1 &lt;&lt; 0)</span>
<span class="cp">#define DDMA_FLAGS_NOIE (1 &lt;&lt; 1)</span>

<span class="cp">#endif </span><span class="cm">/* _LANGUAGE_ASSEMBLY */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _AU1000_DBDMA_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
