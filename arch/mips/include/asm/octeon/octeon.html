<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › octeon › octeon.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>octeon.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2008 Cavium Networks</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ASM_OCTEON_OCTEON_H</span>
<span class="cp">#define __ASM_OCTEON_OCTEON_H</span>

<span class="cp">#include &quot;cvmx.h&quot;</span>

<span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">octeon_bootmem_alloc_range_phys</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span>
						<span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
						<span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
						<span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">do_locking</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">octeon_bootmem_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">do_locking</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">octeon_bootmem_alloc_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
					<span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">do_locking</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">octeon_bootmem_alloc_named</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">octeon_bootmem_alloc_named_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
					      <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">align</span><span class="p">,</span>
					      <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">octeon_bootmem_alloc_named_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span>
						<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_bootmem_free_named</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_bootmem_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_bootmem_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_is_simulation</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_is_pci_host</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_usb_is_ref_clk</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">octeon_get_clock_rate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">octeon_get_io_clock_rate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">octeon_board_type_string</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">octeon_get_pci_interrupts</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_get_southbridge_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_get_boot_coremask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_get_boot_num_arguments</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">octeon_get_boot_argument</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_hal_setup_reserved32</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_user_io_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">octeon_cop2_state</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">octeon_crypto_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">octeon_cop2_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_crypto_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">octeon_cop2_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">octeon_cop2_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">octeon_cop2_state</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_init_cvmcount</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_setup_delays</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define OCTEON_ARGV_MAX_ARGS	64</span>
<span class="cp">#define OCTOEN_SERIAL_LEN	20</span>

<span class="k">struct</span> <span class="n">octeon_boot_descriptor</span> <span class="p">{</span>
	<span class="cm">/* Start of block referenced by assembly code - do not change! */</span>
	<span class="kt">uint32_t</span> <span class="n">desc_version</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">desc_size</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">stack_top</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">heap_base</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">heap_end</span><span class="p">;</span>
	<span class="cm">/* Only used by bootloader */</span>
	<span class="kt">uint64_t</span> <span class="n">entry_point</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">desc_vaddr</span><span class="p">;</span>
	<span class="cm">/* End of This block referenced by assembly code - do not change! */</span>
	<span class="kt">uint32_t</span> <span class="n">exception_base_addr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">stack_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">heap_size</span><span class="p">;</span>
	<span class="cm">/* Argc count for application. */</span>
	<span class="kt">uint32_t</span> <span class="n">argc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">argv</span><span class="p">[</span><span class="n">OCTEON_ARGV_MAX_ARGS</span><span class="p">];</span>

<span class="cp">#define  BOOT_FLAG_INIT_CORE		(1 &lt;&lt; 0)</span>
<span class="cp">#define  OCTEON_BL_FLAG_DEBUG		(1 &lt;&lt; 1)</span>
<span class="cp">#define  OCTEON_BL_FLAG_NO_MAGIC	(1 &lt;&lt; 2)</span>
	<span class="cm">/* If set, use uart1 for console */</span>
<span class="cp">#define  OCTEON_BL_FLAG_CONSOLE_UART1	(1 &lt;&lt; 3)</span>
	<span class="cm">/* If set, use PCI console */</span>
<span class="cp">#define  OCTEON_BL_FLAG_CONSOLE_PCI	(1 &lt;&lt; 4)</span>
	<span class="cm">/* Call exit on break on serial port */</span>
<span class="cp">#define  OCTEON_BL_FLAG_BREAK		(1 &lt;&lt; 5)</span>

	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">core_mask</span><span class="p">;</span>
	<span class="cm">/* DRAM size in megabyes. */</span>
	<span class="kt">uint32_t</span> <span class="n">dram_size</span><span class="p">;</span>
	<span class="cm">/* physical address of free memory descriptor block. */</span>
	<span class="kt">uint32_t</span> <span class="n">phy_mem_desc_addr</span><span class="p">;</span>
	<span class="cm">/* used to pass flags from app to debugger. */</span>
	<span class="kt">uint32_t</span> <span class="n">debugger_flags_base_addr</span><span class="p">;</span>
	<span class="cm">/* CPU clock speed, in hz. */</span>
	<span class="kt">uint32_t</span> <span class="n">eclock_hz</span><span class="p">;</span>
	<span class="cm">/* DRAM clock speed, in hz. */</span>
	<span class="kt">uint32_t</span> <span class="n">dclock_hz</span><span class="p">;</span>
	<span class="cm">/* SPI4 clock in hz. */</span>
	<span class="kt">uint32_t</span> <span class="n">spi_clock_hz</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">board_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">board_rev_major</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">board_rev_minor</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">chip_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">chip_rev_major</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">chip_rev_minor</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">board_serial_number</span><span class="p">[</span><span class="n">OCTOEN_SERIAL_LEN</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mac_addr_base</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">mac_addr_count</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">cvmx_desc_vaddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">octeon_cvmemctl</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">tlbbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">l1cbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">l1dbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">dcmbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">ptgbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* RO 1 = BIST fail, 0 = BIST pass */</span>
		<span class="kt">uint64_t</span> <span class="n">wbfbist</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Reserved */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">22</span><span class="p">;</span>
		<span class="cm">/* R/W If set, marked write-buffer entries time out</span>
<span class="cm">		 * the same as as other entries; if clear, marked</span>
<span class="cm">		 * write-buffer entries use the maximum timeout. */</span>
		<span class="kt">uint64_t</span> <span class="n">dismarkwblongto</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, a merged store does not clear the</span>
<span class="cm">		 * write-buffer entry timeout state. */</span>
		<span class="kt">uint64_t</span> <span class="n">dismrgclrwbto</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W Two bits that are the MSBs of the resultant</span>
<span class="cm">		 * CVMSEG LM word location for an IOBDMA. The other 8</span>
<span class="cm">		 * bits come from the SCRADDR field of the IOBDMA. */</span>
		<span class="kt">uint64_t</span> <span class="n">iobdmascrmsb</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* R/W If set, SYNCWS and SYNCS only order marked</span>
<span class="cm">		 * stores; if clear, SYNCWS and SYNCS only order</span>
<span class="cm">		 * unmarked stores. SYNCWSMARKED has no effect when</span>
<span class="cm">		 * DISSYNCWS is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">syncwsmarked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, SYNCWS acts as SYNCW and SYNCS acts as</span>
<span class="cm">		 * SYNC. */</span>
		<span class="kt">uint64_t</span> <span class="n">dissyncws</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, no stall happens on write buffer</span>
<span class="cm">		 * full. */</span>
		<span class="kt">uint64_t</span> <span class="n">diswbfst</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set (and SX set), supervisor-level</span>
<span class="cm">		 * loads/stores can use XKPHYS addresses with</span>
<span class="cm">		 * VA&lt;48&gt;==0 */</span>
		<span class="kt">uint64_t</span> <span class="n">xkmemenas</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set (and UX set), user-level loads/stores</span>
<span class="cm">		 * can use XKPHYS addresses with VA&lt;48&gt;==0 */</span>
		<span class="kt">uint64_t</span> <span class="n">xkmemenau</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set (and SX set), supervisor-level</span>
<span class="cm">		 * loads/stores can use XKPHYS addresses with</span>
<span class="cm">		 * VA&lt;48&gt;==1 */</span>
		<span class="kt">uint64_t</span> <span class="n">xkioenas</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set (and UX set), user-level loads/stores</span>
<span class="cm">		 * can use XKPHYS addresses with VA&lt;48&gt;==1 */</span>
		<span class="kt">uint64_t</span> <span class="n">xkioenau</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, all stores act as SYNCW (NOMERGE must</span>
<span class="cm">		 * be set when this is set) RW, reset to 0. */</span>
		<span class="kt">uint64_t</span> <span class="n">allsyncw</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, no stores merge, and all stores reach</span>
<span class="cm">		 * the coherent bus in order. */</span>
		<span class="kt">uint64_t</span> <span class="n">nomerge</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W Selects the bit in the counter used for DID</span>
<span class="cm">		 * time-outs 0 = 231, 1 = 230, 2 = 229, 3 =</span>
<span class="cm">		 * 214. Actual time-out is between 1x and 2x this</span>
<span class="cm">		 * interval. For example, with DIDTTO=3, expiration</span>
<span class="cm">		 * interval is between 16K and 32K. */</span>
		<span class="kt">uint64_t</span> <span class="n">didtto</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* R/W If set, the (mem) CSR clock never turns off. */</span>
		<span class="kt">uint64_t</span> <span class="n">csrckalwys</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, mclk never turns off. */</span>
		<span class="kt">uint64_t</span> <span class="n">mclkalwys</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W Selects the bit in the counter used for write</span>
<span class="cm">		 * buffer flush time-outs (WBFLT+11) is the bit</span>
<span class="cm">		 * position in an internal counter used to determine</span>
<span class="cm">		 * expiration. The write buffer expires between 1x and</span>
<span class="cm">		 * 2x this interval. For example, with WBFLT = 0, a</span>
<span class="cm">		 * write buffer expires between 2K and 4K cycles after</span>
<span class="cm">		 * the write buffer entry is allocated. */</span>
		<span class="kt">uint64_t</span> <span class="n">wbfltime</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/* R/W If set, do not put Istream in the L2 cache. */</span>
		<span class="kt">uint64_t</span> <span class="n">istrnol2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W The write buffer threshold. */</span>
		<span class="kt">uint64_t</span> <span class="n">wbthresh</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* Reserved */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in</span>
<span class="cm">		 * kernel/debug mode. */</span>
		<span class="kt">uint64_t</span> <span class="n">cvmsegenak</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in</span>
<span class="cm">		 * supervisor mode. */</span>
		<span class="kt">uint64_t</span> <span class="n">cvmsegenas</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W If set, CVMSEG is available for loads/stores in</span>
<span class="cm">		 * user mode. */</span>
		<span class="kt">uint64_t</span> <span class="n">cvmsegenau</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* R/W Size of local memory in cache blocks, 54 (6912</span>
<span class="cm">		 * bytes) is max legal value. */</span>
		<span class="kt">uint64_t</span> <span class="n">lmemsz</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">octeon_cf_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">base_region_bias</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">base_region</span><span class="p">;</span>	<span class="cm">/* The chip select region used by CF */</span>
	<span class="kt">int</span>		<span class="n">is16bit</span><span class="p">;</span>	<span class="cm">/* 0 - 8bit, !0 - 16bit */</span>
	<span class="kt">int</span>		<span class="n">dma_engine</span><span class="p">;</span>	<span class="cm">/* -1 for no DMA */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">octeon_i2c_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sys_freq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">i2c_freq</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_write_lcd</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_check_cpu_bist</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_get_boot_debug_flag</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">octeon_get_boot_uart</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">uart_port</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">octeon_serial_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">octeon_serial_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write a 32bit value to the Octeon NPI register space</span>
<span class="cm"> *</span>
<span class="cm"> * @address: Address to write to</span>
<span class="cm"> * @val:     Value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">octeon_npi_write32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_write64_uint32</span><span class="p">(</span><span class="n">address</span> <span class="o">^</span> <span class="mi">4</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">cvmx_read64_uint32</span><span class="p">(</span><span class="n">address</span> <span class="o">^</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Read a 32bit value from the Octeon NPI register space</span>
<span class="cm"> *</span>
<span class="cm"> * @address: Address to read</span>
<span class="cm"> * Returns The result</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">octeon_npi_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_read64_uint32</span><span class="p">(</span><span class="n">address</span> <span class="o">^</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">cvmx_bootinfo</span> <span class="o">*</span><span class="n">octeon_bootinfo</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">octeon_bootloader_entry_addr</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">octeon_irq_setup_secondary</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __ASM_OCTEON_OCTEON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
