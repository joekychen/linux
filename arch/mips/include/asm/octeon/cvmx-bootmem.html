<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › octeon › cvmx-bootmem.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cvmx-bootmem.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***********************license start***************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2008 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm"> ***********************license end**************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Simple allocate only memory allocator.  Used to allocate memory at</span>
<span class="cm"> * application start time.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __CVMX_BOOTMEM_H__</span>
<span class="cp">#define __CVMX_BOOTMEM_H__</span>
<span class="cm">/* Must be multiple of 8, changing breaks ABI */</span>
<span class="cp">#define CVMX_BOOTMEM_NAME_LEN 128</span>

<span class="cm">/* Can change without breaking ABI */</span>
<span class="cp">#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS 64</span>

<span class="cm">/* minimum alignment of bootmem alloced blocks */</span>
<span class="cp">#define CVMX_BOOTMEM_ALIGNMENT_SIZE     (16ull)</span>

<span class="cm">/* Flags for cvmx_bootmem_phy_mem* functions */</span>
<span class="cm">/* Allocate from end of block instead of beginning */</span>
<span class="cp">#define CVMX_BOOTMEM_FLAG_END_ALLOC    (1 &lt;&lt; 0)</span>

<span class="cm">/* Don&#39;t do any locking. */</span>
<span class="cp">#define CVMX_BOOTMEM_FLAG_NO_LOCKING   (1 &lt;&lt; 1)</span>

<span class="cm">/* First bytes of each free physical block of memory contain this structure,</span>
<span class="cm"> * which is used to maintain the free memory list.  Since the bootloader is</span>
<span class="cm"> * only 32 bits, there is a union providing 64 and 32 bit versions.  The</span>
<span class="cm"> * application init code converts addresses to 64 bit addresses before the</span>
<span class="cm"> * application starts.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cvmx_bootmem_block_header</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: these are referenced from assembly routines in the</span>
<span class="cm">	 * bootloader, so this structure should not be changed</span>
<span class="cm">	 * without changing those routines as well.</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">next_block_addr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for named memory blocks.  Number of descriptors available</span>
<span class="cm"> * can be changed without affecting compatibility, but name length</span>
<span class="cm"> * changes require a bump in the bootmem descriptor version Note: This</span>
<span class="cm"> * structure must be naturally 64 bit aligned, as a single memory</span>
<span class="cm"> * image will be used by both 32 and 64 bit programs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="p">{</span>
	<span class="cm">/* Base address of named block */</span>
	<span class="kt">uint64_t</span> <span class="n">base_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Size actually allocated for named block (may differ from</span>
<span class="cm">	 * requested).</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* name of named block */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">CVMX_BOOTMEM_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Current descriptor versions */</span>
<span class="cm">/* CVMX bootmem descriptor major version */</span>
<span class="cp">#define CVMX_BOOTMEM_DESC_MAJ_VER   3</span>

<span class="cm">/* CVMX bootmem descriptor minor version */</span>
<span class="cp">#define CVMX_BOOTMEM_DESC_MIN_VER   0</span>

<span class="cm">/* First three members of cvmx_bootmem_desc_t are left in original</span>
<span class="cm"> * positions for backwards compatibility.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cvmx_bootmem_desc</span> <span class="p">{</span>
	<span class="cm">/* spinlock to control access to list */</span>
	<span class="kt">uint32_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* flags for indicating various conditions */</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">head_addr</span><span class="p">;</span>

	<span class="cm">/* Incremented when incompatible changes made */</span>
	<span class="kt">uint32_t</span> <span class="n">major_version</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Incremented changed when compatible changes made, reset to</span>
<span class="cm">	 * zero when major incremented.</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">minor_version</span><span class="p">;</span>

	<span class="kt">uint64_t</span> <span class="n">app_data_addr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">app_data_size</span><span class="p">;</span>

	<span class="cm">/* number of elements in named blocks array */</span>
	<span class="kt">uint32_t</span> <span class="n">named_block_num_blocks</span><span class="p">;</span>

	<span class="cm">/* length of name array in bootmem blocks */</span>
	<span class="kt">uint32_t</span> <span class="n">named_block_name_len</span><span class="p">;</span>
	<span class="cm">/* address of named memory block descriptors */</span>
	<span class="kt">uint64_t</span> <span class="n">named_block_array_addr</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize the boot alloc memory structures. This is</span>
<span class="cm"> * normally called inside of cvmx_user_app_init()</span>
<span class="cm"> *</span>
<span class="cm"> * @mem_desc_ptr:	Address of the free memory list</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_bootmem_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem_desc_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from the free list that was passed</span>
<span class="cm"> * to the application by the bootloader.</span>
<span class="cm"> * This is an allocate-only algorithm, so freeing memory is not possible.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:      Size in bytes of block to allocate</span>
<span class="cm"> * @alignment: Alignment required - must be power of 2</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from the free list that was</span>
<span class="cm"> * passed to the application by the bootloader at a specific</span>
<span class="cm"> * address. This is an allocate-only algorithm, so</span>
<span class="cm"> * freeing memory is not possible. Allocation will fail if</span>
<span class="cm"> * memory cannot be allocated at the specified address.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:      Size in bytes of block to allocate</span>
<span class="cm"> * @address:   Physical address to allocate memory at.  If this memory is not</span>
<span class="cm"> *                  available, the allocation fails.</span>
<span class="cm"> * @alignment: Alignment required - must be power of 2</span>
<span class="cm"> * Returns pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span>
					<span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from the free list that was</span>
<span class="cm"> * passed to the application by the bootloader within a specified</span>
<span class="cm"> * address range. This is an allocate-only algorithm, so</span>
<span class="cm"> * freeing memory is not possible. Allocation will fail if</span>
<span class="cm"> * memory cannot be allocated in the requested range.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:      Size in bytes of block to allocate</span>
<span class="cm"> * @min_addr:  defines the minimum address of the range</span>
<span class="cm"> * @max_addr:  defines the maximum address of the range</span>
<span class="cm"> * @alignment: Alignment required - must be power of 2</span>
<span class="cm"> * Returns pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
				      <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Frees a previously allocated named bootmem block.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:   name of block to free</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on failure,</span>
<span class="cm"> *         !0 on success</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from the free list that was passed</span>
<span class="cm"> * to the application by the bootloader, and assign it a name in the</span>
<span class="cm"> * global named block table.  (part of the cvmx_bootmem_descriptor_t structure)</span>
<span class="cm"> * Named blocks can later be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:      Size in bytes of block to allocate</span>
<span class="cm"> * @alignment: Alignment required - must be power of 2</span>
<span class="cm"> * @name:      name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc_named</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>



<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from the free list that was passed</span>
<span class="cm"> * to the application by the bootloader, and assign it a name in the</span>
<span class="cm"> * global named block table.  (part of the cvmx_bootmem_descriptor_t structure)</span>
<span class="cm"> * Named blocks can later be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:     Size in bytes of block to allocate</span>
<span class="cm"> * @address:  Physical address to allocate memory at.  If this</span>
<span class="cm"> *            memory is not available, the allocation fails.</span>
<span class="cm"> * @name:     name of block - must be less than CVMX_BOOTMEM_NAME_LEN</span>
<span class="cm"> *            bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc_named_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span>
					      <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>



<span class="cm">/**</span>
<span class="cm"> * Allocate a block of memory from a specific range of the free list</span>
<span class="cm"> * that was passed to the application by the bootloader, and assign it</span>
<span class="cm"> * a name in the global named block table.  (part of the</span>
<span class="cm"> * cvmx_bootmem_descriptor_t structure) Named blocks can later be</span>
<span class="cm"> * freed.  If request cannot be satisfied within the address range</span>
<span class="cm"> * specified, NULL is returned</span>
<span class="cm"> *</span>
<span class="cm"> * @size:      Size in bytes of block to allocate</span>
<span class="cm"> * @min_addr:  minimum address of range</span>
<span class="cm"> * @max_addr:  maximum address of range</span>
<span class="cm"> * @align:     Alignment of memory to be allocated. (must be a power of 2)</span>
<span class="cm"> * @name:      name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to block of memory, NULL on error</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cvmx_bootmem_alloc_named_range</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
					    <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">align</span><span class="p">,</span>
					    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_bootmem_free_named</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Finds a named bootmem block by name.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:   name of block to free</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to named block descriptor on success</span>
<span class="cm"> *         0 on failure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span><span class="n">cvmx_bootmem_find_named_block</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocates a block of physical memory from the free list, at</span>
<span class="cm"> * (optional) requested address and alignment.</span>
<span class="cm"> *</span>
<span class="cm"> * @req_size: size of region to allocate.  All requests are rounded up</span>
<span class="cm"> *            to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE bytes size</span>
<span class="cm"> *</span>
<span class="cm"> * @address_min: Minimum address that block can occupy.</span>
<span class="cm"> *</span>
<span class="cm"> * @address_max: Specifies the maximum address_min (inclusive) that</span>
<span class="cm"> *               the allocation can use.</span>
<span class="cm"> *</span>
<span class="cm"> * @alignment: Requested alignment of the block.  If this alignment</span>
<span class="cm"> *             cannot be met, the allocation fails.  This must be a</span>
<span class="cm"> *             power of 2.  (Note: Alignment of</span>
<span class="cm"> *             CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and</span>
<span class="cm"> *             internally enforced.  Requested alignments of less than</span>
<span class="cm"> *             CVMX_BOOTMEM_ALIGNMENT_SIZE are set to</span>
<span class="cm"> *             CVMX_BOOTMEM_ALIGNMENT_SIZE.)</span>
<span class="cm"> *</span>
<span class="cm"> * @flags:     Flags to control options for the allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns physical address of block allocated, or -1 on failure</span>
<span class="cm"> */</span>
<span class="kt">int64_t</span> <span class="n">cvmx_bootmem_phy_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">req_size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address_min</span><span class="p">,</span>
			       <span class="kt">uint64_t</span> <span class="n">address_max</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
			       <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocates a named block of physical memory from the free list, at</span>
<span class="cm"> * (optional) requested address and alignment.</span>
<span class="cm"> *</span>
<span class="cm"> * @param size      size of region to allocate.  All requests are rounded</span>
<span class="cm"> *                  up to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE</span>
<span class="cm"> *                  bytes size</span>
<span class="cm"> * @param min_addr Minimum address that block can occupy.</span>
<span class="cm"> * @param max_addr  Specifies the maximum address_min (inclusive) that</span>
<span class="cm"> *                  the allocation can use.</span>
<span class="cm"> * @param alignment Requested alignment of the block.  If this</span>
<span class="cm"> *                  alignment cannot be met, the allocation fails.</span>
<span class="cm"> *                  This must be a power of 2.  (Note: Alignment of</span>
<span class="cm"> *                  CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and</span>
<span class="cm"> *                  internally enforced.  Requested alignments of less</span>
<span class="cm"> *                  than CVMX_BOOTMEM_ALIGNMENT_SIZE are set to</span>
<span class="cm"> *                  CVMX_BOOTMEM_ALIGNMENT_SIZE.)</span>
<span class="cm"> * @param name      name to assign to named block</span>
<span class="cm"> * @param flags     Flags to control options for the allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * @return physical address of block allocated, or -1 on failure</span>
<span class="cm"> */</span>
<span class="kt">int64_t</span> <span class="n">cvmx_bootmem_phy_named_block_alloc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">min_addr</span><span class="p">,</span>
					   <span class="kt">uint64_t</span> <span class="n">max_addr</span><span class="p">,</span>
					   <span class="kt">uint64_t</span> <span class="n">alignment</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Finds a named memory block by name.</span>
<span class="cm"> * Also used for finding an unused entry in the named block table.</span>
<span class="cm"> *</span>
<span class="cm"> * @name: Name of memory block to find.  If NULL pointer given, then</span>
<span class="cm"> *        finds unused descriptor, if available.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: Flags to control options for the allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Pointer to memory block descriptor, NULL if not found.</span>
<span class="cm"> *         If NULL returned when name parameter is NULL, then no memory</span>
<span class="cm"> *         block descriptors are available.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cvmx_bootmem_named_block_desc</span> <span class="o">*</span>
<span class="n">cvmx_bootmem_phy_named_block_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Frees a named block.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:   name of block to free</span>
<span class="cm"> * @flags:  flags for passing options</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on failure</span>
<span class="cm"> *         1 on success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">cvmx_bootmem_phy_named_block_free</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Frees a block to the bootmem allocator list.  This must</span>
<span class="cm"> * be used with care, as the size provided must match the size</span>
<span class="cm"> * of the block that was allocated, or the list will become</span>
<span class="cm"> * corrupted.</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT:  This is only intended to be used as part of named block</span>
<span class="cm"> * frees and initial population of the free memory list.</span>
<span class="cm"> *                                                      *</span>
<span class="cm"> *</span>
<span class="cm"> * @phy_addr: physical address of block</span>
<span class="cm"> * @size:     size of block in bytes.</span>
<span class="cm"> * @flags:    flags for passing options</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 on success,</span>
<span class="cm"> *         0 on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cvmx_bootmem_phy_free</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">phy_addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Locks the bootmem allocator.  This is useful in certain situations</span>
<span class="cm"> * where multiple allocations must be made without being interrupted.</span>
<span class="cm"> * This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cvmx_bootmem_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Unlocks the bootmem allocator.  This is useful in certain situations</span>
<span class="cm"> * where multiple allocations must be made without being interrupted.</span>
<span class="cm"> * This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">cvmx_bootmem_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/*   __CVMX_BOOTMEM_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
