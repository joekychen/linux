<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › octeon › cvmx-pip.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cvmx-pip.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***********************license start***************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2008 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm"> ***********************license end**************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Interface to the hardware Packet Input Processing unit.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __CVMX_PIP_H__</span>
<span class="cp">#define __CVMX_PIP_H__</span>

<span class="cp">#include &quot;cvmx-wqe.h&quot;</span>
<span class="cp">#include &quot;cvmx-fpa.h&quot;</span>
<span class="cp">#include &quot;cvmx-pip-defs.h&quot;</span>

<span class="cp">#define CVMX_PIP_NUM_INPUT_PORTS                40</span>
<span class="cp">#define CVMX_PIP_NUM_WATCHERS                   4</span>

<span class="cm">/*</span>
<span class="cm"> * Encodes the different error and exception codes</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">CVMX_PIP_L4_NO_ERR</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * 1 = TCP (UDP) packet not long enough to cover TCP (UDP)</span>
<span class="cm">	 * header</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_L4_MAL_ERR</span> <span class="o">=</span> <span class="mi">1ull</span><span class="p">,</span>
	<span class="cm">/* 2  = TCP/UDP checksum failure */</span>
	<span class="n">CVMX_PIP_CHK_ERR</span> <span class="o">=</span> <span class="mi">2ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * 3 = TCP/UDP length check (TCP/UDP length does not match IP</span>
<span class="cm">	 * length).</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_L4_LENGTH_ERR</span> <span class="o">=</span> <span class="mi">3ull</span><span class="p">,</span>
	<span class="cm">/* 4  = illegal TCP/UDP port (either source or dest port is zero) */</span>
	<span class="n">CVMX_PIP_BAD_PRT_ERR</span> <span class="o">=</span> <span class="mi">4ull</span><span class="p">,</span>
	<span class="cm">/* 8  = TCP flags = FIN only */</span>
	<span class="n">CVMX_PIP_TCP_FLG8_ERR</span> <span class="o">=</span> <span class="mi">8ull</span><span class="p">,</span>
	<span class="cm">/* 9  = TCP flags = 0 */</span>
	<span class="n">CVMX_PIP_TCP_FLG9_ERR</span> <span class="o">=</span> <span class="mi">9ull</span><span class="p">,</span>
	<span class="cm">/* 10 = TCP flags = FIN+RST+* */</span>
	<span class="n">CVMX_PIP_TCP_FLG10_ERR</span> <span class="o">=</span> <span class="mi">10ull</span><span class="p">,</span>
	<span class="cm">/* 11 = TCP flags = SYN+URG+* */</span>
	<span class="n">CVMX_PIP_TCP_FLG11_ERR</span> <span class="o">=</span> <span class="mi">11ull</span><span class="p">,</span>
	<span class="cm">/* 12 = TCP flags = SYN+RST+* */</span>
	<span class="n">CVMX_PIP_TCP_FLG12_ERR</span> <span class="o">=</span> <span class="mi">12ull</span><span class="p">,</span>
	<span class="cm">/* 13 = TCP flags = SYN+FIN+* */</span>
	<span class="n">CVMX_PIP_TCP_FLG13_ERR</span> <span class="o">=</span> <span class="mi">13ull</span>
<span class="p">}</span> <span class="n">cvmx_pip_l4_err_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>

	<span class="n">CVMX_PIP_IP_NO_ERR</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">,</span>
	<span class="cm">/* 1 = not IPv4 or IPv6 */</span>
	<span class="n">CVMX_PIP_NOT_IP</span> <span class="o">=</span> <span class="mi">1ull</span><span class="p">,</span>
	<span class="cm">/* 2 = IPv4 header checksum violation */</span>
	<span class="n">CVMX_PIP_IPV4_HDR_CHK</span> <span class="o">=</span> <span class="mi">2ull</span><span class="p">,</span>
	<span class="cm">/* 3 = malformed (packet not long enough to cover IP hdr) */</span>
	<span class="n">CVMX_PIP_IP_MAL_HDR</span> <span class="o">=</span> <span class="mi">3ull</span><span class="p">,</span>
	<span class="cm">/* 4 = malformed (packet not long enough to cover len in IP hdr) */</span>
	<span class="n">CVMX_PIP_IP_MAL_PKT</span> <span class="o">=</span> <span class="mi">4ull</span><span class="p">,</span>
	<span class="cm">/* 5 = TTL / hop count equal zero */</span>
	<span class="n">CVMX_PIP_TTL_HOP</span> <span class="o">=</span> <span class="mi">5ull</span><span class="p">,</span>
	<span class="cm">/* 6 = IPv4 options / IPv6 early extension headers */</span>
	<span class="n">CVMX_PIP_OPTS</span> <span class="o">=</span> <span class="mi">6ull</span>
<span class="p">}</span> <span class="n">cvmx_pip_ip_exc_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * NOTES</span>
<span class="cm"> *       late collision (data received before collision)</span>
<span class="cm"> *            late collisions cannot be detected by the receiver</span>
<span class="cm"> *            they would appear as JAM bits which would appear as bad FCS</span>
<span class="cm"> *            or carrier extend error which is CVMX_PIP_EXTEND_ERR</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* No error */</span>
	<span class="n">CVMX_PIP_RX_NO_ERR</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">,</span>
	<span class="cm">/* RGM+SPI 1 = partially received packet (buffering/bandwidth</span>
<span class="cm">	 * not adequate) */</span>
	<span class="n">CVMX_PIP_PARTIAL_ERR</span> <span class="o">=</span> <span class="mi">1ull</span><span class="p">,</span>
	<span class="cm">/* RGM+SPI 2 = receive packet too large and truncated */</span>
	<span class="n">CVMX_PIP_JABBER_ERR</span> <span class="o">=</span> <span class="mi">2ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 3 = max frame error (pkt len &gt; max frame len) (with FCS</span>
<span class="cm">	 * error)</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_OVER_FCS_ERR</span> <span class="o">=</span> <span class="mi">3ull</span><span class="p">,</span>
	<span class="cm">/* RGM+SPI 4 = max frame error (pkt len &gt; max frame len) */</span>
	<span class="n">CVMX_PIP_OVER_ERR</span> <span class="o">=</span> <span class="mi">4ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 5 = nibble error (data not byte multiple - 100M and 10M</span>
<span class="cm">	 * only)</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_ALIGN_ERR</span> <span class="o">=</span> <span class="mi">5ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 6 = min frame error (pkt len &lt; min frame len) (with FCS</span>
<span class="cm">	 * error)</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_UNDER_FCS_ERR</span> <span class="o">=</span> <span class="mi">6ull</span><span class="p">,</span>
	<span class="cm">/* RGM     7 = FCS error */</span>
	<span class="n">CVMX_PIP_GMX_FCS_ERR</span> <span class="o">=</span> <span class="mi">7ull</span><span class="p">,</span>
	<span class="cm">/* RGM+SPI 8 = min frame error (pkt len &lt; min frame len) */</span>
	<span class="n">CVMX_PIP_UNDER_ERR</span> <span class="o">=</span> <span class="mi">8ull</span><span class="p">,</span>
	<span class="cm">/* RGM     9 = Frame carrier extend error */</span>
	<span class="n">CVMX_PIP_EXTEND_ERR</span> <span class="o">=</span> <span class="mi">9ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 10 = length mismatch (len did not match len in L2</span>
<span class="cm">	 * length/type)</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_LENGTH_ERR</span> <span class="o">=</span> <span class="mi">10ull</span><span class="p">,</span>
	<span class="cm">/* RGM 11 = Frame error (some or all data bits marked err) */</span>
	<span class="n">CVMX_PIP_DAT_ERR</span> <span class="o">=</span> <span class="mi">11ull</span><span class="p">,</span>
	<span class="cm">/*     SPI 11 = DIP4 error */</span>
	<span class="n">CVMX_PIP_DIP_ERR</span> <span class="o">=</span> <span class="mi">11ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 12 = packet was not large enough to pass the skipper -</span>
<span class="cm">	 * no inspection could occur.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_SKIP_ERR</span> <span class="o">=</span> <span class="mi">12ull</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM 13 = studder error (data not repeated - 100M and 10M</span>
<span class="cm">	 * only)</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_NIBBLE_ERR</span> <span class="o">=</span> <span class="mi">13ull</span><span class="p">,</span>
	<span class="cm">/* RGM+SPI 16 = FCS error */</span>
	<span class="n">CVMX_PIP_PIP_FCS</span> <span class="o">=</span> <span class="mi">16L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM+SPI+PCI 17 = packet was not large enough to pass the</span>
<span class="cm">	 * skipper - no inspection could occur.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_PIP_SKIP_ERR</span> <span class="o">=</span> <span class="mi">17L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * RGM+SPI+PCI 18 = malformed l2 (packet not long enough to</span>
<span class="cm">	 * cover L2 hdr).</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PIP_PIP_L2_MAL_HDR</span> <span class="o">=</span> <span class="mi">18L</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTES: xx = late collision (data received before collision)</span>
<span class="cm">	 *       late collisions cannot be detected by the receiver</span>
<span class="cm">	 *       they would appear as JAM bits which would appear as</span>
<span class="cm">	 *       bad FCS or carrier extend error which is</span>
<span class="cm">	 *       CVMX_PIP_EXTEND_ERR</span>
<span class="cm">	 */</span>
<span class="p">}</span> <span class="n">cvmx_pip_rcv_err_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This defines the err_code field errors in the work Q entry</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="n">cvmx_pip_l4_err_t</span> <span class="n">l4_err</span><span class="p">;</span>
	<span class="n">cvmx_pip_ip_exc_t</span> <span class="n">ip_exc</span><span class="p">;</span>
	<span class="n">cvmx_pip_rcv_err_t</span> <span class="n">rcv_err</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pip_err_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Status statistics for a port</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* Inbound octets marked to be dropped by the IPD */</span>
	<span class="kt">uint32_t</span> <span class="n">dropped_octets</span><span class="p">;</span>
	<span class="cm">/* Inbound packets marked to be dropped by the IPD */</span>
	<span class="kt">uint32_t</span> <span class="n">dropped_packets</span><span class="p">;</span>
	<span class="cm">/* RAW PCI Packets received by PIP per port */</span>
	<span class="kt">uint32_t</span> <span class="n">pci_raw_packets</span><span class="p">;</span>
	<span class="cm">/* Number of octets processed by PIP */</span>
	<span class="kt">uint32_t</span> <span class="n">octets</span><span class="p">;</span>
	<span class="cm">/* Number of packets processed by PIP */</span>
	<span class="kt">uint32_t</span> <span class="n">packets</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of indentified L2 multicast packets.  Does not</span>
<span class="cm">	 * include broadcast packets.  Only includes packets whose</span>
<span class="cm">	 * parse mode is SKIP_TO_L2</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">multicast_packets</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of indentified L2 broadcast packets.  Does not</span>
<span class="cm">	 * include multicast packets.  Only includes packets whose</span>
<span class="cm">	 * parse mode is SKIP_TO_L2</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">broadcast_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 64B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_64_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 65-127B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_65_127_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 128-255B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_128_255_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 256-511B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_256_511_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 512-1023B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_512_1023_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 1024-1518B packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_1024_1518_packets</span><span class="p">;</span>
	<span class="cm">/* Number of 1519-max packets */</span>
	<span class="kt">uint32_t</span> <span class="n">len_1519_max_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with FCS or Align opcode errors */</span>
	<span class="kt">uint32_t</span> <span class="n">fcs_align_err_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with length &lt; min */</span>
	<span class="kt">uint32_t</span> <span class="n">runt_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with length &lt; min and FCS error */</span>
	<span class="kt">uint32_t</span> <span class="n">runt_crc_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with length &gt; max */</span>
	<span class="kt">uint32_t</span> <span class="n">oversize_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with length &gt; max and FCS error */</span>
	<span class="kt">uint32_t</span> <span class="n">oversize_crc_packets</span><span class="p">;</span>
	<span class="cm">/* Number of packets without GMX/SPX/PCI errors received by PIP */</span>
	<span class="kt">uint32_t</span> <span class="n">inb_packets</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Total number of octets from all packets received by PIP,</span>
<span class="cm">	 * including CRC</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">inb_octets</span><span class="p">;</span>
	<span class="cm">/* Number of packets with GMX/SPX/PCI errors received by PIP */</span>
	<span class="kt">uint16_t</span> <span class="n">inb_errors</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pip_port_status_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Definition of the PIP custom header that can be prepended</span>
<span class="cm"> * to a packet by external hardware.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Documented as R - Set if the Packet is RAWFULL. If</span>
<span class="cm">		 * set, this header must be the full 8 bytes.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rawfull</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved0</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
		<span class="cm">/* PIP parse mode for this packet */</span>
		<span class="kt">uint64_t</span> <span class="n">parse_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Skip amount, including this header, to the</span>
<span class="cm">		 * beginning of the packet</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">skip_len</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="cm">/* POW input queue for this packet */</span>
		<span class="kt">uint64_t</span> <span class="n">qos</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/* POW input group for this packet */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Flag to store this packet in the work queue entry,</span>
<span class="cm">		 * if possible</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* POW input tag type */</span>
		<span class="kt">uint64_t</span> <span class="n">tag_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* POW input tag */</span>
		<span class="kt">uint64_t</span> <span class="n">tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pip_pkt_inst_hdr_t</span><span class="p">;</span>

<span class="cm">/* CSR typedefs have been moved to cvmx-csr-*.h */</span>

<span class="cm">/**</span>
<span class="cm"> * Configure an ethernet input port</span>
<span class="cm"> *</span>
<span class="cm"> * @port_num: Port number to configure</span>
<span class="cm"> * @port_cfg: Port hardware configuration</span>
<span class="cm"> * @port_tag_cfg:</span>
<span class="cm"> *                 Port POW tagging configuration</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_config_port</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port_num</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">cvmx_pip_prt_cfgx</span> <span class="n">port_cfg</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">cvmx_pip_prt_tagx</span> <span class="n">port_tag_cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_PRT_CFGX</span><span class="p">(</span><span class="n">port_num</span><span class="p">),</span> <span class="n">port_cfg</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_PRT_TAGX</span><span class="p">(</span><span class="n">port_num</span><span class="p">),</span> <span class="n">port_tag_cfg</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/**</span>
<span class="c"> * @deprecated      This function is a thin wrapper around the Pass1 version</span>
<span class="c"> *                  of the CVMX_PIP_QOS_WATCHX CSR; Pass2 has added a field for</span>
<span class="c"> *                  setting the group that is incompatible with this function,</span>
<span class="c"> *                  the preferred upgrade path is to use the CSR directly.</span>
<span class="c"> *</span>
<span class="c"> * Configure the global QoS packet watchers. Each watcher is</span>
<span class="c"> * capable of matching a field in a packet to determine the</span>
<span class="c"> * QoS queue for scheduling.</span>
<span class="c"> *</span>
<span class="c"> * @watcher:    Watcher number to configure (0 - 3).</span>
<span class="c"> * @match_type: Watcher match type</span>
<span class="c"> * @match_value:</span>
<span class="c"> *                   Value the watcher will match against</span>
<span class="c"> * @qos:        QoS queue for packets matching this watcher</span>
<span class="c"> */</span>
<span class="c">static inline void cvmx_pip_config_watcher(uint64_t watcher,</span>
<span class="c">					   cvmx_pip_qos_watch_types match_type,</span>
<span class="c">					   uint64_t match_value, uint64_t qos)</span>
<span class="c">{</span>
<span class="c">	cvmx_pip_port_watcher_cfg_t watcher_config;</span>

<span class="c">	watcher_config.u64 = 0;</span>
<span class="c">	watcher_config.s.match_type = match_type;</span>
<span class="c">	watcher_config.s.match_value = match_value;</span>
<span class="c">	watcher_config.s.qos = qos;</span>

<span class="c">	cvmx_write_csr(CVMX_PIP_QOS_WATCHX(watcher), watcher_config.u64);</span>
<span class="c">}</span>
<span class="cp">#endif</span>
<span class="cm">/**</span>
<span class="cm"> * Configure the VLAN priority to QoS queue mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * @vlan_priority:</span>
<span class="cm"> *               VLAN priority (0-7)</span>
<span class="cm"> * @qos:    QoS queue for packets matching this watcher</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_config_vlan_qos</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">vlan_priority</span><span class="p">,</span>
					    <span class="kt">uint64_t</span> <span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pip_qos_vlanx</span> <span class="n">pip_qos_vlanx</span><span class="p">;</span>
	<span class="n">pip_qos_vlanx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pip_qos_vlanx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_QOS_VLANX</span><span class="p">(</span><span class="n">vlan_priority</span><span class="p">),</span> <span class="n">pip_qos_vlanx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Configure the Diffserv to QoS queue mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * @diffserv: Diffserv field value (0-63)</span>
<span class="cm"> * @qos:      QoS queue for packets matching this watcher</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_config_diffserv_qos</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">diffserv</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">qos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pip_qos_diffx</span> <span class="n">pip_qos_diffx</span><span class="p">;</span>
	<span class="n">pip_qos_diffx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pip_qos_diffx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_QOS_DIFFX</span><span class="p">(</span><span class="n">diffserv</span><span class="p">),</span> <span class="n">pip_qos_diffx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the status counters for a port.</span>
<span class="cm"> *</span>
<span class="cm"> * @port_num: Port number to get statistics for.</span>
<span class="cm"> * @clear:    Set to 1 to clear the counters after they are read</span>
<span class="cm"> * @status:   Where to put the results.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_get_port_status</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">clear</span><span class="p">,</span>
					    <span class="n">cvmx_pip_port_status_t</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat_ctl</span> <span class="n">pip_stat_ctl</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat0_prtx</span> <span class="n">stat0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat1_prtx</span> <span class="n">stat1</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat2_prtx</span> <span class="n">stat2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat3_prtx</span> <span class="n">stat3</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat4_prtx</span> <span class="n">stat4</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat5_prtx</span> <span class="n">stat5</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat6_prtx</span> <span class="n">stat6</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat7_prtx</span> <span class="n">stat7</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat8_prtx</span> <span class="n">stat8</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat9_prtx</span> <span class="n">stat9</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat_inb_pktsx</span> <span class="n">pip_stat_inb_pktsx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat_inb_octsx</span> <span class="n">pip_stat_inb_octsx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_stat_inb_errsx</span> <span class="n">pip_stat_inb_errsx</span><span class="p">;</span>

	<span class="n">pip_stat_ctl</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pip_stat_ctl</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">rdclr</span> <span class="o">=</span> <span class="n">clear</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT_CTL</span><span class="p">,</span> <span class="n">pip_stat_ctl</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">stat0</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT0_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat1</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT1_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat2</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT2_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat3</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT3_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat4</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT4_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat5</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT5_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat6</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT6_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat7</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT7_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat8</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT8_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">stat9</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT9_PRTX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">pip_stat_inb_pktsx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span>
	    <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT_INB_PKTSX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">pip_stat_inb_octsx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span>
	    <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT_INB_OCTSX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>
	<span class="n">pip_stat_inb_errsx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span>
	    <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_STAT_INB_ERRSX</span><span class="p">(</span><span class="n">port_num</span><span class="p">));</span>

	<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_octets</span> <span class="o">=</span> <span class="n">stat0</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">drp_octs</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_packets</span> <span class="o">=</span> <span class="n">stat0</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">drp_pkts</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">octets</span> <span class="o">=</span> <span class="n">stat1</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">octs</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">pci_raw_packets</span> <span class="o">=</span> <span class="n">stat2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">raw</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">packets</span> <span class="o">=</span> <span class="n">stat2</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pkts</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">multicast_packets</span> <span class="o">=</span> <span class="n">stat3</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mcst</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">broadcast_packets</span> <span class="o">=</span> <span class="n">stat3</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">bcst</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_64_packets</span> <span class="o">=</span> <span class="n">stat4</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h64</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_65_127_packets</span> <span class="o">=</span> <span class="n">stat4</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h65to127</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_128_255_packets</span> <span class="o">=</span> <span class="n">stat5</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h128to255</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_256_511_packets</span> <span class="o">=</span> <span class="n">stat5</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h256to511</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_512_1023_packets</span> <span class="o">=</span> <span class="n">stat6</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h512to1023</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_1024_1518_packets</span> <span class="o">=</span> <span class="n">stat6</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h1024to1518</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">len_1519_max_packets</span> <span class="o">=</span> <span class="n">stat7</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">h1519</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">fcs_align_err_packets</span> <span class="o">=</span> <span class="n">stat7</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">fcs</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">runt_packets</span> <span class="o">=</span> <span class="n">stat8</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">undersz</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">runt_crc_packets</span> <span class="o">=</span> <span class="n">stat8</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">frag</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">oversize_packets</span> <span class="o">=</span> <span class="n">stat9</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">oversz</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">oversize_crc_packets</span> <span class="o">=</span> <span class="n">stat9</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">jabber</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_packets</span> <span class="o">=</span> <span class="n">pip_stat_inb_pktsx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">pkts</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_octets</span> <span class="o">=</span> <span class="n">pip_stat_inb_octsx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">octs</span><span class="p">;</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_errors</span> <span class="o">=</span> <span class="n">pip_stat_inb_errsx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">errs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cvmx_octeon_is_pass1</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Kludge to fix Octeon Pass 1 errata - Drop counts</span>
<span class="cm">		 * don&#39;t work.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_packets</span> <span class="o">&gt;</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">packets</span><span class="p">)</span>
			<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_packets</span> <span class="o">=</span>
			    <span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_packets</span> <span class="o">-</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">packets</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_octets</span> <span class="o">-</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_packets</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&gt;</span>
		    <span class="n">status</span><span class="o">-&gt;</span><span class="n">octets</span><span class="p">)</span>
			<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_octets</span> <span class="o">=</span>
			    <span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_octets</span> <span class="o">-</span> <span class="n">status</span><span class="o">-&gt;</span><span class="n">inb_packets</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">-</span>
			    <span class="n">status</span><span class="o">-&gt;</span><span class="n">octets</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span><span class="o">-&gt;</span><span class="n">dropped_octets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Configure the hardware CRC engine</span>
<span class="cm"> *</span>
<span class="cm"> * @interface: Interface to configure (0 or 1)</span>
<span class="cm"> * @invert_result:</span>
<span class="cm"> *                 Invert the result of the CRC</span>
<span class="cm"> * @reflect:  Reflect</span>
<span class="cm"> * @initialization_vector:</span>
<span class="cm"> *                 CRC initialization vector</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_config_crc</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">interface</span><span class="p">,</span>
				       <span class="kt">uint64_t</span> <span class="n">invert_result</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">reflect</span><span class="p">,</span>
				       <span class="kt">uint32_t</span> <span class="n">initialization_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN38XX</span><span class="p">)</span> <span class="o">||</span> <span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN58XX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pip_crc_ctlx</span> <span class="n">config</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">cvmx_pip_crc_ivx</span> <span class="n">pip_crc_ivx</span><span class="p">;</span>

		<span class="n">config</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">invres</span> <span class="o">=</span> <span class="n">invert_result</span><span class="p">;</span>
		<span class="n">config</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">reflect</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_CRC_CTLX</span><span class="p">(</span><span class="n">interface</span><span class="p">),</span> <span class="n">config</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

		<span class="n">pip_crc_ivx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pip_crc_ivx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">iv</span> <span class="o">=</span> <span class="n">initialization_vector</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_CRC_IVX</span><span class="p">(</span><span class="n">interface</span><span class="p">),</span> <span class="n">pip_crc_ivx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Clear all bits in a tag mask. This should be called on</span>
<span class="cm"> * startup before any calls to cvmx_pip_tag_mask_set. Each bit</span>
<span class="cm"> * set in the final mask represent a byte used in the packet for</span>
<span class="cm"> * tag generation.</span>
<span class="cm"> *</span>
<span class="cm"> * @mask_index: Which tag mask to clear (0..3)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_tag_mask_clear</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">mask_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pip_tag_incx</span> <span class="n">pip_tag_incx</span><span class="p">;</span>
	<span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">mask_index</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">mask_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_TAG_INCX</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Sets a range of bits in the tag mask. The tag mask is used</span>
<span class="cm"> * when the cvmx_pip_port_tag_cfg_t tag_mode is non zero.</span>
<span class="cm"> * There are four separate masks that can be configured.</span>
<span class="cm"> *</span>
<span class="cm"> * @mask_index: Which tag mask to modify (0..3)</span>
<span class="cm"> * @offset: Offset into the bitmask to set bits at. Use the GCC macro</span>
<span class="cm"> *          offsetof() to determine the offsets into packet headers.</span>
<span class="cm"> *          For example, offsetof(ethhdr, protocol) returns the offset</span>
<span class="cm"> *          of the ethernet protocol field.  The bitmask selects which</span>
<span class="cm"> *          bytes to include the the tag, with bit offset X selecting</span>
<span class="cm"> *          byte at offset X from the beginning of the packet data.</span>
<span class="cm"> * @len:    Number of bytes to include. Usually this is the sizeof()</span>
<span class="cm"> *          the field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pip_tag_mask_set</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">mask_index</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">,</span>
					 <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pip_tag_incx</span> <span class="n">pip_tag_incx</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">mask_index</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PIP_TAG_INCX</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
		<span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">en</span> <span class="o">|=</span> <span class="mh">0x80</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PIP_TAG_INCX</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">pip_tag_incx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/*  __CVMX_PIP_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
