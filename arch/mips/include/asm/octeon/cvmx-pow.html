<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › octeon › cvmx-pow.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cvmx-pow.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***********************license start***************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2008 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm"> ***********************license end**************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * Interface to the hardware Packet Order / Work unit.</span>
<span class="cm"> *</span>
<span class="cm"> * New, starting with SDK 1.7.0, cvmx-pow supports a number of</span>
<span class="cm"> * extended consistency checks. The define</span>
<span class="cm"> * CVMX_ENABLE_POW_CHECKS controls the runtime insertion of POW</span>
<span class="cm"> * internal state checks to find common programming errors. If</span>
<span class="cm"> * CVMX_ENABLE_POW_CHECKS is not defined, checks are by default</span>
<span class="cm"> * enabled. For example, cvmx-pow will check for the following</span>
<span class="cm"> * program errors or POW state inconsistency.</span>
<span class="cm"> * - Requesting a POW operation with an active tag switch in</span>
<span class="cm"> *   progress.</span>
<span class="cm"> * - Waiting for a tag switch to complete for an excessively</span>
<span class="cm"> *   long period. This is normally a sign of an error in locking</span>
<span class="cm"> *   causing deadlock.</span>
<span class="cm"> * - Illegal tag switches from NULL_NULL.</span>
<span class="cm"> * - Illegal tag switches from NULL.</span>
<span class="cm"> * - Illegal deschedule request.</span>
<span class="cm"> * - WQE pointer not matching the one attached to the core by</span>
<span class="cm"> *   the POW.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __CVMX_POW_H__</span>
<span class="cp">#define __CVMX_POW_H__</span>

<span class="cp">#include &lt;asm/octeon/cvmx-pow-defs.h&gt;</span>

<span class="cp">#include &quot;cvmx-scratch.h&quot;</span>
<span class="cp">#include &quot;cvmx-wqe.h&quot;</span>

<span class="cm">/* Default to having all POW constancy checks turned on */</span>
<span class="cp">#ifndef CVMX_ENABLE_POW_CHECKS</span>
<span class="cp">#define CVMX_ENABLE_POW_CHECKS 1</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="p">{</span>
	<span class="cm">/* Tag ordering is maintained */</span>
	<span class="n">CVMX_POW_TAG_TYPE_ORDERED</span>   <span class="o">=</span> <span class="mi">0L</span><span class="p">,</span>
	<span class="cm">/* Tag ordering is maintained, and at most one PP has the tag */</span>
	<span class="n">CVMX_POW_TAG_TYPE_ATOMIC</span>    <span class="o">=</span> <span class="mi">1L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * The work queue entry from the order - NEVER tag switch from</span>
<span class="cm">	 * NULL to NULL</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_TYPE_NULL</span>      <span class="o">=</span> <span class="mi">2L</span><span class="p">,</span>
	<span class="cm">/* A tag switch to NULL, and there is no space reserved in POW</span>
<span class="cm">	 * - NEVER tag switch to NULL_NULL</span>
<span class="cm">	 * - NEVER tag switch from NULL_NULL</span>
<span class="cm">	 * - NULL_NULL is entered at the beginning of time and on a deschedule.</span>
<span class="cm">	 * - NULL_NULL can be exited by a new work request. A NULL_SWITCH</span>
<span class="cm">	 * load can also switch the state to NULL</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span> <span class="o">=</span> <span class="mi">3L</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Wait flag values for pow functions.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">CVMX_POW_WAIT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CVMX_POW_NO_WAIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">}</span> <span class="n">cvmx_pow_wait_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *  POW tag operations.  These are used in the data stored to the POW.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * switch the tag (only) for this PP</span>
<span class="cm">	 * - the previous tag should be non-NULL in this case</span>
<span class="cm">	 * - tag switch response required</span>
<span class="cm">	 * - fields used: op, type, tag</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_SWTAG</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * switch the tag for this PP, with full information</span>
<span class="cm">	 * - this should be used when the previous tag is NULL</span>
<span class="cm">	 * - tag switch response required</span>
<span class="cm">	 * - fields used: address, op, grp, type, tag</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_SWTAG_FULL</span> <span class="o">=</span> <span class="mi">1L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * switch the tag (and/or group) for this PP and de-schedule</span>
<span class="cm">	 * - OK to keep the tag the same and only change the group</span>
<span class="cm">	 * - fields used: op, no_sched, grp, type, tag</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_SWTAG_DESCH</span> <span class="o">=</span> <span class="mi">2L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * just de-schedule</span>
<span class="cm">	 * - fields used: op, no_sched</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_DESCH</span> <span class="o">=</span> <span class="mi">3L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * create an entirely new work queue entry</span>
<span class="cm">	 * - fields used: address, op, qos, grp, type, tag</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_ADDWQ</span> <span class="o">=</span> <span class="mi">4L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * just update the work queue pointer and grp for this PP</span>
<span class="cm">	 * - fields used: address, op, grp</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_UPDATE_WQP_GRP</span> <span class="o">=</span> <span class="mi">5L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * set the no_sched bit on the de-schedule list</span>
<span class="cm">	 *</span>
<span class="cm">	 * - does nothing if the selected entry is not on the</span>
<span class="cm">	 *   de-schedule list</span>
<span class="cm">	 *</span>
<span class="cm">	 * - does nothing if the stored work queue pointer does not</span>
<span class="cm">	 *   match the address field</span>
<span class="cm">	 *</span>
<span class="cm">	 * - fields used: address, index, op</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Before issuing a *_NSCHED operation, SW must guarantee</span>
<span class="cm">	 *  that all prior deschedules and set/clr NSCHED operations</span>
<span class="cm">	 *  are complete and all prior switches are complete. The</span>
<span class="cm">	 *  hardware provides the opsdone bit and swdone bit for SW</span>
<span class="cm">	 *  polling. After issuing a *_NSCHED operation, SW must</span>
<span class="cm">	 *  guarantee that the set/clr NSCHED is complete before any</span>
<span class="cm">	 *  subsequent operations.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_SET_NSCHED</span> <span class="o">=</span> <span class="mi">6L</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * clears the no_sched bit on the de-schedule list</span>
<span class="cm">	 *</span>
<span class="cm">	 * - does nothing if the selected entry is not on the</span>
<span class="cm">	 *   de-schedule list</span>
<span class="cm">	 *</span>
<span class="cm">	 * - does nothing if the stored work queue pointer does not</span>
<span class="cm">	 *   match the address field</span>
<span class="cm">	 *</span>
<span class="cm">	 * - fields used: address, index, op</span>
<span class="cm">	 *</span>
<span class="cm">	 * Before issuing a *_NSCHED operation, SW must guarantee that</span>
<span class="cm">	 * all prior deschedules and set/clr NSCHED operations are</span>
<span class="cm">	 * complete and all prior switches are complete. The hardware</span>
<span class="cm">	 * provides the opsdone bit and swdone bit for SW</span>
<span class="cm">	 * polling. After issuing a *_NSCHED operation, SW must</span>
<span class="cm">	 * guarantee that the set/clr NSCHED is complete before any</span>
<span class="cm">	 * subsequent operations.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_POW_TAG_OP_CLR_NSCHED</span> <span class="o">=</span> <span class="mi">7L</span><span class="p">,</span>
	<span class="cm">/* do nothing */</span>
	<span class="n">CVMX_POW_TAG_OP_NOP</span> <span class="o">=</span> <span class="mi">15L</span>
<span class="p">}</span> <span class="n">cvmx_pow_tag_op_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This structure defines the store data on a store to POW</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t reschedule this entry. no_sched is used for</span>
<span class="cm">		 * CVMX_POW_TAG_OP_SWTAG_DESCH and</span>
<span class="cm">		 * CVMX_POW_TAG_OP_DESCH</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">no_sched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">unused</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Tontains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* The operation to perform */</span>
		<span class="n">cvmx_pow_tag_op_t</span> <span class="n">op</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">unused2</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The QOS level for the packet. qos is only used for</span>
<span class="cm">		 * CVMX_POW_TAG_OP_ADDWQ</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">qos</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The group that the work queue entry will be</span>
<span class="cm">		 * scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ,</span>
<span class="cm">		 * CVMX_POW_TAG_OP_SWTAG_FULL,</span>
<span class="cm">		 * CVMX_POW_TAG_OP_SWTAG_DESCH, and</span>
<span class="cm">		 * CVMX_POW_TAG_OP_UPDATE_WQP_GRP</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The type of the tag. type is used for everything</span>
<span class="cm">		 * except CVMX_POW_TAG_OP_DESCH,</span>
<span class="cm">		 * CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and</span>
<span class="cm">		 * CVMX_POW_TAG_OP_*_NSCHED</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The actual tag. tag is used for everything except</span>
<span class="cm">		 * CVMX_POW_TAG_OP_DESCH,</span>
<span class="cm">		 * CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and</span>
<span class="cm">		 * CVMX_POW_TAG_OP_*_NSCHED</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pow_tag_req_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This structure describes the address to load stuff from POW</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Address for new work request loads (did&lt;2:0&gt; == 0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Mips64 address region. Should be CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_region</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the ID of POW -- did&lt;2:0&gt; == 0 in this case */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_4_39</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, don&#39;t return load response until work is</span>
<span class="cm">		 * available.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">wait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_0_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">swork</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Address for loads to get POW internal status</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Mips64 address region. Should be CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_region</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the ID of POW -- did&lt;2:0&gt; == 1 in this case */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_10_39</span><span class="o">:</span><span class="mi">30</span><span class="p">;</span>
		<span class="cm">/* The core id to get status for */</span>
		<span class="kt">uint64_t</span> <span class="n">coreid</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set and get_cur is set, return reverse tag-list</span>
<span class="cm">		 * pointer rather than forward tag-list pointer.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_rev</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, return current status rather than pending</span>
<span class="cm">		 * status.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_cur</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, get the work-queue pointer rather than</span>
<span class="cm">		 * tag/type.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_wqp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_0_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sstatus</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Address for memory loads to get POW internal state</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Mips64 address region. Should be CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_region</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the ID of POW -- did&lt;2:0&gt; == 2 in this case */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_16_39</span><span class="o">:</span><span class="mi">24</span><span class="p">;</span>
		<span class="cm">/* POW memory index */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, return deschedule information rather than</span>
<span class="cm">		 * the standard response for work-queue index (invalid</span>
<span class="cm">		 * if the work-queue entry is not on the deschedule</span>
<span class="cm">		 * list).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_des</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, get the work-queue pointer rather than</span>
<span class="cm">		 * tag/type (no effect when get_des set).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_wqp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_0_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">smemload</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Address for index/pointer loads</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Mips64 address region. Should be CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_region</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the ID of POW -- did&lt;2:0&gt; == 3 in this case */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_9_39</span><span class="o">:</span><span class="mi">31</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when {get_rmt ==0 AND get_des_get_tail == 0}, this</span>
<span class="cm">		 * field selects one of eight POW internal-input</span>
<span class="cm">		 * queues (0-7), one per QOS level; values 8-15 are</span>
<span class="cm">		 * illegal in this case; when {get_rmt ==0 AND</span>
<span class="cm">		 * get_des_get_tail == 1}, this field selects one of</span>
<span class="cm">		 * 16 deschedule lists (per group); when get_rmt ==1,</span>
<span class="cm">		 * this field selects one of 16 memory-input queue</span>
<span class="cm">		 * lists.  The two memory-input queue lists associated</span>
<span class="cm">		 * with each QOS level are:</span>
<span class="cm">		 *</span>
<span class="cm">		 * - qosgrp = 0, qosgrp = 8:      QOS0</span>
<span class="cm">		 * - qosgrp = 1, qosgrp = 9:      QOS1</span>
<span class="cm">		 * - qosgrp = 2, qosgrp = 10:     QOS2</span>
<span class="cm">		 * - qosgrp = 3, qosgrp = 11:     QOS3</span>
<span class="cm">		 * - qosgrp = 4, qosgrp = 12:     QOS4</span>
<span class="cm">		 * - qosgrp = 5, qosgrp = 13:     QOS5</span>
<span class="cm">		 * - qosgrp = 6, qosgrp = 14:     QOS6</span>
<span class="cm">		 * - qosgrp = 7, qosgrp = 15:     QOS7</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">qosgrp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set and get_rmt is clear, return deschedule list</span>
<span class="cm">		 * indexes rather than indexes for the specified qos</span>
<span class="cm">		 * level; if set and get_rmt is set, return the tail</span>
<span class="cm">		 * pointer rather than the head pointer for the</span>
<span class="cm">		 * specified qos level.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_des_get_tail</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, return remote pointers rather than the</span>
<span class="cm">		 * local indexes for the specified qos level.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">get_rmt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_0_2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sindexload</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * address for NULL_RD request (did&lt;2:0&gt; == 4) when this is read,</span>
<span class="cm">     * HW attempts to change the state to NULL if it is NULL_NULL (the</span>
<span class="cm">     * hardware cannot switch from NULL_NULL to NULL if a POW entry is</span>
<span class="cm">     * not available - software may need to recover by finishing</span>
<span class="cm">     * another piece of work before a POW entry can ever become</span>
<span class="cm">     * available.)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Mips64 address region. Should be CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_region</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* the ID of POW -- did&lt;2:0&gt; == 4 in this case */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_0_39</span><span class="o">:</span><span class="mi">40</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">snull_rd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pow_load_addr_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This structure defines the response to a load/SENDSINGLE to POW</span>
<span class="cm"> * (except CSR reads)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Response to new work request loads</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when no new work queue entry was returned.  *</span>
<span class="cm">		 * If there was de-scheduled work, the HW will</span>
<span class="cm">		 * definitely return it. When this bit is set, it</span>
<span class="cm">		 * could mean either mean:</span>
<span class="cm">		 *</span>
<span class="cm">		 * - There was no work, or</span>
<span class="cm">		 *</span>
<span class="cm">		 * - There was no work that the HW could find. This</span>
<span class="cm">		 *   case can happen, regardless of the wait bit value</span>
<span class="cm">		 *   in the original request, when there is work in</span>
<span class="cm">		 *   the IQ&#39;s that is too deep down the list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">no_work</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_40_62</span><span class="o">:</span><span class="mi">23</span><span class="p">;</span>
		<span class="cm">/* 36 in O1 -- the work queue pointer */</span>
		<span class="kt">uint64_t</span> <span class="n">addr</span><span class="o">:</span><span class="mi">40</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_work</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==0 and get_wqp==0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending non-NULL SWTAG or</span>
<span class="cm">		 * SWTAG_FULL, and the POW entry has not left the list</span>
<span class="cm">		 * for the original tag. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when SWTAG_FULL and pend_switch is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch_full</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending NULL SWTAG, or an</span>
<span class="cm">		 * implicit switch to NULL.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch_null</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending DESCHED or SWTAG_DESCHED. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_desched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending SWTAG_DESCHED and</span>
<span class="cm">		 * pend_desched is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_desched_switch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when nosched is desired and pend_desched is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_nosched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending GET_WORK. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_new_work</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When pend_new_work is set, this bit indicates that</span>
<span class="cm">		 * the wait bit was set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_new_work_wait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending NULL_RD. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_null_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending CLR_NSCHED. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_nosched_clr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_51</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* This is the index when pend_nosched_clr is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is the new_grp when (pend_desched AND</span>
<span class="cm">		 * pend_desched_switch) is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_34_35</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is the tag type when pend_switch or</span>
<span class="cm">		 * (pend_desched AND pend_desched_switch) are set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * - this is the tag when pend_switch or (pend_desched</span>
<span class="cm">		 *    AND pend_desched_switch) are set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==0 and get_wqp==1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending non-NULL SWTAG or</span>
<span class="cm">		 * SWTAG_FULL, and the POW entry has not left the list</span>
<span class="cm">		 * for the original tag.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when SWTAG_FULL and pend_switch is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch_full</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending NULL SWTAG, or an</span>
<span class="cm">		 * implicit switch to NULL.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch_null</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending DESCHED or</span>
<span class="cm">		 * SWTAG_DESCHED.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_desched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when there is a pending SWTAG_DESCHED and</span>
<span class="cm">		 * pend_desched is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_desched_switch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when nosched is desired and pend_desched is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_nosched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending GET_WORK. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_new_work</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When pend_new_work is set, this bit indicates that</span>
<span class="cm">		 * the wait bit was set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_new_work_wait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending NULL_RD. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_null_rd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Set when there is a pending CLR_NSCHED. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_nosched_clr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_51</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* This is the index when pend_nosched_clr is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is the new_grp when (pend_desched AND</span>
<span class="cm">		 * pend_desched_switch) is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* This is the wqp when pend_nosched_clr is set. */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_wqp</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus1</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==1, get_wqp==0, and</span>
<span class="cm">     * get_rev==0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Points to the next POW entry in the tag list when</span>
<span class="cm">		 * tail == 0 (and tag_type is not NULL or NULL_NULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">link_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The POW entry attached to the core. */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The group attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when this POW entry is at the head of its tag</span>
<span class="cm">		 * list (also set when in the NULL or NULL_NULL</span>
<span class="cm">		 * state).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">head</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when this POW entry is at the tail of its tag</span>
<span class="cm">		 * list (also set when in the NULL or NULL_NULL</span>
<span class="cm">		 * state).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tail</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The tag type attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG, SWTAG_FULL, or</span>
<span class="cm">		 * SWTAG_DESCHED).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tag_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The tag attached to the core (updated when new tag</span>
<span class="cm">		 * list entered on SWTAG, SWTAG_FULL, or</span>
<span class="cm">		 * SWTAG_DESCHED).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus2</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Points to the prior POW entry in the tag list when</span>
<span class="cm">		 * head == 0 (and tag_type is not NULL or</span>
<span class="cm">		 * NULL_NULL). This field is unpredictable when the</span>
<span class="cm">		 * core&#39;s state is NULL or NULL_NULL.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">revlink_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The POW entry attached to the core. */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The group attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* Set when this POW entry is at the head of its tag</span>
<span class="cm">		 * list (also set when in the NULL or NULL_NULL</span>
<span class="cm">		 * state).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">head</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when this POW entry is at the tail of its tag</span>
<span class="cm">		 * list (also set when in the NULL or NULL_NULL</span>
<span class="cm">		 * state).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tail</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The tag type attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG, SWTAG_FULL, or</span>
<span class="cm">		 * SWTAG_DESCHED).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tag_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The tag attached to the core (updated when new tag</span>
<span class="cm">		 * list entered on SWTAG, SWTAG_FULL, or</span>
<span class="cm">		 * SWTAG_DESCHED).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus3</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==1, get_wqp==1, and</span>
<span class="cm">     * get_rev==0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Points to the next POW entry in the tag list when</span>
<span class="cm">		 * tail == 0 (and tag_type is not NULL or NULL_NULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">link_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The POW entry attached to the core. */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The group attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The wqp attached to the core (updated when new tag</span>
<span class="cm">		 * list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">wqp</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus4</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result for a POW Status Load (when get_cur==1, get_wqp==1, and</span>
<span class="cm">     * get_rev==1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_62_63</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Points to the prior POW entry in the tag list when</span>
<span class="cm">		 * head == 0 (and tag_type is not NULL or</span>
<span class="cm">		 * NULL_NULL). This field is unpredictable when the</span>
<span class="cm">		 * core&#39;s state is NULL or NULL_NULL.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">revlink_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The POW entry attached to the core. */</span>
		<span class="kt">uint64_t</span> <span class="n">index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The group attached to the core (updated when new</span>
<span class="cm">		 * tag list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The wqp attached to the core (updated when new tag</span>
<span class="cm">		 * list entered on SWTAG_FULL).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">wqp</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_sstatus5</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Memory Load (get_des == 0 and get_wqp == 0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_51_63</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The next entry in the input, free, descheduled_head</span>
<span class="cm">		 * list (unpredictable if entry is the tail of the</span>
<span class="cm">		 * list).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">next_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The group of the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_35</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when this POW entry is at the tail of its tag</span>
<span class="cm">		 * list (also set when in the NULL or NULL_NULL</span>
<span class="cm">		 * state).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">tail</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The tag type of the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">tag_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* The tag of the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_smemload0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Memory Load (get_des == 0 and get_wqp == 1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_51_63</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The next entry in the input, free, descheduled_head</span>
<span class="cm">		 * list (unpredictable if entry is the tail of the</span>
<span class="cm">		 * list).</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">next_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The group of the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* The WQP held in the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">wqp</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_smemload1</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Memory Load (get_des == 1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_51_63</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The next entry in the tag list connected to the</span>
<span class="cm">		 * descheduled head.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">fwd_index</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* The group of the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">grp</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* The nosched bit for the POW entry. */</span>
		<span class="kt">uint64_t</span> <span class="n">nosched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* There is a pending tag switch */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_switch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The next tag type for the new tag list when</span>
<span class="cm">		 * pend_switch is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The next tag for the new tag list when pend_switch</span>
<span class="cm">		 * is set.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">pend_tag</span><span class="o">:</span><span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_smemload2</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_52_63</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is one or more POW entries on the</span>
<span class="cm">		 * free list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">free_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is exactly one POW entry on the free</span>
<span class="cm">		 * list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">free_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when free_val is set, indicates the first entry on</span>
<span class="cm">		 * the free list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">free_head</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_37</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when free_val is set, indicates the last entry on</span>
<span class="cm">		 * the free list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">free_tail</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is one or more POW entries on the</span>
<span class="cm">		 * input Q list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">loc_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is exactly one POW entry on the</span>
<span class="cm">		 * input Q list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">loc_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_23</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when loc_val is set, indicates the first entry on</span>
<span class="cm">		 * the input Q list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">loc_head</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_11</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when loc_val is set, indicates the last entry on</span>
<span class="cm">		 * the input Q list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">loc_tail</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sindexload0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_52_63</span><span class="o">:</span><span class="mi">12</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is one or more POW entries on the</span>
<span class="cm">		 * nosched list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">nosched_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is exactly one POW entry on the</span>
<span class="cm">		 * nosched list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">nosched_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when nosched_val is set, indicates the first entry</span>
<span class="cm">		 * on the nosched list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">nosched_head</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_37</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when nosched_val is set, indicates the last entry</span>
<span class="cm">		 * on the nosched list.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">nosched_tail</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is one or more descheduled heads on</span>
<span class="cm">		 * the descheduled list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">des_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when there is exactly one descheduled head on</span>
<span class="cm">		 * the descheduled list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">des_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_23</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when des_val is set, indicates the first</span>
<span class="cm">		 * descheduled head on the descheduled list selected</span>
<span class="cm">		 * by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">des_head</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_11</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when des_val is set, indicates the last descheduled</span>
<span class="cm">		 * head on the descheduled list selected by qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">des_tail</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sindexload1</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 0)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_39_63</span><span class="o">:</span><span class="mi">25</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when this DRAM list is the current head</span>
<span class="cm">		 * (i.e. is the next to be reloaded when the POW</span>
<span class="cm">		 * hardware reloads a POW entry from DRAM). The POW</span>
<span class="cm">		 * hardware alternates between the two DRAM lists</span>
<span class="cm">		 * associated with a QOS level when it reloads work</span>
<span class="cm">		 * from DRAM into the POW unit.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_is_head</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when the DRAM portion of the input Q list</span>
<span class="cm">		 * selected by qosgrp contains one or more pieces of</span>
<span class="cm">		 * work.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set when the DRAM portion of the input Q list</span>
<span class="cm">		 * selected by qosgrp contains exactly one piece of</span>
<span class="cm">		 * work.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When rmt_val is set, indicates the first piece of</span>
<span class="cm">		 * work on the DRAM input Q list selected by</span>
<span class="cm">		 * qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_head</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sindexload2</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Result For POW Index/Pointer Load (get_rmt ==</span>
<span class="cm">     * 1/get_des_get_tail == 1)</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_39_63</span><span class="o">:</span><span class="mi">25</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when this DRAM list is the current head</span>
<span class="cm">		 * (i.e. is the next to be reloaded when the POW</span>
<span class="cm">		 * hardware reloads a POW entry from DRAM). The POW</span>
<span class="cm">		 * hardware alternates between the two DRAM lists</span>
<span class="cm">		 * associated with a QOS level when it reloads work</span>
<span class="cm">		 * from DRAM into the POW unit.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_is_head</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when the DRAM portion of the input Q list</span>
<span class="cm">		 * selected by qosgrp contains one or more pieces of</span>
<span class="cm">		 * work.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_val</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set when the DRAM portion of the input Q list</span>
<span class="cm">		 * selected by qosgrp contains exactly one piece of</span>
<span class="cm">		 * work.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_one</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * when rmt_val is set, indicates the last piece of</span>
<span class="cm">		 * work on the DRAM input Q list selected by</span>
<span class="cm">		 * qosgrp.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">rmt_tail</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sindexload3</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Response to NULL_RD request loads</span>
<span class="cm">     */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint64_t</span> <span class="n">unused</span><span class="o">:</span><span class="mi">62</span><span class="p">;</span>
		<span class="cm">/* of type cvmx_pow_tag_type_t. state is one of the</span>
<span class="cm">		 * following:</span>
<span class="cm">		 *</span>
<span class="cm">		 * - CVMX_POW_TAG_TYPE_ORDERED</span>
<span class="cm">		 * - CVMX_POW_TAG_TYPE_ATOMIC</span>
<span class="cm">		 * - CVMX_POW_TAG_TYPE_NULL</span>
<span class="cm">		 * - CVMX_POW_TAG_TYPE_NULL_NULL</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">state</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s_null_rd</span><span class="p">;</span>

<span class="p">}</span> <span class="n">cvmx_pow_tag_load_resp_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This structure describes the address used for stores to the POW.</span>
<span class="cm"> *  The store address is meaningful on stores to the POW.  The</span>
<span class="cm"> *  hardware assumes that an aligned 64-bit store was used for all</span>
<span class="cm"> *  these stores.  Note the assumption that the work queue entry is</span>
<span class="cm"> *  aligned on an 8-byte boundary (since the low-order 3 address bits</span>
<span class="cm"> *  must be zero).  Note that not all fields are used by all</span>
<span class="cm"> *  operations.</span>
<span class="cm"> *</span>
<span class="cm"> *  NOTE: The following is the behavior of the pending switch bit at the PP</span>
<span class="cm"> *       for POW stores (i.e. when did&lt;7:3&gt; == 0xc)</span>
<span class="cm"> *     - did&lt;2:0&gt; == 0      =&gt; pending switch bit is set</span>
<span class="cm"> *     - did&lt;2:0&gt; == 1      =&gt; no affect on the pending switch bit</span>
<span class="cm"> *     - did&lt;2:0&gt; == 3      =&gt; pending switch bit is cleared</span>
<span class="cm"> *     - did&lt;2:0&gt; == 7      =&gt; no affect on the pending switch bit</span>
<span class="cm"> *     - did&lt;2:0&gt; == others =&gt; must not be used</span>
<span class="cm"> *     - No other loads/stores have an affect on the pending switch bit</span>
<span class="cm"> *     - The switch bus from POW can clear the pending switch bit</span>
<span class="cm"> *</span>
<span class="cm"> *  NOTE: did&lt;2:0&gt; == 2 is used by the HW for a special single-cycle</span>
<span class="cm"> *  ADDWQ command that only contains the pointer). SW must never use</span>
<span class="cm"> *  did&lt;2:0&gt; == 2.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Unsigned 64 bit integer representation of store address</span>
<span class="cm">     */</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Memory region.  Should be CVMX_IO_SEG in most cases */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_reg</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_49_61</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Must be one */</span>
		<span class="cm">/* Device ID of POW.  Note that different sub-dids are used. */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">reserved_36_39</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* Must be zero */</span>
		<span class="cm">/* Address field. addr&lt;2:0&gt; must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">addr</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stag</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pow_tag_store_addr_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * decode of the store data when an IOBDMA SENDSINGLE is sent to POW</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the (64-bit word) location in scratchpad to write</span>
<span class="cm">		 * to (if len != 0)</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">scraddr</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* the number of words in the response (0 =&gt; no response) */</span>
		<span class="kt">uint64_t</span> <span class="n">len</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* the ID of the device on the non-coherent bus */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">unused</span><span class="o">:</span><span class="mi">36</span><span class="p">;</span>
		<span class="cm">/* if set, don&#39;t return load response until work is available */</span>
		<span class="kt">uint64_t</span> <span class="n">wait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">unused2</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>

<span class="p">}</span> <span class="n">cvmx_pow_iobdma_store_t</span><span class="p">;</span>

<span class="cm">/* CSR typedefs have been moved to cvmx-csr-*.h */</span>

<span class="cm">/**</span>
<span class="cm"> * Get the POW tag for this core. This returns the current</span>
<span class="cm"> * tag type, tag, group, and POW entry index associated with</span>
<span class="cm"> * this core. Index is only valid if the tag type isn&#39;t NULL_NULL.</span>
<span class="cm"> * If a tag switch is pending this routine returns the tag before</span>
<span class="cm"> * the tag switch, not after.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Current tag</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_pow_tag_req_t</span> <span class="nf">cvmx_pow_get_current_tag</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_load_addr_t</span> <span class="n">load_addr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_load_resp_t</span> <span class="n">load_resp</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">load_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG1</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">get_cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_resp</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">load_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">result</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="n">load_resp</span><span class="p">.</span><span class="n">s_sstatus2</span><span class="p">.</span><span class="n">grp</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">load_resp</span><span class="p">.</span><span class="n">s_sstatus2</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">load_resp</span><span class="p">.</span><span class="n">s_sstatus2</span><span class="p">.</span><span class="n">tag_type</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">load_resp</span><span class="p">.</span><span class="n">s_sstatus2</span><span class="p">.</span><span class="n">tag</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the POW WQE for this core. This returns the work queue</span>
<span class="cm"> * entry currently associated with this core.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns WQE pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="nf">cvmx_pow_get_current_wqp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_load_addr_t</span> <span class="n">load_addr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_load_resp_t</span> <span class="n">load_resp</span><span class="p">;</span>

	<span class="n">load_addr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG1</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">coreid</span> <span class="o">=</span> <span class="n">cvmx_get_core_num</span><span class="p">();</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">get_cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_addr</span><span class="p">.</span><span class="n">sstatus</span><span class="p">.</span><span class="n">get_wqp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_resp</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">load_addr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">load_resp</span><span class="p">.</span><span class="n">s_sstatus4</span><span class="p">.</span><span class="n">wqp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CVMX_MF_CHORD</span>
<span class="cp">#define CVMX_MF_CHORD(dest)         CVMX_RDHWR(dest, 30)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Print a warning if a tag switch is pending for this core</span>
<span class="cm"> *</span>
<span class="cm"> * @function: Function name checking for a pending tag switch</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">switch_complete</span><span class="p">;</span>
	<span class="n">CVMX_MF_CHORD</span><span class="p">(</span><span class="n">switch_complete</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">switch_complete</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with tag switch in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Waits for a tag switch to complete by polling the completion bit.</span>
<span class="cm"> * Note that switches to NULL complete immediately and do not need</span>
<span class="cm"> * to be waited for.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">MAX_CYCLES</span> <span class="o">=</span> <span class="mi">1ull</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">switch_complete</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">start_cycle</span> <span class="o">=</span> <span class="n">cvmx_get_cycle</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CVMX_MF_CHORD</span><span class="p">(</span><span class="n">switch_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">switch_complete</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cvmx_get_cycle</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">start_cycle</span> <span class="o">+</span> <span class="n">MAX_CYCLES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Tag switch is taking a long time, &quot;</span>
				   <span class="s">&quot;possible deadlock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">start_cycle</span> <span class="o">=</span> <span class="o">-</span><span class="n">MAX_CYCLES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Synchronous work request.  Requests work from the POW.</span>
<span class="cm"> * This function does NOT wait for previous tag switches to complete,</span>
<span class="cm"> * so the caller must ensure that there is not a pending tag switch.</span>
<span class="cm"> *</span>
<span class="cm"> * @wait:   When set, call stalls until work becomes avaiable, or times out.</span>
<span class="cm"> *               If not set, returns immediately.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Returns the WQE pointer from POW. Returns NULL if no work</span>
<span class="cm"> * was available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="nf">cvmx_pow_work_request_sync_nocheck</span><span class="p">(</span><span class="n">cvmx_pow_wait_t</span>
							     <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_load_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_load_resp_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">swork</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">swork</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">swork</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_SWTAG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">swork</span><span class="p">.</span><span class="n">wait</span> <span class="o">=</span> <span class="n">wait</span><span class="p">;</span>

	<span class="n">result</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">s_work</span><span class="p">.</span><span class="n">no_work</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">s_work</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Synchronous work request.  Requests work from the POW.</span>
<span class="cm"> * This function waits for any previous tag switch to complete before</span>
<span class="cm"> * requesting the new work.</span>
<span class="cm"> *</span>
<span class="cm"> * @wait:   When set, call stalls until work becomes avaiable, or times out.</span>
<span class="cm"> *               If not set, returns immediately.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Returns the WQE pointer from POW. Returns NULL if no work</span>
<span class="cm"> * was available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="nf">cvmx_pow_work_request_sync</span><span class="p">(</span><span class="n">cvmx_pow_wait_t</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Must not have a switch pending when requesting work */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">cvmx_pow_work_request_sync_nocheck</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Synchronous null_rd request.  Requests a switch out of NULL_NULL POW state.</span>
<span class="cm"> * This function waits for any previous tag switch to complete before</span>
<span class="cm"> * requesting the null_rd.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Returns the POW state of type cvmx_pow_tag_type_t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="nf">cvmx_pow_work_request_null_rd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_load_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_load_resp_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Must not have a switch pending when requesting work */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">snull_rd</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">snull_rd</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">snull_rd</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_NULL_RD</span><span class="p">;</span>

	<span class="n">result</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">s_null_rd</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Asynchronous work request.  Work is requested from the POW unit,</span>
<span class="cm"> * and should later be checked with function</span>
<span class="cm"> * cvmx_pow_work_response_async.  This function does NOT wait for</span>
<span class="cm"> * previous tag switches to complete, so the caller must ensure that</span>
<span class="cm"> * there is not a pending tag switch.</span>
<span class="cm"> *</span>
<span class="cm"> * @scr_addr: Scratch memory address that response will be returned</span>
<span class="cm"> *            to, which is either a valid WQE, or a response with the</span>
<span class="cm"> *            invalid bit set.  Byte address, must be 8 byte aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * @wait: 1 to cause response to wait for work to become available (or</span>
<span class="cm"> *        timeout), 0 to cause response to return immediately</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_work_request_async_nocheck</span><span class="p">(</span><span class="kt">int</span> <span class="n">scr_addr</span><span class="p">,</span>
						       <span class="n">cvmx_pow_wait_t</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_iobdma_store_t</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* scr_addr must be 8 byte aligned */</span>
	<span class="n">data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">scraddr</span> <span class="o">=</span> <span class="n">scr_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_SWTAG</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">wait</span> <span class="o">=</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">cvmx_send_single</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Asynchronous work request.  Work is requested from the POW unit,</span>
<span class="cm"> * and should later be checked with function</span>
<span class="cm"> * cvmx_pow_work_response_async.  This function waits for any previous</span>
<span class="cm"> * tag switch to complete before requesting the new work.</span>
<span class="cm"> *</span>
<span class="cm"> * @scr_addr: Scratch memory address that response will be returned</span>
<span class="cm"> *            to, which is either a valid WQE, or a response with the</span>
<span class="cm"> *            invalid bit set.  Byte address, must be 8 byte aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * @wait: 1 to cause response to wait for work to become available (or</span>
<span class="cm"> *                  timeout), 0 to cause response to return immediately</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_work_request_async</span><span class="p">(</span><span class="kt">int</span> <span class="n">scr_addr</span><span class="p">,</span>
					       <span class="n">cvmx_pow_wait_t</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Must not have a switch pending when requesting work */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">cvmx_pow_work_request_async_nocheck</span><span class="p">(</span><span class="n">scr_addr</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Gets result of asynchronous work request.  Performs a IOBDMA sync</span>
<span class="cm"> * to wait for the response.</span>
<span class="cm"> *</span>
<span class="cm"> * @scr_addr: Scratch memory address to get result from Byte address,</span>
<span class="cm"> *            must be 8 byte aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Returns the WQE from the scratch register, or NULL if no</span>
<span class="cm"> * work was available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="nf">cvmx_pow_work_response_async</span><span class="p">(</span><span class="kt">int</span> <span class="n">scr_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pow_tag_load_resp_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">CVMX_SYNCIOBDMA</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_scratch_read64</span><span class="p">(</span><span class="n">scr_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">s_work</span><span class="p">.</span><span class="n">no_work</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">s_work</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Checks if a work queue entry pointer returned by a work</span>
<span class="cm"> * request is valid.  It may be invalid due to no work</span>
<span class="cm"> * being available or due to a timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * @wqe_ptr: pointer to a work queue entry returned by the POW</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if pointer is valid</span>
<span class="cm"> *         1 if invalid (no work was returned)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">cvmx_pow_work_invalid</span><span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">wqe_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wqe_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Starts a tag switch to the provided tag value and tag type.</span>
<span class="cm"> * Completion for the tag switch must be checked for separately.  This</span>
<span class="cm"> * function does NOT update the work queue entry in dram to match tag</span>
<span class="cm"> * value and type, so the application must keep track of these if they</span>
<span class="cm"> * are important to the application.  This tag switch command must not</span>
<span class="cm"> * be used for switches to NULL, as the tag switch pending bit will be</span>
<span class="cm"> * set by the switch request, but never cleared by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This should not be used when switching from a NULL tag.  Use</span>
<span class="cm"> * cvmx_pow_tag_sw_full() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does no checks, so the caller must ensure that any</span>
<span class="cm"> * previous tag switch has completed.</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:      new tag value</span>
<span class="cm"> * @tag_type: new tag type (ordered or atomic)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_nocheck</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_tag_req_t</span> <span class="n">current_tag</span><span class="p">;</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
		<span class="n">current_tag</span> <span class="o">=</span> <span class="n">cvmx_pow_get_current_tag</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL_NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">tag_type</span><span class="p">)</span>
		   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">))</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called to perform a tag switch to the &quot;</span>
				   <span class="s">&quot;same tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag_type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called to perform a tag switch to &quot;</span>
				   <span class="s">&quot;NULL. Use cvmx_pow_tag_sw_null() instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that WQE in DRAM is not updated here, as the POW does</span>
<span class="cm">	 * not read from DRAM once the WQE is in flight.  See hardware</span>
<span class="cm">	 * manual for complete details.  It is the application&#39;s</span>
<span class="cm">	 * responsibility to keep track of the current tag value if</span>
<span class="cm">	 * that is important.</span>
<span class="cm">	 */</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_SWTAG</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tag_type</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_SWTAG</span><span class="p">;</span>

	<span class="cm">/* once this store arrives at POW, it will attempt the switch</span>
<span class="cm">	   software must wait for the switch to complete separately */</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Starts a tag switch to the provided tag value and tag type.</span>
<span class="cm"> * Completion for the tag switch must be checked for separately.  This</span>
<span class="cm"> * function does NOT update the work queue entry in dram to match tag</span>
<span class="cm"> * value and type, so the application must keep track of these if they</span>
<span class="cm"> * are important to the application.  This tag switch command must not</span>
<span class="cm"> * be used for switches to NULL, as the tag switch pending bit will be</span>
<span class="cm"> * set by the switch request, but never cleared by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This should not be used when switching from a NULL tag.  Use</span>
<span class="cm"> * cvmx_pow_tag_sw_full() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits for any previous tag switch to complete, and also</span>
<span class="cm"> * displays an error on tag switches to NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:      new tag value</span>
<span class="cm"> * @tag_type: new tag type (ordered or atomic)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that WQE in DRAM is not updated here, as the POW does</span>
<span class="cm">	 * not read from DRAM once the WQE is in flight.  See hardware</span>
<span class="cm">	 * manual for complete details.  It is the application&#39;s</span>
<span class="cm">	 * responsibility to keep track of the current tag value if</span>
<span class="cm">	 * that is important.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that there is not a pending tag switch, as a tag</span>
<span class="cm">	 * switch cannot be started if a previous switch is still</span>
<span class="cm">	 * pending.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">cvmx_pow_tag_sw_nocheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tag_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Starts a tag switch to the provided tag value and tag type.</span>
<span class="cm"> * Completion for the tag switch must be checked for separately.  This</span>
<span class="cm"> * function does NOT update the work queue entry in dram to match tag</span>
<span class="cm"> * value and type, so the application must keep track of these if they</span>
<span class="cm"> * are important to the application.  This tag switch command must not</span>
<span class="cm"> * be used for switches to NULL, as the tag switch pending bit will be</span>
<span class="cm"> * set by the switch request, but never cleared by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be used for tag switches from NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does no checks, so the caller must ensure that any</span>
<span class="cm"> * previous tag switch has completed.</span>
<span class="cm"> *</span>
<span class="cm"> * @wqp:      pointer to work queue entry to submit.  This entry is</span>
<span class="cm"> *            updated to match the other parameters</span>
<span class="cm"> * @tag:      tag value to be assigned to work queue entry</span>
<span class="cm"> * @tag_type: type of tag</span>
<span class="cm"> * @group:    group value for the work queue entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_full_nocheck</span><span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">wqp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
						<span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">,</span>
						<span class="kt">uint64_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_tag_req_t</span> <span class="n">current_tag</span><span class="p">;</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
		<span class="n">current_tag</span> <span class="o">=</span> <span class="n">cvmx_pow_get_current_tag</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL_NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">tag_type</span><span class="p">)</span>
		   <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">))</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called to perform a tag switch to &quot;</span>
				   <span class="s">&quot;the same tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag_type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called to perform a tag switch to &quot;</span>
				   <span class="s">&quot;NULL. Use cvmx_pow_tag_sw_null() instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wqp</span> <span class="o">!=</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="mh">0x80</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wqp</span> <span class="o">!=</span> <span class="n">cvmx_pow_get_current_wqp</span><span class="p">())</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s passed WQE(%p) doesn&#39;t match &quot;</span>
					   <span class="s">&quot;the address in the POW(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">,</span> <span class="n">wqp</span><span class="p">,</span>
				     <span class="n">cvmx_pow_get_current_wqp</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that WQE in DRAM is not updated here, as the POW does</span>
<span class="cm">	 * not read from DRAM once the WQE is in flight.  See hardware</span>
<span class="cm">	 * manual for complete details.  It is the application&#39;s</span>
<span class="cm">	 * responsibility to keep track of the current tag value if</span>
<span class="cm">	 * that is important.</span>
<span class="cm">	 */</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_SWTAG_FULL</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tag_type</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_SWTAG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">CAST64</span><span class="p">(</span><span class="n">wqp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * once this store arrives at POW, it will attempt the switch</span>
<span class="cm">	 * software must wait for the switch to complete separately.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Starts a tag switch to the provided tag value and tag type.</span>
<span class="cm"> * Completion for the tag switch must be checked for separately.  This</span>
<span class="cm"> * function does NOT update the work queue entry in dram to match tag</span>
<span class="cm"> * value and type, so the application must keep track of these if they</span>
<span class="cm"> * are important to the application.  This tag switch command must not</span>
<span class="cm"> * be used for switches to NULL, as the tag switch pending bit will be</span>
<span class="cm"> * set by the switch request, but never cleared by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be used for tag switches from NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits for any pending tag switches to complete</span>
<span class="cm"> * before requesting the tag switch.</span>
<span class="cm"> *</span>
<span class="cm"> * @wqp:      pointer to work queue entry to submit.  This entry is updated</span>
<span class="cm"> *            to match the other parameters</span>
<span class="cm"> * @tag:      tag value to be assigned to work queue entry</span>
<span class="cm"> * @tag_type: type of tag</span>
<span class="cm"> * @group:      group value for the work queue entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_full</span><span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">wqp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">,</span>
					<span class="kt">uint64_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that there is not a pending tag switch, as a tag</span>
<span class="cm">	 * switch cannot be started if a previous switch is still</span>
<span class="cm">	 * pending.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">cvmx_pow_tag_sw_full_nocheck</span><span class="p">(</span><span class="n">wqp</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">tag_type</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Switch to a NULL tag, which ends any ordering or</span>
<span class="cm"> * synchronization provided by the POW for the current</span>
<span class="cm"> * work queue entry.  This operation completes immediately,</span>
<span class="cm"> * so completion should not be waited for.</span>
<span class="cm"> * This function does NOT wait for previous tag switches to complete,</span>
<span class="cm"> * so the caller must ensure that any previous tag switches have completed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_null_nocheck</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_tag_req_t</span> <span class="n">current_tag</span><span class="p">;</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
		<span class="n">current_tag</span> <span class="o">=</span> <span class="n">cvmx_pow_get_current_tag</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL_NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called when we already have a &quot;</span>
				   <span class="s">&quot;NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_SWTAG</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG1</span><span class="p">;</span>

	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="cm">/* switch to NULL completes immediately */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Switch to a NULL tag, which ends any ordering or</span>
<span class="cm"> * synchronization provided by the POW for the current</span>
<span class="cm"> * work queue entry.  This operation completes immediately,</span>
<span class="cm"> * so completion should not be waited for.</span>
<span class="cm"> * This function waits for any pending tag switches to complete</span>
<span class="cm"> * before requesting the switch to NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_null</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that there is not a pending tag switch, as a tag</span>
<span class="cm">	 * switch cannot be started if a previous switch is still</span>
<span class="cm">	 * pending.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">cvmx_pow_tag_sw_null_nocheck</span><span class="p">();</span>

	<span class="cm">/* switch to NULL completes immediately */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Submits work to an input queue.  This function updates the work</span>
<span class="cm"> * queue entry in DRAM to match the arguments given.  Note that the</span>
<span class="cm"> * tag provided is for the work queue entry submitted, and is</span>
<span class="cm"> * unrelated to the tag that the core currently holds.</span>
<span class="cm"> *</span>
<span class="cm"> * @wqp:      pointer to work queue entry to submit.  This entry is</span>
<span class="cm"> *            updated to match the other parameters</span>
<span class="cm"> * @tag:      tag value to be assigned to work queue entry</span>
<span class="cm"> * @tag_type: type of tag</span>
<span class="cm"> * @qos:      Input queue to add to.</span>
<span class="cm"> * @grp:      group value for the work queue entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_work_submit</span><span class="p">(</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="n">wqp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">,</span>
					<span class="kt">uint64_t</span> <span class="n">qos</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">grp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="n">wqp</span><span class="o">-&gt;</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
	<span class="n">wqp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">wqp</span><span class="o">-&gt;</span><span class="n">tag_type</span> <span class="o">=</span> <span class="n">tag_type</span><span class="p">;</span>
	<span class="n">wqp</span><span class="o">-&gt;</span><span class="n">grp</span> <span class="o">=</span> <span class="n">grp</span><span class="p">;</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_ADDWQ</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tag_type</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos</span> <span class="o">=</span> <span class="n">qos</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="n">grp</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cvmx_ptr_to_phys</span><span class="p">(</span><span class="n">wqp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SYNC write to memory before the work submit.  This is</span>
<span class="cm">	 * necessary as POW may read values from DRAM at this time.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_SYNCWS</span><span class="p">;</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This function sets the group mask for a core.  The group mask</span>
<span class="cm"> * indicates which groups each core will accept work from. There are</span>
<span class="cm"> * 16 groups.</span>
<span class="cm"> *</span>
<span class="cm"> * @core_num:   core to apply mask to</span>
<span class="cm"> * @mask:   Group mask. There are 16 groups, so only bits 0-15 are valid,</span>
<span class="cm"> *               representing groups 0-15.</span>
<span class="cm"> *               Each 1 bit in the mask enables the core to accept work from</span>
<span class="cm"> *               the corresponding group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_set_group_mask</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">core_num</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pow_pp_grp_mskx</span> <span class="n">grp_msk</span><span class="p">;</span>

	<span class="n">grp_msk</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">core_num</span><span class="p">));</span>
	<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">grp_msk</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">core_num</span><span class="p">),</span> <span class="n">grp_msk</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * This function sets POW static priorities for a core. Each input queue has</span>
<span class="cm"> * an associated priority value.</span>
<span class="cm"> *</span>
<span class="cm"> * @core_num:   core to apply priorities to</span>
<span class="cm"> * @priority:   Vector of 8 priorities, one per POW Input Queue (0-7).</span>
<span class="cm"> *                   Highest priority is 0 and lowest is 7. A priority value</span>
<span class="cm"> *                   of 0xF instructs POW to skip the Input Queue when</span>
<span class="cm"> *                   scheduling to this specific core.</span>
<span class="cm"> *                   NOTE: priorities should not have gaps in values, meaning</span>
<span class="cm"> *                         {0,1,1,1,1,1,1,1} is a valid configuration while</span>
<span class="cm"> *                         {0,2,2,2,2,2,2,2} is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_set_priority</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">core_num</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">priority</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="cm">/* POW priorities are supported on CN5xxx and later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN3XXX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pow_pp_grp_mskx</span> <span class="n">grp_msk</span><span class="p">;</span>

		<span class="n">grp_msk</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">core_num</span><span class="p">));</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos0_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos1_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos2_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos3_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos4_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos5_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos6_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="n">grp_msk</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">qos7_pri</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

		<span class="cm">/* Detect gaps between priorities and flag error */</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">prio_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">priority</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xF</span><span class="p">)</span>
					<span class="n">prio_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">priority</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">prio_mask</span> <span class="o">^</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cvmx_pop</span><span class="p">(</span><span class="n">prio_mask</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;POW static priorities should be &quot;</span>
				       <span class="s">&quot;contiguous (0x%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">prio_mask</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_POW_PP_GRP_MSKX</span><span class="p">(</span><span class="n">core_num</span><span class="p">),</span> <span class="n">grp_msk</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Performs a tag switch and then an immediate deschedule. This completes</span>
<span class="cm"> * immediately, so completion must not be waited for.  This function does NOT</span>
<span class="cm"> * update the wqe in DRAM to match arguments.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does NOT wait for any prior tag switches to complete, so the</span>
<span class="cm"> * calling code must do this.</span>
<span class="cm"> *</span>
<span class="cm"> * Note the following CAVEAT of the Octeon HW behavior when</span>
<span class="cm"> * re-scheduling DE-SCHEDULEd items whose (next) state is</span>
<span class="cm"> * ORDERED:</span>
<span class="cm"> *   - If there are no switches pending at the time that the</span>
<span class="cm"> *     HW executes the de-schedule, the HW will only re-schedule</span>
<span class="cm"> *     the head of the FIFO associated with the given tag. This</span>
<span class="cm"> *     means that in many respects, the HW treats this ORDERED</span>
<span class="cm"> *     tag as an ATOMIC tag. Note that in the SWTAG_DESCH</span>
<span class="cm"> *     case (to an ORDERED tag), the HW will do the switch</span>
<span class="cm"> *     before the deschedule whenever it is possible to do</span>
<span class="cm"> *     the switch immediately, so it may often look like</span>
<span class="cm"> *     this case.</span>
<span class="cm"> *   - If there is a pending switch to ORDERED at the time</span>
<span class="cm"> *     the HW executes the de-schedule, the HW will perform</span>
<span class="cm"> *     the switch at the time it re-schedules, and will be</span>
<span class="cm"> *     able to reschedule any/all of the entries with the</span>
<span class="cm"> *     same tag.</span>
<span class="cm"> * Due to this behavior, the RECOMMENDATION to software is</span>
<span class="cm"> * that they have a (next) state of ATOMIC when they</span>
<span class="cm"> * DE-SCHEDULE. If an ORDERED tag is what was really desired,</span>
<span class="cm"> * SW can choose to immediately switch to an ORDERED tag</span>
<span class="cm"> * after the work (that has an ATOMIC tag) is re-scheduled.</span>
<span class="cm"> * Note that since there are never any tag switches pending</span>
<span class="cm"> * when the HW re-schedules, this switch can be IMMEDIATE upon</span>
<span class="cm"> * the reception of the pointer during the re-schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:      New tag value</span>
<span class="cm"> * @tag_type: New tag type</span>
<span class="cm"> * @group:    New group value</span>
<span class="cm"> * @no_sched: Control whether this work queue entry will be rescheduled.</span>
<span class="cm"> *                 - 1 : don&#39;t schedule this work</span>
<span class="cm"> *                 - 0 : allow this work to be scheduled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_desched_nocheck</span><span class="p">(</span>
	<span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">,</span>
	<span class="kt">uint64_t</span> <span class="n">group</span><span class="p">,</span>
	<span class="kt">uint64_t</span> <span class="n">no_sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_tag_req_t</span> <span class="n">current_tag</span><span class="p">;</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
		<span class="n">current_tag</span> <span class="o">=</span> <span class="n">cvmx_pow_get_current_tag</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL_NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL tag. Deschedule not &quot;</span>
				   <span class="s">&quot;allowed from NULL state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">CVMX_POW_TAG_TYPE_ATOMIC</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tag_type</span> <span class="o">!=</span> <span class="n">CVMX_POW_TAG_TYPE_ATOMIC</span><span class="p">))</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called where neither the before or &quot;</span>
				   <span class="s">&quot;after tag is ATOMIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_SWTAG_DESCH</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tag_type</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">grp</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">no_sched</span> <span class="o">=</span> <span class="n">no_sched</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG3</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * since TAG3 is used, this store will clear the local pending</span>
<span class="cm">	 * switch bit.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Performs a tag switch and then an immediate deschedule. This completes</span>
<span class="cm"> * immediately, so completion must not be waited for.  This function does NOT</span>
<span class="cm"> * update the wqe in DRAM to match arguments.</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits for any prior tag switches to complete, so the</span>
<span class="cm"> * calling code may call this function with a pending tag switch.</span>
<span class="cm"> *</span>
<span class="cm"> * Note the following CAVEAT of the Octeon HW behavior when</span>
<span class="cm"> * re-scheduling DE-SCHEDULEd items whose (next) state is</span>
<span class="cm"> * ORDERED:</span>
<span class="cm"> *   - If there are no switches pending at the time that the</span>
<span class="cm"> *     HW executes the de-schedule, the HW will only re-schedule</span>
<span class="cm"> *     the head of the FIFO associated with the given tag. This</span>
<span class="cm"> *     means that in many respects, the HW treats this ORDERED</span>
<span class="cm"> *     tag as an ATOMIC tag. Note that in the SWTAG_DESCH</span>
<span class="cm"> *     case (to an ORDERED tag), the HW will do the switch</span>
<span class="cm"> *     before the deschedule whenever it is possible to do</span>
<span class="cm"> *     the switch immediately, so it may often look like</span>
<span class="cm"> *     this case.</span>
<span class="cm"> *   - If there is a pending switch to ORDERED at the time</span>
<span class="cm"> *     the HW executes the de-schedule, the HW will perform</span>
<span class="cm"> *     the switch at the time it re-schedules, and will be</span>
<span class="cm"> *     able to reschedule any/all of the entries with the</span>
<span class="cm"> *     same tag.</span>
<span class="cm"> * Due to this behavior, the RECOMMENDATION to software is</span>
<span class="cm"> * that they have a (next) state of ATOMIC when they</span>
<span class="cm"> * DE-SCHEDULE. If an ORDERED tag is what was really desired,</span>
<span class="cm"> * SW can choose to immediately switch to an ORDERED tag</span>
<span class="cm"> * after the work (that has an ATOMIC tag) is re-scheduled.</span>
<span class="cm"> * Note that since there are never any tag switches pending</span>
<span class="cm"> * when the HW re-schedules, this switch can be IMMEDIATE upon</span>
<span class="cm"> * the reception of the pointer during the re-schedule.</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:      New tag value</span>
<span class="cm"> * @tag_type: New tag type</span>
<span class="cm"> * @group:    New group value</span>
<span class="cm"> * @no_sched: Control whether this work queue entry will be rescheduled.</span>
<span class="cm"> *                 - 1 : don&#39;t schedule this work</span>
<span class="cm"> *                 - 0 : allow this work to be scheduled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_tag_sw_desched</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">cvmx_pow_tag_type</span> <span class="n">tag_type</span><span class="p">,</span>
					   <span class="kt">uint64_t</span> <span class="n">group</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">no_sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Need to make sure any writes to the work queue entry are complete */</span>
	<span class="n">CVMX_SYNCWS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure that there is not a pending tag switch, as a tag</span>
<span class="cm">	 * switch cannot be started if a previous switch is still</span>
<span class="cm">	 * pending.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">cvmx_pow_tag_sw_desched_nocheck</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tag_type</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">no_sched</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Descchedules the current work queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * @no_sched: no schedule flag value to be set on the work queue</span>
<span class="cm"> *            entry.  If this is set the entry will not be</span>
<span class="cm"> *            rescheduled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pow_desched</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">no_sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_addr_t</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">cvmx_pow_tag_req_t</span> <span class="n">tag_req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CVMX_ENABLE_POW_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cvmx_pow_tag_req_t</span> <span class="n">current_tag</span><span class="p">;</span>
		<span class="n">__cvmx_pow_warn_if_pending_switch</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
		<span class="n">current_tag</span> <span class="o">=</span> <span class="n">cvmx_pow_get_current_tag</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL_NULL tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_tag</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CVMX_POW_TAG_TYPE_NULL</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s called with NULL tag. Deschedule not &quot;</span>
				   <span class="s">&quot;expected from NULL state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Need to make sure any writes to the work queue entry are complete */</span>
	<span class="n">CVMX_SYNCWS</span><span class="p">;</span>

	<span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">CVMX_POW_TAG_OP_DESCH</span><span class="p">;</span>
	<span class="n">tag_req</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">no_sched</span> <span class="o">=</span> <span class="n">no_sched</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">mem_region</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">sio</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_TAG_TAG3</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * since TAG3 is used, this store will clear the local pending</span>
<span class="cm">	 * switch bit.</span>
<span class="cm">	 */</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">tag_req</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************</span>
<span class="cm">* Define usage of bits within the 32 bit tag values.</span>
<span class="cm">*****************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Number of bits of the tag used by software.  The SW bits are always</span>
<span class="cm"> * a contiguous block of the high starting at bit 31.  The hardware</span>
<span class="cm"> * bits are always the low bits.  By default, the top 8 bits of the</span>
<span class="cm"> * tag are reserved for software, and the low 24 are set by the IPD</span>
<span class="cm"> * unit.</span>
<span class="cm"> */</span>
<span class="cp">#define CVMX_TAG_SW_BITS    (8)</span>
<span class="cp">#define CVMX_TAG_SW_SHIFT   (32 - CVMX_TAG_SW_BITS)</span>

<span class="cm">/* Below is the list of values for the top 8 bits of the tag. */</span>
<span class="cm">/*</span>
<span class="cm"> * Tag values with top byte of this value are reserved for internal</span>
<span class="cm"> * executive uses.</span>
<span class="cm"> */</span>
<span class="cp">#define CVMX_TAG_SW_BITS_INTERNAL  0x1</span>
<span class="cm">/* The executive divides the remaining 24 bits as follows:</span>
<span class="cm"> *  - the upper 8 bits (bits 23 - 16 of the tag) define a subgroup</span>
<span class="cm"> *</span>
<span class="cm"> *  - the lower 16 bits (bits 15 - 0 of the tag) define are the value</span>
<span class="cm"> *    with the subgroup</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this section describes the format of tags generated by</span>
<span class="cm"> * software - refer to the hardware documentation for a description of</span>
<span class="cm"> * the tags values generated by the packet input hardware.  Subgroups</span>
<span class="cm"> * are defined here.</span>
<span class="cm"> */</span>
<span class="cm">/* Mask for the value portion of the tag */</span>
<span class="cp">#define CVMX_TAG_SUBGROUP_MASK  0xFFFF</span>
<span class="cp">#define CVMX_TAG_SUBGROUP_SHIFT 16</span>
<span class="cp">#define CVMX_TAG_SUBGROUP_PKO  0x1</span>

<span class="cm">/* End of executive tag subgroup definitions */</span>

<span class="cm">/*</span>
<span class="cm"> * The remaining values software bit values 0x2 - 0xff are available</span>
<span class="cm"> * for application use.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * This function creates a 32 bit tag value from the two values provided.</span>
<span class="cm"> *</span>
<span class="cm"> * @sw_bits: The upper bits (number depends on configuration) are set</span>
<span class="cm"> *           to this value.  The remainder of bits are set by the</span>
<span class="cm"> *           hw_bits parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * @hw_bits: The lower bits (number depends on configuration) are set</span>
<span class="cm"> *           to this value.  The remainder of bits are set by the</span>
<span class="cm"> *           sw_bits parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 32 bit value of the combined hw and sw bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">cvmx_pow_tag_compose</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">sw_bits</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">hw_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">sw_bits</span> <span class="o">&amp;</span> <span class="n">cvmx_build_mask</span><span class="p">(</span><span class="n">CVMX_TAG_SW_BITS</span><span class="p">))</span> <span class="o">&lt;&lt;</span>
			<span class="n">CVMX_TAG_SW_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">hw_bits</span> <span class="o">&amp;</span> <span class="n">cvmx_build_mask</span><span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">CVMX_TAG_SW_BITS</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Extracts the bits allocated for software use from the tag</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:    32 bit tag value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns N bit software tag value, where N is configurable with the</span>
<span class="cm"> * CVMX_TAG_SW_BITS define</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">cvmx_pow_tag_get_sw_bits</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">CVMX_TAG_SW_BITS</span><span class="p">))</span> <span class="o">&amp;</span>
		<span class="n">cvmx_build_mask</span><span class="p">(</span><span class="n">CVMX_TAG_SW_BITS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * Extracts the bits allocated for hardware use from the tag</span>
<span class="cm"> *</span>
<span class="cm"> * @tag:    32 bit tag value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns (32 - N) bit software tag value, where N is configurable</span>
<span class="cm"> * with the CVMX_TAG_SW_BITS define</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">cvmx_pow_tag_get_hw_bits</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="n">cvmx_build_mask</span><span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">CVMX_TAG_SW_BITS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Store the current POW internal state into the supplied</span>
<span class="cm"> * buffer. It is recommended that you pass a buffer of at least</span>
<span class="cm"> * 128KB. The format of the capture may change based on SDK</span>
<span class="cm"> * version and Octeon chip.</span>
<span class="cm"> *</span>
<span class="cm"> * @buffer: Buffer to store capture into</span>
<span class="cm"> * @buffer_size:</span>
<span class="cm"> *               The size of the supplied buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success, negative on failure</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_pow_capture</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buffer_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Dump a POW capture to the console in a human readable format.</span>
<span class="cm"> *</span>
<span class="cm"> * @buffer: POW capture from cvmx_pow_capture()</span>
<span class="cm"> * @buffer_size:</span>
<span class="cm"> *               Size of the buffer</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_pow_display</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buffer_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Return the number of POW entries supported by this chip</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Number of POW entries</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_pow_get_num_entries</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __CVMX_POW_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
