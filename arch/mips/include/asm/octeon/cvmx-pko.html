<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › mips › include › asm › octeon › cvmx-pko.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cvmx-pko.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/***********************license start***************</span>
<span class="cm"> * Author: Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: support@caviumnetworks.com</span>
<span class="cm"> * This file is part of the OCTEON SDK</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003-2008 Cavium Networks</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License, Version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or</span>
<span class="cm"> * NONINFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this file; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> * or visit http://www.gnu.org/licenses/.</span>
<span class="cm"> *</span>
<span class="cm"> * This file may also be available under a different license from Cavium.</span>
<span class="cm"> * Contact Cavium Networks for more information</span>
<span class="cm"> ***********************license end**************************************/</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * Interface to the hardware Packet Output unit.</span>
<span class="cm"> *</span>
<span class="cm"> * Starting with SDK 1.7.0, the PKO output functions now support</span>
<span class="cm"> * two types of locking. CVMX_PKO_LOCK_ATOMIC_TAG continues to</span>
<span class="cm"> * function similarly to previous SDKs by using POW atomic tags</span>
<span class="cm"> * to preserve ordering and exclusivity. As a new option, you</span>
<span class="cm"> * can now pass CVMX_PKO_LOCK_CMD_QUEUE which uses a ll/sc</span>
<span class="cm"> * memory based locking instead. This locking has the advantage</span>
<span class="cm"> * of not affecting the tag state but doesn&#39;t preserve packet</span>
<span class="cm"> * ordering. CVMX_PKO_LOCK_CMD_QUEUE is appropriate in most</span>
<span class="cm"> * generic code while CVMX_PKO_LOCK_CMD_QUEUE should be used</span>
<span class="cm"> * with hand tuned fast path code.</span>
<span class="cm"> *</span>
<span class="cm"> * Some of other SDK differences visible to the command command</span>
<span class="cm"> * queuing:</span>
<span class="cm"> * - PKO indexes are no longer stored in the FAU. A large</span>
<span class="cm"> *   percentage of the FAU register block used to be tied up</span>
<span class="cm"> *   maintaining PKO queue pointers. These are now stored in a</span>
<span class="cm"> *   global named block.</span>
<span class="cm"> * - The PKO &lt;b&gt;use_locking&lt;/b&gt; parameter can now have a global</span>
<span class="cm"> *   effect. Since all application use the same named block,</span>
<span class="cm"> *   queue locking correctly applies across all operating</span>
<span class="cm"> *   systems when using CVMX_PKO_LOCK_CMD_QUEUE.</span>
<span class="cm"> * - PKO 3 word commands are now supported. Use</span>
<span class="cm"> *   cvmx_pko_send_packet_finish3().</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __CVMX_PKO_H__</span>
<span class="cp">#define __CVMX_PKO_H__</span>

<span class="cp">#include &quot;cvmx-fpa.h&quot;</span>
<span class="cp">#include &quot;cvmx-pow.h&quot;</span>
<span class="cp">#include &quot;cvmx-cmd-queue.h&quot;</span>
<span class="cp">#include &quot;cvmx-pko-defs.h&quot;</span>

<span class="cm">/* Adjust the command buffer size by 1 word so that in the case of using only</span>
<span class="cm"> * two word PKO commands no command words stradle buffers.  The useful values</span>
<span class="cm"> * for this are 0 and 1. */</span>
<span class="cp">#define CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST (1)</span>

<span class="cp">#define CVMX_PKO_MAX_OUTPUT_QUEUES_STATIC 256</span>
<span class="cp">#define CVMX_PKO_MAX_OUTPUT_QUEUES      ((OCTEON_IS_MODEL(OCTEON_CN31XX) || \</span>
<span class="cp">	OCTEON_IS_MODEL(OCTEON_CN3010) || OCTEON_IS_MODEL(OCTEON_CN3005) || \</span>
<span class="cp">	OCTEON_IS_MODEL(OCTEON_CN50XX)) ? 32 : \</span>
<span class="cp">		(OCTEON_IS_MODEL(OCTEON_CN58XX) || \</span>
<span class="cp">		OCTEON_IS_MODEL(OCTEON_CN56XX)) ? 256 : 128)</span>
<span class="cp">#define CVMX_PKO_NUM_OUTPUT_PORTS       40</span>
<span class="cm">/* use this for queues that are not used */</span>
<span class="cp">#define CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID 63</span>
<span class="cp">#define CVMX_PKO_QUEUE_STATIC_PRIORITY  9</span>
<span class="cp">#define CVMX_PKO_ILLEGAL_QUEUE  0xFFFF</span>
<span class="cp">#define CVMX_PKO_MAX_QUEUE_DEPTH 0</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">CVMX_PKO_SUCCESS</span><span class="p">,</span>
	<span class="n">CVMX_PKO_INVALID_PORT</span><span class="p">,</span>
	<span class="n">CVMX_PKO_INVALID_QUEUE</span><span class="p">,</span>
	<span class="n">CVMX_PKO_INVALID_PRIORITY</span><span class="p">,</span>
	<span class="n">CVMX_PKO_NO_MEMORY</span><span class="p">,</span>
	<span class="n">CVMX_PKO_PORT_ALREADY_SETUP</span><span class="p">,</span>
	<span class="n">CVMX_PKO_CMD_QUEUE_INIT_ERROR</span>
<span class="p">}</span> <span class="n">cvmx_pko_status_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This enumeration represents the differnet locking modes supported by PKO.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * PKO doesn&#39;t do any locking. It is the responsibility of the</span>
<span class="cm">	 * application to make sure that no other core is accessing</span>
<span class="cm">	 * the same queue at the same time</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PKO_LOCK_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * PKO performs an atomic tagswitch to insure exclusive access</span>
<span class="cm">	 * to the output queue. This will maintain packet ordering on</span>
<span class="cm">	 * output.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PKO_LOCK_ATOMIC_TAG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * PKO uses the common command queue locks to insure exclusive</span>
<span class="cm">	 * access to the output queue. This is a memory based</span>
<span class="cm">	 * ll/sc. This is the most portable locking mechanism.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_PKO_LOCK_CMD_QUEUE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span> <span class="n">cvmx_pko_lock_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">packets</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">octets</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">doorbell</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pko_port_status_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This structure defines the address to use on a packet enqueue</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Must CVMX_IO_SEG */</span>
		<span class="kt">uint64_t</span> <span class="n">mem_space</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
		<span class="cm">/* Must be one */</span>
		<span class="kt">uint64_t</span> <span class="n">is_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The ID of the device on the non-coherent bus */</span>
		<span class="kt">uint64_t</span> <span class="n">did</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved2</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved3</span><span class="o">:</span><span class="mi">18</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The hardware likes to have the output port in</span>
<span class="cm">		 * addition to the output queue,</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">port</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The output queue to send the packet to (0-127 are</span>
<span class="cm">		 * legal)</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">queue</span><span class="o">:</span><span class="mi">9</span><span class="p">;</span>
		<span class="cm">/* Must be zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reserved4</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pko_doorbell_address_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Structure of the first packet output command word.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The size of the reg1 operation - could be 8, 16,</span>
<span class="cm">		 * 32, or 64 bits.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">size1</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The size of the reg0 operation - could be 8, 16,</span>
<span class="cm">		 * 32, or 64 bits.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">size0</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, subtract 1, if clear, subtract packet</span>
<span class="cm">		 * size.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">subone1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The register, subtract will be done if reg1 is</span>
<span class="cm">		 * non-zero.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">reg1</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/* If set, subtract 1, if clear, subtract packet size */</span>
		<span class="kt">uint64_t</span> <span class="n">subone0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The register, subtract will be done if reg0 is non-zero */</span>
		<span class="kt">uint64_t</span> <span class="n">reg0</span><span class="o">:</span><span class="mi">11</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When set, interpret segment pointer and segment</span>
<span class="cm">		 * bytes in little endian order.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">le</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When set, packet data not allocated in L2 cache by</span>
<span class="cm">		 * PKO.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">n2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set and rsp is set, word3 contains a pointer to</span>
<span class="cm">		 * a work queue entry.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">wqp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* If set, the hardware will send a response when done */</span>
		<span class="kt">uint64_t</span> <span class="n">rsp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, the supplied pkt_ptr is really a pointer to</span>
<span class="cm">		 * a list of pkt_ptr&#39;s.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">gather</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If ipoffp1 is non zero, (ipoffp1-1) is the number</span>
<span class="cm">		 * of bytes to IP header, and the hardware will</span>
<span class="cm">		 * calculate and insert the UDP/TCP checksum.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">ipoffp1</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If set, ignore the I bit (force to zero) from all</span>
<span class="cm">		 * pointer structures.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">ignore_i</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If clear, the hardware will attempt to free the</span>
<span class="cm">		 * buffers containing the packet.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">dontfree</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The total number of segs in the packet, if gather</span>
<span class="cm">		 * set, also gather list length.</span>
<span class="cm">		 */</span>
		<span class="kt">uint64_t</span> <span class="n">segs</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
		<span class="cm">/* Including L2, but no trailing CRC */</span>
		<span class="kt">uint64_t</span> <span class="n">total_bytes</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pko_command_word0_t</span><span class="p">;</span>

<span class="cm">/* CSR typedefs have been moved to cvmx-csr-*.h */</span>

<span class="cm">/**</span>
<span class="cm"> * Definition of internal state for Packet output processing</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* ptr to start of buffer, offset kept in FAU reg */</span>
	<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">start_ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cvmx_pko_state_elem_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Call before any other calls to initialize the packet</span>
<span class="cm"> * output system.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_pko_initialize_global</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_pko_initialize_local</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Enables the packet output hardware. It must already be</span>
<span class="cm"> * configured.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_pko_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Disables the packet output. Does not affect any configuration.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_pko_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Shutdown and free resources required by packet output.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cvmx_pko_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Configure a output port and the associated queues for use.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:       Port to configure.</span>
<span class="cm"> * @base_queue: First queue number to associate with this port.</span>
<span class="cm"> * @num_queues: Number of queues t oassociate with this port</span>
<span class="cm"> * @priority:   Array of priority levels for each queue. Values are</span>
<span class="cm"> *                   allowed to be 1-8. A value of 8 get 8 times the traffic</span>
<span class="cm"> *                   of a value of 1. There must be num_queues elements in the</span>
<span class="cm"> *                   array.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">cvmx_pko_status_t</span> <span class="n">cvmx_pko_config_port</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port</span><span class="p">,</span>
					      <span class="kt">uint64_t</span> <span class="n">base_queue</span><span class="p">,</span>
					      <span class="kt">uint64_t</span> <span class="n">num_queues</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">priority</span><span class="p">[]);</span>

<span class="cm">/**</span>
<span class="cm"> * Ring the packet output doorbell. This tells the packet</span>
<span class="cm"> * output hardware that &quot;len&quot; command words have been added</span>
<span class="cm"> * to its pending list.  This command includes the required</span>
<span class="cm"> * CVMX_SYNCWS before the doorbell ring.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port the packet is for</span>
<span class="cm"> * @queue:  Queue the packet is for</span>
<span class="cm"> * @len:    Length of the command in 64 bit words</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pko_doorbell</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">queue</span><span class="p">,</span>
				     <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_pko_doorbell_address_t</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">mem_space</span> <span class="o">=</span> <span class="n">CVMX_IO_SEG</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">did</span> <span class="o">=</span> <span class="n">CVMX_OCT_DID_PKT_SEND</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">is_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">ptr</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need to make sure output queue data is in DRAM before</span>
<span class="cm">	 * doorbell write.</span>
<span class="cm">	 */</span>
	<span class="n">CVMX_SYNCWS</span><span class="p">;</span>
	<span class="n">cvmx_write_io</span><span class="p">(</span><span class="n">ptr</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Prepare to send a packet.  This may initiate a tag switch to</span>
<span class="cm"> * get exclusive access to the output queue structure, and</span>
<span class="cm"> * performs other prep work for the packet send operation.</span>
<span class="cm"> *</span>
<span class="cm"> * cvmx_pko_send_packet_finish() MUST be called after this function is called,</span>
<span class="cm"> * and must be called with the same port/queue/use_locking arguments.</span>
<span class="cm"> *</span>
<span class="cm"> * The use_locking parameter allows the caller to use three</span>
<span class="cm"> * possible locking modes.</span>
<span class="cm"> * - CVMX_PKO_LOCK_NONE</span>
<span class="cm"> *      - PKO doesn&#39;t do any locking. It is the responsibility</span>
<span class="cm"> *          of the application to make sure that no other core</span>
<span class="cm"> *          is accessing the same queue at the same time.</span>
<span class="cm"> * - CVMX_PKO_LOCK_ATOMIC_TAG</span>
<span class="cm"> *      - PKO performs an atomic tagswitch to insure exclusive</span>
<span class="cm"> *          access to the output queue. This will maintain</span>
<span class="cm"> *          packet ordering on output.</span>
<span class="cm"> * - CVMX_PKO_LOCK_CMD_QUEUE</span>
<span class="cm"> *      - PKO uses the common command queue locks to insure</span>
<span class="cm"> *          exclusive access to the output queue. This is a</span>
<span class="cm"> *          memory based ll/sc. This is the most portable</span>
<span class="cm"> *          locking mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: If atomic locking is used, the POW entry CANNOT be</span>
<span class="cm"> * descheduled, as it does not contain a valid WQE pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port to send it on</span>
<span class="cm"> * @queue:  Queue to use</span>
<span class="cm"> * @use_locking: CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or</span>
<span class="cm"> *               CVMX_PKO_LOCK_CMD_QUEUE</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pko_send_packet_prepare</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">queue</span><span class="p">,</span>
						<span class="n">cvmx_pko_lock_t</span> <span class="n">use_locking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_locking</span> <span class="o">==</span> <span class="n">CVMX_PKO_LOCK_ATOMIC_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Must do a full switch here to handle all cases.  We</span>
<span class="cm">		 * use a fake WQE pointer, as the POW does not access</span>
<span class="cm">		 * this memory.  The WQE pointer and group are only</span>
<span class="cm">		 * used if this work is descheduled, which is not</span>
<span class="cm">		 * supported by the</span>
<span class="cm">		 * cvmx_pko_send_packet_prepare/cvmx_pko_send_packet_finish</span>
<span class="cm">		 * combination.  Note that this is a special case in</span>
<span class="cm">		 * which these fake values can be used - this is not a</span>
<span class="cm">		 * general technique.</span>
<span class="cm">		 */</span>
		<span class="kt">uint32_t</span> <span class="n">tag</span> <span class="o">=</span>
		    <span class="n">CVMX_TAG_SW_BITS_INTERNAL</span> <span class="o">&lt;&lt;</span> <span class="n">CVMX_TAG_SW_SHIFT</span> <span class="o">|</span>
		    <span class="n">CVMX_TAG_SUBGROUP_PKO</span> <span class="o">&lt;&lt;</span> <span class="n">CVMX_TAG_SUBGROUP_SHIFT</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">CVMX_TAG_SUBGROUP_MASK</span> <span class="o">&amp;</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">cvmx_pow_tag_sw_full</span><span class="p">((</span><span class="n">cvmx_wqe_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">cvmx_phys_to_ptr</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="n">tag</span><span class="p">,</span>
				     <span class="n">CVMX_POW_TAG_TYPE_ATOMIC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Complete packet output. cvmx_pko_send_packet_prepare() must be</span>
<span class="cm"> * called exactly once before this, and the same parameters must be</span>
<span class="cm"> * passed to both cvmx_pko_send_packet_prepare() and</span>
<span class="cm"> * cvmx_pko_send_packet_finish().</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port to send it on</span>
<span class="cm"> * @queue:  Queue to use</span>
<span class="cm"> * @pko_command:</span>
<span class="cm"> *               PKO HW command word</span>
<span class="cm"> * @packet: Packet to send</span>
<span class="cm"> * @use_locking: CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or</span>
<span class="cm"> *               CVMX_PKO_LOCK_CMD_QUEUE</span>
<span class="cm"> *</span>
<span class="cm"> * Returns returns CVMX_PKO_SUCCESS on success, or error code on</span>
<span class="cm"> * failure of output</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_pko_status_t</span> <span class="nf">cvmx_pko_send_packet_finish</span><span class="p">(</span>
	<span class="kt">uint64_t</span> <span class="n">port</span><span class="p">,</span>
	<span class="kt">uint64_t</span> <span class="n">queue</span><span class="p">,</span>
	<span class="n">cvmx_pko_command_word0_t</span> <span class="n">pko_command</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">cvmx_buf_ptr</span> <span class="n">packet</span><span class="p">,</span>
	<span class="n">cvmx_pko_lock_t</span> <span class="n">use_locking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_cmd_queue_result_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_locking</span> <span class="o">==</span> <span class="n">CVMX_PKO_LOCK_ATOMIC_TAG</span><span class="p">)</span>
		<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">cvmx_cmd_queue_write2</span><span class="p">(</span><span class="n">CVMX_CMD_QUEUE_PKO</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span>
				       <span class="p">(</span><span class="n">use_locking</span> <span class="o">==</span> <span class="n">CVMX_PKO_LOCK_CMD_QUEUE</span><span class="p">),</span>
				       <span class="n">pko_command</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">packet</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cvmx_pko_doorbell</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_NO_MEMORY</span><span class="p">)</span>
		   <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_FULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_NO_MEMORY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_INVALID_QUEUE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Complete packet output. cvmx_pko_send_packet_prepare() must be</span>
<span class="cm"> * called exactly once before this, and the same parameters must be</span>
<span class="cm"> * passed to both cvmx_pko_send_packet_prepare() and</span>
<span class="cm"> * cvmx_pko_send_packet_finish().</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port to send it on</span>
<span class="cm"> * @queue:  Queue to use</span>
<span class="cm"> * @pko_command:</span>
<span class="cm"> *               PKO HW command word</span>
<span class="cm"> * @packet: Packet to send</span>
<span class="cm"> * @addr: Plysical address of a work queue entry or physical address</span>
<span class="cm"> *        to zero on complete.</span>
<span class="cm"> * @use_locking: CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or</span>
<span class="cm"> *               CVMX_PKO_LOCK_CMD_QUEUE</span>
<span class="cm"> *</span>
<span class="cm"> * Returns returns CVMX_PKO_SUCCESS on success, or error code on</span>
<span class="cm"> * failure of output</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cvmx_pko_status_t</span> <span class="nf">cvmx_pko_send_packet_finish3</span><span class="p">(</span>
	<span class="kt">uint64_t</span> <span class="n">port</span><span class="p">,</span>
	<span class="kt">uint64_t</span> <span class="n">queue</span><span class="p">,</span>
	<span class="n">cvmx_pko_command_word0_t</span> <span class="n">pko_command</span><span class="p">,</span>
	<span class="k">union</span> <span class="n">cvmx_buf_ptr</span> <span class="n">packet</span><span class="p">,</span>
	<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span>
	<span class="n">cvmx_pko_lock_t</span> <span class="n">use_locking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cvmx_cmd_queue_result_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_locking</span> <span class="o">==</span> <span class="n">CVMX_PKO_LOCK_ATOMIC_TAG</span><span class="p">)</span>
		<span class="n">cvmx_pow_tag_sw_wait</span><span class="p">();</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">cvmx_cmd_queue_write3</span><span class="p">(</span><span class="n">CVMX_CMD_QUEUE_PKO</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span>
				       <span class="p">(</span><span class="n">use_locking</span> <span class="o">==</span> <span class="n">CVMX_PKO_LOCK_CMD_QUEUE</span><span class="p">),</span>
				       <span class="n">pko_command</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">packet</span><span class="p">.</span><span class="n">u64</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cvmx_pko_doorbell</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_NO_MEMORY</span><span class="p">)</span>
		   <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">CVMX_CMD_QUEUE_FULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_NO_MEMORY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_INVALID_QUEUE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Return the pko output queue associated with a port and a specific core.</span>
<span class="cm"> * In normal mode (PKO lockless operation is disabled), the value returned</span>
<span class="cm"> * is the base queue.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port number</span>
<span class="cm"> * @core:   Core to get queue for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Core-specific output queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cvmx_pko_get_base_queue_per_core</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">core</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0</span>
<span class="cp">#define CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0 16</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1</span>
<span class="cp">#define CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1 16</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">port</span> <span class="o">*</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE0</span> <span class="o">+</span> <span class="n">core</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="o">&amp;&amp;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE0</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE0</span> <span class="o">+</span> <span class="p">(</span><span class="n">port</span> <span class="o">-</span>
							   <span class="mi">16</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE1</span> <span class="o">+</span> <span class="n">core</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">port</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE0</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE0</span> <span class="o">+</span>
		    <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE1</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE1</span> <span class="o">+</span> <span class="p">(</span><span class="n">port</span> <span class="o">-</span>
							   <span class="mi">32</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_PCI</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">port</span> <span class="o">&gt;=</span> <span class="mi">36</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE0</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE0</span> <span class="o">+</span>
		    <span class="n">CVMX_PKO_MAX_PORTS_INTERFACE1</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE1</span> <span class="o">+</span>
		    <span class="mi">4</span> <span class="o">*</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_PCI</span> <span class="o">+</span> <span class="p">(</span><span class="n">port</span> <span class="o">-</span>
							<span class="mi">36</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">CVMX_PKO_QUEUES_PER_PORT_LOOP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Given the limit on the number of ports we can map to</span>
<span class="cm">		 * CVMX_MAX_OUTPUT_QUEUES_STATIC queues (currently 256,</span>
<span class="cm">		 * divided among all cores), the remaining unmapped ports</span>
<span class="cm">		 * are assigned an illegal queue number */</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_ILLEGAL_QUEUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * For a given port number, return the base pko output queue</span>
<span class="cm"> * for the port.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port number</span>
<span class="cm"> * Returns Base output queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cvmx_pko_get_base_queue</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cvmx_pko_get_base_queue_per_core</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * For a given port number, return the number of pko output queues.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port number</span>
<span class="cm"> * Returns Number of output queues</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cvmx_pko_get_num_queues</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_INTERFACE1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_PCI</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CVMX_PKO_QUEUES_PER_PORT_LOOP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the status counters for a port.</span>
<span class="cm"> *</span>
<span class="cm"> * @port_num: Port number to get statistics for.</span>
<span class="cm"> * @clear:    Set to 1 to clear the counters after they are read</span>
<span class="cm"> * @status:   Where to put the results.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cvmx_pko_get_port_status</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">port_num</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">clear</span><span class="p">,</span>
					    <span class="n">cvmx_pko_port_status_t</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cvmx_pko_reg_read_idx</span> <span class="n">pko_reg_read_idx</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pko_mem_count0</span> <span class="n">pko_mem_count0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cvmx_pko_mem_count1</span> <span class="n">pko_mem_count1</span><span class="p">;</span>

	<span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">port_num</span><span class="p">;</span>
	<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PKO_REG_READ_IDX</span><span class="p">,</span> <span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>

	<span class="n">pko_mem_count0</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_COUNT0</span><span class="p">);</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">packets</span> <span class="o">=</span> <span class="n">pko_mem_count0</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pko_mem_count0</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">port_num</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_COUNT0</span><span class="p">,</span> <span class="n">pko_mem_count0</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pko_mem_count1</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_COUNT1</span><span class="p">);</span>
	<span class="n">status</span><span class="o">-&gt;</span><span class="n">octets</span> <span class="o">=</span> <span class="n">pko_mem_count1</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pko_mem_count1</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">port_num</span><span class="p">;</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_COUNT1</span><span class="p">,</span> <span class="n">pko_mem_count1</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OCTEON_IS_MODEL</span><span class="p">(</span><span class="n">OCTEON_CN3XXX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pko_mem_debug9</span> <span class="n">debug9</span><span class="p">;</span>
		<span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">cvmx_pko_get_base_queue</span><span class="p">(</span><span class="n">port_num</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PKO_REG_READ_IDX</span><span class="p">,</span> <span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">debug9</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_DEBUG9</span><span class="p">);</span>
		<span class="n">status</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">=</span> <span class="n">debug9</span><span class="p">.</span><span class="n">cn38xx</span><span class="p">.</span><span class="n">doorbell</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cvmx_pko_mem_debug8</span> <span class="n">debug8</span><span class="p">;</span>
		<span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">cvmx_pko_get_base_queue</span><span class="p">(</span><span class="n">port_num</span><span class="p">);</span>
		<span class="n">cvmx_write_csr</span><span class="p">(</span><span class="n">CVMX_PKO_REG_READ_IDX</span><span class="p">,</span> <span class="n">pko_reg_read_idx</span><span class="p">.</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">debug8</span><span class="p">.</span><span class="n">u64</span> <span class="o">=</span> <span class="n">cvmx_read_csr</span><span class="p">(</span><span class="n">CVMX_PKO_MEM_DEBUG8</span><span class="p">);</span>
		<span class="n">status</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">=</span> <span class="n">debug8</span><span class="p">.</span><span class="n">cn58xx</span><span class="p">.</span><span class="n">doorbell</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Rate limit a PKO port to a max packets/sec. This function is only</span>
<span class="cm"> * supported on CN57XX, CN56XX, CN55XX, and CN54XX.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:      Port to rate limit</span>
<span class="cm"> * @packets_s: Maximum packet/sec</span>
<span class="cm"> * @burst:     Maximum number of packets to burst in a row before rate</span>
<span class="cm"> *                  limiting cuts in.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success, negative on failure</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_pko_rate_limit_packets</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packets_s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">burst</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Rate limit a PKO port to a max bits/sec. This function is only</span>
<span class="cm"> * supported on CN57XX, CN56XX, CN55XX, and CN54XX.</span>
<span class="cm"> *</span>
<span class="cm"> * @port:   Port to rate limit</span>
<span class="cm"> * @bits_s: PKO rate limit in bits/sec</span>
<span class="cm"> * @burst:  Maximum number of bits to burst before rate</span>
<span class="cm"> *               limiting cuts in.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns Zero on success, negative on failure</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cvmx_pko_rate_limit_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">bits_s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">burst</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __CVMX_PKO_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
