<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › xtensa › include › asm › pgtable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pgtable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/asm-xtensa/pgtable.h</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 - 2007 Tensilica Inc.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _XTENSA_PGTABLE_H</span>
<span class="cp">#define _XTENSA_PGTABLE_H</span>

<span class="cp">#include &lt;asm-generic/pgtable-nopmd.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * We only use two ring levels, user and kernel space.</span>
<span class="cm"> */</span>

<span class="cp">#define USER_RING		1	</span><span class="cm">/* user ring level */</span><span class="cp"></span>
<span class="cp">#define KERNEL_RING		0	</span><span class="cm">/* kernel ring level */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The Xtensa architecture port of Linux has a two-level page table system,</span>
<span class="cm"> * i.e. the logical three-level Linux page table layout is folded.</span>
<span class="cm"> * Each task has the following memory page tables:</span>
<span class="cm"> *</span>
<span class="cm"> *   PGD table (page directory), ie. 3rd-level page table:</span>
<span class="cm"> *	One page (4 kB) of 1024 (PTRS_PER_PGD) pointers to PTE tables</span>
<span class="cm"> *	(Architectures that don&#39;t have the PMD folded point to the PMD tables)</span>
<span class="cm"> *</span>
<span class="cm"> *	The pointer to the PGD table for a given task can be retrieved from</span>
<span class="cm"> *	the task structure (struct task_struct*) t, e.g. current():</span>
<span class="cm"> *	  (t-&gt;mm ? t-&gt;mm : t-&gt;active_mm)-&gt;pgd</span>
<span class="cm"> *</span>
<span class="cm"> *   PMD tables (page middle-directory), ie. 2nd-level page tables:</span>
<span class="cm"> *	Absent for the Xtensa architecture (folded, PTRS_PER_PMD == 1).</span>
<span class="cm"> *</span>
<span class="cm"> *   PTE tables (page table entry), ie. 1st-level page tables:</span>
<span class="cm"> *	One page (4 kB) of 1024 (PTRS_PER_PTE) PTEs with a special PTE</span>
<span class="cm"> *	invalid_pte_table for absent mappings.</span>
<span class="cm"> *</span>
<span class="cm"> * The individual pages are 4 kB big with special pages for the empty_zero_page.</span>
<span class="cm"> */</span>

<span class="cp">#define PGDIR_SHIFT	22</span>
<span class="cp">#define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="cp">#define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>

<span class="cm">/*</span>
<span class="cm"> * Entries per page directory level: we use two-level, so</span>
<span class="cm"> * we don&#39;t really have any PMD directory physically.</span>
<span class="cm"> */</span>
<span class="cp">#define PTRS_PER_PTE		1024</span>
<span class="cp">#define PTRS_PER_PTE_SHIFT	10</span>
<span class="cp">#define PTRS_PER_PGD		1024</span>
<span class="cp">#define PGD_ORDER		0</span>
<span class="cp">#define USER_PTRS_PER_PGD	(TASK_SIZE/PGDIR_SIZE)</span>
<span class="cp">#define FIRST_USER_ADDRESS	0</span>
<span class="cp">#define FIRST_USER_PGD_NR	(FIRST_USER_ADDRESS &gt;&gt; PGDIR_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Virtual memory area. We keep a distance to other memory regions to be</span>
<span class="cm"> * on the safe side. We also use this area for cache aliasing.</span>
<span class="cm"> */</span>

<span class="cp">#define VMALLOC_START		0xC0000000</span>
<span class="cp">#define VMALLOC_END		0xC7FEFFFF</span>
<span class="cp">#define TLBTEMP_BASE_1		0xC7FF0000</span>
<span class="cp">#define TLBTEMP_BASE_2		0xC7FF8000</span>

<span class="cm">/*</span>
<span class="cm"> * Xtensa Linux config PTE layout (when present):</span>
<span class="cm"> *	31-12:	PPN</span>
<span class="cm"> *	11-6:	Software</span>
<span class="cm"> *	5-4:	RING</span>
<span class="cm"> *	3-0:	CA</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to the Alpha and MIPS ports, we need to keep track of the ref</span>
<span class="cm"> * and mod bits in software.  We have a software &quot;you can read</span>
<span class="cm"> * from this page&quot; bit, and a hardware one which actually lets the</span>
<span class="cm"> * process read from the page.  On the same token we have a software</span>
<span class="cm"> * writable bit and the real hardware one which actually lets the</span>
<span class="cm"> * process write to the page.</span>
<span class="cm"> *</span>
<span class="cm"> * See further below for PTE layout for swapped-out pages.</span>
<span class="cm"> */</span>

<span class="cp">#define _PAGE_HW_EXEC		(1&lt;&lt;0)	</span><span class="cm">/* hardware: page is executable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_HW_WRITE		(1&lt;&lt;1)	</span><span class="cm">/* hardware: page is writable */</span><span class="cp"></span>

<span class="cp">#define _PAGE_FILE		(1&lt;&lt;1)	</span><span class="cm">/* non-linear mapping, if !present */</span><span class="cp"></span>
<span class="cp">#define _PAGE_PROTNONE		(3&lt;&lt;0)	</span><span class="cm">/* special case for VM_PROT_NONE */</span><span class="cp"></span>

<span class="cm">/* None of these cache modes include MP coherency:  */</span>
<span class="cp">#define _PAGE_CA_BYPASS		(0&lt;&lt;2)	</span><span class="cm">/* bypass, non-speculative */</span><span class="cp"></span>
<span class="cp">#define _PAGE_CA_WB		(1&lt;&lt;2)	</span><span class="cm">/* write-back */</span><span class="cp"></span>
<span class="cp">#define _PAGE_CA_WT		(2&lt;&lt;2)	</span><span class="cm">/* write-through */</span><span class="cp"></span>
<span class="cp">#define _PAGE_CA_MASK		(3&lt;&lt;2)</span>
<span class="cp">#define _PAGE_INVALID		(3&lt;&lt;2)</span>

<span class="cp">#define _PAGE_USER		(1&lt;&lt;4)	</span><span class="cm">/* user access (ring=1) */</span><span class="cp"></span>

<span class="cm">/* Software */</span>
<span class="cp">#define _PAGE_WRITABLE_BIT	6</span>
<span class="cp">#define _PAGE_WRITABLE		(1&lt;&lt;6)	</span><span class="cm">/* software: page writable */</span><span class="cp"></span>
<span class="cp">#define _PAGE_DIRTY		(1&lt;&lt;7)	</span><span class="cm">/* software: page dirty */</span><span class="cp"></span>
<span class="cp">#define _PAGE_ACCESSED		(1&lt;&lt;8)	</span><span class="cm">/* software: page accessed (read) */</span><span class="cp"></span>

<span class="cm">/* On older HW revisions, we always have to set bit 0 */</span>
<span class="cp">#if XCHAL_HW_VERSION_MAJOR &lt; 2000</span>
<span class="cp"># define _PAGE_VALID		(1&lt;&lt;0)</span>
<span class="cp">#else</span>
<span class="cp"># define _PAGE_VALID		0</span>
<span class="cp">#endif</span>

<span class="cp">#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)</span>
<span class="cp">#define _PAGE_PRESENT	(_PAGE_VALID | _PAGE_CA_WB | _PAGE_ACCESSED)</span>

<span class="cp">#ifdef CONFIG_MMU</span>

<span class="cp">#define PAGE_NONE	   __pgprot(_PAGE_INVALID | _PAGE_USER | _PAGE_PROTNONE)</span>
<span class="cp">#define PAGE_COPY	   __pgprot(_PAGE_PRESENT | _PAGE_USER)</span>
<span class="cp">#define PAGE_COPY_EXEC	   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_HW_EXEC)</span>
<span class="cp">#define PAGE_READONLY	   __pgprot(_PAGE_PRESENT | _PAGE_USER)</span>
<span class="cp">#define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_HW_EXEC)</span>
<span class="cp">#define PAGE_SHARED	   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_WRITABLE)</span>
<span class="cp">#define PAGE_SHARED_EXEC \</span>
<span class="cp">	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_WRITABLE | _PAGE_HW_EXEC)</span>
<span class="cp">#define PAGE_KERNEL	   __pgprot(_PAGE_PRESENT | _PAGE_HW_WRITE)</span>
<span class="cp">#define PAGE_KERNEL_EXEC   __pgprot(_PAGE_PRESENT|_PAGE_HW_WRITE|_PAGE_HW_EXEC)</span>

<span class="cp">#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
<span class="cp"># define _PAGE_DIRECTORY (_PAGE_VALID | _PAGE_ACCESSED)</span>
<span class="cp">#else</span>
<span class="cp"># define _PAGE_DIRECTORY (_PAGE_VALID | _PAGE_ACCESSED | _PAGE_CA_WB)</span>
<span class="cp">#endif</span>

<span class="cp">#else </span><span class="cm">/* no mmu */</span><span class="cp"></span>

<span class="cp"># define PAGE_NONE       __pgprot(0)</span>
<span class="cp"># define PAGE_SHARED     __pgprot(0)</span>
<span class="cp"># define PAGE_COPY       __pgprot(0)</span>
<span class="cp"># define PAGE_READONLY   __pgprot(0)</span>
<span class="cp"># define PAGE_KERNEL     __pgprot(0)</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * On certain configurations of Xtensa MMUs (eg. the initial Linux config),</span>
<span class="cm"> * the MMU can&#39;t do page protection for execute, and considers that the same as</span>
<span class="cm"> * read.  Also, write permissions may imply read permissions.</span>
<span class="cm"> * What follows is the closest we can get by reasonable means..</span>
<span class="cm"> * See linux/mm/mmap.c for protection_map[] array that uses these definitions.</span>
<span class="cm"> */</span>
<span class="cp">#define __P000	PAGE_NONE		</span><span class="cm">/* private --- */</span><span class="cp"></span>
<span class="cp">#define __P001	PAGE_READONLY		</span><span class="cm">/* private --r */</span><span class="cp"></span>
<span class="cp">#define __P010	PAGE_COPY		</span><span class="cm">/* private -w- */</span><span class="cp"></span>
<span class="cp">#define __P011	PAGE_COPY		</span><span class="cm">/* private -wr */</span><span class="cp"></span>
<span class="cp">#define __P100	PAGE_READONLY_EXEC	</span><span class="cm">/* private x-- */</span><span class="cp"></span>
<span class="cp">#define __P101	PAGE_READONLY_EXEC	</span><span class="cm">/* private x-r */</span><span class="cp"></span>
<span class="cp">#define __P110	PAGE_COPY_EXEC		</span><span class="cm">/* private xw- */</span><span class="cp"></span>
<span class="cp">#define __P111	PAGE_COPY_EXEC		</span><span class="cm">/* private xwr */</span><span class="cp"></span>

<span class="cp">#define __S000	PAGE_NONE		</span><span class="cm">/* shared  --- */</span><span class="cp"></span>
<span class="cp">#define __S001	PAGE_READONLY		</span><span class="cm">/* shared  --r */</span><span class="cp"></span>
<span class="cp">#define __S010	PAGE_SHARED		</span><span class="cm">/* shared  -w- */</span><span class="cp"></span>
<span class="cp">#define __S011	PAGE_SHARED		</span><span class="cm">/* shared  -wr */</span><span class="cp"></span>
<span class="cp">#define __S100	PAGE_READONLY_EXEC	</span><span class="cm">/* shared  x-- */</span><span class="cp"></span>
<span class="cp">#define __S101	PAGE_READONLY_EXEC	</span><span class="cm">/* shared  x-r */</span><span class="cp"></span>
<span class="cp">#define __S110	PAGE_SHARED_EXEC	</span><span class="cm">/* shared  xw- */</span><span class="cp"></span>
<span class="cp">#define __S111	PAGE_SHARED_EXEC	</span><span class="cm">/* shared  xwr */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cp">#define pte_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pte %08lx.\n&quot;, __FILE__, __LINE__, pte_val(e))</span>
<span class="cp">#define pgd_ERROR(e) \</span>
<span class="cp">	printk(&quot;%s:%d: bad pgd entry %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">empty_zero_page</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="cp">#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="n">pgd_t</span> <span class="n">swapper_pg_dir</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pgd_t</span><span class="p">)];</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pgtable_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># define swapper_pg_dir NULL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgtable_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The pmd contains the kernel virtual address of the pte page.</span>
<span class="cm"> */</span>
<span class="cp">#define pmd_page_vaddr(pmd) ((unsigned long)(pmd_val(pmd) &amp; PAGE_MASK))</span>
<span class="cp">#define pmd_page(pmd) virt_to_page(pmd_val(pmd))</span>

<span class="cm">/*</span>
<span class="cm"> * pte status.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_none(pte)	 (pte_val(pte) == _PAGE_INVALID)</span>
<span class="cp">#define pte_present(pte)						\</span>
<span class="cp">	(((pte_val(pte) &amp; _PAGE_CA_MASK) != _PAGE_INVALID)		\</span>
<span class="cp">	 || ((pte_val(pte) &amp; _PAGE_PROTNONE) == _PAGE_PROTNONE))</span>
<span class="cp">#define pte_clear(mm,addr,ptep)						\</span>
<span class="cp">	do { update_pte(ptep, __pte(_PAGE_INVALID)); } while(0)</span>

<span class="cp">#define pmd_none(pmd)	 (!pmd_val(pmd))</span>
<span class="cp">#define pmd_present(pmd) (pmd_val(pmd) &amp; PAGE_MASK)</span>
<span class="cp">#define pmd_bad(pmd)	 (pmd_val(pmd) &amp; ~PAGE_MASK)</span>
<span class="cp">#define pmd_clear(pmdp)	 do { set_pmd(pmdp, __pmd(0)); } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_write</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_WRITABLE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_dirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_young</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_file</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_FILE</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pte_special</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_wrprotect</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>	
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_WRITABLE</span> <span class="o">|</span> <span class="n">_PAGE_HW_WRITE</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkclean</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_PAGE_DIRTY</span> <span class="o">|</span> <span class="n">_PAGE_HW_WRITE</span><span class="p">);</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkold</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkdirty</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_DIRTY</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkyoung</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_ACCESSED</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">|=</span> <span class="n">_PAGE_WRITABLE</span><span class="p">;</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_mkspecial</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">pte</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion functions: convert a page and protection to a page entry,</span>
<span class="cm"> * and a page entry and page directory to the page they refer to.</span>
<span class="cm"> */</span>

<span class="cp">#define pte_pfn(pte)		(pte_val(pte) &gt;&gt; PAGE_SHIFT)</span>
<span class="cp">#define pte_same(a,b)		(pte_val(a) == pte_val(b))</span>
<span class="cp">#define pte_page(x)		pfn_to_page(pte_pfn(x))</span>
<span class="cp">#define pfn_pte(pfn, prot)	__pte(((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>
<span class="cp">#define mk_pte(page, prot)	pfn_pte(page_to_pfn(page), prot)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">pte_modify</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pte</span><span class="p">((</span><span class="n">pte_val</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_PAGE_CHG_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">pgprot_val</span><span class="p">(</span><span class="n">newprot</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Certain architectures need to do special things when pte&#39;s</span>
<span class="cm"> * within a page table are directly modified.  Thus, the following</span>
<span class="cm"> * hook is made available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="n">pteval</span><span class="p">;</span>
<span class="cp">#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;dhwb %0, 0&quot;</span> <span class="o">::</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="n">ptep</span><span class="p">));</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">update_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">set_pmd</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmdval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pmdp</span> <span class="o">=</span> <span class="n">pmdval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ptep_test_and_clear_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
    			  <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_young</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">update_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span>
<span class="nf">ptep_get_and_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ptep_set_wrprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
  	<span class="n">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
  	<span class="n">update_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* to find an entry in a kernel page-table-directory */</span>
<span class="cp">#define pgd_offset_k(address)	pgd_offset(&amp;init_mm, address)</span>

<span class="cm">/* to find an entry in a page-table-directory */</span>
<span class="cp">#define pgd_offset(mm,address)	((mm)-&gt;pgd + pgd_index(address))</span>

<span class="cp">#define pgd_index(address)	((address) &gt;&gt; PGDIR_SHIFT)</span>

<span class="cm">/* Find an entry in the second-level page table.. */</span>
<span class="cp">#define pmd_offset(dir,address) ((pmd_t*)(dir))</span>

<span class="cm">/* Find an entry in the third-level page table.. */</span>
<span class="cp">#define pte_index(address)	(((address) &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))</span>
<span class="cp">#define pte_offset_kernel(dir,addr) 					\</span>
<span class="cp">	((pte_t*) pmd_page_vaddr(*(dir)) + pte_index(addr))</span>
<span class="cp">#define pte_offset_map(dir,addr)	pte_offset_kernel((dir),(addr))</span>
<span class="cp">#define pte_unmap(pte)		do { } while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * Encode and decode a swap entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Format of swap pte:</span>
<span class="cm"> *  bit	   0	   MBZ</span>
<span class="cm"> *  bit	   1	   page-file (must be zero)</span>
<span class="cm"> *  bits   2 -  3  page hw access mode (must be 11: _PAGE_INVALID)</span>
<span class="cm"> *  bits   4 -  5  ring protection (must be 01: _PAGE_USER)</span>
<span class="cm"> *  bits   6 - 10  swap type (5 bits -&gt; 32 types)</span>
<span class="cm"> *  bits  11 - 31  swap offset / PAGE_SIZE (21 bits -&gt; 8GB)</span>
<span class="cm"> </span>
<span class="cm"> * Format of file pte:</span>
<span class="cm"> *  bit	   0	   MBZ</span>
<span class="cm"> *  bit	   1	   page-file (must be one: _PAGE_FILE)</span>
<span class="cm"> *  bits   2 -  3  page hw access mode (must be 11: _PAGE_INVALID)</span>
<span class="cm"> *  bits   4 -  5  ring protection (must be 01: _PAGE_USER)</span>
<span class="cm"> *  bits   6 - 31  file offset / PAGE_SIZE</span>
<span class="cm"> */</span>

<span class="cp">#define __swp_type(entry)	(((entry).val &gt;&gt; 6) &amp; 0x1f)</span>
<span class="cp">#define __swp_offset(entry)	((entry).val &gt;&gt; 11)</span>
<span class="cp">#define __swp_entry(type,offs)	\</span>
<span class="cp">	((swp_entry_t) {((type) &lt;&lt; 6) | ((offs) &lt;&lt; 11) | _PAGE_INVALID})</span>
<span class="cp">#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })</span>
<span class="cp">#define __swp_entry_to_pte(x)	((pte_t) { (x).val })</span>

<span class="cp">#define PTE_FILE_MAX_BITS	28</span>
<span class="cp">#define pte_to_pgoff(pte)	(pte_val(pte) &gt;&gt; 4)</span>
<span class="cp">#define pgoff_to_pte(off)	\</span>
<span class="cp">	((pte_t) { ((off) &lt;&lt; 4) | _PAGE_INVALID | _PAGE_FILE })</span>

<span class="cp">#endif </span><span class="cm">/*  !defined (__ASSEMBLY__) */</span><span class="cp"></span>


<span class="cp">#ifdef __ASSEMBLY__</span>

<span class="cm">/* Assembly macro _PGD_INDEX is the same as C pgd_index(unsigned long),</span>
<span class="cm"> *                _PGD_OFFSET as C pgd_offset(struct mm_struct*, unsigned long),</span>
<span class="cm"> *                _PMD_OFFSET as C pmd_offset(pgd_t*, unsigned long)</span>
<span class="cm"> *                _PTE_OFFSET as C pte_offset(pmd_t*, unsigned long)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: We require an additional temporary register which can be the same as</span>
<span class="cm"> *       the register that holds the address.</span>
<span class="cm"> *</span>
<span class="cm"> * ((pte_t*) ((unsigned long)(pmd_val(*pmd) &amp; PAGE_MASK)) + pte_index(addr))</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define _PGD_INDEX(rt,rs)	extui	rt, rs, PGDIR_SHIFT, 32-PGDIR_SHIFT</span>
<span class="cp">#define _PTE_INDEX(rt,rs)	extui	rt, rs, PAGE_SHIFT, PTRS_PER_PTE_SHIFT</span>

<span class="cp">#define _PGD_OFFSET(mm,adr,tmp)		l32i	mm, mm, MM_PGD;		\</span>
<span class="cp">					_PGD_INDEX(tmp, adr);		\</span>
<span class="cp">					addx4	mm, tmp, mm</span>

<span class="cp">#define _PTE_OFFSET(pmd,adr,tmp)	_PTE_INDEX(tmp, adr);		\</span>
<span class="cp">					srli	pmd, pmd, PAGE_SHIFT;	\</span>
<span class="cp">					slli	pmd, pmd, PAGE_SHIFT;	\</span>
<span class="cp">					addx4	pmd, tmp, pmd</span>

<span class="cp">#else</span>

<span class="cp">#define kern_addr_valid(addr)	(1)</span>

<span class="k">extern</span>  <span class="kt">void</span> <span class="n">update_mmu_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * remap a physical page `pfn&#39; of size `size&#39; with page protection `prot&#39;</span>
<span class="cm"> * into virtual address `from&#39;</span>
<span class="cm"> */</span>

<span class="cp">#define io_remap_pfn_range(vma,from,pfn,size,prot) \</span>
<span class="cp">                remap_pfn_range(vma, from, pfn, size, prot)</span>

<span class="k">typedef</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_addr_t</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !defined (__ASSEMBLY__) */</span><span class="cp"></span>

<span class="cp">#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG</span>
<span class="cp">#define __HAVE_ARCH_PTEP_GET_AND_CLEAR</span>
<span class="cp">#define __HAVE_ARCH_PTEP_SET_WRPROTECT</span>
<span class="cp">#define __HAVE_ARCH_PTEP_MKDIRTY</span>
<span class="cp">#define __HAVE_ARCH_PTE_SAME</span>

<span class="cp">#include &lt;asm-generic/pgtable.h&gt;</span>

<span class="cp">#endif </span><span class="cm">/* _XTENSA_PGTABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
