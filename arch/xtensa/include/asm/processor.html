<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › xtensa › include › asm › processor.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>processor.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * include/asm-xtensa/processor.h</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 - 2005 Tensilica Inc.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _XTENSA_PROCESSOR_H</span>
<span class="cp">#define _XTENSA_PROCESSOR_H</span>

<span class="cp">#include &lt;variant/core.h&gt;</span>
<span class="cp">#include &lt;platform/hardware.h&gt;</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;asm/regs.h&gt;</span>

<span class="cm">/* Assertions. */</span>

<span class="cp">#if (XCHAL_HAVE_WINDOWED != 1)</span>
<span class="cp"># error Linux requires the Xtensa Windowed Registers Option.</span>
<span class="cp">#endif</span>

<span class="cp">#define ARCH_SLAB_MINALIGN	XCHAL_DATA_WIDTH</span>

<span class="cm">/*</span>
<span class="cm"> * User space process size: 1 GB.</span>
<span class="cm"> * Windowed call ABI requires caller and callee to be located within the same</span>
<span class="cm"> * 1 GB region. The C compiler places trampoline code on the stack for sources</span>
<span class="cm"> * that take the address of a nested C function (a feature used by glibc), so</span>
<span class="cm"> * the 1 GB requirement applies to the stack as well.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cp">#define TASK_SIZE	__XTENSA_UL_CONST(0x40000000)</span>
<span class="cp">#else</span>
<span class="cp">#define TASK_SIZE	(PLATFORM_DEFAULT_MEM_START + PLATFORM_DEFAULT_MEM_SIZE)</span>
<span class="cp">#endif</span>

<span class="cp">#define STACK_TOP	TASK_SIZE</span>
<span class="cp">#define STACK_TOP_MAX	STACK_TOP</span>

<span class="cm">/*</span>
<span class="cm"> * General exception cause assigned to debug exceptions. Debug exceptions go</span>
<span class="cm"> * to their own vector, rather than the general exception vectors (user,</span>
<span class="cm"> * kernel, double); and their specific causes are reported via DEBUGCAUSE</span>
<span class="cm"> * rather than EXCCAUSE.  However it is sometimes convenient to redirect debug</span>
<span class="cm"> * exceptions to the general exception mechanism.  To do this, an otherwise</span>
<span class="cm"> * unused EXCCAUSE value was assigned to debug exceptions for this purpose.</span>
<span class="cm"> */</span>

<span class="cp">#define EXCCAUSE_MAPPED_DEBUG	63</span>

<span class="cm">/*</span>
<span class="cm"> * We use DEPC also as a flag to distinguish between double and regular</span>
<span class="cm"> * exceptions. For performance reasons, DEPC might contain the value of</span>
<span class="cm"> * EXCCAUSE for regular exceptions, so we use this definition to mark a</span>
<span class="cm"> * valid double exception address.</span>
<span class="cm"> * (Note: We use it in bgeui, so it should be 64, 128, or 256)</span>
<span class="cm"> */</span>

<span class="cp">#define VALID_DOUBLE_EXCEPTION_ADDRESS	64</span>

<span class="cm">/* LOCKLEVEL defines the interrupt level that masks all</span>
<span class="cm"> * general-purpose interrupts.</span>
<span class="cm"> */</span>
<span class="cp">#define LOCKLEVEL 1</span>

<span class="cm">/* WSBITS and WBBITS are the width of the WINDOWSTART and WINDOWBASE</span>
<span class="cm"> * registers</span>
<span class="cm"> */</span>
<span class="cp">#define WSBITS  (XCHAL_NUM_AREGS / 4)      </span><span class="cm">/* width of WINDOWSTART in bits */</span><span class="cp"></span>
<span class="cp">#define WBBITS  (XCHAL_NUM_AREGS_LOG2 - 2) </span><span class="cm">/* width of WINDOWBASE in bits */</span><span class="cp"></span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* Build a valid return address for the specified call winsize.</span>
<span class="cm"> * winsize must be 1 (call4), 2 (call8), or 3 (call12)</span>
<span class="cm"> */</span>
<span class="cp">#define MAKE_RA_FOR_CALL(ra,ws)   (((ra) &amp; 0x3fffffff) | (ws) &lt;&lt; 30)</span>

<span class="cm">/* Convert return address to a valid pc</span>
<span class="cm"> * Note: We assume that the stack pointer is in the same 1GB ranges as the ra</span>
<span class="cm"> */</span>
<span class="cp">#define MAKE_PC_FROM_RA(ra,sp)    (((ra) &amp; 0x3fffffff) | ((sp) &amp; 0xc0000000))</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mm_segment_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">thread_struct</span> <span class="p">{</span>

	<span class="cm">/* kernel&#39;s return address and stack pointer for context switching */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra</span><span class="p">;</span> <span class="cm">/* kernel&#39;s a0: return address and window call size */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">;</span> <span class="cm">/* kernel&#39;s a1: stack pointer */</span>

	<span class="n">mm_segment_t</span> <span class="n">current_ds</span><span class="p">;</span>    <span class="cm">/* see uaccess.h for example uses */</span>

	<span class="cm">/* struct xtensa_cpuinfo info; */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bad_vaddr</span><span class="p">;</span> <span class="cm">/* last user fault */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bad_uaddr</span><span class="p">;</span> <span class="cm">/* last kernel fault accessing user space */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ibreak</span><span class="p">[</span><span class="n">XCHAL_NUM_IBREAK</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbreaka</span><span class="p">[</span><span class="n">XCHAL_NUM_DBREAK</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dbreakc</span><span class="p">[</span><span class="n">XCHAL_NUM_DBREAK</span><span class="p">];</span>

	<span class="cm">/* Make structure 16 bytes aligned. */</span>
	<span class="kt">int</span> <span class="n">align</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Default implementation of macro that returns current</span>
<span class="cm"> * instruction pointer (&quot;program counter&quot;).</span>
<span class="cm"> */</span>
<span class="cp">#define current_text_addr()  ({ __label__ _l; _l: &amp;&amp;_l;})</span>


<span class="cm">/* This decides where the kernel will search for a free chunk of vm</span>
<span class="cm"> * space during mmap&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_UNMAPPED_BASE	(TASK_SIZE / 2)</span>

<span class="cp">#define INIT_THREAD  \</span>
<span class="cp">{									\</span>
<span class="cp">	ra:		0, 						\</span>
<span class="cp">	sp:		sizeof(init_stack) + (long) &amp;init_stack,	\</span>
<span class="cp">	current_ds:	{0},						\</span>
<span class="cp">	</span><span class="cm">/*info:		{0}, */</span><span class="cp">						\</span>
<span class="cp">	bad_vaddr:	0,						\</span>
<span class="cp">	bad_uaddr:	0,						\</span>
<span class="cp">	error_code:	0,						\</span>
<span class="cp">}</span>


<span class="cm">/*</span>
<span class="cm"> * Do necessary setup to start up a newly executed thread.</span>
<span class="cm"> * Note: We set-up ps as if we did a call4 to the new pc.</span>
<span class="cm"> *       set_thread_state in signal.c depends on it.</span>
<span class="cm"> */</span>
<span class="cp">#define USER_PS_VALUE ((1 &lt;&lt; PS_WOE_BIT) |				\</span>
<span class="cp">                       (1 &lt;&lt; PS_CALLINC_SHIFT) |			\</span>
<span class="cp">                       (USER_RING &lt;&lt; PS_RING_SHIFT) |			\</span>
<span class="cp">                       (1 &lt;&lt; PS_UM_BIT) |				\</span>
<span class="cp">                       (1 &lt;&lt; PS_EXCM_BIT))</span>

<span class="cm">/* Clearing a0 terminates the backtrace. */</span>
<span class="cp">#define start_thread(regs, new_pc, new_sp) \</span>
<span class="cp">	regs-&gt;pc = new_pc; \</span>
<span class="cp">	regs-&gt;ps = USER_PS_VALUE; \</span>
<span class="cp">	regs-&gt;areg[1] = new_sp; \</span>
<span class="cp">	regs-&gt;areg[0] = 0; \</span>
<span class="cp">	regs-&gt;wmask = 1; \</span>
<span class="cp">	regs-&gt;depc = 0; \</span>
<span class="cp">	regs-&gt;windowbase = 0; \</span>
<span class="cp">	regs-&gt;windowstart = 1;</span>

<span class="cm">/* Forward declaration */</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="cm">/* Free all resources held by a thread. */</span>
<span class="cp">#define release_thread(thread) do { } while(0)</span>

<span class="cm">/* Create a kernel thread without removing it from tasklists */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Copy and release all segment info associated with a VM */</span>
<span class="cp">#define copy_segments(p, mm)	do { } while(0)</span>
<span class="cp">#define release_segments(mm)	do { } while(0)</span>
<span class="cp">#define forget_segments()	do { } while (0)</span>

<span class="cp">#define thread_saved_pc(tsk)	(task_pt_regs(tsk)-&gt;pc)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#define KSTK_EIP(tsk)		(task_pt_regs(tsk)-&gt;pc)</span>
<span class="cp">#define KSTK_ESP(tsk)		(task_pt_regs(tsk)-&gt;areg[1])</span>

<span class="cp">#define cpu_relax()  barrier()</span>

<span class="cm">/* Special register access. */</span>

<span class="cp">#define WSR(v,sr) __asm__ __volatile__ (&quot;wsr %0,&quot;__stringify(sr) :: &quot;a&quot;(v));</span>
<span class="cp">#define RSR(v,sr) __asm__ __volatile__ (&quot;rsr %0,&quot;__stringify(sr) : &quot;=a&quot;(v));</span>

<span class="cp">#define set_sr(x,sr) ({unsigned int v=(unsigned int)x; WSR(v,sr);})</span>
<span class="cp">#define get_sr(sr) ({unsigned int v; RSR(v,sr); v; })</span>

<span class="cp">#endif	</span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* _XTENSA_PROCESSOR_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
