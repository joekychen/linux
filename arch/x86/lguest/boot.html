<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › lguest › boot.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>boot.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*P:010</span>
<span class="cm"> * A hypervisor allows multiple Operating Systems to run on a single machine.</span>
<span class="cm"> * To quote David Wheeler: &quot;Any problem in computer science can be solved with</span>
<span class="cm"> * another layer of indirection.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * We keep things simple in two ways.  First, we start with a normal Linux</span>
<span class="cm"> * kernel and insert a module (lg.ko) which allows us to run other Linux</span>
<span class="cm"> * kernels the same way we&#39;d run processes.  We call the first kernel the Host,</span>
<span class="cm"> * and the others the Guests.  The program which sets up and configures Guests</span>
<span class="cm"> * (such as the example in Documentation/virtual/lguest/lguest.c) is called the</span>
<span class="cm"> * Launcher.</span>
<span class="cm"> *</span>
<span class="cm"> * Secondly, we only run specially modified Guests, not normal kernels: setting</span>
<span class="cm"> * CONFIG_LGUEST_GUEST to &quot;y&quot; compiles this file into the kernel so it knows</span>
<span class="cm"> * how to be a Guest at boot time.  This means that you can use the same kernel</span>
<span class="cm"> * you boot normally (ie. as a Host) as a Guest.</span>
<span class="cm"> *</span>
<span class="cm"> * These Guests know that they cannot do privileged operations, such as disable</span>
<span class="cm"> * interrupts, and that they have to ask the Host to do such things explicitly.</span>
<span class="cm"> * This file consists of all the replacements for such low-level native</span>
<span class="cm"> * hardware operations: these special Guest versions call the Host.</span>
<span class="cm"> *</span>
<span class="cm"> * So how does the kernel know it&#39;s a Guest?  We&#39;ll see that later, but let&#39;s</span>
<span class="cm"> * just say that we end up here where we replace the native functions various</span>
<span class="cm"> * &quot;paravirt&quot; structures with our Guest versions, then boot like normal.</span>
<span class="cm">:*/</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006, Rusty Russell &lt;rusty@rustcorp.com.au&gt; IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/start_kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/screen_info.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/lguest.h&gt;</span>
<span class="cp">#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_console.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/lguest.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/stackprotector.h&gt;</span>
<span class="cp">#include &lt;asm/reboot.h&gt;		</span><span class="cm">/* for struct machine_ops */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/kvm_para.h&gt;</span>

<span class="cm">/*G:010</span>
<span class="cm"> * Welcome to the Guest!</span>
<span class="cm"> *</span>
<span class="cm"> * The Guest in our tale is a simple creature: identical to the Host but</span>
<span class="cm"> * behaving in simplified but equivalent ways.  In particular, the Guest is the</span>
<span class="cm"> * same kernel as the Host (or at least, built from the same source code).</span>
<span class="cm">:*/</span>

<span class="k">struct</span> <span class="n">lguest_data</span> <span class="n">lguest_data</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">hcall_status</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">LHCALL_RING_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">noirq_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">lguest_noirq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">noirq_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">lguest_noirq_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kernel_address</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blocked_interrupts</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span> <span class="cm">/* Block timer interrupts */</span>
	<span class="p">.</span><span class="n">syscall_vec</span> <span class="o">=</span> <span class="n">SYSCALL_VECTOR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*G:037</span>
<span class="cm"> * async_hcall() is pretty simple: I&#39;m quite proud of it really.  We have a</span>
<span class="cm"> * ring buffer of stored hypercalls which the Host will run though next time we</span>
<span class="cm"> * do a normal hypercall.  Each entry in the ring has 5 slots for the hypercall</span>
<span class="cm"> * arguments, and a &quot;hcall_status&quot; word which is 0 if the call is ready to go,</span>
<span class="cm"> * and 255 once the Host has finished with it.</span>
<span class="cm"> *</span>
<span class="cm"> * If we come around to a slot which hasn&#39;t been finished, then the table is</span>
<span class="cm"> * full and we just make the hypercall directly.  This has the nice side</span>
<span class="cm"> * effect of causing the Host to run all the stored calls in the ring buffer</span>
<span class="cm"> * which empties it for next time!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_hcall</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note: This code assumes we&#39;re uniprocessor. */</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_call</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable interrupts if not already disabled: we don&#39;t want an</span>
<span class="cm">	 * interrupt handler making a hypercall while we&#39;re already doing</span>
<span class="cm">	 * one!</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lguest_data</span><span class="p">.</span><span class="n">hcall_status</span><span class="p">[</span><span class="n">next_call</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Table full, so do normal hcall which will flush table. */</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcalls</span><span class="p">[</span><span class="n">next_call</span><span class="p">].</span><span class="n">arg0</span> <span class="o">=</span> <span class="n">call</span><span class="p">;</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcalls</span><span class="p">[</span><span class="n">next_call</span><span class="p">].</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcalls</span><span class="p">[</span><span class="n">next_call</span><span class="p">].</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcalls</span><span class="p">[</span><span class="n">next_call</span><span class="p">].</span><span class="n">arg3</span> <span class="o">=</span> <span class="n">arg3</span><span class="p">;</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcalls</span><span class="p">[</span><span class="n">next_call</span><span class="p">].</span><span class="n">arg4</span> <span class="o">=</span> <span class="n">arg4</span><span class="p">;</span>
		<span class="cm">/* Arguments must all be written before we mark it to go */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">lguest_data</span><span class="p">.</span><span class="n">hcall_status</span><span class="p">[</span><span class="n">next_call</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">next_call</span> <span class="o">==</span> <span class="n">LHCALL_RING_SIZE</span><span class="p">)</span>
			<span class="n">next_call</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*G:035</span>
<span class="cm"> * Notice the lazy_hcall() above, rather than hcall().  This is our first real</span>
<span class="cm"> * optimization trick!</span>
<span class="cm"> *</span>
<span class="cm"> * When lazy_mode is set, it means we&#39;re allowed to defer all hypercalls and do</span>
<span class="cm"> * them as a batch when lazy_mode is eventually turned off.  Because hypercalls</span>
<span class="cm"> * are reasonably expensive, batching them up makes sense.  For example, a</span>
<span class="cm"> * large munmap might update dozens of page table entries: that code calls</span>
<span class="cm"> * paravirt_enter_lazy_mmu(), does the dozen updates, then calls</span>
<span class="cm"> * lguest_leave_lazy_mode().</span>
<span class="cm"> *</span>
<span class="cm"> * So, when we&#39;re in lazy mode, we call async_hcall() to store the call for</span>
<span class="cm"> * future processing:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lazy_hcall1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_get_lazy_mode</span><span class="p">()</span> <span class="o">==</span> <span class="n">PARAVIRT_LAZY_NONE</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">async_hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* You can imagine what lazy_hcall2, 3 and 4 look like. :*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lazy_hcall2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_get_lazy_mode</span><span class="p">()</span> <span class="o">==</span> <span class="n">PARAVIRT_LAZY_NONE</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">async_hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lazy_hcall3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_get_lazy_mode</span><span class="p">()</span> <span class="o">==</span> <span class="n">PARAVIRT_LAZY_NONE</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">async_hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_PAE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lazy_hcall4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg1</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">paravirt_get_lazy_mode</span><span class="p">()</span> <span class="o">==</span> <span class="n">PARAVIRT_LAZY_NONE</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">async_hcall</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg4</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*G:036</span>
<span class="cm"> * When lazy mode is turned off, we issue the do-nothing hypercall to</span>
<span class="cm"> * flush any stored calls, and call the generic helper to reset the</span>
<span class="cm"> * per-cpu lazy mode variable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_leave_lazy_mmu_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_FLUSH_ASYNC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">paravirt_leave_lazy_mmu</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We also catch the end of context switch; we enter lazy mode for much of</span>
<span class="cm"> * that too, so again we need to flush here.</span>
<span class="cm"> *</span>
<span class="cm"> * (Technically, this is lazy CPU mode, and normally we&#39;re in lazy MMU</span>
<span class="cm"> * mode, but unlike Xen, lguest doesn&#39;t care about the difference).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_end_context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_FLUSH_ASYNC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">paravirt_end_context_switch</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*G:032</span>
<span class="cm"> * After that diversion we return to our first native-instruction</span>
<span class="cm"> * replacements: four functions for interrupt control.</span>
<span class="cm"> *</span>
<span class="cm"> * The simplest way of implementing these would be to have &quot;turn interrupts</span>
<span class="cm"> * off&quot; and &quot;turn interrupts on&quot; hypercalls.  Unfortunately, this is too slow:</span>
<span class="cm"> * these are by far the most commonly called functions of those we override.</span>
<span class="cm"> *</span>
<span class="cm"> * So instead we keep an &quot;irq_enabled&quot; field inside our &quot;struct lguest_data&quot;,</span>
<span class="cm"> * which the Guest can update with a single instruction.  The Host knows to</span>
<span class="cm"> * check there before it tries to deliver an interrupt.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * save_flags() is expected to return the processor state (ie. &quot;flags&quot;).  The</span>
<span class="cm"> * flags word contains all kind of stuff, but in practice Linux only cares</span>
<span class="cm"> * about the interrupt flag.  Our &quot;save_flags()&quot; just returns that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">save_fl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">irq_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Interrupts go off... */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lguest_data</span><span class="p">.</span><span class="n">irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let&#39;s pause a moment.  Remember how I said these are called so often?</span>
<span class="cm"> * Jeremy Fitzhardinge optimized them so hard early in 2009 that he had to</span>
<span class="cm"> * break some rules.  In particular, these functions are assumed to save their</span>
<span class="cm"> * own registers if they need to: normal C functions assume they can trash the</span>
<span class="cm"> * eax register.  To use normal C functions, we use</span>
<span class="cm"> * PV_CALLEE_SAVE_REGS_THUNK(), which pushes %eax onto the stack, calls the</span>
<span class="cm"> * C function, then restores it.</span>
<span class="cm"> */</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">save_fl</span><span class="p">);</span>
<span class="n">PV_CALLEE_SAVE_REGS_THUNK</span><span class="p">(</span><span class="n">irq_disable</span><span class="p">);</span>
<span class="cm">/*:*/</span>

<span class="cm">/* These are in i386_head.S */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lg_irq_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lg_restore_fl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*M:003</span>
<span class="cm"> * We could be more efficient in our checking of outstanding interrupts, rather</span>
<span class="cm"> * than using a branch.  One way would be to put the &quot;irq_enabled&quot; field in a</span>
<span class="cm"> * page by itself, and have the Host write-protect it when an interrupt comes</span>
<span class="cm"> * in when irqs are disabled.  There will then be a page fault as soon as</span>
<span class="cm"> * interrupts are re-enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * A better method is to implement soft interrupt disable generally for x86:</span>
<span class="cm"> * instead of disabling interrupts, we set a flag.  If an interrupt does come</span>
<span class="cm"> * in, we then disable them for real.  This is uncommon, so we could simply use</span>
<span class="cm"> * a hypercall for interrupt control and not worry about efficiency.</span>
<span class="cm">:*/</span>

<span class="cm">/*G:034</span>
<span class="cm"> * The Interrupt Descriptor Table (IDT).</span>
<span class="cm"> *</span>
<span class="cm"> * The IDT tells the processor what to do when an interrupt comes in.  Each</span>
<span class="cm"> * entry in the table is a 64-bit descriptor: this holds the privilege level,</span>
<span class="cm"> * address of the handler, and... well, who cares?  The Guest just asks the</span>
<span class="cm"> * Host to make the change anyway, because the Host controls the real IDT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_write_idt_entry</span><span class="p">(</span><span class="n">gate_desc</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">entrynum</span><span class="p">,</span> <span class="k">const</span> <span class="n">gate_desc</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The gate_desc structure is 8 bytes long: we hand it to the Host in</span>
<span class="cm">	 * two 32-bit chunks.  The whole 32-bit kernel used to hand descriptors</span>
<span class="cm">	 * around like this; typesafety wasn&#39;t a big concern in Linux&#39;s early</span>
<span class="cm">	 * years.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">g</span><span class="p">;</span>
	<span class="cm">/* Keep the local copy up to date. */</span>
	<span class="n">native_write_idt_entry</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">entrynum</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
	<span class="cm">/* Tell Host about this new entry. */</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_LOAD_IDT_ENTRY</span><span class="p">,</span> <span class="n">entrynum</span><span class="p">,</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Changing to a different IDT is very rare: we keep the IDT up-to-date every</span>
<span class="cm"> * time it is written, so we can simply loop through all entries and tell the</span>
<span class="cm"> * Host about them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_load_idt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">idt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_LOAD_IDT_ENTRY</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Global Descriptor Table.</span>
<span class="cm"> *</span>
<span class="cm"> * The Intel architecture defines another table, called the Global Descriptor</span>
<span class="cm"> * Table (GDT).  You tell the CPU where it is (and its size) using the &quot;lgdt&quot;</span>
<span class="cm"> * instruction, and then several other instructions refer to entries in the</span>
<span class="cm"> * table.  There are three entries which the Switcher needs, so the Host simply</span>
<span class="cm"> * controls the entire thing and the Guest asks it to make changes using the</span>
<span class="cm"> * LOAD_GDT hypercall.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the exactly like the IDT code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_load_gdt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">gdt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_LOAD_GDT_ENTRY</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gdt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">gdt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For a single GDT entry which changes, we simply change our copy and</span>
<span class="cm"> * then tell the host about it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_write_gdt_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entrynum</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_write_gdt_entry</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">entrynum</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="cm">/* Tell Host about this new entry. */</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_LOAD_GDT_ENTRY</span><span class="p">,</span> <span class="n">entrynum</span><span class="p">,</span>
	      <span class="n">dt</span><span class="p">[</span><span class="n">entrynum</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="n">entrynum</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are three &quot;thread local storage&quot; GDT entries which change</span>
<span class="cm"> * on every context switch (these three entries are how glibc implements</span>
<span class="cm"> * __thread variables).  As an optimization, we have a hypercall</span>
<span class="cm"> * specifically for this case.</span>
<span class="cm"> *</span>
<span class="cm"> * Wouldn&#39;t it be nicer to have a general LOAD_GDT_ENTRIES hypercall</span>
<span class="cm"> * which took a range of entries?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_load_tls</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There&#39;s one problem which normal hardware doesn&#39;t have: the Host</span>
<span class="cm">	 * can&#39;t handle us removing entries we&#39;re currently using.  So we clear</span>
<span class="cm">	 * the GS register here: if it&#39;s needed it&#39;ll be reloaded anyway.</span>
<span class="cm">	 */</span>
	<span class="n">lazy_load_gs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">lazy_hcall2</span><span class="p">(</span><span class="n">LHCALL_LOAD_TLS</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tls_array</span><span class="p">),</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*G:038</span>
<span class="cm"> * That&#39;s enough excitement for now, back to ploughing through each of the</span>
<span class="cm"> * different pv_ops structures (we&#39;re about 1/3 of the way through).</span>
<span class="cm"> *</span>
<span class="cm"> * This is the Local Descriptor Table, another weird Intel thingy.  Linux only</span>
<span class="cm"> * uses this for some strange applications like Wine.  We don&#39;t do anything</span>
<span class="cm"> * here, so they&#39;ll get an informative and friendly Segmentation Fault.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_ldt</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This loads a GDT entry into the &quot;Task Register&quot;: that entry points to a</span>
<span class="cm"> * structure called the Task State Segment.  Some comments scattered though the</span>
<span class="cm"> * kernel code indicate that this used for task switching in ages past, along</span>
<span class="cm"> * with blood sacrifice and astrology.</span>
<span class="cm"> *</span>
<span class="cm"> * Now there&#39;s nothing interesting in here that we don&#39;t get told elsewhere.</span>
<span class="cm"> * But the native version uses the &quot;ltr&quot; instruction, which makes the Host</span>
<span class="cm"> * complain to the Guest about a Segmentation Fault and it&#39;ll oops.  So we</span>
<span class="cm"> * override the native version with a do-nothing version.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_load_tr_desc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;cpuid&quot; instruction is a way of querying both the CPU identity</span>
<span class="cm"> * (manufacturer, model, etc) and its features.  It was introduced before the</span>
<span class="cm"> * Pentium in 1993 and keeps getting extended by both Intel, AMD and others.</span>
<span class="cm"> * As you might imagine, after a decade and a half this treatment, it is now a</span>
<span class="cm"> * giant ball of hair.  Its entry in the current Intel manual runs to 28 pages.</span>
<span class="cm"> *</span>
<span class="cm"> * This instruction even it has its own Wikipedia entry.  The Wikipedia entry</span>
<span class="cm"> * has been translated into 6 languages.  I am not making this up!</span>
<span class="cm"> *</span>
<span class="cm"> * We could get funky here and identify ourselves as &quot;GenuineLguest&quot;, but</span>
<span class="cm"> * instead we just use the real &quot;cpuid&quot; instruction.  Then I pretty much turned</span>
<span class="cm"> * off feature bits until the Guest booted.  (Don&#39;t say that: you&#39;ll damage</span>
<span class="cm"> * lguest sales!)  Shut up, inner voice!  (Hey, just pointing out that this is</span>
<span class="cm"> * hardly future proof.)  No one&#39;s listening!  They don&#39;t like you anyway,</span>
<span class="cm"> * parenthetic weirdo!</span>
<span class="cm"> *</span>
<span class="cm"> * Replacing the cpuid so we can turn features off is great for the kernel, but</span>
<span class="cm"> * anyone (including userspace) can just use the raw &quot;cpuid&quot; instruction and</span>
<span class="cm"> * the Host won&#39;t even notice since it isn&#39;t privileged.  So we try not to get</span>
<span class="cm"> * too worked up about it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_cpuid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ax</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bx</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="n">ax</span><span class="p">;</span>

	<span class="n">native_cpuid</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">bx</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">dx</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">function</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * CPUID 0 gives the highest legal CPUID number (and the ID string).</span>
<span class="cm">	 * We futureproof our code a little by sticking to known CPUID values.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ax</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ax</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPUID 1 is a basic feature request.</span>
<span class="cm">	 *</span>
<span class="cm">	 * CX: we only allow kernel to see SSE3, CMPXCHG16B and SSSE3</span>
<span class="cm">	 * DX: SSE, SSE2, FXSR, MMX, CMOV, CMPXCHG8B, TSC, FPU and PAE.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="n">cx</span> <span class="o">&amp;=</span> <span class="mh">0x00002201</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dx</span> <span class="o">&amp;=</span> <span class="mh">0x07808151</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The Host can do a nice optimization if it knows that the</span>
<span class="cm">		 * kernel mappings (addresses above 0xC0000000 or whatever</span>
<span class="cm">		 * PAGE_OFFSET is set to) haven&#39;t changed.  But Linux calls</span>
<span class="cm">		 * flush_tlb_user() for both user and kernel mappings unless</span>
<span class="cm">		 * the Page Global Enable (PGE) feature bit is set.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">dx</span> <span class="o">|=</span> <span class="mh">0x00002000</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We also lie, and say we&#39;re family id 5.  6 or greater</span>
<span class="cm">		 * leads to a rdmsr in early_init_intel which we can&#39;t handle.</span>
<span class="cm">		 * Family ID is returned as bits 8-12 in ax.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">ax</span> <span class="o">&amp;=</span> <span class="mh">0xFFFFF0FF</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ax</span> <span class="o">|=</span> <span class="mh">0x00000500</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is used to detect if we&#39;re running under KVM.  We might be,</span>
<span class="cm">	 * but that&#39;s a Host matter, not us.  So say we&#39;re not.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">KVM_CPUID_SIGNATURE</span>:
		<span class="o">*</span><span class="n">bx</span> <span class="o">=</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="o">*</span><span class="n">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 0x80000000 returns the highest Extended Function, so we futureproof</span>
<span class="cm">	 * like we do above by limiting it to known fields.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mh">0x80000000</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ax</span> <span class="o">&gt;</span> <span class="mh">0x80000008</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ax</span> <span class="o">=</span> <span class="mh">0x80000008</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PAE systems can mark pages as non-executable.  Linux calls this the</span>
<span class="cm">	 * NX bit.  Intel calls it XD (eXecute Disable), AMD EVP (Enhanced</span>
<span class="cm">	 * Virus Protection).  We just switch it off here, since we don&#39;t</span>
<span class="cm">	 * support it.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mh">0x80000001</span>:
		<span class="o">*</span><span class="n">dx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Intel has four control registers, imaginatively named cr0, cr2, cr3 and cr4.</span>
<span class="cm"> * I assume there&#39;s a cr1, but it hasn&#39;t bothered us yet, so we&#39;ll not bother</span>
<span class="cm"> * it.  The Host needs to know when the Guest wants to change them, so we have</span>
<span class="cm"> * a whole series of functions like read_cr0() and write_cr0().</span>
<span class="cm"> *</span>
<span class="cm"> * We start with cr0.  cr0 allows you to turn on and off all kinds of basic</span>
<span class="cm"> * features, but Linux only really cares about one: the horrifically-named Task</span>
<span class="cm"> * Switched (TS) bit at bit 3 (ie. 8)</span>
<span class="cm"> *</span>
<span class="cm"> * What does the TS bit do?  Well, it causes the CPU to trap (interrupt 7) if</span>
<span class="cm"> * the floating point unit is used.  Which allows us to restore FPU state</span>
<span class="cm"> * lazily after a task switch, and Linux uses that gratefully, but wouldn&#39;t a</span>
<span class="cm"> * name like &quot;FPUTRAP bit&quot; be a little less cryptic?</span>
<span class="cm"> *</span>
<span class="cm"> * We store cr0 locally because the Host never changes it.  The Guest sometimes</span>
<span class="cm"> * wants to read it and we&#39;d prefer not to bother the Host unnecessarily.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_cr0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_write_cr0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_TS</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">X86_CR0_TS</span><span class="p">);</span>
	<span class="n">current_cr0</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_read_cr0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_cr0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Intel provided a special instruction to clear the TS bit for people too cool</span>
<span class="cm"> * to use write_cr0() to do it.  This &quot;clts&quot; instruction is faster, because all</span>
<span class="cm"> * the vowels have been optimized out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_clts</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_TS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">current_cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_CR0_TS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cr2 is the virtual address of the last page fault, which the Guest only ever</span>
<span class="cm"> * reads.  The Host kindly writes this into our &quot;struct lguest_data&quot;, so we</span>
<span class="cm"> * just read it out of there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_read_cr2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">cr2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* See lguest_set_pte() below. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">cr3_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_cr3</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * cr3 is the current toplevel pagetable page: the principle is the same as</span>
<span class="cm"> * cr0.  Keep a local copy, and tell the Host when it changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_write_cr3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cr3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_NEW_PGTABLE</span><span class="p">,</span> <span class="n">cr3</span><span class="p">);</span>
	<span class="n">current_cr3</span> <span class="o">=</span> <span class="n">cr3</span><span class="p">;</span>

	<span class="cm">/* These two page tables are simple, linear, and used during boot */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr3</span> <span class="o">!=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cr3</span> <span class="o">!=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">initial_page_table</span><span class="p">))</span>
		<span class="n">cr3_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_read_cr3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current_cr3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* cr4 is used to enable and disable PGE, but we don&#39;t care. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_read_cr4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_write_cr4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Page Table Handling.</span>
<span class="cm"> *</span>
<span class="cm"> * Now would be a good time to take a rest and grab a coffee or similarly</span>
<span class="cm"> * relaxing stimulant.  The easy parts are behind us, and the trek gradually</span>
<span class="cm"> * winds uphill from here.</span>
<span class="cm"> *</span>
<span class="cm"> * Quick refresher: memory is divided into &quot;pages&quot; of 4096 bytes each.  The CPU</span>
<span class="cm"> * maps virtual addresses to physical addresses using &quot;page tables&quot;.  We could</span>
<span class="cm"> * use one huge index of 1 million entries: each address is 4 bytes, so that&#39;s</span>
<span class="cm"> * 1024 pages just to hold the page tables.   But since most virtual addresses</span>
<span class="cm"> * are unused, we use a two level index which saves space.  The cr3 register</span>
<span class="cm"> * contains the physical address of the top level &quot;page directory&quot; page, which</span>
<span class="cm"> * contains physical addresses of up to 1024 second-level pages.  Each of these</span>
<span class="cm"> * second level pages contains up to 1024 physical addresses of actual pages,</span>
<span class="cm"> * or Page Table Entries (PTEs).</span>
<span class="cm"> *</span>
<span class="cm"> * Here&#39;s a diagram, where arrows indicate physical addresses:</span>
<span class="cm"> *</span>
<span class="cm"> * cr3 ---&gt; +---------+</span>
<span class="cm"> *	    |  	   ---------&gt;+---------+</span>
<span class="cm"> *	    |	      |	     | PADDR1  |</span>
<span class="cm"> *	  Mid-level   |	     | PADDR2  |</span>
<span class="cm"> *	  (PMD) page  |	     | 	       |</span>
<span class="cm"> *	    |	      |	   Lower-level |</span>
<span class="cm"> *	    |	      |	   (PTE) page  |</span>
<span class="cm"> *	    |	      |	     |	       |</span>
<span class="cm"> *	      ....    	     	 ....</span>
<span class="cm"> *</span>
<span class="cm"> * So to convert a virtual address to a physical address, we look up the top</span>
<span class="cm"> * level, which points us to the second level, which gives us the physical</span>
<span class="cm"> * address of that page.  If the top level entry was not present, or the second</span>
<span class="cm"> * level entry was not present, then the virtual address is invalid (we</span>
<span class="cm"> * say &quot;the page was not mapped&quot;).</span>
<span class="cm"> *</span>
<span class="cm"> * Put another way, a 32-bit virtual address is divided up like so:</span>
<span class="cm"> *</span>
<span class="cm"> *  1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="cm"> * |&lt;---- 10 bits ----&gt;|&lt;---- 10 bits ----&gt;|&lt;------ 12 bits ------&gt;|</span>
<span class="cm"> *    Index into top     Index into second      Offset within page</span>
<span class="cm"> *  page directory page    pagetable page</span>
<span class="cm"> *</span>
<span class="cm"> * Now, unfortunately, this isn&#39;t the whole story: Intel added Physical Address</span>
<span class="cm"> * Extension (PAE) to allow 32 bit systems to use 64GB of memory (ie. 36 bits).</span>
<span class="cm"> * These are held in 64-bit page table entries, so we can now only fit 512</span>
<span class="cm"> * entries in a page, and the neat three-level tree breaks down.</span>
<span class="cm"> *</span>
<span class="cm"> * The result is a four level page table:</span>
<span class="cm"> *</span>
<span class="cm"> * cr3 --&gt; [ 4 Upper  ]</span>
<span class="cm"> *	   [   Level  ]</span>
<span class="cm"> *	   [  Entries ]</span>
<span class="cm"> *	   [(PUD Page)]---&gt; +---------+</span>
<span class="cm"> *	 		    |  	   ---------&gt;+---------+</span>
<span class="cm"> *	 		    |	      |	     | PADDR1  |</span>
<span class="cm"> *	 		  Mid-level   |	     | PADDR2  |</span>
<span class="cm"> *	 		  (PMD) page  |	     | 	       |</span>
<span class="cm"> *	 		    |	      |	   Lower-level |</span>
<span class="cm"> *	 		    |	      |	   (PTE) page  |</span>
<span class="cm"> *	 		    |	      |	     |	       |</span>
<span class="cm"> *	 		      ....    	     	 ....</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * And the virtual address is decoded as:</span>
<span class="cm"> *</span>
<span class="cm"> *         1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="cm"> *      |&lt;-2-&gt;|&lt;--- 9 bits ----&gt;|&lt;---- 9 bits ---&gt;|&lt;------ 12 bits ------&gt;|</span>
<span class="cm"> * Index into    Index into mid    Index into lower    Offset within page</span>
<span class="cm"> * top entries   directory page     pagetable page</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s too hard to switch between these two formats at runtime, so Linux only</span>
<span class="cm"> * supports one or the other depending on whether CONFIG_X86_PAE is set.  Many</span>
<span class="cm"> * distributions turn it on, and not just for people with silly amounts of</span>
<span class="cm"> * memory: the larger PTE entries allow room for the NX bit, which lets the</span>
<span class="cm"> * kernel disable execution of pages and increase security.</span>
<span class="cm"> *</span>
<span class="cm"> * This was a problem for lguest, which couldn&#39;t run on these distributions;</span>
<span class="cm"> * then Matias Zabaljauregui figured it all out and implemented it, and only a</span>
<span class="cm"> * handful of puppies were crushed in the process!</span>
<span class="cm"> *</span>
<span class="cm"> * Back to our point: the kernel spends a lot of time changing both the</span>
<span class="cm"> * top-level page directory and lower-level pagetable pages.  The Guest doesn&#39;t</span>
<span class="cm"> * know physical addresses, so while it maintains these page tables exactly</span>
<span class="cm"> * like normal, it also needs to keep the Host informed whenever it makes a</span>
<span class="cm"> * change: the Host will create the real page tables based on the Guests&#39;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The Guest calls this after it has set a second-level entry (pte), ie. to map</span>
<span class="cm"> * a page into a process&#39; address space.  We tell the Host the toplevel and</span>
<span class="cm"> * address this corresponds to.  The Guest uses one pagetable per process, so</span>
<span class="cm"> * we need to tell the Host which one we&#39;re changing (mm-&gt;pgd).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_pte_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="cm">/* PAE needs to hand a 64 bit page table entry, so it uses two args. */</span>
	<span class="n">lazy_hcall4</span><span class="p">(</span><span class="n">LHCALL_SET_PTE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span>
		    <span class="n">ptep</span><span class="o">-&gt;</span><span class="n">pte_low</span><span class="p">,</span> <span class="n">ptep</span><span class="o">-&gt;</span><span class="n">pte_high</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">lazy_hcall3</span><span class="p">(</span><span class="n">LHCALL_SET_PTE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">),</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="o">-&gt;</span><span class="n">pte_low</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* This is the &quot;set and update&quot; combo-meal-deal version. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pte_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			      <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="n">lguest_pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Guest calls lguest_set_pud to set a top-level entry and lguest_set_pmd</span>
<span class="cm"> * to set a middle-level entry when PAE is activated.</span>
<span class="cm"> *</span>
<span class="cm"> * Again, we set the entry then tell the Host which page we changed,</span>
<span class="cm"> * and the index of the entry we changed.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pud</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pudp</span><span class="p">,</span> <span class="n">pud_t</span> <span class="n">pudval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pud</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span> <span class="n">pudval</span><span class="p">);</span>

	<span class="cm">/* 32 bytes aligned pdpt address and the index. */</span>
	<span class="n">lazy_hcall2</span><span class="p">(</span><span class="n">LHCALL_SET_PGD</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pudp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFE0</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pudp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pud_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pmd</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmdval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pmd</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmdval</span><span class="p">);</span>
	<span class="n">lazy_hcall2</span><span class="p">(</span><span class="n">LHCALL_SET_PMD</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="cm">/* The Guest calls lguest_set_pmd to set a top-level entry when !PAE. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pmd</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmdval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pmd</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">pmdval</span><span class="p">);</span>
	<span class="n">lazy_hcall2</span><span class="p">(</span><span class="n">LHCALL_SET_PGD</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pmdp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pmd_t</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * There are a couple of legacy places where the kernel sets a PTE, but we</span>
<span class="cm"> * don&#39;t know the top level any more.  This is useless for us, since we don&#39;t</span>
<span class="cm"> * know which pagetable is changing or what address, so we just tell the Host</span>
<span class="cm"> * to forget all of them.  Fortunately, this is very rare.</span>
<span class="cm"> *</span>
<span class="cm"> * ... except in early boot when the kernel sets up the initial pagetables,</span>
<span class="cm"> * which makes booting astonishingly slow: 48 seconds!  So we don&#39;t even tell</span>
<span class="cm"> * the Host anything changed until we&#39;ve done the first real page table switch,</span>
<span class="cm"> * which brings boot back to 4.3 seconds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pteval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pteval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr3_changed</span><span class="p">)</span>
		<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_FLUSH_TLB</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_PAE</span>
<span class="cm">/*</span>
<span class="cm"> * With 64-bit PTE values, we need to be careful setting them: if we set 32</span>
<span class="cm"> * bits at a time, the hardware could see a weird half-set entry.  These</span>
<span class="cm"> * versions ensure we update all 64 bits at once.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_pte_atomic</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_set_pte_atomic</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cr3_changed</span><span class="p">)</span>
		<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_FLUSH_TLB</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_pte_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			     <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">native_pte_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="n">lguest_pte_update</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_pmd_clear</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lguest_set_pmd</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Unfortunately for Lguest, the pv_mmu_ops for page tables were based on</span>
<span class="cm"> * native page table operations.  On native hardware you can set a new page</span>
<span class="cm"> * table entry whenever you want, but if you want to remove one you have to do</span>
<span class="cm"> * a TLB flush (a TLB is a little cache of page table entries kept by the CPU).</span>
<span class="cm"> *</span>
<span class="cm"> * So the lguest_set_pte_at() and lguest_set_pmd() functions above are only</span>
<span class="cm"> * called when a valid entry is written, not when it&#39;s removed (ie. marked not</span>
<span class="cm"> * present).  Instead, this is where we come when the Guest wants to remove a</span>
<span class="cm"> * page table entry: we tell the Host to set that entry to 0 (ie. the present</span>
<span class="cm"> * bit is zero).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_flush_tlb_single</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Simply set it to zero: if it was not, it will fault back in. */</span>
	<span class="n">lazy_hcall3</span><span class="p">(</span><span class="n">LHCALL_SET_PTE</span><span class="p">,</span> <span class="n">current_cr3</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is what happens after the Guest has removed a large number of entries.</span>
<span class="cm"> * This tells the Host that any of the page table entries for userspace might</span>
<span class="cm"> * have changed, ie. virtual addresses below PAGE_OFFSET.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_flush_tlb_user</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_FLUSH_TLB</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when the kernel page tables have changed.  That&#39;s not very</span>
<span class="cm"> * common (unless the Guest is using highmem, which makes the Guest extremely</span>
<span class="cm"> * slow), so it&#39;s worth separating this from the user flushing above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_flush_tlb_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall1</span><span class="p">(</span><span class="n">LHCALL_FLUSH_TLB</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Unadvanced Programmable Interrupt Controller.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an attempt to implement the simplest possible interrupt controller.</span>
<span class="cm"> * I spent some time looking though routines like set_irq_chip_and_handler,</span>
<span class="cm"> * set_irq_chip_and_handler_name, set_irq_chip_data and set_phasers_to_stun and</span>
<span class="cm"> * I *think* this is as simple as it gets.</span>
<span class="cm"> *</span>
<span class="cm"> * We can tell the Host what interrupts we want blocked ready for using the</span>
<span class="cm"> * lguest_data.interrupts bitmap, so disabling (aka &quot;masking&quot;) them is as</span>
<span class="cm"> * simple as setting a bit.  We don&#39;t actually &quot;ack&quot; interrupts as such, we</span>
<span class="cm"> * just mask and unmask them.  I wonder if we should be cleverer?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_lguest_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">blocked_interrupts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_lguest_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">blocked_interrupts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This structure describes the lguest IRQ controller. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">lguest_irq_controller</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;lguest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">disable_lguest_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask_ack</span>	<span class="o">=</span> <span class="n">disable_lguest_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">enable_lguest_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This sets up the Interrupt Descriptor Table (IDT) entry for each hardware</span>
<span class="cm"> * interrupt (except 128, which is used for system calls), and then tells the</span>
<span class="cm"> * Linux infrastructure that each interrupt is controlled by our level-based</span>
<span class="cm"> * lguest interrupt controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">lguest_init_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Some systems map &quot;vectors&quot; to interrupts weirdly.  Not us! */</span>
		<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">SYSCALL_VECTOR</span><span class="p">)</span>
			<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This call is required to set up for 4k stacks, where we have</span>
<span class="cm">	 * separate stacks for hard and soft interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">irq_ctx_init</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt descriptors are allocated as-needed, but low-numbered ones are</span>
<span class="cm"> * reserved by the generic x86 code.  So we ignore irq_alloc_desc_at if it</span>
<span class="cm"> * tells us the irq is already used: other errors (ie. ENOMEM) we take</span>
<span class="cm"> * seriously.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">lguest_setup_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Returns -ve error or vector number. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">irq_alloc_desc_at</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lguest_irq_controller</span><span class="p">,</span>
				      <span class="n">handle_level_irq</span><span class="p">,</span> <span class="s">&quot;level&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Time.</span>
<span class="cm"> *</span>
<span class="cm"> * It would be far better for everyone if the Guest had its own clock, but</span>
<span class="cm"> * until then the Host gives us the time on every interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_get_wallclock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The TSC is an Intel thing called the Time Stamp Counter.  The Host tells us</span>
<span class="cm"> * what speed it runs at, or 0 if it&#39;s unusable as a reliable clock source.</span>
<span class="cm"> * This matches what we want here: if we return 0 from this function, the x86</span>
<span class="cm"> * TSC clock will give up and not register itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">lguest_tsc_khz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">tsc_khz</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we can&#39;t use the TSC, the kernel falls back to our lower-priority</span>
<span class="cm"> * &quot;lguest_clock&quot;, where we read the time value given to us by the Host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">lguest_clock_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sec</span><span class="p">,</span> <span class="n">nsec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the time is in two parts (seconds and nanoseconds), we risk</span>
<span class="cm">	 * reading it just as it&#39;s changing from 99 &amp; 0.999999999 to 100 and 0,</span>
<span class="cm">	 * and getting 99 and 0.  As Linux tends to come apart under the stress</span>
<span class="cm">	 * of time travel, we must be careful:</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* First we read the seconds part. */</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This read memory barrier tells the compiler and the CPU that</span>
<span class="cm">		 * this can&#39;t be reordered: we have to complete the above</span>
<span class="cm">		 * before going on.</span>
<span class="cm">		 */</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="cm">/* Now we read the nanoseconds part. */</span>
		<span class="n">nsec</span> <span class="o">=</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
		<span class="cm">/* Make sure we&#39;ve done that. */</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="cm">/* Now if the seconds part has changed, try again. */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lguest_data</span><span class="p">.</span><span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">!=</span> <span class="n">sec</span><span class="p">));</span>

	<span class="cm">/* Our lguest clock is in real nanoseconds. */</span>
	<span class="k">return</span> <span class="n">sec</span><span class="o">*</span><span class="mi">1000000000ULL</span> <span class="o">+</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is the fallback clocksource: lower priority than the TSC clocksource. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">lguest_clock</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;lguest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">lguest_clock_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>		<span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We also need a &quot;struct clock_event_device&quot;: Linux asks us to set it to go</span>
<span class="cm"> * off some time in the future.  Actually, James Morris figured all this out, I</span>
<span class="cm"> * just applied the patch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lguest_clockevent_set_next_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
                                           <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: I don&#39;t think this can ever happen, but James tells me he had</span>
<span class="cm">	 * to put this code in.  Maybe we should remove it now.  Anyone? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">LG_CLOCK_MIN_DELTA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: small delta %lu ns</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Please wake us this far in the future. */</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_SET_CLOCKEVENT</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_clockevent_set_mode</span><span class="p">(</span><span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">,</span>
                                      <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span>:
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span>:
		<span class="cm">/* A 0 argument shuts the clock down. */</span>
		<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_SET_CLOCKEVENT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_ONESHOT</span>:
		<span class="cm">/* This is what we expect. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_PERIODIC</span>:
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_RESUME</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This describes our primitive timer chip. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="n">lguest_clockevent</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>                   <span class="o">=</span> <span class="s">&quot;lguest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">features</span>               <span class="o">=</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_next_event</span>         <span class="o">=</span> <span class="n">lguest_clockevent_set_next_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mode</span>               <span class="o">=</span> <span class="n">lguest_clockevent_set_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>                 <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mult</span>                   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shift</span>                  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">min_delta_ns</span>           <span class="o">=</span> <span class="n">LG_CLOCK_MIN_DELTA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_delta_ns</span>           <span class="o">=</span> <span class="n">LG_CLOCK_MAX_DELTA</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is the Guest timer interrupt handler (hardware interrupt 0).  We just</span>
<span class="cm"> * call the clockevent infrastructure and it does whatever needs doing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_time_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t interrupt us while this is running. */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lguest_clockevent</span><span class="p">.</span><span class="n">event_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_clockevent</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At some point in the boot process, we get asked to set up our timing</span>
<span class="cm"> * infrastructure.  The kernel doesn&#39;t expect timer interrupts before this, but</span>
<span class="cm"> * we cleverly initialized the &quot;blocked_interrupts&quot; field of &quot;struct</span>
<span class="cm"> * lguest_data&quot; so that timer interrupts were blocked until now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set up the timer interrupt (0) to go to our simple timer routine */</span>
	<span class="n">lguest_setup_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">irq_set_handler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lguest_time_irq</span><span class="p">);</span>

	<span class="n">clocksource_register_hz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_clock</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t set cpumask in the initializer: damn C limitations!  Set it</span>
<span class="cm">	 * here and register our timer device. */</span>
	<span class="n">lguest_clockevent</span><span class="p">.</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lguest_clockevent</span><span class="p">);</span>

	<span class="cm">/* Finally, we unblock the timer interrupt. */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lguest_data</span><span class="p">.</span><span class="n">blocked_interrupts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Miscellaneous bits and pieces.</span>
<span class="cm"> *</span>
<span class="cm"> * Here is an oddball collection of functions which the Guest needs for things</span>
<span class="cm"> * to work.  They&#39;re pretty simple.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The Guest needs to tell the Host what stack it expects traps to use.  For</span>
<span class="cm"> * native hardware, this is part of the Task State Segment mentioned above in</span>
<span class="cm"> * lguest_load_tr_desc(), but to help hypervisors there&#39;s this special call.</span>
<span class="cm"> *</span>
<span class="cm"> * We tell the Host the segment we want to use (__KERNEL_DS is the kernel data</span>
<span class="cm"> * segment), the privilege level (we&#39;re privilege level 1, the Host is 0 and</span>
<span class="cm"> * will not tolerate us trying to use that), the stack pointer, and the number</span>
<span class="cm"> * of pages in the stack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_load_sp0</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lazy_hcall3</span><span class="p">(</span><span class="n">LHCALL_SET_STACK</span><span class="p">,</span> <span class="n">__KERNEL_DS</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">,</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">sp0</span><span class="p">,</span>
		   <span class="n">THREAD_SIZE</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Let&#39;s just say, I wouldn&#39;t do debugging under a Guest. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_set_debugreg</span><span class="p">(</span><span class="kt">int</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: Implement */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are times when the kernel wants to make sure that no memory writes are</span>
<span class="cm"> * caught in the cache (that they&#39;ve all reached real hardware devices).  This</span>
<span class="cm"> * doesn&#39;t matter for the Guest which has virtual hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * On the Pentium 4 and above, cpuid() indicates that the Cache Line Flush</span>
<span class="cm"> * (clflush) instruction is available and the kernel uses that.  Otherwise, it</span>
<span class="cm"> * uses the older &quot;Write Back and Invalidate Cache&quot; (wbinvd) instruction.</span>
<span class="cm"> * Unlike clflush, wbinvd can only be run at privilege level 0.  So we can</span>
<span class="cm"> * ignore clflush, but replace wbinvd.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_wbinvd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the Guest expects to have an Advanced Programmable Interrupt Controller,</span>
<span class="cm"> * we play dumb by ignoring writes and returning 0 for reads.  So it&#39;s no</span>
<span class="cm"> * longer Programmable nor Controlling anything, and I don&#39;t think 8 lines of</span>
<span class="cm"> * code qualifies for Advanced.  It will also never interrupt anything.  It</span>
<span class="cm"> * does, however, allow us to get through the Linux boot code.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_apic_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">lguest_apic_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">lguest_apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Warn to see if there&#39;s any stray references */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">lguest_apic_safe_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_lguest_basic_apic_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">lguest_apic_read</span><span class="p">;</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">lguest_apic_write</span><span class="p">;</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">icr_read</span> <span class="o">=</span> <span class="n">lguest_apic_icr_read</span><span class="p">;</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">icr_write</span> <span class="o">=</span> <span class="n">lguest_apic_icr_write</span><span class="p">;</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">wait_icr_idle</span> <span class="o">=</span> <span class="n">lguest_apic_wait_icr_idle</span><span class="p">;</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">safe_wait_icr_idle</span> <span class="o">=</span> <span class="n">lguest_apic_safe_wait_icr_idle</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* STOP!  Until an interrupt comes in. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_safe_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_HALT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The SHUTDOWN hypercall takes a string to describe what&#39;s happening, and</span>
<span class="cm"> * an argument which says whether this to restart (reboot) the Guest or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the Host always prefers that the Guest speak in physical addresses</span>
<span class="cm"> * rather than virtual addresses, so we use __pa() here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_power_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_SHUTDOWN</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="s">&quot;Power down&quot;</span><span class="p">),</span>
	      <span class="n">LGUEST_SHUTDOWN_POWEROFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Panicing.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t.  But if you did, this is what happens.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lguest_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">l</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_SHUTDOWN</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">LGUEST_SHUTDOWN_POWEROFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* The hcall won&#39;t return, but to keep gcc happy, we&#39;re &quot;done&quot;. */</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">paniced</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">lguest_panic</span>
<span class="p">};</span>

<span class="cm">/* Setting up memory is fairly easy. */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">lguest_memory_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The Linux bootloader header contains an &quot;e820&quot; memory map: the</span>
<span class="cm">	 * Launcher populated the first entry with our memory limit.</span>
<span class="cm">	 */</span>
	<span class="n">e820_add_region</span><span class="p">(</span><span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span>
			  <span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>

	<span class="cm">/* This string is for the boot messages. */</span>
	<span class="k">return</span> <span class="s">&quot;LGUEST&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We will eventually use the virtio console device to produce console output,</span>
<span class="cm"> * but before that is set up we use LHCALL_NOTIFY on normal memory to produce</span>
<span class="cm"> * console output.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">early_put_chars</span><span class="p">(</span><span class="n">u32</span> <span class="n">vtermno</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">scratch</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* We use a nul-terminated string, so we make a copy.  Icky, huh? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scratch</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scratch</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scratch</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_NOTIFY</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">scratch</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* This routine returns the number of bytes actually written. */</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rebooting also tells the Host we&#39;re finished, but the RESTART flag tells the</span>
<span class="cm"> * Launcher to reboot us.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lguest_restart</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hcall</span><span class="p">(</span><span class="n">LHCALL_SHUTDOWN</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">reason</span><span class="p">),</span> <span class="n">LGUEST_SHUTDOWN_RESTART</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*G:050</span>
<span class="cm"> * Patching (Powerfully Placating Performance Pedants)</span>
<span class="cm"> *</span>
<span class="cm"> * We have already seen that pv_ops structures let us replace simple native</span>
<span class="cm"> * instructions with calls to the appropriate back end all throughout the</span>
<span class="cm"> * kernel.  This allows the same kernel to run as a Guest and as a native</span>
<span class="cm"> * kernel, but it&#39;s slow because of all the indirect branches.</span>
<span class="cm"> *</span>
<span class="cm"> * Remember that David Wheeler quote about &quot;Any problem in computer science can</span>
<span class="cm"> * be solved with another layer of indirection&quot;?  The rest of that quote is</span>
<span class="cm"> * &quot;... But that usually will create another problem.&quot;  This is the first of</span>
<span class="cm"> * those problems.</span>
<span class="cm"> *</span>
<span class="cm"> * Our current solution is to allow the paravirt back end to optionally patch</span>
<span class="cm"> * over the indirect calls to replace them with something more efficient.  We</span>
<span class="cm"> * patch two of the simplest of the most commonly called functions: disable</span>
<span class="cm"> * interrupts and save interrupts.  We usually have 6 or 10 bytes to patch</span>
<span class="cm"> * into: the Guest versions of these operations are small enough that we can</span>
<span class="cm"> * fit comfortably.</span>
<span class="cm"> *</span>
<span class="cm"> * First we need assembly templates of each of the patchable Guest operations,</span>
<span class="cm"> * and these are in i386_head.S.</span>
<span class="cm"> */</span>

<span class="cm">/*G:060 We construct a table from the assembler templates: */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lguest_insns</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lguest_insns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PARAVIRT_PATCH</span><span class="p">(</span><span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">irq_disable</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">lgstart_cli</span><span class="p">,</span> <span class="n">lgend_cli</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">PARAVIRT_PATCH</span><span class="p">(</span><span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">save_fl</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">lgstart_pushf</span><span class="p">,</span> <span class="n">lgend_pushf</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Now our patch routine is fairly simple (based on the native one in</span>
<span class="cm"> * paravirt.c).  If we have a replacement, we copy it in and return how much of</span>
<span class="cm"> * the available space we used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">lguest_patch</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">clobber</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ibuf</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t do anything special if we don&#39;t have a replacement */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lguest_insns</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">lguest_insns</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">paravirt_patch_default</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">clobber</span><span class="p">,</span> <span class="n">ibuf</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">insn_len</span> <span class="o">=</span> <span class="n">lguest_insns</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">end</span> <span class="o">-</span> <span class="n">lguest_insns</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Similarly if it can&#39;t fit (doesn&#39;t happen, but let&#39;s be thorough). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">insn_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">paravirt_patch_default</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">clobber</span><span class="p">,</span> <span class="n">ibuf</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Copy in our instructions. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">lguest_insns</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">insn_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">insn_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*G:029</span>
<span class="cm"> * Once we get to lguest_init(), we know we&#39;re a Guest.  The various</span>
<span class="cm"> * pv_ops structures in the kernel provide points for (almost) every routine we</span>
<span class="cm"> * have to override to avoid privileged instructions.</span>
<span class="cm"> */</span>
<span class="n">__init</span> <span class="kt">void</span> <span class="nf">lguest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We&#39;re under lguest. */</span>
	<span class="n">pv_info</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;lguest&quot;</span><span class="p">;</span>
	<span class="cm">/* Paravirt is enabled. */</span>
	<span class="n">pv_info</span><span class="p">.</span><span class="n">paravirt_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* We&#39;re running at privilege level 1, not 0 as normal. */</span>
	<span class="n">pv_info</span><span class="p">.</span><span class="n">kernel_rpl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Everyone except Xen runs with this set. */</span>
	<span class="n">pv_info</span><span class="p">.</span><span class="n">shared_kernel_pmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We set up all the lguest overrides for sensitive operations.  These</span>
<span class="cm">	 * are detailed with the operations themselves.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Interrupt-related operations */</span>
	<span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">save_fl</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">save_fl</span><span class="p">);</span>
	<span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">restore_fl</span> <span class="o">=</span> <span class="n">__PV_IS_CALLEE_SAVE</span><span class="p">(</span><span class="n">lg_restore_fl</span><span class="p">);</span>
	<span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">irq_disable</span> <span class="o">=</span> <span class="n">PV_CALLEE_SAVE</span><span class="p">(</span><span class="n">irq_disable</span><span class="p">);</span>
	<span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">irq_enable</span> <span class="o">=</span> <span class="n">__PV_IS_CALLEE_SAVE</span><span class="p">(</span><span class="n">lg_irq_enable</span><span class="p">);</span>
	<span class="n">pv_irq_ops</span><span class="p">.</span><span class="n">safe_halt</span> <span class="o">=</span> <span class="n">lguest_safe_halt</span><span class="p">;</span>

	<span class="cm">/* Setup operations */</span>
	<span class="n">pv_init_ops</span><span class="p">.</span><span class="n">patch</span> <span class="o">=</span> <span class="n">lguest_patch</span><span class="p">;</span>

	<span class="cm">/* Intercepts of various CPU instructions */</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">load_gdt</span> <span class="o">=</span> <span class="n">lguest_load_gdt</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">cpuid</span> <span class="o">=</span> <span class="n">lguest_cpuid</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">load_idt</span> <span class="o">=</span> <span class="n">lguest_load_idt</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">iret</span> <span class="o">=</span> <span class="n">lguest_iret</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">load_sp0</span> <span class="o">=</span> <span class="n">lguest_load_sp0</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">load_tr_desc</span> <span class="o">=</span> <span class="n">lguest_load_tr_desc</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">set_ldt</span> <span class="o">=</span> <span class="n">lguest_set_ldt</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">load_tls</span> <span class="o">=</span> <span class="n">lguest_load_tls</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">set_debugreg</span> <span class="o">=</span> <span class="n">lguest_set_debugreg</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">clts</span> <span class="o">=</span> <span class="n">lguest_clts</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">read_cr0</span> <span class="o">=</span> <span class="n">lguest_read_cr0</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">write_cr0</span> <span class="o">=</span> <span class="n">lguest_write_cr0</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">read_cr4</span> <span class="o">=</span> <span class="n">lguest_read_cr4</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">write_cr4</span> <span class="o">=</span> <span class="n">lguest_write_cr4</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">write_gdt_entry</span> <span class="o">=</span> <span class="n">lguest_write_gdt_entry</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">write_idt_entry</span> <span class="o">=</span> <span class="n">lguest_write_idt_entry</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">wbinvd</span> <span class="o">=</span> <span class="n">lguest_wbinvd</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">start_context_switch</span> <span class="o">=</span> <span class="n">paravirt_start_context_switch</span><span class="p">;</span>
	<span class="n">pv_cpu_ops</span><span class="p">.</span><span class="n">end_context_switch</span> <span class="o">=</span> <span class="n">lguest_end_context_switch</span><span class="p">;</span>

	<span class="cm">/* Pagetable management */</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">write_cr3</span> <span class="o">=</span> <span class="n">lguest_write_cr3</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">flush_tlb_user</span> <span class="o">=</span> <span class="n">lguest_flush_tlb_user</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">flush_tlb_single</span> <span class="o">=</span> <span class="n">lguest_flush_tlb_single</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">flush_tlb_kernel</span> <span class="o">=</span> <span class="n">lguest_flush_tlb_kernel</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pte</span> <span class="o">=</span> <span class="n">lguest_set_pte</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pte_at</span> <span class="o">=</span> <span class="n">lguest_set_pte_at</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pmd</span> <span class="o">=</span> <span class="n">lguest_set_pmd</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_PAE</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pte_atomic</span> <span class="o">=</span> <span class="n">lguest_set_pte_atomic</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">pte_clear</span> <span class="o">=</span> <span class="n">lguest_pte_clear</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">pmd_clear</span> <span class="o">=</span> <span class="n">lguest_pmd_clear</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">set_pud</span> <span class="o">=</span> <span class="n">lguest_set_pud</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">read_cr2</span> <span class="o">=</span> <span class="n">lguest_read_cr2</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">read_cr3</span> <span class="o">=</span> <span class="n">lguest_read_cr3</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">lazy_mode</span><span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="n">paravirt_enter_lazy_mmu</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">lazy_mode</span><span class="p">.</span><span class="n">leave</span> <span class="o">=</span> <span class="n">lguest_leave_lazy_mmu_mode</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">pte_update</span> <span class="o">=</span> <span class="n">lguest_pte_update</span><span class="p">;</span>
	<span class="n">pv_mmu_ops</span><span class="p">.</span><span class="n">pte_update_defer</span> <span class="o">=</span> <span class="n">lguest_pte_update</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
	<span class="cm">/* APIC read/write intercepts */</span>
	<span class="n">set_lguest_basic_apic_ops</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">x86_init</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="n">memory_setup</span> <span class="o">=</span> <span class="n">lguest_memory_setup</span><span class="p">;</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">irqs</span><span class="p">.</span><span class="n">intr_init</span> <span class="o">=</span> <span class="n">lguest_init_IRQ</span><span class="p">;</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">timers</span><span class="p">.</span><span class="n">timer_init</span> <span class="o">=</span> <span class="n">lguest_time_init</span><span class="p">;</span>
	<span class="n">x86_platform</span><span class="p">.</span><span class="n">calibrate_tsc</span> <span class="o">=</span> <span class="n">lguest_tsc_khz</span><span class="p">;</span>
	<span class="n">x86_platform</span><span class="p">.</span><span class="n">get_wallclock</span> <span class="o">=</span>  <span class="n">lguest_get_wallclock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now is a good time to look at the implementations of these functions</span>
<span class="cm">	 * before returning to the rest of lguest_init().</span>
<span class="cm">	 */</span>

	<span class="cm">/*G:070</span>
<span class="cm">	 * Now we&#39;ve seen all the paravirt_ops, we return to</span>
<span class="cm">	 * lguest_init() where the rest of the fairly chaotic boot setup</span>
<span class="cm">	 * occurs.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The stack protector is a weird thing where gcc places a canary</span>
<span class="cm">	 * value on the stack and then checks it on return.  This file is</span>
<span class="cm">	 * compiled with -fno-stack-protector it, so we got this far without</span>
<span class="cm">	 * problems.  The value of the canary is kept at offset 20 from the</span>
<span class="cm">	 * %gs register, so we need to set that up before calling C functions</span>
<span class="cm">	 * in other files.</span>
<span class="cm">	 */</span>
	<span class="n">setup_stack_canary_segment</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could just call load_stack_canary_segment(), but we might as well</span>
<span class="cm">	 * call switch_to_new_gdt() which loads the whole table and sets up the</span>
<span class="cm">	 * per-cpu segment descriptor register %fs as well.</span>
<span class="cm">	 */</span>
	<span class="n">switch_to_new_gdt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Host&lt;-&gt;Guest Switcher lives at the top of our address space, and</span>
<span class="cm">	 * the Host told us how big it is when we made LGUEST_INIT hypercall:</span>
<span class="cm">	 * it put the answer in lguest_data.reserve_mem</span>
<span class="cm">	 */</span>
	<span class="n">reserve_top_address</span><span class="p">(</span><span class="n">lguest_data</span><span class="p">.</span><span class="n">reserve_mem</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t initialize the lock dependency checker now, it crashes</span>
<span class="cm">	 * atomic_notifier_chain_register, then paravirt_disable_iospace.</span>
<span class="cm">	 */</span>
	<span class="n">lockdep_init</span><span class="p">();</span>

	<span class="cm">/* Hook in our special panic hypercall code. */</span>
	<span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">panic_notifier_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paniced</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The IDE code spends about 3 seconds probing for disks: if we reserve</span>
<span class="cm">	 * all the I/O ports up front it can&#39;t get them and so doesn&#39;t probe.</span>
<span class="cm">	 * Other device drivers are similar (but less severe).  This cuts the</span>
<span class="cm">	 * kernel boot time on my machine from 4.1 seconds to 0.45 seconds.</span>
<span class="cm">	 */</span>
	<span class="n">paravirt_disable_iospace</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is messy CPU setup stuff which the native boot code does before</span>
<span class="cm">	 * start_kernel, so we have to do, too:</span>
<span class="cm">	 */</span>
	<span class="n">cpu_detect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_cpu_data</span><span class="p">);</span>
	<span class="cm">/* head.S usually sets up the first capability word, so do it here. */</span>
	<span class="n">new_cpu_data</span><span class="p">.</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuid_edx</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Math is always hard! */</span>
	<span class="n">new_cpu_data</span><span class="p">.</span><span class="n">hard_math</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t have features.  We have puppies!  Puppies! */</span>
<span class="cp">#ifdef CONFIG_X86_MCE</span>
	<span class="n">mce_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ACPI</span>
	<span class="n">acpi_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * We set the preferred console to &quot;hvc&quot;.  This is the &quot;hypervisor</span>
<span class="cm">	 * virtual console&quot; driver written by the PowerPC people, which we also</span>
<span class="cm">	 * adapted for lguest&#39;s use.</span>
<span class="cm">	 */</span>
	<span class="n">add_preferred_console</span><span class="p">(</span><span class="s">&quot;hvc&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Register our very early console. */</span>
	<span class="n">virtio_cons_early_init</span><span class="p">(</span><span class="n">early_put_chars</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last of all, we set the power management poweroff hook to point to</span>
<span class="cm">	 * the Guest routine to power off, and the reboot hook to our restart</span>
<span class="cm">	 * routine.</span>
<span class="cm">	 */</span>
	<span class="n">pm_power_off</span> <span class="o">=</span> <span class="n">lguest_power_off</span><span class="p">;</span>
	<span class="n">machine_ops</span><span class="p">.</span><span class="n">restart</span> <span class="o">=</span> <span class="n">lguest_restart</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we&#39;re set up, call i386_start_kernel() in head32.c and we proceed</span>
<span class="cm">	 * to boot as normal.  It never returns.</span>
<span class="cm">	 */</span>
	<span class="n">i386_start_kernel</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * This marks the end of stage II of our journey, The Guest.</span>
<span class="cm"> *</span>
<span class="cm"> * It is now time for us to explore the layer of virtual drivers and complete</span>
<span class="cm"> * our understanding of the Guest in &quot;make Drivers&quot;.</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
