<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › lib › csum-partial_64.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>csum-partial_64.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * arch/x86_64/lib/csum-partial.c</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains network checksum routines that are better done</span>
<span class="cm"> * in an architecture-specific manner due to speed.</span>
<span class="cm"> */</span>
 
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/checksum.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">from32to16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">a</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span> 
	<span class="n">asm</span><span class="p">(</span><span class="s">&quot;addw %w2,%w0</span><span class="se">\n\t</span><span class="s">&quot;</span>
	    <span class="s">&quot;adcw $0,%w0</span><span class="se">\n</span><span class="s">&quot;</span> 
	    <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
	    <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do a 64-bit checksum on an arbitrary memory area.</span>
<span class="cm"> * Returns a 32bit checksum.</span>
<span class="cm"> *</span>
<span class="cm"> * This isn&#39;t as time critical as it used to be because many NICs</span>
<span class="cm"> * do hardware checksumming these days.</span>
<span class="cm"> * </span>
<span class="cm"> * Things tried and found to not make it faster:</span>
<span class="cm"> * Manual Prefetching</span>
<span class="cm"> * Unrolling to an 128 bytes inner loop.</span>
<span class="cm"> * Using interleaving with more registers to break the carry chains.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">do_csum</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">odd</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span> 
	<span class="n">odd</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">odd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">buff</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="n">buff</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* nr of 16-bit words.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">buff</span><span class="p">;</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">buff</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* nr of 32-bit words.. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">count64</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">buff</span><span class="p">;</span>
				<span class="n">count</span><span class="o">--</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">buff</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* nr of 64-bit words.. */</span>

			<span class="cm">/* main loop using 64byte blocks */</span>
			<span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">count64</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">count64</span><span class="p">)</span> <span class="p">{</span> 
				<span class="n">asm</span><span class="p">(</span><span class="s">&quot;addq 0*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 1*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 2*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 3*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 4*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 5*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 6*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq 7*8(%[src]),%[res]</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq %[zero],%[res]&quot;</span>
				    <span class="o">:</span> <span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				    <span class="o">:</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="p">[</span><span class="n">zero</span><span class="p">]</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">zero</span><span class="p">),</span>
				    <span class="s">&quot;[res]&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">));</span>
				<span class="n">buff</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
				<span class="n">count64</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* last up to 7 8byte blocks */</span>
			<span class="n">count</span> <span class="o">%=</span> <span class="mi">8</span><span class="p">;</span> 
			<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span> 
				<span class="n">asm</span><span class="p">(</span><span class="s">&quot;addq %1,%0</span><span class="se">\n\t</span><span class="s">&quot;</span>
				    <span class="s">&quot;adcq %2,%0</span><span class="se">\n</span><span class="s">&quot;</span> 
					    <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				    <span class="o">:</span> <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">buff</span><span class="p">),</span> 
				    <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">zero</span><span class="p">),</span>  <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">));</span>
				<span class="o">--</span><span class="n">count</span><span class="p">;</span> 
					<span class="n">buff</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">add32_with_carry</span><span class="p">(</span><span class="n">result</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">,</span>
						  <span class="n">result</span><span class="o">&amp;</span><span class="mh">0xffffffff</span><span class="p">);</span> 

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">buff</span><span class="p">;</span>
				<span class="n">buff</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span> <span class="n">buff</span><span class="p">;</span>
			<span class="n">buff</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">add32_with_carry</span><span class="p">(</span><span class="n">result</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">,</span> <span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">odd</span><span class="p">))</span> <span class="p">{</span> 
		<span class="n">result</span> <span class="o">=</span> <span class="n">from32to16</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">result</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">result</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * computes the checksum of a memory block at buff, length len,</span>
<span class="cm"> * and adds in &quot;sum&quot; (32-bit)</span>
<span class="cm"> *</span>
<span class="cm"> * returns a 32-bit number suitable for feeding into itself</span>
<span class="cm"> * or csum_tcpudp_magic</span>
<span class="cm"> *</span>
<span class="cm"> * this function must be called with even lengths, except</span>
<span class="cm"> * for the last fragment, which may be odd</span>
<span class="cm"> *</span>
<span class="cm"> * it&#39;s best to have buff aligned on a 64-bit boundary</span>
<span class="cm"> */</span>
<span class="n">__wsum</span> <span class="nf">csum_partial</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__wsum</span><span class="p">)</span><span class="n">add32_with_carry</span><span class="p">(</span><span class="n">do_csum</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
						<span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this routine is used for miscellaneous IP-like checksums, mainly</span>
<span class="cm"> * in icmp.c</span>
<span class="cm"> */</span>
<span class="n">__sum16</span> <span class="nf">ip_compute_csum</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ip_compute_csum</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
