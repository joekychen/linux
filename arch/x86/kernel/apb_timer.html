<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › apb_timer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>apb_timer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * apb_timer.c: Driver for Langwell APB timers</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2009 Intel Corporation</span>
<span class="cm"> * Author: Jacob Pan (jacob.jun.pan@intel.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; version 2</span>
<span class="cm"> * of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> * Langwell is the south complex of Intel Moorestown MID platform. There are</span>
<span class="cm"> * eight external timers in total that can be used by the operating system.</span>
<span class="cm"> * The timer information, such as frequency and addresses, is provided to the</span>
<span class="cm"> * OS via SFI tables.</span>
<span class="cm"> * Timer interrupts are routed via FW/HW emulated IOAPIC independently via</span>
<span class="cm"> * individual redirection table entries (RTE).</span>
<span class="cm"> * Unlike HPET, there is no master counter, therefore one of the timers are</span>
<span class="cm"> * used as clocksource. The overall allocation looks like:</span>
<span class="cm"> *  - timer 0 - NR_CPUs for per cpu timer</span>
<span class="cm"> *  - one timer for clocksource</span>
<span class="cm"> *  - one timer for watchdog driver.</span>
<span class="cm"> * It is also worth notice that APB timer does not support true one-shot mode,</span>
<span class="cm"> * free-running mode will be used here to emulate one-shot mode.</span>
<span class="cm"> * APB timer can also be used as broadcast timer along with per cpu local APIC</span>
<span class="cm"> * timer, but by default APB timer has higher rating than local APIC timers.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dw_apb_timer.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/sfi.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>

<span class="cp">#include &lt;asm/fixmap.h&gt;</span>
<span class="cp">#include &lt;asm/apb_timer.h&gt;</span>
<span class="cp">#include &lt;asm/mrst.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>

<span class="cp">#define APBT_CLOCKEVENT_RATING		110</span>
<span class="cp">#define APBT_CLOCKSOURCE_RATING		250</span>

<span class="cp">#define APBT_CLOCKEVENT0_NUM   (0)</span>
<span class="cp">#define APBT_CLOCKSOURCE_NUM   (2)</span>

<span class="k">static</span> <span class="n">phys_addr_t</span> <span class="n">apbt_address</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">apb_timer_block_enabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">apbt_virt_address</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Common DW APB timer info</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">apbt_freq</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">apbt_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dw_apb_clock_event_device</span>	<span class="o">*</span><span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span>					<span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">irq</span><span class="p">;</span>
	<span class="kt">char</span>					<span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dw_apb_clocksource</span> <span class="o">*</span><span class="n">clocksource_apbt</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">adev_virt_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apbt_virt_address</span> <span class="o">+</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="n">APBTMRS_REG_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">apbt_dev</span><span class="p">,</span> <span class="n">cpu_apbt_dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apbt_num_timers_used</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apbt_set_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sfi_timer_table_entry</span> <span class="o">*</span><span class="n">mtmr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phy_cs_timer_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apbt_virt_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT base already mapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtmr</span> <span class="o">=</span> <span class="n">sfi_get_mtmr</span><span class="p">(</span><span class="n">APBT_CLOCKEVENT0_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtmr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to get MTMR %d from SFI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">APBT_CLOCKEVENT0_NUM</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apbt_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span><span class="n">mtmr</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apbt_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No timer base from SFI, use default</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">apbt_address</span> <span class="o">=</span> <span class="n">APBT_DEFAULT_BASE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apbt_virt_address</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">apbt_address</span><span class="p">,</span> <span class="n">APBT_MMAP_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apbt_virt_address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Failed mapping APBT phy address at %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>\
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">apbt_address</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">panic_noapbt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apbt_freq</span> <span class="o">=</span> <span class="n">mtmr</span><span class="o">-&gt;</span><span class="n">freq_hz</span><span class="p">;</span>
	<span class="n">sfi_free_mtmr</span><span class="p">(</span><span class="n">mtmr</span><span class="p">);</span>

	<span class="cm">/* Now figure out the physical timer id for clocksource device */</span>
	<span class="n">mtmr</span> <span class="o">=</span> <span class="n">sfi_get_mtmr</span><span class="p">(</span><span class="n">APBT_CLOCKSOURCE_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtmr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">panic_noapbt</span><span class="p">;</span>

	<span class="cm">/* Now figure out the physical timer id */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Use timer %d for clocksource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">mtmr</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">/</span> <span class="n">APBTMRS_REG_SIZE</span><span class="p">);</span>
	<span class="n">phy_cs_timer_id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">mtmr</span><span class="o">-&gt;</span><span class="n">phys_addr</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">APBTMRS_REG_SIZE</span><span class="p">;</span>

	<span class="n">clocksource_apbt</span> <span class="o">=</span> <span class="n">dw_apb_clocksource_init</span><span class="p">(</span><span class="n">APBT_CLOCKSOURCE_RATING</span><span class="p">,</span>
		<span class="s">&quot;apbt0&quot;</span><span class="p">,</span> <span class="n">apbt_virt_address</span> <span class="o">+</span> <span class="n">phy_cs_timer_id</span> <span class="o">*</span>
		<span class="n">APBTMRS_REG_SIZE</span><span class="p">,</span> <span class="n">apbt_freq</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">panic_noapbt:</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to setup APB system timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apbt_clear_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">apbt_virt_address</span><span class="p">);</span>
	<span class="n">apbt_virt_address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * APBT timer interrupt enable / disable</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_apbt_capable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">apbt_virt_address</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apbt_clockevent_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sfi_timer_table_entry</span> <span class="o">*</span><span class="n">mtmr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_apbt_dev</span><span class="p">);</span>

	<span class="n">mtmr</span> <span class="o">=</span> <span class="n">sfi_get_mtmr</span><span class="p">(</span><span class="n">APBT_CLOCKEVENT0_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtmr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to get MTMR %d from SFI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">APBT_CLOCKEVENT0_NUM</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adev</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">dw_apb_clockevent_init</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="s">&quot;apbt0&quot;</span><span class="p">,</span>
		<span class="n">mrst_timer_options</span> <span class="o">==</span> <span class="n">MRST_TIMER_LAPIC_APBT</span> <span class="o">?</span>
		<span class="n">APBT_CLOCKEVENT_RATING</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">:</span> <span class="n">APBT_CLOCKEVENT_RATING</span><span class="p">,</span>
		<span class="n">adev_virt_addr</span><span class="p">(</span><span class="n">adev</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">apbt_freq</span><span class="p">);</span>
	<span class="cm">/* Firmware does EOI handling for us. */</span>
	<span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">eoi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mrst_timer_options</span> <span class="o">==</span> <span class="n">MRST_TIMER_LAPIC_APBT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">global_clock_event</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">ced</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s clockevent registered as global</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">global_clock_event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dw_apb_clockevent_register</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">sfi_free_mtmr</span><span class="p">(</span><span class="n">mtmr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apbt_setup_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* timer0 irq has been setup early */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">irq_modify_status</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IRQ_MOVE_PCNTXT</span><span class="p">);</span>
	<span class="n">irq_set_affinity</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
	<span class="cm">/* APB timer irqs are set up as mp_irqs, timer is edge type */</span>
	<span class="n">__irq_set_handler</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;edge&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Should be called with per cpu */</span>
<span class="kt">void</span> <span class="nf">apbt_setup_secondary_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t register boot CPU clockevent */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">adev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_apbt_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">dw_apb_clockevent_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">APBT_CLOCKEVENT_RATING</span><span class="p">,</span> <span class="n">adev_virt_addr</span><span class="p">(</span><span class="n">adev</span><span class="p">),</span>
			<span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">apbt_freq</span><span class="p">);</span>
		<span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">eoi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dw_apb_clockevent_resume</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Registering CPU %d clockevent device %s, cpu %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">cpu</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">apbt_setup_irq</span><span class="p">(</span><span class="n">adev</span><span class="p">);</span>
	<span class="n">dw_apb_clockevent_register</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this notify handler process CPU hotplug events. in case of S0i3, nonboot</span>
<span class="cm"> * cpus are disabled/enabled frequently, for performance reasons, we keep the</span>
<span class="cm"> * per cpu timer irq registered so that we do need to do free_irq/request_irq.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: it might be more reliable to directly disable percpu clockevent device</span>
<span class="cm"> * without the notifier chain. currently, cpu 0 may get interrupts from other</span>
<span class="cm"> * cpu timers during the offline process due to the ordering of notification.</span>
<span class="cm"> * the extra interrupt is harmless.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apbt_cpuhp_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_apbt_dev</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
		<span class="n">dw_apb_clockevent_pause</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_RUNNING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;skipping APBT CPU %lu offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT clockevent for cpu %lu offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">dw_apb_clockevent_stop</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT notified %lu, no action</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">apbt_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mrst_timer_options</span> <span class="o">==</span> <span class="n">MRST_TIMER_LAPIC_APBT</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">apb_timer_block_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* This notifier should be called after workqueue is ready */</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">apbt_cpuhp_notify</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">apbt_late_init</span><span class="p">);</span>
<span class="cp">#else</span>

<span class="kt">void</span> <span class="nf">apbt_setup_secondary_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apbt_clocksource_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">t1</span><span class="p">;</span>

	<span class="cm">/* Start the counter, use timer 2 as source, timer 0/1 for event */</span>
	<span class="n">dw_apb_clocksource_start</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>

	<span class="cm">/* Verify whether apbt counter works */</span>
	<span class="n">t1</span> <span class="o">=</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>
	<span class="n">rdtscll</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t know the TSC frequency yet, but waiting for</span>
<span class="cm">	 * 200000 TSC cycles is safe:</span>
<span class="cm">	 * 4 GHz == 50us</span>
<span class="cm">	 * 1 GHz == 200us</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rep_nop</span><span class="p">();</span>
		<span class="n">rdtscll</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">now</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">200000UL</span><span class="p">);</span>

	<span class="cm">/* APBT is the only always on clocksource, it has to work! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;APBT counter not counting. APBT disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">dw_apb_clocksource_register</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Early setup the APBT timer, only use timer 0 for booting then switch to</span>
<span class="cm"> * per CPU timer if possible.</span>
<span class="cm"> * returns 1 if per cpu apbt is setup</span>
<span class="cm"> * returns 0 if no per cpu apbt is chosen</span>
<span class="cm"> * panic if set up failed, this is the only platform timer on Moorestown.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">apbt_time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sfi_timer_table_entry</span> <span class="o">*</span><span class="n">p_mtmr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">percpu_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apbt_dev</span> <span class="o">*</span><span class="n">adev</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apb_timer_block_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">apbt_set_mapping</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apbt_virt_address</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_noapbt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the frequency and check for a sane value, for ESL model</span>
<span class="cm">	 * we extend the possible clock range to allow time scaling.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apbt_freq</span> <span class="o">&lt;</span> <span class="n">APBT_MIN_FREQ</span> <span class="o">||</span> <span class="n">apbt_freq</span> <span class="o">&gt;</span> <span class="n">APBT_MAX_FREQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT has invalid freq 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">apbt_freq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_noapbt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apbt_clocksource_register</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT has failed to register clocksource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_noapbt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apbt_clockevent_register</span><span class="p">())</span>
		<span class="n">apb_timer_block_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;APBT has failed to register clockevent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_noapbt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* kernel cmdline disable apb timer, so we will use lapic timers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mrst_timer_options</span> <span class="o">==</span> <span class="n">MRST_TIMER_LAPIC_APBT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apbt: disabled per cpu timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %d CPUs online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">sfi_mtimer_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">percpu_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">apbt_num_timers_used</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">percpu_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">apbt_num_timers_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: %d APB timers used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">apbt_num_timers_used</span><span class="p">);</span>

	<span class="cm">/* here we set up per CPU timer data structure */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">apbt_num_timers_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_apbt_dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">adev</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">adev</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">p_mtmr</span> <span class="o">=</span> <span class="n">sfi_get_mtmr</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_mtmr</span><span class="p">)</span>
			<span class="n">adev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">p_mtmr</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to get timer for cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;apbt%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_noapbt:</span>
	<span class="n">apbt_clear_mapping</span><span class="p">();</span>
	<span class="n">apb_timer_block_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;failed to enable APB timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called before apb_timer_enable, use early map */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">apbt_quick_calibrate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">khz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">loop</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">apbt_set_mapping</span><span class="p">();</span>
	<span class="n">dw_apb_clocksource_start</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>

	<span class="cm">/* check if the timer can count down, otherwise return */</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="cm">/* count 16 ms */</span>
	<span class="n">loop</span> <span class="o">=</span> <span class="p">(</span><span class="n">apbt_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* restart the timer to ensure it won&#39;t get to 0 in the calibration */</span>
	<span class="n">dw_apb_clocksource_start</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">+=</span> <span class="n">loop</span><span class="p">;</span>

	<span class="n">t1</span> <span class="o">=</span> <span class="n">__native_read_tsc</span><span class="p">();</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">dw_apb_clocksource_read</span><span class="p">(</span><span class="n">clocksource_apbt</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">new</span> <span class="o">&lt;</span> <span class="n">old</span><span class="p">);</span>

	<span class="n">t2</span> <span class="o">=</span> <span class="n">__native_read_tsc</span><span class="p">();</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">loop</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;APBT TSC calibration failed, not enough resolution</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">div_u64</span><span class="p">((</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">),</span> <span class="n">loop</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">);</span>
	<span class="n">khz</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">apbt_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;TSC freq calculated by APB timer is %lu khz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">khz</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">khz</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
