<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › traps.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>traps.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *  Copyright (C) 2000, 2001, 2002 Andi Kleen, SuSE Labs</span>
<span class="cm"> *</span>
<span class="cm"> *  Pentium III FXSR, SSE support</span>
<span class="cm"> *	Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Handle hardware traps and faults.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#ifdef CONFIG_EISA</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/eisa.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_EDAC)</span>
<span class="cp">#include &lt;linux/edac.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;asm/stacktrace.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/debugreg.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/ftrace.h&gt;</span>
<span class="cp">#include &lt;asm/traps.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/fpu-internal.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>

<span class="cp">#include &lt;asm/mach_traps.h&gt;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cp">#include &lt;asm/x86_init.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm/processor-flags.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="n">system_call</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Do we ignore FPU interrupts ? */</span>
<span class="kt">char</span> <span class="n">ignore_fpu_irq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The IDT has to be page-aligned to simplify the Pentium</span>
<span class="cm"> * F0 0F bug workaround.</span>
<span class="cm"> */</span>
<span class="n">gate_desc</span> <span class="n">idt_table</span><span class="p">[</span><span class="n">NR_VECTORS</span><span class="p">]</span> <span class="n">__page_aligned_data</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">}</span> <span class="p">},</span> <span class="p">};</span>
<span class="cp">#endif</span>

<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">used_vectors</span><span class="p">,</span> <span class="n">NR_VECTORS</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">used_vectors</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">conditional_sti</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_conditional_sti</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inc_preempt_count</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">conditional_cli</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_conditional_cli</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">dec_preempt_count</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">do_trap</span><span class="p">(</span><span class="kt">int</span> <span class="n">trapnr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
	<span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_VM_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * traps 0, 1, 3, 4, and 5 should be forwarded to vm86.</span>
<span class="cm">		 * On nmi (interrupt 2), do_trap should not be called.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trapnr</span> <span class="o">&lt;</span> <span class="n">X86_TRAP_UD</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">vm86_trap</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">trap_signal</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">kernel_trap</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="nl">trap_signal:</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want error_code and trap_nr set for userspace faults and</span>
<span class="cm">	 * kernelspace faults which result in die(), but not</span>
<span class="cm">	 * kernelspace faults which are fixed up.  die() gives the</span>
<span class="cm">	 * process no chance to handle the signal and notice the</span>
<span class="cm">	 * kernel fault information, so that won&#39;t result in polluting</span>
<span class="cm">	 * the information about previously queued, but not yet</span>
<span class="cm">	 * delivered, faults.  See also do_general_protection below.</span>
<span class="cm">	 */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">trapnr</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span> <span class="o">&amp;&amp;</span> <span class="n">unhandled_signal</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">signr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;%s[%d] trap %s ip:%lx sp:%lx error:%lx&quot;</span><span class="p">,</span>
		       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span>
		       <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
		<span class="n">print_vma_addr</span><span class="p">(</span><span class="s">&quot; in &quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
		<span class="n">force_sig_info</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">kernel_trap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">trapnr</span><span class="p">;</span>
		<span class="n">die</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="nl">vm86_trap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle_vm86_trap</span><span class="p">((</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">,</span>
						<span class="n">error_code</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">trap_signal</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#define DO_ERROR(trapnr, signr, str, name)				\</span>
<span class="cp">dotraplinkage void do_##name(struct pt_regs *regs, long error_code)	\</span>
<span class="cp">{									\</span>
<span class="cp">	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\</span>
<span class="cp">							== NOTIFY_STOP)	\</span>
<span class="cp">		return;							\</span>
<span class="cp">	conditional_sti(regs);						\</span>
<span class="cp">	do_trap(trapnr, signr, str, regs, error_code, NULL);		\</span>
<span class="cp">}</span>

<span class="cp">#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr)		\</span>
<span class="cp">dotraplinkage void do_##name(struct pt_regs *regs, long error_code)	\</span>
<span class="cp">{									\</span>
<span class="cp">	siginfo_t info;							\</span>
<span class="cp">	info.si_signo = signr;						\</span>
<span class="cp">	info.si_errno = 0;						\</span>
<span class="cp">	info.si_code = sicode;						\</span>
<span class="cp">	info.si_addr = (void __user *)siaddr;				\</span>
<span class="cp">	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\</span>
<span class="cp">							== NOTIFY_STOP)	\</span>
<span class="cp">		return;							\</span>
<span class="cp">	conditional_sti(regs);						\</span>
<span class="cp">	do_trap(trapnr, signr, str, regs, error_code, &amp;info);		\</span>
<span class="cp">}</span>

<span class="n">DO_ERROR_INFO</span><span class="p">(</span><span class="n">X86_TRAP_DE</span><span class="p">,</span> <span class="n">SIGFPE</span><span class="p">,</span> <span class="s">&quot;divide error&quot;</span><span class="p">,</span> <span class="n">divide_error</span><span class="p">,</span> <span class="n">FPE_INTDIV</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_OF</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="s">&quot;overflow&quot;</span><span class="p">,</span> <span class="n">overflow</span><span class="p">)</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_BR</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="s">&quot;bounds&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
<span class="n">DO_ERROR_INFO</span><span class="p">(</span><span class="n">X86_TRAP_UD</span><span class="p">,</span> <span class="n">SIGILL</span><span class="p">,</span> <span class="s">&quot;invalid opcode&quot;</span><span class="p">,</span> <span class="n">invalid_op</span><span class="p">,</span> <span class="n">ILL_ILLOPN</span><span class="p">,</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_OLD_MF</span><span class="p">,</span> <span class="n">SIGFPE</span><span class="p">,</span> <span class="s">&quot;coprocessor segment overrun&quot;</span><span class="p">,</span>
		<span class="n">coprocessor_segment_overrun</span><span class="p">)</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_TS</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="s">&quot;invalid TSS&quot;</span><span class="p">,</span> <span class="n">invalid_TSS</span><span class="p">)</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_NP</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="s">&quot;segment not present&quot;</span><span class="p">,</span> <span class="n">segment_not_present</span><span class="p">)</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="n">DO_ERROR</span><span class="p">(</span><span class="n">X86_TRAP_SS</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="s">&quot;stack segment&quot;</span><span class="p">,</span> <span class="n">stack_segment</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="n">DO_ERROR_INFO</span><span class="p">(</span><span class="n">X86_TRAP_AC</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="s">&quot;alignment check&quot;</span><span class="p">,</span> <span class="n">alignment_check</span><span class="p">,</span>
		<span class="n">BUS_ADRALN</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cm">/* Runs on IST stack */</span>
<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">do_stack_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="s">&quot;stack segment&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
			<span class="n">X86_TRAP_SS</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">preempt_conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">do_trap</span><span class="p">(</span><span class="n">X86_TRAP_SS</span><span class="p">,</span> <span class="n">SIGBUS</span><span class="p">,</span> <span class="s">&quot;stack segment&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">preempt_conditional_cli</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">do_double_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;double fault&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="cm">/* Return not checked because double check cannot be ignored */</span>
	<span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">X86_TRAP_DF</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">);</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">X86_TRAP_DF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is always a kernel trap and never fixable (and thus must</span>
<span class="cm">	 * never return).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span>
		<span class="n">die</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="n">do_general_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>

	<span class="n">conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_VM_MASK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">gp_in_vm86</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">gp_in_kernel</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">X86_TRAP_GP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">show_unhandled_signals</span> <span class="o">&amp;&amp;</span> <span class="n">unhandled_signal</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;%s[%d] general protection ip:%lx sp:%lx error:%lx&quot;</span><span class="p">,</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span>
			<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
		<span class="n">print_vma_addr</span><span class="p">(</span><span class="s">&quot; in &quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="nl">gp_in_vm86:</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">handle_vm86_fault</span><span class="p">((</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="nl">gp_in_kernel:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">X86_TRAP_GP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_GPF</span><span class="p">,</span> <span class="s">&quot;general protection fault&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
			<span class="n">X86_TRAP_GP</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">die</span><span class="p">(</span><span class="s">&quot;general protection fault&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* May run on IST stack. */</span>
<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="n">notrace</span> <span class="n">do_int3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>
	<span class="cm">/*</span>
<span class="cm">	 * ftrace must be first, everything else may cause a recursive crash.</span>
<span class="cm">	 * See note by declaration of modifying_ftrace_code in ftrace.c</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modifying_ftrace_code</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ftrace_int3_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_ll_trap</span><span class="p">(</span><span class="n">DIE_INT3</span><span class="p">,</span> <span class="s">&quot;int3&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">X86_TRAP_BP</span><span class="p">,</span>
				<span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KGDB_LOW_LEVEL_TRAP */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_INT3</span><span class="p">,</span> <span class="s">&quot;int3&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">X86_TRAP_BP</span><span class="p">,</span>
			<span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let others (NMI) know that the debug stack is in use</span>
<span class="cm">	 * as we may switch to the interrupt stack.</span>
<span class="cm">	 */</span>
	<span class="n">debug_stack_usage_inc</span><span class="p">();</span>
	<span class="n">preempt_conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">do_trap</span><span class="p">(</span><span class="n">X86_TRAP_BP</span><span class="p">,</span> <span class="n">SIGTRAP</span><span class="p">,</span> <span class="s">&quot;int3&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">preempt_conditional_cli</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">debug_stack_usage_dec</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cm">/*</span>
<span class="cm"> * Help handler running on IST stack to switch back to user stack</span>
<span class="cm"> * for scheduling or signal handling. The actual stack switch is done in</span>
<span class="cm"> * entry.S</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="n">__kprobes</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">sync_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">eregs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">eregs</span><span class="p">;</span>
	<span class="cm">/* Did already sync */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eregs</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span><span class="n">eregs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="cm">/* Exception from user space */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">eregs</span><span class="p">))</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="n">task_pt_regs</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Exception from kernel and interrupts are enabled. Move to</span>
<span class="cm">	 * kernel process stack.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eregs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)(</span><span class="n">eregs</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eregs</span> <span class="o">!=</span> <span class="n">regs</span><span class="p">)</span>
		<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">*</span><span class="n">eregs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">regs</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Our handling of the processor debug registers is non-trivial.</span>
<span class="cm"> * We do not clear them on entry and exit from the kernel. Therefore</span>
<span class="cm"> * it is possible to get a watchpoint trap here from inside the kernel.</span>
<span class="cm"> * However, the code in ./ptrace.c has ensured that the user can</span>
<span class="cm"> * only set watchpoints on userspace addresses. Therefore the in-kernel</span>
<span class="cm"> * watchpoint trap can only occur in code which is reading/writing</span>
<span class="cm"> * from user space. Such code must not hold kernel locks (since it</span>
<span class="cm"> * can equally take a page fault), therefore it is safe to call</span>
<span class="cm"> * force_sig_info even though that claims and releases locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Code in ./signal.c ensures that the debug control register</span>
<span class="cm"> * is restored before we deliver any signal, and therefore that</span>
<span class="cm"> * user code runs with the correct debug control register even though</span>
<span class="cm"> * we clear it here.</span>
<span class="cm"> *</span>
<span class="cm"> * Being careful here means that we don&#39;t have to be as careful in a</span>
<span class="cm"> * lot of more complicated places (task switching can be a bit lazy</span>
<span class="cm"> * about restoring all the debug state, and ptrace doesn&#39;t have to</span>
<span class="cm"> * find every occurrence of the TF bit that could be saved away even</span>
<span class="cm"> * by user code)</span>
<span class="cm"> *</span>
<span class="cm"> * May run on IST stack.</span>
<span class="cm"> */</span>
<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="n">do_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">user_icebp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dr6</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span>

	<span class="n">get_debugreg</span><span class="p">(</span><span class="n">dr6</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="cm">/* Filter out all the reserved bits which are preset to 1 */</span>
	<span class="n">dr6</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DR6_RESERVED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If dr6 has no reason to give us about the origin of this trap,</span>
<span class="cm">	 * then it&#39;s very likely the result of an icebp/int01 trap.</span>
<span class="cm">	 * User wants a sigtrap for that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dr6</span> <span class="o">&amp;&amp;</span> <span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="n">user_icebp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Catch kmemcheck conditions first of all! */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dr6</span> <span class="o">&amp;</span> <span class="n">DR_STEP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kmemcheck_trap</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* DR6 may or may not be cleared by the CPU */</span>
	<span class="n">set_debugreg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The processor cleared BTF, so don&#39;t mark that we need it set.</span>
<span class="cm">	 */</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TIF_BLOCKSTEP</span><span class="p">);</span>

	<span class="cm">/* Store the virtualized DR6 value */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">debugreg6</span> <span class="o">=</span> <span class="n">dr6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_DEBUG</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr6</span><span class="p">),</span> <span class="n">error_code</span><span class="p">,</span>
							<span class="n">SIGTRAP</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let others (NMI) know that the debug stack is in use</span>
<span class="cm">	 * as we may switch to the interrupt stack.</span>
<span class="cm">	 */</span>
	<span class="n">debug_stack_usage_inc</span><span class="p">();</span>

	<span class="cm">/* It&#39;s safe to allow irq&#39;s after DR6 has been saved */</span>
	<span class="n">preempt_conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_VM_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_vm86_trap</span><span class="p">((</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="p">)</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
					<span class="n">X86_TRAP_DB</span><span class="p">);</span>
		<span class="n">preempt_conditional_cli</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">debug_stack_usage_dec</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Single-stepping through system calls: ignore any exceptions in</span>
<span class="cm">	 * kernel space, but re-enable TF when returning to user mode.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We already checked v86 mode above, so we can check for kernel mode</span>
<span class="cm">	 * by just checking the CPL of CS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dr6</span> <span class="o">&amp;</span> <span class="n">DR_STEP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">debugreg6</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DR_STEP</span><span class="p">;</span>
		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TIF_SINGLESTEP</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">si_code</span> <span class="o">=</span> <span class="n">get_si_code</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">debugreg6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">debugreg6</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DR_STEP</span> <span class="o">|</span> <span class="n">DR_TRAP_BITS</span><span class="p">)</span> <span class="o">||</span> <span class="n">user_icebp</span><span class="p">)</span>
		<span class="n">send_sigtrap</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">si_code</span><span class="p">);</span>
	<span class="n">preempt_conditional_cli</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">debug_stack_usage_dec</span><span class="p">();</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note that we play around with the &#39;TS&#39; bit in an attempt to get</span>
<span class="cm"> * the correct behaviour even in the presence of the asynchronous</span>
<span class="cm"> * IRQ13 behaviour</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">math_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="n">trapnr</span> <span class="o">==</span> <span class="n">X86_TRAP_MF</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;fpu exception&quot;</span> <span class="o">:</span>
						<span class="s">&quot;simd exception&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">,</span> <span class="n">SIGFPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode_vm</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">trapnr</span><span class="p">;</span>
			<span class="n">die</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the info for the exception handler and clear the error.</span>
<span class="cm">	 */</span>
	<span class="n">save_init_fpu</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">trapnr</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGFPE</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trapnr</span> <span class="o">==</span> <span class="n">X86_TRAP_MF</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cwd</span><span class="p">,</span> <span class="n">swd</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * (~cwd &amp; swd) will mask out exceptions that are not set to unmasked</span>
<span class="cm">		 * status.  0x3f is the exception bits in these regs, 0x200 is the</span>
<span class="cm">		 * C1 reg you need in case of a stack fault, 0x040 is the stack</span>
<span class="cm">		 * fault bit.  We should only be taking one exception at a time,</span>
<span class="cm">		 * so if this combination doesn&#39;t produce any single exception,</span>
<span class="cm">		 * then we have a bad program that isn&#39;t synchronizing its FPU usage</span>
<span class="cm">		 * and it will suffer the consequences since we won&#39;t be able to</span>
<span class="cm">		 * fully reproduce the context of the exception</span>
<span class="cm">		 */</span>
		<span class="n">cwd</span> <span class="o">=</span> <span class="n">get_fpu_cwd</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">swd</span> <span class="o">=</span> <span class="n">get_fpu_swd</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">swd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cwd</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The SIMD FPU exceptions are handled a little differently, as there</span>
<span class="cm">		 * is only a single status/control register.  Thus, to determine which</span>
<span class="cm">		 * unmasked exception was caught we must mask the exception mask bits</span>
<span class="cm">		 * at 0x1f80, and then use these to mask the exception bits at 0x3f.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mxcsr</span> <span class="o">=</span> <span class="n">get_fpu_mxcsr</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">mxcsr</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mxcsr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x001</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Invalid op */</span>
		<span class="cm">/*</span>
<span class="cm">		 * swd &amp; 0x240 == 0x040: Stack Underflow</span>
<span class="cm">		 * swd &amp; 0x240 == 0x240: Stack Overflow</span>
<span class="cm">		 * User must clear the SF bit (0x40) if set</span>
<span class="cm">		 */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTINV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x004</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Divide by Zero */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTDIV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x008</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Overflow */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTOVF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x012</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Denormal, Underflow */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTUND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x020</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Precision */</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">FPE_FLTRES</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re using IRQ 13, or supposedly even some trap</span>
<span class="cm">		 * X86_TRAP_MF implementations, it&#39;s possible</span>
<span class="cm">		 * we get a spurious trap, which is not an error.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">do_coprocessor_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">ignore_fpu_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">math_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">X86_TRAP_MF</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span>
<span class="n">do_simd_coprocessor_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">math_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">X86_TRAP_XF</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span>
<span class="n">do_spurious_interrupt_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* No need to warn about this any longer. */</span>
<span class="c">	printk(KERN_INFO &quot;Ignoring P6 Local APIC Spurious Interrupt Bug...\n&quot;);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">smp_thermal_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">smp_threshold_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;math_state_restore()&#39; saves the current math information in the</span>
<span class="cm"> * old math state array, and gets the new ones from the current task</span>
<span class="cm"> *</span>
<span class="cm"> * Careful.. There are problems with IBM-designed IRQ13 behaviour.</span>
<span class="cm"> * Don&#39;t touch unless you *really* know how it works.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with kernel preemption disabled (eg with local</span>
<span class="cm"> * local interrupts as in the case of do_device_not_available).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">math_state_restore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk_used_math</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * does a slab alloc which can sleep</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">init_fpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ran out of memory!</span>
<span class="cm">			 */</span>
			<span class="n">do_group_exit</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">__thread_fpu_begin</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Paranoid restore. send a SIGSEGV if we fail to restore the state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">restore_fpu_checking</span><span class="p">(</span><span class="n">tsk</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__thread_fpu_end</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">fpu_counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">math_state_restore</span><span class="p">);</span>

<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">do_device_not_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MATH_EMULATION</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_cr0</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">X86_CR0_EM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">math_emu_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

		<span class="n">conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

		<span class="n">info</span><span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
		<span class="n">math_emulate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">math_state_restore</span><span class="p">();</span> <span class="cm">/* interrupts still off */</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">conditional_sti</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="n">dotraplinkage</span> <span class="kt">void</span> <span class="nf">do_iret_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGILL</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">ILL_BADSTK</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify_die</span><span class="p">(</span><span class="n">DIE_TRAP</span><span class="p">,</span> <span class="s">&quot;iret exception&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
			<span class="n">X86_TRAP_IRET</span><span class="p">,</span> <span class="n">SIGILL</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">do_trap</span><span class="p">(</span><span class="n">X86_TRAP_IRET</span><span class="p">,</span> <span class="n">SIGILL</span><span class="p">,</span> <span class="s">&quot;iret exception&quot;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Set of traps needed for early debugging. */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug</span><span class="p">,</span> <span class="n">DEBUG_STACK</span><span class="p">);</span>
	<span class="cm">/* int3 can be called from all */</span>
	<span class="n">set_system_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_BP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int3</span><span class="p">,</span> <span class="n">DEBUG_STACK</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_PF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_fault</span><span class="p">);</span>
	<span class="n">load_idt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EISA</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">early_ioremap</span><span class="p">(</span><span class="mh">0x0FFFD9</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="sc">&#39;I&#39;</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="sc">&#39;S&#39;</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">))</span>
		<span class="n">EISA_bus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">early_iounmap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_DE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">divide_error</span><span class="p">);</span>
	<span class="n">set_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_NMI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmi</span><span class="p">,</span> <span class="n">NMI_STACK</span><span class="p">);</span>
	<span class="cm">/* int4 can be called from all */</span>
	<span class="n">set_system_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_OF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">overflow</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_BR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bounds</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_UD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_op</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_NM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_not_available</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">set_task_gate</span><span class="p">(</span><span class="n">X86_TRAP_DF</span><span class="p">,</span> <span class="n">GDT_ENTRY_DOUBLEFAULT_TSS</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">set_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_DF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">double_fault</span><span class="p">,</span> <span class="n">DOUBLEFAULT_STACK</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_OLD_MF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coprocessor_segment_overrun</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_TS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_TSS</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_NP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segment_not_present</span><span class="p">);</span>
	<span class="n">set_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_SS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack_segment</span><span class="p">,</span> <span class="n">STACKFAULT_STACK</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_GP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">general_protection</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_SPURIOUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spurious_interrupt_bug</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_MF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">coprocessor_error</span><span class="p">);</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_AC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alignment_check</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_MCE</span>
	<span class="n">set_intr_gate_ist</span><span class="p">(</span><span class="n">X86_TRAP_MC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">machine_check</span><span class="p">,</span> <span class="n">MCE_STACK</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">set_intr_gate</span><span class="p">(</span><span class="n">X86_TRAP_XF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">simd_coprocessor_error</span><span class="p">);</span>

	<span class="cm">/* Reserve all the builtin and the syscall vector: */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IA32_EMULATION</span>
	<span class="n">set_system_intr_gate</span><span class="p">(</span><span class="n">IA32_SYSCALL_VECTOR</span><span class="p">,</span> <span class="n">ia32_syscall</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IA32_SYSCALL_VECTOR</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">set_system_trap_gate</span><span class="p">(</span><span class="n">SYSCALL_VECTOR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">system_call</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SYSCALL_VECTOR</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should be a barrier for any external CPU state:</span>
<span class="cm">	 */</span>
	<span class="n">cpu_init</span><span class="p">();</span>

	<span class="n">x86_init</span><span class="p">.</span><span class="n">irqs</span><span class="p">.</span><span class="n">trap_init</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmi_idt_table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idt_table</span><span class="p">,</span> <span class="n">IDT_ENTRIES</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">set_nmi_gate</span><span class="p">(</span><span class="n">X86_TRAP_DB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug</span><span class="p">);</span>
	<span class="n">set_nmi_gate</span><span class="p">(</span><span class="n">X86_TRAP_BP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">int3</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
