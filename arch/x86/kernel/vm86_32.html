<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › vm86_32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vm86_32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 1994  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  29 dec 2001 - Fixed oopses caused by unchecked access to the vm86</span>
<span class="cm"> *                stack - Manfred Spraul &lt;manfred@colorfullife.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  22 mar 2002 - Manfred detected the stackfaults, but didn&#39;t handle</span>
<span class="cm"> *                them correctly. Now the emulation will be in a</span>
<span class="cm"> *                consistent state after stackfaults - Kasper Dupont</span>
<span class="cm"> *                &lt;kasperd@daimi.au.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  22 mar 2002 - Added missing clear_IF in set_vflags_* Kasper Dupont</span>
<span class="cm"> *                &lt;kasperd@daimi.au.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  ?? ??? 2002 - Fixed premature returns from handle_vm86_fault</span>
<span class="cm"> *                caused by Kasper Dupont&#39;s changes - Stas Sergeev</span>
<span class="cm"> *</span>
<span class="cm"> *   4 apr 2002 - Fixed CHECK_IF_IN_TRAP broken by Stas&#39; changes.</span>
<span class="cm"> *                Kasper Dupont &lt;kasperd@daimi.au.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   9 apr 2002 - Changed syntax of macros in handle_vm86_fault.</span>
<span class="cm"> *                Kasper Dupont &lt;kasperd@daimi.au.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   9 apr 2002 - Changed stack access macros to jump to a label</span>
<span class="cm"> *                instead of returning to userspace. This simplifies</span>
<span class="cm"> *                do_int, and is needed by handle_vm6_fault. Kasper</span>
<span class="cm"> *                Dupont &lt;kasperd@daimi.au.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Known problems:</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt handling is not guaranteed:</span>
<span class="cm"> * - a real x86 will disable all interrupts for one instruction</span>
<span class="cm"> *   after a &quot;mov ss,xx&quot; to make stack handling atomic even without</span>
<span class="cm"> *   the &#39;lss&#39; instruction. We can&#39;t guarantee this in v86 mode,</span>
<span class="cm"> *   as the next instruction might result in a page fault or similar.</span>
<span class="cm"> * - a real x86 will have interrupts disabled for one instruction</span>
<span class="cm"> *   past the &#39;sti&#39; that enables them. We don&#39;t bother with all the</span>
<span class="cm"> *   details yet.</span>
<span class="cm"> *</span>
<span class="cm"> * Let&#39;s hope these problems do not actually matter for anything.</span>
<span class="cm"> */</span>


<span class="cp">#define KVM86	((struct kernel_vm86_struct *)regs)</span>
<span class="cp">#define VMPI	KVM86-&gt;vm86plus</span>


<span class="cm">/*</span>
<span class="cm"> * 8- and 16-bit register defines..</span>
<span class="cm"> */</span>
<span class="cp">#define AL(regs)	(((unsigned char *)&amp;((regs)-&gt;pt.ax))[0])</span>
<span class="cp">#define AH(regs)	(((unsigned char *)&amp;((regs)-&gt;pt.ax))[1])</span>
<span class="cp">#define IP(regs)	(*(unsigned short *)&amp;((regs)-&gt;pt.ip))</span>
<span class="cp">#define SP(regs)	(*(unsigned short *)&amp;((regs)-&gt;pt.sp))</span>

<span class="cm">/*</span>
<span class="cm"> * virtual flags (16 and 32-bit versions)</span>
<span class="cm"> */</span>
<span class="cp">#define VFLAGS	(*(unsigned short *)&amp;(current-&gt;thread.v86flags))</span>
<span class="cp">#define VEFLAGS	(current-&gt;thread.v86flags)</span>

<span class="cp">#define set_flags(X, new, mask) \</span>
<span class="cp">((X) = ((X) &amp; ~(mask)) | ((new) &amp; (mask)))</span>

<span class="cp">#define SAFE_MASK	(0xDD5)</span>
<span class="cp">#define RETURN_MASK	(0xDFF)</span>

<span class="cm">/* convert kernel_vm86_regs to vm86_regs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_vm86_regs_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm86_regs</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * kernel_vm86_regs is missing gs, so copy everything up to</span>
<span class="cm">	 * (but not including) orig_eax, and then rest including orig_eax.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">orig_eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">)</span> <span class="o">-</span>
			    <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convert vm86_regs to kernel_vm86_regs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_vm86_regs_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">vm86_regs</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* copy ax-fs inclusive */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">));</span>
	<span class="cm">/* copy orig_ax-__gsh+extra */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">orig_eax</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">)</span> <span class="o">-</span>
			      <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span><span class="p">,</span> <span class="n">pt</span><span class="p">.</span><span class="n">orig_ax</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">extra</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="nf">save_v86_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This gets called from entry.S with interrupts disabled, but</span>
<span class="cm">	 * from process context. Enable interrupts here, before trying</span>
<span class="cm">	 * to access user space.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;no vm86_info: BAD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_flags</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">VEFLAGS</span><span class="p">,</span> <span class="n">X86_EFLAGS_VIF</span> <span class="o">|</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">copy_vm86_regs_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86_info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">screen_bitmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86_info</span><span class="o">-&gt;</span><span class="n">screen_bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;vm86: could not access userspace vm86_info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">init_tss</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp0</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_sp0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sysenter_cs</span> <span class="o">=</span> <span class="n">__KERNEL_CS</span><span class="p">;</span>
	<span class="n">load_sp0</span><span class="p">(</span><span class="n">tss</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_sp0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">KVM86</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="p">;</span>

	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_fs</span><span class="p">;</span>
	<span class="n">set_user_gs</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_gs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_screen_rdonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="mh">0xA0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="mh">0xA0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="mh">0xA0000</span><span class="p">);</span>
	<span class="n">split_huge_page_pmd</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="mh">0xA0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">set_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
		<span class="n">pte</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">flush_tlb</span><span class="p">();</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="n">do_vm86_irq_handling</span><span class="p">(</span><span class="kt">int</span> <span class="n">subfunction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irqnumber</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_sys_vm86</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sys_vm86old</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm86_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">v86</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kernel_vm86_struct</span> <span class="n">info</span><span class="p">;</span> <span class="cm">/* declare this _on top_,</span>
<span class="cm">					 * this avoids wasting of stack space.</span>
<span class="cm">					 * This remains on the stack until we</span>
<span class="cm">					 * return to 32 bit user space.</span>
<span class="cm">					 */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_sp0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">copy_vm86_regs_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v86</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span>
				       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_struct</span><span class="p">,</span> <span class="n">vm86plus</span><span class="p">)</span> <span class="o">-</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">vm86plus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">regs32</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">vm86plus</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">regs32</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86_info</span> <span class="o">=</span> <span class="n">v86</span><span class="p">;</span>
	<span class="n">do_sys_vm86</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* we never return here */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">sys_vm86</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kernel_vm86_struct</span> <span class="n">info</span><span class="p">;</span> <span class="cm">/* declare this _on top_,</span>
<span class="cm">					 * this avoids wasting of stack space.</span>
<span class="cm">					 * This remains on the stack until we</span>
<span class="cm">					 * return to 32 bit user space.</span>
<span class="cm">					 */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm86plus_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">v86</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VM86_REQUEST_IRQ</span>:
	<span class="k">case</span> <span class="n">VM86_FREE_IRQ</span>:
	<span class="k">case</span> <span class="n">VM86_GET_IRQ_BITS</span>:
	<span class="k">case</span> <span class="n">VM86_GET_AND_RESET_IRQ</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_vm86_irq_handling</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VM86_PLUS_INSTALL_CHECK</span>:
		<span class="cm">/*</span>
<span class="cm">		 * NOTE: on old vm86 stuff this will return the error</span>
<span class="cm">		 *  from access_ok(), because the subfunction is</span>
<span class="cm">		 *  interpreted as (invalid) address to vm86_struct.</span>
<span class="cm">		 *  So the installation check works.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we come here only for functions VM86_ENTER, VM86_ENTER_NO_BYPASS */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_sp0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">v86</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm86plus_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">copy_vm86_regs_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v86</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span>
				       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_struct</span><span class="p">,</span> <span class="n">regs32</span><span class="p">)</span> <span class="o">-</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">regs32</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">vm86plus</span><span class="p">.</span><span class="n">is_vm86pus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm86_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">v86</span><span class="p">;</span>
	<span class="n">do_sys_vm86</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* we never return here */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_sys_vm86</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * make sure the vm86() system call doesn&#39;t try to do anything silly</span>
<span class="cm"> */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">ds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">fs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_X86_32_LAZY_GS</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">gs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The flags register is also special: we cannot trust that the user</span>
<span class="cm"> * has set it up safely, so this makes sure interrupt etc flags are</span>
<span class="cm"> * inherited from protected mode.</span>
<span class="cm"> */</span>
	<span class="n">VEFLAGS</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">SAFE_MASK</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SAFE_MASK</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">X86_VM_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cpu_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_286</span>:
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_386</span>:
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span> <span class="o">=</span> <span class="n">X86_EFLAGS_NT</span> <span class="o">|</span> <span class="n">X86_EFLAGS_IOPL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_486</span>:
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span> <span class="o">=</span> <span class="n">X86_EFLAGS_AC</span> <span class="o">|</span> <span class="n">X86_EFLAGS_NT</span> <span class="o">|</span> <span class="n">X86_EFLAGS_IOPL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span> <span class="o">=</span> <span class="n">X86_EFLAGS_ID</span> <span class="o">|</span> <span class="n">X86_EFLAGS_AC</span> <span class="o">|</span> <span class="n">X86_EFLAGS_NT</span> <span class="o">|</span> <span class="n">X86_EFLAGS_IOPL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Save old state, set default return value (%ax) to 0 (VM86_SIGNAL)</span>
<span class="cm"> */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">VM86_SIGNAL</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_sp0</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp0</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_fs</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">saved_gs</span> <span class="o">=</span> <span class="n">get_user_gs</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="p">);</span>

	<span class="n">tss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">init_tss</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">VM86_TSS_ESP0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_sep</span><span class="p">)</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sysenter_cs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">load_sp0</span><span class="p">(</span><span class="n">tss</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">screen_bitmap</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_bitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VM86_SCREEN_BITMAP</span><span class="p">)</span>
		<span class="n">mark_screen_rdonly</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="cm">/*call __audit_syscall_exit since we do not exit via the normal paths */</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">))</span>
		<span class="n">__audit_syscall_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
		<span class="s">&quot;movl %0,%%esp</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;movl %1,%%ebp</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_X86_32_LAZY_GS</span>
		<span class="s">&quot;mov  %2, %%gs</span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
		<span class="s">&quot;jmp resume_userspace&quot;</span>
		<span class="o">:</span> <span class="cm">/* no outputs */</span>
		<span class="o">:</span><span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">)),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="cm">/* we never return here */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">return_to_32bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs16</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs32</span><span class="p">;</span>

	<span class="n">regs32</span> <span class="o">=</span> <span class="n">save_v86_state</span><span class="p">(</span><span class="n">regs16</span><span class="p">);</span>
	<span class="n">regs32</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;movl %0,%%esp</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;movl %1,%%ebp</span><span class="se">\n\t</span><span class="s">&quot;</span>
		<span class="s">&quot;jmp resume_userspace&quot;</span>
		<span class="o">:</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">regs32</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">current_thread_info</span><span class="p">()));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_IF</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VEFLAGS</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_VIF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VEFLAGS</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VIP</span><span class="p">)</span>
		<span class="n">return_to_32bit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">VM86_STI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_IF</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VEFLAGS</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_VIF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_TF</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_AC</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_AC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It is correct to call set_IF(regs) from the set_vflags_*</span>
<span class="cm"> * functions. However someone forgot to call clear_IF(regs)</span>
<span class="cm"> * in the opposite case.</span>
<span class="cm"> * After the command sequence CLI PUSHF STI POPF you should</span>
<span class="cm"> * end up with interrupts disabled, but you ended up with</span>
<span class="cm"> * interrupts enabled.</span>
<span class="cm"> *  ( I was testing my own changes, but the only bug I</span>
<span class="cm"> *    could find was in a function I had not changed. )</span>
<span class="cm"> * [KD]</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_vflags_long</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_flags</span><span class="p">(</span><span class="n">VEFLAGS</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span><span class="p">);</span>
	<span class="n">set_flags</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">SAFE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">set_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_vflags_short</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_flags</span><span class="p">(</span><span class="n">VFLAGS</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span><span class="p">);</span>
	<span class="n">set_flags</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">SAFE_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
		<span class="n">set_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_vflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RETURN_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VEFLAGS</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_VIF</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_IF</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_IOPL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flags</span> <span class="o">|</span> <span class="p">(</span><span class="n">VEFLAGS</span> <span class="o">&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">v86mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_revectored</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">revectored_struct</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;btl %2,%1</span><span class="se">\n\t</span><span class="s">sbbl %0,%0&quot;</span>
		<span class="o">:</span><span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span>
		<span class="o">:</span><span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">bitmap</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">nr</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define val_byte(val, n) (((__u8 *)&amp;val)[n])</span>

<span class="cp">#define pushb(base, ptr, val, err_label) \</span>
<span class="cp">	do { \</span>
<span class="cp">		__u8 __val = val; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(__val, base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define pushw(base, ptr, val, err_label) \</span>
<span class="cp">	do { \</span>
<span class="cp">		__u16 __val = val; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 1), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 0), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define pushl(base, ptr, val, err_label) \</span>
<span class="cp">	do { \</span>
<span class="cp">		__u32 __val = val; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 3), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 2), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 1), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr--; \</span>
<span class="cp">		if (put_user(val_byte(__val, 0), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define popb(base, ptr, err_label) \</span>
<span class="cp">	({ \</span>
<span class="cp">		__u8 __res; \</span>
<span class="cp">		if (get_user(__res, base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		__res; \</span>
<span class="cp">	})</span>

<span class="cp">#define popw(base, ptr, err_label) \</span>
<span class="cp">	({ \</span>
<span class="cp">		__u16 __res; \</span>
<span class="cp">		if (get_user(val_byte(__res, 0), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		if (get_user(val_byte(__res, 1), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		__res; \</span>
<span class="cp">	})</span>

<span class="cp">#define popl(base, ptr, err_label) \</span>
<span class="cp">	({ \</span>
<span class="cp">		__u32 __res; \</span>
<span class="cp">		if (get_user(val_byte(__res, 0), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		if (get_user(val_byte(__res, 1), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		if (get_user(val_byte(__res, 2), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		if (get_user(val_byte(__res, 3), base + ptr) &lt; 0) \</span>
<span class="cp">			goto err_label; \</span>
<span class="cp">		ptr++; \</span>
<span class="cp">		__res; \</span>
<span class="cp">	})</span>

<span class="cm">/* There are so many possible reasons for this function to return</span>
<span class="cm"> * VM86_INTx, so adding another doesn&#39;t bother me. We can expect</span>
<span class="cm"> * userspace programs to be able to handle it. (Getting a problem</span>
<span class="cm"> * in userspace is always better than an Oops anyway.) [KD]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">intr_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">segoffs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">cs</span> <span class="o">==</span> <span class="n">BIOSSEG</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cannot_handle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_revectored</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">KVM86</span><span class="o">-&gt;</span><span class="n">int_revectored</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cannot_handle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mh">0x21</span> <span class="o">&amp;&amp;</span> <span class="n">is_revectored</span><span class="p">(</span><span class="n">AH</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">KVM86</span><span class="o">-&gt;</span><span class="n">int21_revectored</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cannot_handle</span><span class="p">;</span>
	<span class="n">intr_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">segoffs</span><span class="p">,</span> <span class="n">intr_ptr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cannot_handle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">segoffs</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="n">BIOSSEG</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cannot_handle</span><span class="p">;</span>
	<span class="n">pushw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">get_vflags</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">cannot_handle</span><span class="p">);</span>
	<span class="n">pushw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">cs</span><span class="p">,</span> <span class="n">cannot_handle</span><span class="p">);</span>
	<span class="n">pushw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">cannot_handle</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">segoffs</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">-=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">segoffs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">clear_TF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">clear_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">clear_AC</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">cannot_handle:</span>
	<span class="n">return_to_32bit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">VM86_INTx</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">handle_vm86_trap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VMPI</span><span class="p">.</span><span class="n">is_vm86pus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">trapno</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">trapno</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">KVM86</span><span class="o">-&gt;</span><span class="n">regs32</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">VM86_TRAP</span> <span class="o">+</span> <span class="p">(</span><span class="n">trapno</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="cm">/* setting this flag forces the code in entry_32.S to</span>
<span class="cm">			   call save_v86_state() and change the stack pointer</span>
<span class="cm">			   to KVM86-&gt;regs32 */</span>
			<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_IRET</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">do_int</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">trapno</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trapno</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* we let this handle by the calling routine */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">trap_nr</span> <span class="o">=</span> <span class="n">trapno</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">error_code</span> <span class="o">=</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handle_vm86_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_vm86_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">csp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">orig_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data32</span><span class="p">,</span> <span class="n">pref_done</span><span class="p">;</span>

<span class="cp">#define CHECK_IF_IN_TRAP \</span>
<span class="cp">	if (VMPI.vm86dbg_active &amp;&amp; VMPI.vm86dbg_TFpendig) \</span>
<span class="cp">		newflags |= X86_EFLAGS_TF</span>
<span class="cp">#define VM86_FAULT_RETURN do { \</span>
<span class="cp">	if (VMPI.force_return_for_pic  &amp;&amp; (VEFLAGS &amp; (X86_EFLAGS_IF | X86_EFLAGS_VIF))) \</span>
<span class="cp">		return_to_32bit(regs, VM86_PICRETURN); \</span>
<span class="cp">	if (orig_flags &amp; X86_EFLAGS_TF) \</span>
<span class="cp">		handle_vm86_trap(regs, 0, 1); \</span>
<span class="cp">	return; } while (0)</span>

	<span class="n">orig_flags</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">csp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">cs</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ssp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">data32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pref_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">popb</span><span class="p">(</span><span class="n">csp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x66</span>:      <span class="cm">/* 32-bit data */</span>     <span class="n">data32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x67</span>:      <span class="cm">/* 32-bit address */</span>  <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x2e</span>:      <span class="cm">/* CS */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3e</span>:      <span class="cm">/* DS */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x26</span>:      <span class="cm">/* ES */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x36</span>:      <span class="cm">/* SS */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x65</span>:      <span class="cm">/* GS */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x64</span>:      <span class="cm">/* FS */</span>              <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xf2</span>:      <span class="cm">/* repnz */</span>       <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xf3</span>:      <span class="cm">/* rep */</span>             <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">pref_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pref_done</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* pushf */</span>
	<span class="k">case</span> <span class="mh">0x9c</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">data32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pushl</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">get_vflags</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pushw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">get_vflags</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">VM86_FAULT_RETURN</span><span class="p">;</span>

	<span class="cm">/* popf */</span>
	<span class="k">case</span> <span class="mh">0x9d</span>:
		<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newflags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newflags</span> <span class="o">=</span> <span class="n">popl</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newflags</span> <span class="o">=</span> <span class="n">popw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">CHECK_IF_IN_TRAP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data32</span><span class="p">)</span>
			<span class="n">set_vflags_long</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_vflags_short</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="n">VM86_FAULT_RETURN</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* int xx */</span>
	<span class="k">case</span> <span class="mh">0xcd</span>: <span class="p">{</span>
		<span class="kt">int</span> <span class="n">intno</span> <span class="o">=</span> <span class="n">popb</span><span class="p">(</span><span class="n">csp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">VMPI</span><span class="p">.</span><span class="n">vm86dbg_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">intno</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">VMPI</span><span class="p">.</span><span class="n">vm86dbg_intxxtab</span><span class="p">[</span><span class="n">intno</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">])</span>
				<span class="n">return_to_32bit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">VM86_INTx</span> <span class="o">+</span> <span class="p">(</span><span class="n">intno</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">do_int</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">intno</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* iret */</span>
	<span class="k">case</span> <span class="mh">0xcf</span>:
		<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newip</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newcs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newflags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newip</span> <span class="o">=</span> <span class="n">popl</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">newcs</span> <span class="o">=</span> <span class="n">popl</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">newflags</span> <span class="o">=</span> <span class="n">popl</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newip</span> <span class="o">=</span> <span class="n">popw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">newcs</span> <span class="o">=</span> <span class="n">popw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">newflags</span> <span class="o">=</span> <span class="n">popw</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">simulate_sigsegv</span><span class="p">);</span>
			<span class="n">SP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">newip</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">newcs</span><span class="p">;</span>
		<span class="n">CHECK_IF_IN_TRAP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_vflags_long</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_vflags_short</span><span class="p">(</span><span class="n">newflags</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">VM86_FAULT_RETURN</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* cli */</span>
	<span class="k">case</span> <span class="mh">0xfa</span>:
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">clear_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">VM86_FAULT_RETURN</span><span class="p">;</span>

	<span class="cm">/* sti */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Damn. This is incorrect: the &#39;sti&#39; instruction should actually</span>
<span class="cm">	 * enable interrupts after the /next/ instruction. Not good.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Probably needs some horsing around with the TF flag. Aiee..</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mh">0xfb</span>:
		<span class="n">IP</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="n">set_IF</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
		<span class="n">VM86_FAULT_RETURN</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">return_to_32bit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">VM86_UNKNOWN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">simulate_sigsegv:</span>
	<span class="cm">/* FIXME: After a long discussion with Stas we finally</span>
<span class="cm">	 *        agreed, that this is wrong. Here we should</span>
<span class="cm">	 *        really send a SIGSEGV to the user program.</span>
<span class="cm">	 *        But how do we create the correct context? We</span>
<span class="cm">	 *        are inside a general protection fault handler</span>
<span class="cm">	 *        and has just returned from a page fault handler.</span>
<span class="cm">	 *        The correct context for the signal handler</span>
<span class="cm">	 *        should be a mixture of the two, but how do we</span>
<span class="cm">	 *        get the information? [KD]</span>
<span class="cm">	 */</span>
	<span class="n">return_to_32bit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">VM86_UNKNOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ---------------- vm86 special IRQ passing stuff ----------------- */</span>

<span class="cp">#define VM86_IRQNAME		&quot;vm86irq&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vm86_irqs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vm86_irqs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">irqbits_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irqbits</span><span class="p">;</span>

<span class="cp">#define ALLOWED_SIGS (1 </span><span class="cm">/* 0 = don&#39;t send a signal */</span><span class="cp"> \</span>
<span class="cp">	| (1 &lt;&lt; SIGUSR1) | (1 &lt;&lt; SIGUSR2) | (1 &lt;&lt; SIGIO)  | (1 &lt;&lt; SIGURG) \</span>
<span class="cp">	| (1 &lt;&lt; SIGUNUSED))</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">intno</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq_bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irq_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">intno</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irqbits</span> <span class="o">&amp;</span> <span class="n">irq_bit</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">intno</span><span class="p">].</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">irqbits</span> <span class="o">|=</span> <span class="n">irq_bit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">intno</span><span class="p">].</span><span class="n">sig</span><span class="p">)</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">intno</span><span class="p">].</span><span class="n">sig</span><span class="p">,</span> <span class="n">vm86_irqs</span><span class="p">[</span><span class="n">intno</span><span class="p">].</span><span class="n">tsk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * IRQ will be re-enabled when user asks for the irq (whether</span>
<span class="cm">	 * polling or as a result of the signal)</span>
<span class="cm">	 */</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">intno</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_vm86_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irqnumber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irqnumber</span><span class="p">].</span><span class="n">tsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">irqbits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irqnumber</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">release_vm86_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">FIRST_VM86_IRQ</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">LAST_VM86_IRQ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
		<span class="n">free_vm86_irq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_and_reset_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irqnumber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">invalid_vm86_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irqnumber</span><span class="p">].</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">irqbits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">irqnumber</span><span class="p">);</span>
	<span class="n">irqbits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqbits_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_vm86_irq_handling</span><span class="p">(</span><span class="kt">int</span> <span class="n">subfunction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irqnumber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">subfunction</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">VM86_GET_AND_RESET_IRQ</span>: <span class="p">{</span>
			<span class="k">return</span> <span class="n">get_and_reset_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">VM86_GET_IRQ_BITS</span>: <span class="p">{</span>
			<span class="k">return</span> <span class="n">irqbits</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">VM86_REQUEST_IRQ</span>: <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">irqnumber</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">irqnumber</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ALLOWED_SIGS</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_vm86_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">tsk</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VM86_IRQNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
			<span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irq</span><span class="p">].</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span>  <span class="n">VM86_FREE_IRQ</span>: <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_vm86_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irqnumber</span><span class="p">].</span><span class="n">tsk</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vm86_irqs</span><span class="p">[</span><span class="n">irqnumber</span><span class="p">].</span><span class="n">tsk</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">free_vm86_irq</span><span class="p">(</span><span class="n">irqnumber</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
