<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › smpboot.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smpboot.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	x86 SMP booting functions</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) 1995 Alan Cox, Building #3 &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *	(c) 1998, 1999, 2000, 2009 Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *	Copyright 2001 Andi Kleen, SuSE Labs.</span>
<span class="cm"> *</span>
<span class="cm"> *	Much of the core SMP work is based on previous work by Thomas Radke, to</span>
<span class="cm"> *	whom a great many thanks are extended.</span>
<span class="cm"> *</span>
<span class="cm"> *	Thanks to Intel for making available several different Pentium,</span>
<span class="cm"> *	Pentium Pro and Pentium-II/Xeon MP machines.</span>
<span class="cm"> *	Original development of Linux SMP code supported by Caldera.</span>
<span class="cm"> *</span>
<span class="cm"> *	This code is released under the GNU General Public License version 2 or</span>
<span class="cm"> *	later.</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes</span>
<span class="cm"> *		Felix Koop	:	NR_CPUS used properly</span>
<span class="cm"> *		Jose Renau	:	Handle single CPU case.</span>
<span class="cm"> *		Alan Cox	:	By repeated request 8) - Total BogoMIPS report.</span>
<span class="cm"> *		Greg Wright	:	Fix for kernel stacks panic.</span>
<span class="cm"> *		Erich Boleyn	:	MP v1.4 and additional changes.</span>
<span class="cm"> *	Matthias Sattler	:	Changes for 2.1 kernel map.</span>
<span class="cm"> *	Michel Lespinasse	:	Changes for 2.1 kernel map.</span>
<span class="cm"> *	Michael Chastain	:	Change trampoline.S to gnu as.</span>
<span class="cm"> *		Alan Cox	:	Dumb bug: &#39;B&#39; step PPro&#39;s are fine</span>
<span class="cm"> *		Ingo Molnar	:	Added APIC timers, based on code</span>
<span class="cm"> *					from Jose Renau</span>
<span class="cm"> *		Ingo Molnar	:	various cleanups and rewrites</span>
<span class="cm"> *		Tigran Aivazian	:	fixed &quot;0.00 in /proc/uptime on SMP&quot; bug.</span>
<span class="cm"> *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs</span>
<span class="cm"> *	Andi Kleen		:	Changed for SMP boot into long mode.</span>
<span class="cm"> *		Martin J. Bligh	: 	Added support for multi-quad systems</span>
<span class="cm"> *		Dave Jones	:	Report invalid combinations of Athlon CPUs.</span>
<span class="cm"> *		Rusty Russell	:	Hacked into shape for new &quot;hotplug&quot; boot process.</span>
<span class="cm"> *      Andi Kleen              :       Converted to new state machine.</span>
<span class="cm"> *	Ashok Raj		: 	CPU hotplug support</span>
<span class="cm"> *	Glauber Costa		:	i386 and x86_64 integration</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/tboot.h&gt;</span>
<span class="cp">#include &lt;linux/stackprotector.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/cpuidle.h&gt;</span>

<span class="cp">#include &lt;asm/acpi.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/nmi.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/realmode.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/numa.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;asm/mwait.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>

<span class="cp">#include &lt;asm/smpboot_hooks.h&gt;</span>
<span class="cp">#include &lt;asm/i8259.h&gt;</span>

<span class="cp">#include &lt;asm/realmode.h&gt;</span>

<span class="cm">/* State of each CPU */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cpu_state</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cm">/*</span>
<span class="cm"> * We need this for trampoline_base protection from concurrent accesses when</span>
<span class="cm"> * off- and onlining cores wildly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">x86_cpu_hotplug_driver_mutex</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cpu_hotplug_driver_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_cpu_hotplug_driver_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_hotplug_driver_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_cpu_hotplug_driver_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">arch_cpu_probe</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">ssize_t</span> <span class="nf">arch_cpu_release</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Number of siblings per CPU package */</span>
<span class="kt">int</span> <span class="n">smp_num_siblings</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">smp_num_siblings</span><span class="p">);</span>

<span class="cm">/* Last level cache ID of each logical CPU */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">cpu_llc_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">BAD_APICID</span><span class="p">;</span>

<span class="cm">/* representing HT siblings of each logical CPU */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">cpu_sibling_map</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">);</span>

<span class="cm">/* representing HT and core siblings of each logical CPU */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">cpu_core_map</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">cpu_llc_shared_map</span><span class="p">);</span>

<span class="cm">/* Per CPU bogomips and other parameters */</span>
<span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span><span class="p">,</span> <span class="n">cpu_info</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">cpu_info</span><span class="p">);</span>

<span class="n">atomic_t</span> <span class="n">init_deasserted</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Report back to the Boot Processor.</span>
<span class="cm"> * Running on AP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">smp_callin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpuid</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If waken up by an INIT in an 82489DX configuration</span>
<span class="cm">	 * we may get here before an INIT-deassert IPI reaches</span>
<span class="cm">	 * our local APIC.  We have to wait for the IPI or we&#39;ll</span>
<span class="cm">	 * lock up on an APIC access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">wait_for_init_deassert</span><span class="p">)</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">wait_for_init_deassert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_deasserted</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * (This works even if the APIC is not enabled.)</span>
<span class="cm">	 */</span>
	<span class="n">phys_id</span> <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>
	<span class="n">cpuid</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: phys CPU#%d, CPU#%d already present??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="n">phys_id</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;CPU#%d (phys ID: %d) waiting for CALLOUT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">,</span> <span class="n">phys_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * STARTUP IPIs are fragile beasts as they might sometimes</span>
<span class="cm">	 * trigger some glue motherboard logic. Complete APIC bus</span>
<span class="cm">	 * silence for 1 second, this overestimates the time the</span>
<span class="cm">	 * boot CPU is spending to send the up to 2 STARTUP IPIs</span>
<span class="cm">	 * by a factor of two. This should be enough.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Waiting 2s total for startup (udelay is not yet working)</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Has the boot CPU finished it&#39;s STARTUP sequence?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;%s: CPU%d started up but did not get a callout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">cpuid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the boot CPU has finished the init stage and is spinning</span>
<span class="cm">	 * on callin_map until we finish. We are free to set up this</span>
<span class="cm">	 * CPU, first the APIC. (this is probably redundant on most</span>
<span class="cm">	 * boards)</span>
<span class="cm">	 */</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;CALLIN, before setup_local_APIC().</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">smp_callin_clear_local_apic</span><span class="p">)</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">smp_callin_clear_local_apic</span><span class="p">();</span>
	<span class="n">setup_local_APIC</span><span class="p">();</span>
	<span class="n">end_local_APIC_setup</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to setup vector mappings before we enable interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">setup_vector_irq</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save our processor parameters. Note: this information</span>
<span class="cm">	 * is needed for clock calibration.</span>
<span class="cm">	 */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get our bogomips.</span>
<span class="cm">	 * Update loops_per_jiffy in cpu_data. Previous call to</span>
<span class="cm">	 * smp_store_cpu_info() stored a value that is close but not as</span>
<span class="cm">	 * accurate as the value just calculated.</span>
<span class="cm">	 */</span>
	<span class="n">calibrate_delay</span><span class="p">();</span>
	<span class="n">cpu_data</span><span class="p">(</span><span class="n">cpuid</span><span class="p">).</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Stack at about %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This must be done before setting cpu_online_mask</span>
<span class="cm">	 * or calling notify_cpu_starting.</span>
<span class="cm">	 */</span>
	<span class="n">set_cpu_sibling_map</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">notify_cpu_starting</span><span class="p">(</span><span class="n">cpuid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow the master to continue.</span>
<span class="cm">	 */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Activate a secondary processor.</span>
<span class="cm"> */</span>
<span class="n">notrace</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">start_secondary</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t put *anything* before cpu_init(), SMP booting is too</span>
<span class="cm">	 * fragile that we want to limit the things done here to the</span>
<span class="cm">	 * most necessary things.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_init</span><span class="p">();</span>
	<span class="n">x86_cpuinit</span><span class="p">.</span><span class="n">early_percpu_clock_init</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_callin</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* switch away from the initial page table */</span>
	<span class="n">load_cr3</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
	<span class="n">__flush_tlb_all</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* otherwise gcc will move up smp_processor_id before the cpu_init */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check TSC synchronization with the BP:</span>
<span class="cm">	 */</span>
	<span class="n">check_tsc_sync_target</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to hold call_lock, so there is no inconsistency</span>
<span class="cm">	 * between the time smp_call_function() determines number of</span>
<span class="cm">	 * IPI recipients, and the time when the determination is made</span>
<span class="cm">	 * for which cpus receive the IPI. Holding this</span>
<span class="cm">	 * lock helps us to not include this cpu in a currently in progress</span>
<span class="cm">	 * smp_call_function().</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to hold vector_lock so there the set of online cpus</span>
<span class="cm">	 * does not change while we are assigning vectors to cpus.  Holding</span>
<span class="cm">	 * this lock ensures we don&#39;t half assign or remove an irq from a cpu.</span>
<span class="cm">	 */</span>
	<span class="n">ipi_call_lock</span><span class="p">();</span>
	<span class="n">lock_vector_lock</span><span class="p">();</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">unlock_vector_lock</span><span class="p">();</span>
	<span class="n">ipi_call_unlock</span><span class="p">();</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">=</span> <span class="n">CPU_ONLINE</span><span class="p">;</span>
	<span class="n">x86_platform</span><span class="p">.</span><span class="n">nmi_init</span><span class="p">();</span>

	<span class="cm">/* enable local interrupts */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="cm">/* to prevent fake stack check failure in clock setup */</span>
	<span class="n">boot_init_stack_canary</span><span class="p">();</span>

	<span class="n">x86_cpuinit</span><span class="p">.</span><span class="n">setup_percpu_clockev</span><span class="p">();</span>

	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">cpu_idle</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The bootstrap kernel entry code has set these up. Save them for</span>
<span class="cm"> * a given CPU</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">smp_store_cpu_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

	<span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">identify_secondary_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__cpuinit</span>
<span class="nf">topology_sane</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">,</span> <span class="n">cpu2</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu2</span><span class="p">),</span>
		<span class="s">&quot;sched: CPU #%d&#39;s %s-sibling CPU #%d is not on the same node! &quot;</span>
		<span class="s">&quot;[node: %d != %d]. Ignoring dependency.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cpu1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cpu2</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu1</span><span class="p">),</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define link_mask(_m, c1, c2)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	cpumask_set_cpu((c1), cpu_##_m##_mask(c2));			\</span>
<span class="cp">	cpumask_set_cpu((c2), cpu_##_m##_mask(c1));			\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__cpuinit</span> <span class="nf">match_smt</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_TOPOEXT</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">,</span> <span class="n">cpu2</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">&amp;&amp;</span>
		    <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_id</span><span class="p">,</span> <span class="n">cpu1</span><span class="p">)</span> <span class="o">==</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_id</span><span class="p">,</span> <span class="n">cpu2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">compute_unit_id</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">compute_unit_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">topology_sane</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;smt&quot;</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">&amp;&amp;</span>
		   <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_core_id</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">cpu_core_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">topology_sane</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;smt&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__cpuinit</span> <span class="nf">match_llc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">,</span> <span class="n">cpu2</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_id</span><span class="p">,</span> <span class="n">cpu1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BAD_APICID</span> <span class="o">&amp;&amp;</span>
	    <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_id</span><span class="p">,</span> <span class="n">cpu1</span><span class="p">)</span> <span class="o">==</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_id</span><span class="p">,</span> <span class="n">cpu2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">topology_sane</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;llc&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__cpuinit</span> <span class="nf">match_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_AMD_DCM</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">topology_sane</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="s">&quot;mc&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">set_cpu_sibling_map</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">has_mc</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_max_cores</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_smt</span> <span class="o">=</span> <span class="n">smp_num_siblings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_setup_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_smt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_mc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_llc_shared_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">booted_cores</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_sibling_setup_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">has_smt</span> <span class="o">&amp;&amp;</span> <span class="n">match_smt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">)))</span>
			<span class="n">link_mask</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">has_mc</span> <span class="o">&amp;&amp;</span> <span class="n">match_llc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">)))</span>
			<span class="n">link_mask</span><span class="p">(</span><span class="n">llc_shared</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This needs a separate iteration over the cpus because we rely on all</span>
<span class="cm">	 * cpu_sibling_mask links to be set-up.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu_sibling_setup_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">has_mc</span> <span class="o">&amp;&amp;</span> <span class="n">match_mc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">link_mask</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Does this new cpu bringup a new core?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * for each core in package, increment</span>
<span class="cm">				 * the booted_cores for this new cpu</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
					<span class="n">c</span><span class="o">-&gt;</span><span class="n">booted_cores</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * increment the core count for all</span>
<span class="cm">				 * the other cpus in this package</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
					<span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">booted_cores</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">cpu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">booted_cores</span><span class="p">)</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">booted_cores</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">booted_cores</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* maps the cpu to the sched domain representing multi-core */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">cpu_coregroup_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_llc_shared_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">impress_friends</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bogosum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow the user to impress friends.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Before bogomips.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">))</span>
			<span class="n">bogosum</span> <span class="o">+=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">num_online_cpus</span><span class="p">(),</span>
		<span class="n">bogosum</span><span class="o">/</span><span class="p">(</span><span class="mi">500000</span><span class="o">/</span><span class="n">HZ</span><span class="p">),</span>
		<span class="p">(</span><span class="n">bogosum</span><span class="o">/</span><span class="p">(</span><span class="mi">5000</span><span class="o">/</span><span class="n">HZ</span><span class="p">))</span><span class="o">%</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Before bogocount - setting activated=1.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__inquire_remote_apic</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">regs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">APIC_ID</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">APIC_LVR</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">APIC_SPIV</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;ID&quot;</span><span class="p">,</span> <span class="s">&quot;VERSION&quot;</span><span class="p">,</span> <span class="s">&quot;SPIV&quot;</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Inquiring remote APIC 0x%x...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;... APIC 0x%x %s: &quot;</span><span class="p">,</span> <span class="n">apicid</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for idle.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">safe_apic_wait_icr_idle</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span>
			       <span class="s">&quot;a previous APIC delivery may have failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">apic_icr_write</span><span class="p">(</span><span class="n">APIC_DM_REMRD</span> <span class="o">|</span> <span class="n">regs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">apicid</span><span class="p">);</span>

		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">APIC_ICR_RR_MASK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">APIC_ICR_RR_INPROG</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">APIC_ICR_RR_VALID</span>:
			<span class="n">status</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_RRR</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Poke the other CPU in the eye via NMI to wake it up. Remember that the normal</span>
<span class="cm"> * INIT, INIT, STARTUP sequence will reset the chip hard for us, and this</span>
<span class="cm"> * won&#39;t ... remember to clear down the APIC, etc later.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">wakeup_secondary_cpu_via_nmi</span><span class="p">(</span><span class="kt">int</span> <span class="n">logical_apicid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_eip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_status</span><span class="p">,</span> <span class="n">accept_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxlvt</span><span class="p">;</span>

	<span class="cm">/* Target chip */</span>
	<span class="cm">/* Boot on the stack */</span>
	<span class="cm">/* Kick the second */</span>
	<span class="n">apic_icr_write</span><span class="p">(</span><span class="n">APIC_DM_NMI</span> <span class="o">|</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">dest_logical</span><span class="p">,</span> <span class="n">logical_apicid</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">send_status</span> <span class="o">=</span> <span class="n">safe_apic_wait_icr_idle</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give the other CPU some time to accept the IPI.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>			<span class="cm">/* Due to the Pentium erratum 3AP.  */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">accept_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xEF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NMI sent.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;APIC never delivered???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">accept_status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;APIC delivery error (%lx).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">accept_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">|</span> <span class="n">accept_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">wakeup_secondary_cpu_via_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">phys_apicid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_eip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">send_status</span><span class="p">,</span> <span class="n">accept_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxlvt</span><span class="p">,</span> <span class="n">num_starts</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be paranoid about clearing APIC errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">phys_apicid</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>		<span class="cm">/* Due to the Pentium erratum 3AP.  */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Asserting INIT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn INIT on target chip</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send IPI</span>
<span class="cm">	 */</span>
	<span class="n">apic_icr_write</span><span class="p">(</span><span class="n">APIC_INT_LEVELTRIG</span> <span class="o">|</span> <span class="n">APIC_INT_ASSERT</span> <span class="o">|</span> <span class="n">APIC_DM_INIT</span><span class="p">,</span>
		       <span class="n">phys_apicid</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">send_status</span> <span class="o">=</span> <span class="n">safe_apic_wait_icr_idle</span><span class="p">();</span>

	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Deasserting INIT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Target chip */</span>
	<span class="cm">/* Send IPI */</span>
	<span class="n">apic_icr_write</span><span class="p">(</span><span class="n">APIC_INT_LEVELTRIG</span> <span class="o">|</span> <span class="n">APIC_DM_INIT</span><span class="p">,</span> <span class="n">phys_apicid</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">send_status</span> <span class="o">=</span> <span class="n">safe_apic_wait_icr_idle</span><span class="p">();</span>

	<span class="n">mb</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_deasserted</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should we send STARTUP IPIs ?</span>
<span class="cm">	 *</span>
<span class="cm">	 * Determine this based on the APIC version.</span>
<span class="cm">	 * If we don&#39;t have an integrated APIC, don&#39;t send the STARTUP IPIs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">phys_apicid</span><span class="p">]))</span>
		<span class="n">num_starts</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_starts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Paravirt / VMI wants a startup IPI hook here to set up the</span>
<span class="cm">	 * target processor state.</span>
<span class="cm">	 */</span>
	<span class="n">startup_ipi_hook</span><span class="p">(</span><span class="n">phys_apicid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start_secondary</span><span class="p">,</span>
			 <span class="n">stack_start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Run STARTUP IPI loop.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;#startup loops: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_starts</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">num_starts</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Sending STARTUP #%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>		<span class="cm">/* Due to the Pentium erratum 3AP.  */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;After apic_write.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * STARTUP IPI</span>
<span class="cm">		 */</span>

		<span class="cm">/* Target chip */</span>
		<span class="cm">/* Boot on the stack */</span>
		<span class="cm">/* Kick the second */</span>
		<span class="n">apic_icr_write</span><span class="p">(</span><span class="n">APIC_DM_STARTUP</span> <span class="o">|</span> <span class="p">(</span><span class="n">start_eip</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">),</span>
			       <span class="n">phys_apicid</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Give the other CPU some time to accept the IPI.</span>
<span class="cm">		 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Startup point 1.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for send to finish...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">send_status</span> <span class="o">=</span> <span class="n">safe_apic_wait_icr_idle</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Give the other CPU some time to accept the IPI.</span>
<span class="cm">		 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>		<span class="cm">/* Due to the Pentium erratum 3AP.  */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">accept_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xEF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">||</span> <span class="n">accept_status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;After Startup.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">send_status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;APIC never delivered???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">accept_status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;APIC delivery error (%lx).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">accept_status</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">send_status</span> <span class="o">|</span> <span class="n">accept_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* reduce the number of lines printed when booting a large cpu count system */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">announce_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apicid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">current_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_BOOTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">current_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_node</span> <span class="o">&gt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; Ok.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">current_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Booting Node %3d, Processors &quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; #%d%s&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">==</span> <span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; Ok.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Booting Node %d Processor %d APIC 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">node</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE - on most systems this is a PHYSICAL apic ID, but on multiquad</span>
<span class="cm"> * (ie clustered apic addressing mode), this is a LOGICAL apic ID.</span>
<span class="cm"> * Returns zero if CPU booted OK, else error code from</span>
<span class="cm"> * -&gt;wakeup_secondary_cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">do_boot_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="n">trampoline_status</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">__va</span><span class="p">(</span><span class="n">real_mode_header</span><span class="o">-&gt;</span><span class="n">trampoline_status</span><span class="p">);</span>
	<span class="cm">/* start_ip had better be page-aligned! */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_ip</span> <span class="o">=</span> <span class="n">real_mode_header</span><span class="o">-&gt;</span><span class="n">trampoline_start</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boot_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">alternatives_smp_switch</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span>
			  <span class="p">(</span><span class="n">THREAD_SIZE</span> <span class="o">+</span>  <span class="n">task_stack_page</span><span class="p">(</span><span class="n">idle</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">current_task</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* Stack for startup_32 can be just as for start_secondary onwards */</span>
	<span class="n">irq_ctx_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">TIF_FORK</span><span class="p">);</span>
	<span class="n">initial_gs</span> <span class="o">=</span> <span class="n">per_cpu_offset</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">kernel_stack</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_stack_page</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">KERNEL_STACK_OFFSET</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">early_gdt_descr</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">initial_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start_secondary</span><span class="p">;</span>
	<span class="n">stack_start</span>  <span class="o">=</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sp</span><span class="p">;</span>

	<span class="cm">/* So we see what&#39;s up */</span>
	<span class="n">announce_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This grunge runs the startup process for</span>
<span class="cm">	 * the targeted processor.</span>
<span class="cm">	 */</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_deasserted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_uv_system_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">UV_NON_UNIQUE_APIC</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Setting warm reset code and vector.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">smpboot_setup_warm_reset_vector</span><span class="p">(</span><span class="n">start_ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Be paranoid about clearing APIC errors.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kick the secondary CPU. Use the method in the APIC driver</span>
<span class="cm">	 * if it&#39;s defined - or use an INIT boot APIC message otherwise:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">wakeup_secondary_cpu</span><span class="p">)</span>
		<span class="n">boot_error</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">wakeup_secondary_cpu</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">start_ip</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">boot_error</span> <span class="o">=</span> <span class="n">wakeup_secondary_cpu_via_init</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">start_ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * allow APs to start initializing.</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Before Callout %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;After Callout %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait 5s total for a response</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">;</span> <span class="n">timeout</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* It has booted */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Allow other tasks to run while we wait for the</span>
<span class="cm">			 * AP to come online. This also gives a chance</span>
<span class="cm">			 * for the MTRR work(triggered by the AP coming online)</span>
<span class="cm">			 * to be completed in the stop machine context.</span>
<span class="cm">			 */</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">print_cpu_msr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;CPU%d: has booted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">boot_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">trampoline_status</span> <span class="o">==</span> <span class="mh">0xA5A5A5A5</span><span class="p">)</span>
				<span class="cm">/* trampoline started but...? */</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;CPU%d: Stuck ??</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* trampoline code not run */</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;CPU%d: Not responding.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">inquire_remote_apic</span><span class="p">)</span>
				<span class="n">apic</span><span class="o">-&gt;</span><span class="n">inquire_remote_apic</span><span class="p">(</span><span class="n">apicid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try to put things back the way they were before ... */</span>
		<span class="n">numa_remove_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span> <span class="cm">/* was set by numa_add_cpu */</span>

		<span class="cm">/* was set by do_boot_cpu() */</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">);</span>

		<span class="cm">/* was set by cpu_init() */</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_initialized_mask</span><span class="p">);</span>

		<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">BAD_APICID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* mark &quot;stuck&quot; area as not stuck */</span>
	<span class="o">*</span><span class="n">trampoline_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_uv_system_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">UV_NON_UNIQUE_APIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Cleanup possible dangling ends...</span>
<span class="cm">		 */</span>
		<span class="n">smpboot_restore_warm_reset_vector</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">boot_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">native_cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tidle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apicid</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_present_to_apicid</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;++++++++++++++++++++=_---CPU UP  %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">==</span> <span class="n">BAD_APICID</span> <span class="o">||</span> <span class="n">apicid</span> <span class="o">==</span> <span class="n">boot_cpu_physical_apicid</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">physid_isset</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">apic_id_valid</span><span class="p">(</span><span class="n">apicid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bad cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Already booted CPU?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;do_boot_cpu %d Already started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save current MTRR state in case it was changed since early boot</span>
<span class="cm">	 * (e.g. by the ACPI SMI) to initialize new CPUs with MTRRs in sync:</span>
<span class="cm">	 */</span>
	<span class="n">mtrr_save_state</span><span class="p">();</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_UP_PREPARE</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_boot_cpu</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">tidle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;do_boot_cpu failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check TSC synchronization with the AP (keep irqs disabled</span>
<span class="cm">	 * while doing so):</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_tsc_sync_source</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * arch_disable_smp_support() - disables SMP support for x86 at runtime</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">arch_disable_smp_support</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_ioapic_support</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fall back to non SMP mode after errors.</span>
<span class="cm"> *</span>
<span class="cm"> * RED-PEN audit/test this more. I bet there is more state messed up here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">disable_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_cpu_present</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">init_cpu_possible</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">smpboot_clear_io_apic_irqs</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_found_config</span><span class="p">)</span>
		<span class="n">physid_set_mask_of_physid</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">physid_set_mask_of_physid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Various sanity checks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smp_sanity_check</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

<span class="cp">#if !defined(CONFIG_X86_BIGSMP) &amp;&amp; defined(CONFIG_X86_32)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">def_to_bigsmp</span> <span class="o">&amp;&amp;</span> <span class="n">nr_cpu_ids</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">nr</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;More than 8 CPUs detected - skipping them.</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;Use CONFIG_X86_BIGSMP.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_present_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
				<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nr_cpu_ids</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physid_isset</span><span class="p">(</span><span class="n">hard_smp_processor_id</span><span class="p">(),</span> <span class="n">phys_cpu_present_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;weird, boot CPU (#%d) not listed by the BIOS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hard_smp_processor_id</span><span class="p">());</span>

		<span class="n">physid_set</span><span class="p">(</span><span class="n">hard_smp_processor_id</span><span class="p">(),</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we couldn&#39;t find an SMP configuration at boot time,</span>
<span class="cm">	 * get out of here now!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp_found_config</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">acpi_lapic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SMP motherboard not detected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">disable_smp</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">APIC_init_uniprocessor</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Local APIC not detected.&quot;</span>
					   <span class="s">&quot; Using dummy APIC emulation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should not be necessary because the MP table should list the boot</span>
<span class="cm">	 * CPU too, but we do it for the sake of robustness anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">check_phys_apicid_present</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;weird, boot CPU (#%d) not listed by the BIOS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">boot_cpu_physical_apicid</span><span class="p">);</span>
		<span class="n">physid_set</span><span class="p">(</span><span class="n">hard_smp_processor_id</span><span class="p">(),</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we couldn&#39;t find a local APIC, then get out of here now!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disable_apic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;BIOS bug, local APIC #%d not detected!...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">boot_cpu_physical_apicid</span><span class="p">);</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;... forcing use of dummy APIC emulation.&quot;</span>
				<span class="s">&quot;(tell your hw vendor)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">smpboot_clear_io_apic</span><span class="p">();</span>
		<span class="n">disable_ioapic_support</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">verify_local_APIC</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If SMP should be disabled, then really disable it!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP mode deactivated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">smpboot_clear_io_apic</span><span class="p">();</span>

		<span class="n">connect_bsp_APIC</span><span class="p">();</span>
		<span class="n">setup_local_APIC</span><span class="p">();</span>
		<span class="n">bsp_end_local_APIC_setup</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_cpu_index_default</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="cm">/* mark all to hotplug */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare for SMP bootup.  The MP table or ACPI has been read</span>
<span class="cm"> * earlier.  Just do some sanity checking here and enable APIC mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">native_smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">smp_cpu_index_default</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup boot CPU information</span>
<span class="cm">	 */</span>
	<span class="n">smp_store_cpu_info</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* Final full version of the data */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cpu_callin_mask</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">mb</span><span class="p">();</span>

	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* needed? */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_sibling_map</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_core_map</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_llc_shared_map</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_cpu_sibling_map</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">smp_sanity_check</span><span class="p">(</span><span class="n">max_cpus</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">disable_smp</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">default_setup_apic_routing</span><span class="p">();</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_apic_id</span><span class="p">()</span> <span class="o">!=</span> <span class="n">boot_cpu_physical_apicid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Boot APIC ID in local APIC unexpected (%d vs %d)&quot;</span><span class="p">,</span>
		     <span class="n">read_apic_id</span><span class="p">(),</span> <span class="n">boot_cpu_physical_apicid</span><span class="p">);</span>
		<span class="cm">/* Or can we switch back to PIC here? */</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">connect_bsp_APIC</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch from PIC to APIC mode.</span>
<span class="cm">	 */</span>
	<span class="n">setup_local_APIC</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable IO APIC before setting up error vector</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_ioapic_setup</span> <span class="o">&amp;&amp;</span> <span class="n">nr_ioapics</span><span class="p">)</span>
		<span class="n">enable_IO_APIC</span><span class="p">();</span>

	<span class="n">bsp_end_local_APIC_setup</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">setup_portio_remap</span><span class="p">)</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">setup_portio_remap</span><span class="p">();</span>

	<span class="n">smpboot_setup_io_apic</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up local APIC timer on boot CPU.</span>
<span class="cm">	 */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU%d: &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">print_cpu_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">timers</span><span class="p">.</span><span class="n">setup_percpu_clockev</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="n">uv_system_init</span><span class="p">();</span>

	<span class="n">set_mtrr_aps_delayed_init</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_disable_nonboot_cpus_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Avoid the smp alternatives switch during the disable_nonboot_cpus().</span>
<span class="cm">	 * In the suspend path, we will be back in the SMP mode shortly anyways.</span>
<span class="cm">	 */</span>
	<span class="n">skip_smp_alternatives</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_disable_nonboot_cpus_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skip_smp_alternatives</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_enable_nonboot_cpus_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_mtrr_aps_delayed_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_enable_nonboot_cpus_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mtrr_aps_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Early setup to make printk work.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">native_smp_prepare_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">me</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">switch_to_new_gdt</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
	<span class="cm">/* already set me in cpu_online_mask in boot_cpu_init() */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_ONLINE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">native_smp_cpus_done</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cpus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Boot done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">nmi_selftest</span><span class="p">();</span>
	<span class="n">impress_friends</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
	<span class="n">setup_ioapic_dest</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">mtrr_aps_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">setup_possible_cpus</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">_setup_possible_cpus</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">setup_possible_cpus</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;possible_cpus&quot;</span><span class="p">,</span> <span class="n">_setup_possible_cpus</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * cpu_possible_mask should be static, it cannot change as cpu&#39;s</span>
<span class="cm"> * are onlined, or offlined. The reason is per-cpu data-structures</span>
<span class="cm"> * are allocated by some modules at init time, and dont expect to</span>
<span class="cm"> * do this dynamically on cpu arrival/departure.</span>
<span class="cm"> * cpu_present_mask on the other hand can change dynamically.</span>
<span class="cm"> * In case when cpu_hotplug is not compiled, then we resort to current</span>
<span class="cm"> * behaviour, which is cpu_possible == cpu_present.</span>
<span class="cm"> * - Ashok Raj</span>
<span class="cm"> *</span>
<span class="cm"> * Three ways to find out the number of additional hotplug CPUs:</span>
<span class="cm"> * - If the BIOS specified disabled CPUs in ACPI/mptables use that.</span>
<span class="cm"> * - The user can overwrite it with possible_cpus=NUM</span>
<span class="cm"> * - Otherwise don&#39;t reserve additional CPUs.</span>
<span class="cm"> * We do this because additional CPUs waste a lot of memory.</span>
<span class="cm"> * -AK</span>
<span class="cm"> */</span>
<span class="n">__init</span> <span class="kt">void</span> <span class="nf">prefill_possible_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">possible</span><span class="p">;</span>

	<span class="cm">/* no processor from mptable or madt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_processors</span><span class="p">)</span>
		<span class="n">num_processors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">setup_max_cpus</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_possible_cpus</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">possible</span> <span class="o">=</span> <span class="n">num_processors</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">setup_max_cpus</span><span class="p">)</span>
			<span class="n">possible</span> <span class="o">+=</span> <span class="n">disabled_cpus</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">possible</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">possible</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">possible</span> <span class="o">=</span> <span class="n">setup_possible_cpus</span><span class="p">;</span>

	<span class="n">total_cpus</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">possible</span><span class="p">,</span> <span class="n">num_processors</span> <span class="o">+</span> <span class="n">disabled_cpus</span><span class="p">);</span>

	<span class="cm">/* nr_cpu_ids could be reduced via nr_cpus= */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">possible</span> <span class="o">&gt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%d Processors exceeds NR_CPUS limit of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">possible</span><span class="p">,</span> <span class="n">nr_cpu_ids</span><span class="p">);</span>
		<span class="n">possible</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_max_cpus</span><span class="p">)</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">possible</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;%d Processors exceeds max_cpus limit of %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">possible</span><span class="p">,</span> <span class="n">setup_max_cpus</span><span class="p">);</span>
		<span class="n">possible</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;SMP: Allowing %d CPUs, %d hotplug CPUs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">possible</span><span class="p">,</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">possible</span> <span class="o">-</span> <span class="n">num_processors</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">possible</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">nr_cpu_ids</span> <span class="o">=</span> <span class="n">possible</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_siblinginfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sibling</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">sibling</span><span class="p">));</span>
		<span class="cm">/*/</span>
<span class="cm">		 * last thread sibling in this cpu core going down</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">cpu_data</span><span class="p">(</span><span class="n">sibling</span><span class="p">).</span><span class="n">booted_cores</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">sibling</span><span class="p">));</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">cpu_sibling_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">cpu_core_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_core_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_sibling_setup_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__ref</span> <span class="nf">remove_cpu_from_maps</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callout_mask</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_callin_mask</span><span class="p">);</span>
	<span class="cm">/* was set by cpu_init() */</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_initialized_mask</span><span class="p">);</span>
	<span class="n">numa_remove_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_disable_common</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">remove_siblinginfo</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* It&#39;s now safe to remove this processor from the online map */</span>
	<span class="n">lock_vector_lock</span><span class="p">();</span>
	<span class="n">remove_cpu_from_maps</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">unlock_vector_lock</span><span class="p">();</span>
	<span class="n">fixup_irqs</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">native_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perhaps use cpufreq to drop frequency, but that could go</span>
<span class="cm">	 * into generic code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We won&#39;t take down the boot processor on i386 due to some</span>
<span class="cm">	 * interrupts only being able to be serviced by the BSP.</span>
<span class="cm">	 * Especially so if we&#39;re not using an IOAPIC	-zwane</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">clear_local_APIC</span><span class="p">();</span>

	<span class="n">cpu_disable_common</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t do anything here: idle task is faking death itself. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* They ack this in play_dead by setting CPU_DEAD */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPU_DEAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_RUNNING</span><span class="p">)</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU %u is now offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">num_online_cpus</span><span class="p">())</span>
				<span class="n">alternatives_smp_switch</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;CPU %u didn&#39;t die...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">play_dead_common</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idle_task_exit</span><span class="p">();</span>
	<span class="n">reset_lazy_tlbstate</span><span class="p">();</span>
	<span class="n">amd_e400_remove_cpu</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="n">mb</span><span class="p">();</span>
	<span class="cm">/* Ack it */</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">cpu_state</span><span class="p">,</span> <span class="n">CPU_DEAD</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * With physical CPU hotplug, we should halt the cpu</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to flush the caches before going to sleep, lest we have</span>
<span class="cm"> * dirty data in our caches when we come back up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mwait_play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">highest_cstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">highest_subcstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mwait_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">this_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_MWAIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mwait_usable</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CLFLSH</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">cpu_info</span><span class="p">.</span><span class="n">cpuid_level</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CPUID_MWAIT_LEAF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">eax</span> <span class="o">=</span> <span class="n">CPUID_MWAIT_LEAF</span><span class="p">;</span>
	<span class="n">ecx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">native_cpuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * eax will be 0 if EDX enumeration is not valid.</span>
<span class="cm">	 * Initialized below to cstate, sub_cstate value when EDX is valid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="n">CPUID5_ECX_EXTENSIONS_SUPPORTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">edx</span> <span class="o">&gt;&gt;=</span> <span class="n">MWAIT_SUBSTATE_SIZE</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">edx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">edx</span> <span class="o">&gt;&gt;=</span> <span class="n">MWAIT_SUBSTATE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">edx</span> <span class="o">&amp;</span> <span class="n">MWAIT_SUBSTATE_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">highest_cstate</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">highest_subcstate</span> <span class="o">=</span> <span class="n">edx</span> <span class="o">&amp;</span> <span class="n">MWAIT_SUBSTATE_MASK</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">eax</span> <span class="o">=</span> <span class="p">(</span><span class="n">highest_cstate</span> <span class="o">&lt;&lt;</span> <span class="n">MWAIT_SUBSTATE_SIZE</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">highest_subcstate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This should be a memory location in a cache line which is</span>
<span class="cm">	 * unlikely to be touched by other processors.  The actual</span>
<span class="cm">	 * content is immaterial as it is not actually modified in any way.</span>
<span class="cm">	 */</span>
	<span class="n">mwait_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">wbinvd</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The CLFLUSH is a workaround for erratum AAI65 for</span>
<span class="cm">		 * the Xeon 7400 series.  It&#39;s not clear it is actually</span>
<span class="cm">		 * needed, but it should be harmless in either case.</span>
<span class="cm">		 * The WBINVD is insufficient due to the spurious-wakeup</span>
<span class="cm">		 * case where we return around the loop.</span>
<span class="cm">		 */</span>
		<span class="n">clflush</span><span class="p">(</span><span class="n">mwait_ptr</span><span class="p">);</span>
		<span class="n">__monitor</span><span class="p">(</span><span class="n">mwait_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">__mwait</span><span class="p">(</span><span class="n">eax</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlt_play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">cpu_info</span><span class="p">.</span><span class="n">x86</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">wbinvd</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">native_halt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">play_dead_common</span><span class="p">();</span>
	<span class="n">tboot_shutdown</span><span class="p">(</span><span class="n">TB_SHUTDOWN_WFS</span><span class="p">);</span>

	<span class="n">mwait_play_dead</span><span class="p">();</span>	<span class="cm">/* Only returns on failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuidle_play_dead</span><span class="p">())</span>
		<span class="n">hlt_play_dead</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* ... !CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">native_cpu_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_cpu_die</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We said &quot;no&quot; in __cpu_disable */</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
