<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › apic › apic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>apic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Local APIC handling, local APIC timers</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) 1999, 2000, 2009 Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes</span>
<span class="cm"> *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs;</span>
<span class="cm"> *					thanks to Eric Gilmore</span>
<span class="cm"> *					and Rolf G. Tews</span>
<span class="cm"> *					for testing these extensively.</span>
<span class="cm"> *	Maciej W. Rozycki	:	Various updates and fixes.</span>
<span class="cm"> *	Mikael Pettersson	:	Power Management for UP-APIC.</span>
<span class="cm"> *	Pavel Machek and</span>
<span class="cm"> *	Mikael Pettersson	:	PM converted to driver model.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>
<span class="cp">#include &lt;linux/acpi_pmtmr.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/i8253.h&gt;</span>
<span class="cp">#include &lt;linux/dmar.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>

<span class="cp">#include &lt;asm/irq_remapping.h&gt;</span>
<span class="cp">#include &lt;asm/perf_event.h&gt;</span>
<span class="cp">#include &lt;asm/x86_init.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/mpspec.h&gt;</span>
<span class="cp">#include &lt;asm/i8259.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/io_apic.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/hpet.h&gt;</span>
<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/tsc.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_processors</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="n">disabled_cpus</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="cm">/* Processor that is doing the boot up */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boot_cpu_physical_apicid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1U</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The highest APIC ID seen during enumeration.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_physical_apicid</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Bitmask of physically existing CPUs:</span>
<span class="cm"> */</span>
<span class="n">physid_mask_t</span> <span class="n">phys_cpu_present_map</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Map cpu index to physical APIC ID</span>
<span class="cm"> */</span>
<span class="n">DEFINE_EARLY_PER_CPU</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">BAD_APICID</span><span class="p">);</span>
<span class="n">DEFINE_EARLY_PER_CPU</span><span class="p">(</span><span class="n">u16</span><span class="p">,</span> <span class="n">x86_bios_cpu_apicid</span><span class="p">,</span> <span class="n">BAD_APICID</span><span class="p">);</span>
<span class="n">EXPORT_EARLY_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">);</span>
<span class="n">EXPORT_EARLY_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">x86_bios_cpu_apicid</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>

<span class="cm">/*</span>
<span class="cm"> * On x86_32, the mapping between cpu and logical apicid may vary</span>
<span class="cm"> * depending on apic in use.  The following early percpu variable is</span>
<span class="cm"> * used for the mapping.  This is where the behaviors of x86_64 and 32</span>
<span class="cm"> * actually diverge.  Let&#39;s keep it ugly for now.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_EARLY_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">x86_cpu_to_logical_apicid</span><span class="p">,</span> <span class="n">BAD_APICID</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Knob to control our willingness to enable the local APIC.</span>
<span class="cm"> *</span>
<span class="cm"> * +1=force-enable</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">force_enable_local_apic</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * APIC command line parameters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_lapic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">force_enable_local_apic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;lapic&quot;</span><span class="p">,</span> <span class="n">parse_lapic</span><span class="p">);</span>
<span class="cm">/* Local APIC was disabled by the BIOS and enabled by the kernel */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">enabled_via_apicbase</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Handle interrupt mode configuration register (IMCR).</span>
<span class="cm"> * This register controls whether the interrupt signals</span>
<span class="cm"> * that reach the BSP come from the master PIC or from the</span>
<span class="cm"> * local APIC. Before entering Symmetric I/O Mode, either</span>
<span class="cm"> * the BIOS or the operating system must switch out of</span>
<span class="cm"> * PIC Mode by changing the IMCR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">imcr_pic_to_apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* select IMCR register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x70</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">);</span>
	<span class="cm">/* NMI and 8259 INTR go through APIC */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">imcr_apic_to_pic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* select IMCR register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x70</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">);</span>
	<span class="cm">/* NMI and 8259 INTR go directly to BSP */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">apic_calibrate_pmtmr</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_apicpmtimer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic_calibrate_pmtmr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">notsc_setup</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;apicpmtimer&quot;</span><span class="p">,</span> <span class="n">setup_apicpmtimer</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">x2apic_mode</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_X2APIC</span>
<span class="cm">/* x2apic enabled before OS handover */</span>
<span class="kt">int</span> <span class="n">x2apic_preenabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">x2apic_disabled</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nox2apic</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_nox2apic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">apicid</span> <span class="o">=</span> <span class="n">native_apic_msr_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&gt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Apicid: %08x, cannot enforce nox2apic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">apicid</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;x2apic already enabled. will disable it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_X2APIC</span><span class="p">);</span>

	<span class="n">nox2apic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nox2apic&quot;</span><span class="p">,</span> <span class="n">setup_nox2apic</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mp_lapic_addr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">disable_apic</span><span class="p">;</span>
<span class="cm">/* Disable local APIC timer from the kernel commandline or via dmi quirk */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_apic_timer</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="cm">/* Local APIC timer works in C2 */</span>
<span class="kt">int</span> <span class="n">local_apic_timer_c2_ok</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">local_apic_timer_c2_ok</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">first_system_vector</span> <span class="o">=</span> <span class="mh">0xfe</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Debug level, exported for io_apic.c</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_verbosity</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">pic_mode</span><span class="p">;</span>

<span class="cm">/* Have we found an MP table */</span>
<span class="kt">int</span> <span class="n">smp_found_config</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">lapic_resource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Local APIC&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_BUSY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lapic_timer_frequency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">apic_pm_activate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">apic_phys</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Get the LAPIC version</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lapic_get_version</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check, if the APIC is integrated or a separate chip</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lapic_is_integrated</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">lapic_get_version</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check, whether this is a modern or a first generation APIC</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">modern_apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* AMD systems use old APIC versions, so check the CPU */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_AMD</span> <span class="o">&amp;&amp;</span>
	    <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0xf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lapic_get_version</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mh">0x14</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * right after this call apic become NOOP driven</span>
<span class="cm"> * so apic-&gt;write/read doesn&#39;t do anything</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">apic_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;APIC: switched to apic NOOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">apic</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">apic_noop</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">APIC_ICR_BUSY</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">native_safe_apic_wait_icr_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">send_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">send_status</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">APIC_ICR_BUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">send_status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">inc_irq_stat</span><span class="p">(</span><span class="n">icr_read_retry_count</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">send_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_apic_icr_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">low</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ICR2</span><span class="p">,</span> <span class="n">SET_APIC_DEST_FIELD</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">,</span> <span class="n">low</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">native_apic_icr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">icr1</span><span class="p">,</span> <span class="n">icr2</span><span class="p">;</span>

	<span class="n">icr2</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ICR2</span><span class="p">);</span>
	<span class="n">icr1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">icr1</span> <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">icr2</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/**</span>
<span class="cm"> * get_physical_broadcast - Get number of physical broadcast IDs</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_physical_broadcast</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">modern_apic</span><span class="p">()</span> <span class="o">?</span> <span class="mh">0xff</span> <span class="o">:</span> <span class="mh">0xf</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * lapic_get_maxlvt - get the maximum number of local vector table entries</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">lapic_get_maxlvt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * - we always have APIC integrated on 64bit mode</span>
<span class="cm">	 * - 82489DXs do not report # of LVT entries</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">?</span> <span class="n">GET_APIC_MAXLVT</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC timer</span>
<span class="cm"> */</span>

<span class="cm">/* Clock divisor */</span>
<span class="cp">#define APIC_DIVISOR 16</span>

<span class="cm">/*</span>
<span class="cm"> * This function sets up the local APIC timer, with a timeout of</span>
<span class="cm"> * &#39;clocks&#39; APIC bus clock. During calibration we actually call</span>
<span class="cm"> * this function twice on the boot CPU, once with a bogus timeout</span>
<span class="cm"> * value, second time for real. The other (noncalibrating) CPUs</span>
<span class="cm"> * call this function only once, with the real, calibrated value.</span>
<span class="cm"> *</span>
<span class="cm"> * We do reads before writes even if unnecessary, to get around the</span>
<span class="cm"> * P5 APIC double write bug.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__setup_APIC_LVTT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oneshot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irqen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lvtt_value</span><span class="p">,</span> <span class="n">tmp_value</span><span class="p">;</span>

	<span class="n">lvtt_value</span> <span class="o">=</span> <span class="n">LOCAL_TIMER_VECTOR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oneshot</span><span class="p">)</span>
		<span class="n">lvtt_value</span> <span class="o">|=</span> <span class="n">APIC_LVT_TIMER_PERIODIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lapic_is_integrated</span><span class="p">())</span>
		<span class="n">lvtt_value</span> <span class="o">|=</span> <span class="n">SET_APIC_TIMER_BASE</span><span class="p">(</span><span class="n">APIC_TIMER_BASE_DIV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqen</span><span class="p">)</span>
		<span class="n">lvtt_value</span> <span class="o">|=</span> <span class="n">APIC_LVT_MASKED</span><span class="p">;</span>

	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">lvtt_value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Divide PICLK by 16</span>
<span class="cm">	 */</span>
	<span class="n">tmp_value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TDCR</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TDCR</span><span class="p">,</span>
		<span class="p">(</span><span class="n">tmp_value</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">APIC_TDR_DIV_1</span> <span class="o">|</span> <span class="n">APIC_TDR_DIV_TMBASE</span><span class="p">))</span> <span class="o">|</span>
		<span class="n">APIC_TDR_DIV_16</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oneshot</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">,</span> <span class="n">clocks</span> <span class="o">/</span> <span class="n">APIC_DIVISOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup extended LVT, AMD specific</span>
<span class="cm"> *</span>
<span class="cm"> * Software should use the LVT offsets the BIOS provides.  The offsets</span>
<span class="cm"> * are determined by the subsystems using it like those for MCE</span>
<span class="cm"> * threshold or IBS.  On K8 only offset 0 (APIC500) and MCE interrupts</span>
<span class="cm"> * are supported. Beginning with family 10h at least 4 offsets are</span>
<span class="cm"> * available.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the offsets must be consistent for all cores, we keep track</span>
<span class="cm"> * of the LVT offsets in software and reserve the offset for the same</span>
<span class="cm"> * vector also to be used on other cores. An offset is freed by</span>
<span class="cm"> * setting the entry to APIC_EILVT_MASKED.</span>
<span class="cm"> *</span>
<span class="cm"> * If the BIOS is right, there should be no conflicts. Otherwise a</span>
<span class="cm"> * &quot;[Firmware Bug]: ...&quot; error message is generated. However, if</span>
<span class="cm"> * software does not properly determines the offsets, it is not</span>
<span class="cm"> * necessarily a BIOS bug.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">eilvt_offsets</span><span class="p">[</span><span class="n">APIC_EILVT_NR_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">eilvt_entry_is_changeable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">APIC_EILVT_MASKED</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="n">APIC_EILVT_MASKED</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">((</span><span class="n">new</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">APIC_EILVT_MASKED</span><span class="p">)</span> <span class="o">==</span> <span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">reserve_eilvt_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsvd</span><span class="p">,</span> <span class="n">vector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">APIC_EILVT_NR_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">rsvd</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eilvt_offsets</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="n">rsvd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">APIC_EILVT_MASKED</span><span class="p">;</span>	<span class="cm">/* 0: unassigned */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vector</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">eilvt_entry_is_changeable</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
			<span class="cm">/* may not change if vectors are different */</span>
			<span class="k">return</span> <span class="n">rsvd</span><span class="p">;</span>
		<span class="n">rsvd</span> <span class="o">=</span> <span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eilvt_offsets</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">rsvd</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rsvd</span> <span class="o">!=</span> <span class="n">new</span><span class="p">);</span>

	<span class="n">rsvd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_EILVT_MASKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsvd</span> <span class="o">&amp;&amp;</span> <span class="n">rsvd</span> <span class="o">!=</span> <span class="n">vector</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;LVT offset %d assigned for vector 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If mask=1, the LVT entry does not generate interrupts while mask=0</span>
<span class="cm"> * enables the vector. See also the BKDGs. Must be called with</span>
<span class="cm"> * preemption disabled.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">setup_APIC_eilvt</span><span class="p">(</span><span class="n">u8</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">vector</span><span class="p">,</span> <span class="n">u8</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">APIC_EILVTn</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">reserved</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">msg_type</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">reserved</span> <span class="o">=</span> <span class="n">reserve_eilvt_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span> <span class="o">!=</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="n">FW_BUG</span> <span class="s">&quot;cpu %d, try to use APIC%lX (LVT offset %d) for &quot;</span>
		       <span class="s">&quot;vector 0x%x, but the register is already in use for &quot;</span>
		       <span class="s">&quot;vector 0x%x on another cpu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">reg</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eilvt_entry_is_changeable</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="n">FW_BUG</span> <span class="s">&quot;cpu %d, try to use APIC%lX (LVT offset %d) for &quot;</span>
		       <span class="s">&quot;vector 0x%x, but the register is already in use for &quot;</span>
		       <span class="s">&quot;vector 0x%x on this cpu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">reg</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">apic_write</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">setup_APIC_eilvt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Program the next event, relative to now</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lapic_next_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the lapic timer in periodic or oneshot mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_setup</span><span class="p">(</span><span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/* Lapic used as dummy for broadcast ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_PERIODIC</span>:
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_ONESHOT</span>:
		<span class="n">__setup_APIC_LVTT</span><span class="p">(</span><span class="n">lapic_timer_frequency</span><span class="p">,</span>
				  <span class="n">mode</span> <span class="o">!=</span> <span class="n">CLOCK_EVT_MODE_PERIODIC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span>:
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span>:
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">APIC_LVT_MASKED</span> <span class="o">|</span> <span class="n">LOCAL_TIMER_VECTOR</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_MODE_RESUME</span>:
		<span class="cm">/* Nothing to do here */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC timer broadcast function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_broadcast</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">LOCAL_TIMER_VECTOR</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * The local apic timer can be used for any function which is CPU local.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="n">lapic_clockevent</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;lapic&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">features</span>	<span class="o">=</span> <span class="n">CLOCK_EVT_FEAT_PERIODIC</span> <span class="o">|</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span>
			<span class="o">|</span> <span class="n">CLOCK_EVT_FEAT_C3STOP</span> <span class="o">|</span> <span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shift</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mode</span>	<span class="o">=</span> <span class="n">lapic_timer_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_next_event</span>	<span class="o">=</span> <span class="n">lapic_next_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">broadcast</span>	<span class="o">=</span> <span class="n">lapic_timer_broadcast</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>		<span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span><span class="p">,</span> <span class="n">lapic_events</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the local APIC timer for this CPU. Copy the initialized values</span>
<span class="cm"> * of the boot CPU and register the clock event in the framework.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">setup_APIC_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">levt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">lapic_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_ARAT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_EVT_FEAT_C3STOP</span><span class="p">;</span>
		<span class="cm">/* Make LAPIC timer preferrable over percpu HPET */</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">rating</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">levt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_clockevent</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">levt</span><span class="p">));</span>
	<span class="n">levt</span><span class="o">-&gt;</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="n">levt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In this functions we calibrate APIC bus clocks to the external timer.</span>
<span class="cm"> *</span>
<span class="cm"> * We want to do the calibration only once since we want to have local timer</span>
<span class="cm"> * irqs syncron. CPUs connected by the same APIC bus have the very same bus</span>
<span class="cm"> * frequency.</span>
<span class="cm"> *</span>
<span class="cm"> * This was previously done by reading the PIT/HPET and waiting for a wrap</span>
<span class="cm"> * around to find out, that a tick has elapsed. I have a box, where the PIT</span>
<span class="cm"> * readout is broken, so it never gets out of the wait loop again. This was</span>
<span class="cm"> * also reported by others.</span>
<span class="cm"> *</span>
<span class="cm"> * Monitoring the jiffies value is inaccurate and the clockevents</span>
<span class="cm"> * infrastructure allows us to do a simple substitution of the interrupt</span>
<span class="cm"> * handler.</span>
<span class="cm"> *</span>
<span class="cm"> * The calibration routine also uses the pm_timer when possible, as the PIT</span>
<span class="cm"> * happens to run way too slow (factor 2.3 on my VAIO CoreDuo, which goes</span>
<span class="cm"> * back to normal later in the boot process).</span>
<span class="cm"> */</span>

<span class="cp">#define LAPIC_CAL_LOOPS		(HZ/10)</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">int</span> <span class="n">lapic_cal_loops</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">long</span> <span class="n">lapic_cal_t1</span><span class="p">,</span> <span class="n">lapic_cal_t2</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lapic_cal_tsc1</span><span class="p">,</span> <span class="n">lapic_cal_tsc2</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lapic_cal_pm1</span><span class="p">,</span> <span class="n">lapic_cal_pm2</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lapic_cal_j1</span><span class="p">,</span> <span class="n">lapic_cal_j2</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Temporary interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">lapic_cal_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tapic</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TMCCT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pm</span> <span class="o">=</span> <span class="n">acpi_pm_read_early</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span>
		<span class="n">rdtscll</span><span class="p">(</span><span class="n">tsc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lapic_cal_loops</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">lapic_cal_t1</span> <span class="o">=</span> <span class="n">tapic</span><span class="p">;</span>
		<span class="n">lapic_cal_tsc1</span> <span class="o">=</span> <span class="n">tsc</span><span class="p">;</span>
		<span class="n">lapic_cal_pm1</span> <span class="o">=</span> <span class="n">pm</span><span class="p">;</span>
		<span class="n">lapic_cal_j1</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LAPIC_CAL_LOOPS</span>:
		<span class="n">lapic_cal_t2</span> <span class="o">=</span> <span class="n">tapic</span><span class="p">;</span>
		<span class="n">lapic_cal_tsc2</span> <span class="o">=</span> <span class="n">tsc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm</span> <span class="o">&lt;</span> <span class="n">lapic_cal_pm1</span><span class="p">)</span>
			<span class="n">pm</span> <span class="o">+=</span> <span class="n">ACPI_PM_OVRRUN</span><span class="p">;</span>
		<span class="n">lapic_cal_pm2</span> <span class="o">=</span> <span class="n">pm</span><span class="p">;</span>
		<span class="n">lapic_cal_j2</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">calibrate_by_pmtimer</span><span class="p">(</span><span class="kt">long</span> <span class="n">deltapm</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">delta</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">deltatsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">pm_100ms</span> <span class="o">=</span> <span class="n">PMTMR_TICKS_PER_SEC</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">pm_thresh</span> <span class="o">=</span> <span class="n">pm_100ms</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mult</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">res</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_X86_PM_TIMER</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... PM-Timer delta = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">deltapm</span><span class="p">);</span>

	<span class="cm">/* Check, if the PM timer is available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deltapm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">mult</span> <span class="o">=</span> <span class="n">clocksource_hz2mult</span><span class="p">(</span><span class="n">PMTMR_TICKS_PER_SEC</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">deltapm</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pm_100ms</span> <span class="o">-</span> <span class="n">pm_thresh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">deltapm</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">pm_100ms</span> <span class="o">+</span> <span class="n">pm_thresh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... PM-Timer result ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">deltapm</span><span class="p">)</span> <span class="o">*</span>  <span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;APIC calibration not consistent &quot;</span>
		   <span class="s">&quot;with PM-Timer: %ldms instead of 100ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">);</span>

	<span class="cm">/* Correct the lapic counter value */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)(</span><span class="o">*</span><span class="n">delta</span><span class="p">))</span> <span class="o">*</span> <span class="n">pm_100ms</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">deltapm</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;APIC delta adjusted to PM-Timer: &quot;</span>
		<span class="s">&quot;%lu (%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">delta</span><span class="p">);</span>
	<span class="o">*</span><span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Correct the tsc counter value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)(</span><span class="o">*</span><span class="n">deltatsc</span><span class="p">))</span> <span class="o">*</span> <span class="n">pm_100ms</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">deltapm</span><span class="p">);</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;TSC delta adjusted to &quot;</span>
					  <span class="s">&quot;PM-Timer: %lu (%ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">deltatsc</span><span class="p">);</span>
		<span class="o">*</span><span class="n">deltatsc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">calibrate_APIC_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">levt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">lapic_events</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">real_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deltaj</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltatsc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pm_referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * check if lapic timer has already been calibrated by platform</span>
<span class="cm">	 * specific routine, such as tsc calibration code. if so, we just fill</span>
<span class="cm">	 * in the clockevent structure and return.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lapic_timer_frequency</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;lapic timer already calibrated %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lapic_timer_frequency</span><span class="p">);</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="n">div_sc</span><span class="p">(</span><span class="n">lapic_timer_frequency</span><span class="o">/</span><span class="n">APIC_DIVISOR</span><span class="p">,</span>
					<span class="n">TICK_NSEC</span><span class="p">,</span> <span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">shift</span><span class="p">);</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">max_delta_ns</span> <span class="o">=</span>
			<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0x7FFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_clockevent</span><span class="p">);</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">min_delta_ns</span> <span class="o">=</span>
			<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0xF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_clockevent</span><span class="p">);</span>
		<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="cm">/* Replace the global interrupt handler */</span>
	<span class="n">real_handler</span> <span class="o">=</span> <span class="n">global_clock_event</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">;</span>
	<span class="n">global_clock_event</span><span class="o">-&gt;</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">lapic_cal_handler</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the APIC counter to maximum. There is no way the lapic</span>
<span class="cm">	 * can underflow in the 100ms detection time frame</span>
<span class="cm">	 */</span>
	<span class="n">__setup_APIC_LVTT</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Let the interrupts run */</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">lapic_cal_loops</span> <span class="o">&lt;=</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="cm">/* Restore the real event handler */</span>
	<span class="n">global_clock_event</span><span class="o">-&gt;</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">real_handler</span><span class="p">;</span>

	<span class="cm">/* Build delta t1-t2 as apic timer counts down */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">lapic_cal_t1</span> <span class="o">-</span> <span class="n">lapic_cal_t2</span><span class="p">;</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... lapic delta = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

	<span class="n">deltatsc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">lapic_cal_tsc2</span> <span class="o">-</span> <span class="n">lapic_cal_tsc1</span><span class="p">);</span>

	<span class="cm">/* we trust the PM based calibration if possible */</span>
	<span class="n">pm_referenced</span> <span class="o">=</span> <span class="o">!</span><span class="n">calibrate_by_pmtimer</span><span class="p">(</span><span class="n">lapic_cal_pm2</span> <span class="o">-</span> <span class="n">lapic_cal_pm1</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deltatsc</span><span class="p">);</span>

	<span class="cm">/* Calculate the scaled math multiplication factor */</span>
	<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="n">div_sc</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">TICK_NSEC</span> <span class="o">*</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">,</span>
				       <span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">shift</span><span class="p">);</span>
	<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">max_delta_ns</span> <span class="o">=</span>
		<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0x7FFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_clockevent</span><span class="p">);</span>
	<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">min_delta_ns</span> <span class="o">=</span>
		<span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="mh">0xF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_clockevent</span><span class="p">);</span>

	<span class="n">lapic_timer_frequency</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">APIC_DIVISOR</span><span class="p">)</span> <span class="o">/</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;..... delta %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;..... mult: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">mult</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;..... calibration result: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">lapic_timer_frequency</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;..... CPU clock speed is &quot;</span>
			    <span class="s">&quot;%ld.%04ld MHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">deltatsc</span> <span class="o">/</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">),</span>
			    <span class="p">(</span><span class="n">deltatsc</span> <span class="o">/</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;..... host bus clock speed is &quot;</span>
		    <span class="s">&quot;%u.%04u MHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">lapic_timer_frequency</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">),</span>
		    <span class="n">lapic_timer_frequency</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a sanity check on the APIC calibration result</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lapic_timer_frequency</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;APIC frequency too slow, disabling apic timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">levt</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PM timer calibration failed or not turned on</span>
<span class="cm">	 * so lets try APIC timer based calibration</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm_referenced</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... verify APIC timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup the apic timer manually</span>
<span class="cm">		 */</span>
		<span class="n">levt</span><span class="o">-&gt;</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">lapic_cal_handler</span><span class="p">;</span>
		<span class="n">lapic_timer_setup</span><span class="p">(</span><span class="n">CLOCK_EVT_MODE_PERIODIC</span><span class="p">,</span> <span class="n">levt</span><span class="p">);</span>
		<span class="n">lapic_cal_loops</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Let the interrupts run */</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">lapic_cal_loops</span> <span class="o">&lt;=</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="cm">/* Stop the lapic timer */</span>
		<span class="n">lapic_timer_setup</span><span class="p">(</span><span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">,</span> <span class="n">levt</span><span class="p">);</span>

		<span class="cm">/* Jiffies delta */</span>
		<span class="n">deltaj</span> <span class="o">=</span> <span class="n">lapic_cal_j2</span> <span class="o">-</span> <span class="n">lapic_cal_j1</span><span class="p">;</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... jiffies delta = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">deltaj</span><span class="p">);</span>

		<span class="cm">/* Check, if the jiffies result is consistent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">deltaj</span> <span class="o">&gt;=</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">deltaj</span> <span class="o">&lt;=</span> <span class="n">LAPIC_CAL_LOOPS</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;... jiffies result ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">levt</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">levt</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;APIC timer disabled due to verification failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the boot APIC</span>
<span class="cm"> *</span>
<span class="cm"> * Calibrate and verify the result.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_boot_APIC_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The local apic timer can be disabled via the kernel</span>
<span class="cm">	 * commandline or from the CPU detection code. Register the lapic</span>
<span class="cm">	 * timer as a dummy clock event source on SMP systems, so the</span>
<span class="cm">	 * broadcast mechanism is used. On UP systems simply ignore it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic_timer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Disabling APIC timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* No broadcast on UP ! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">setup_APIC_timer</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;Using local APIC timer interrupts.</span><span class="se">\n</span><span class="s">&quot;</span>
		    <span class="s">&quot;calibrating APIC timer ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">calibrate_APIC_clock</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* No broadcast on UP ! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">setup_APIC_timer</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If nmi_watchdog is set to IO_APIC, we need the</span>
<span class="cm">	 * PIT/HPET going.  Otherwise register lapic as a dummy</span>
<span class="cm">	 * device.</span>
<span class="cm">	 */</span>
	<span class="n">lapic_clockevent</span><span class="p">.</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_EVT_FEAT_DUMMY</span><span class="p">;</span>

	<span class="cm">/* Setup the lapic or request the broadcast */</span>
	<span class="n">setup_APIC_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">setup_secondary_APIC_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_APIC_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The guts of the apic timer interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">local_apic_timer_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">lapic_events</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Normally we should not be here till LAPIC has been initialized but</span>
<span class="cm">	 * in some cases like kdump, its possible that there is a pending LAPIC</span>
<span class="cm">	 * timer interrupt from previous kernel&#39;s context and is delivered in</span>
<span class="cm">	 * new kernel the moment interrupts are enabled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Interrupts are enabled early and LAPIC is setup much later, hence</span>
<span class="cm">	 * its possible that when we get here evt-&gt;event_handler is NULL.</span>
<span class="cm">	 * Check for event_handler being NULL and discard the interrupt as</span>
<span class="cm">	 * spurious.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Spurious LAPIC timer interrupt on cpu %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* Switch it off */</span>
		<span class="n">lapic_timer_setup</span><span class="p">(</span><span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">,</span> <span class="n">evt</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the NMI deadlock-detector uses this.</span>
<span class="cm">	 */</span>
	<span class="n">inc_irq_stat</span><span class="p">(</span><span class="n">apic_timer_irqs</span><span class="p">);</span>

	<span class="n">evt</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">(</span><span class="n">evt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC timer interrupt. This is the most natural way for doing</span>
<span class="cm"> * local interrupts, but local timer interrupts can be emulated by</span>
<span class="cm"> * broadcast interrupts too. [in case the hw doesn&#39;t support APIC timers]</span>
<span class="cm"> *</span>
<span class="cm"> * [ if a single-CPU system runs an SMP kernel then we call the local</span>
<span class="cm"> *   interrupt as well. Thus we cannot inline the local irq ... ]</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__irq_entry</span> <span class="nf">smp_apic_timer_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">old_regs</span> <span class="o">=</span> <span class="n">set_irq_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE! We&#39;d better ACK the irq immediately,</span>
<span class="cm">	 * because timer handling can be slow.</span>
<span class="cm">	 */</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * update_process_times() expects us to have done irq_enter().</span>
<span class="cm">	 * Besides, if we don&#39;t timer interrupts ignore the global</span>
<span class="cm">	 * interrupt lock, which is the WrongThing (tm) to do.</span>
<span class="cm">	 */</span>
	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">exit_idle</span><span class="p">();</span>
	<span class="n">local_apic_timer_interrupt</span><span class="p">();</span>
	<span class="n">irq_exit</span><span class="p">();</span>

	<span class="n">set_irq_regs</span><span class="p">(</span><span class="n">old_regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">setup_profiling_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multiplier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC start and shutdown</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * clear_local_APIC - shutdown the local APIC</span>
<span class="cm"> *</span>
<span class="cm"> * This is called, when a CPU is disabled and before rebooting, so the state of</span>
<span class="cm"> * the local APIC has no dangling leftovers. Also used to cleanout any BIOS</span>
<span class="cm"> * leftovers during boot.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clear_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxlvt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="cm">/* APIC hasn&#39;t been mapped yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">apic_phys</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Masking an LVT entry can trigger a local APIC error</span>
<span class="cm">	 * if the vector is zero. Mask LVTERR first to prevent this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">ERROR_APIC_VECTOR</span><span class="p">;</span> <span class="cm">/* any non-zero vector will do */</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Careful: we have to set masks only first to deassert</span>
<span class="cm">	 * any level-triggered sources.</span>
<span class="cm">	 */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* lets not touch this if we didn&#39;t frob it */</span>
<span class="cp">#ifdef CONFIG_X86_THERMAL_VECTOR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTTHMR</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTTHMR</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_MCE_INTEL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTCMCI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">APIC_LVT_MASKED</span><span class="p">))</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTCMCI</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean APIC state for other OSs:</span>
<span class="cm">	 */</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>

	<span class="cm">/* Integrated APIC (!82489DX) ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lapic_is_integrated</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="cm">/* Clear ESR due to Pentium errata 3AP and 11AP */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disable_local_APIC - clear and disable the local APIC</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disable_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/* APIC hasn&#39;t been mapped yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">apic_phys</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">clear_local_APIC</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable APIC (implies clearing of registers</span>
<span class="cm">	 * for 82489DX!).</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_SPIV_APIC_ENABLED</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * When LAPIC was disabled by the BIOS and enabled by the kernel,</span>
<span class="cm">	 * restore the disabled state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enabled_via_apicbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>

		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">l</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_IA32_APICBASE_ENABLE</span><span class="p">;</span>
		<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If Linux enabled the LAPIC against the BIOS default disable it down before</span>
<span class="cm"> * re-entering the BIOS on shutdown.  Otherwise the BIOS may get confused and</span>
<span class="cm"> * not power-off.  Additionally clear all LVT entries before disable_local_APIC</span>
<span class="cm"> * for the case where Linux didn&#39;t enable the LAPIC.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lapic_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">apic_from_smp_config</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enabled_via_apicbase</span><span class="p">)</span>
		<span class="n">clear_local_APIC</span><span class="p">();</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">disable_local_APIC</span><span class="p">();</span>


	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is to verify that we&#39;re looking at a real local APIC.</span>
<span class="cm"> * Check these against your board if the CPUs aren&#39;t getting</span>
<span class="cm"> * started for no apparent reason.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">verify_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg0</span><span class="p">,</span> <span class="n">reg1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The version register is read-only in a real APIC.</span>
<span class="cm">	 */</span>
	<span class="n">reg0</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting VERSION: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">,</span> <span class="n">reg0</span> <span class="o">^</span> <span class="n">APIC_LVR_MASK</span><span class="p">);</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting VERSION: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The two version reads above should print the same</span>
<span class="cm">	 * numbers.  If the second one is different, then we</span>
<span class="cm">	 * poke at a non-APIC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg1</span> <span class="o">!=</span> <span class="n">reg0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the version looks reasonably.</span>
<span class="cm">	 */</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">reg0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg1</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">||</span> <span class="n">reg1</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg1</span> <span class="o">&lt;</span> <span class="mh">0x02</span> <span class="o">||</span> <span class="n">reg1</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ID register is read/write in a real APIC.</span>
<span class="cm">	 */</span>
	<span class="n">reg0</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting ID: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">,</span> <span class="n">reg0</span> <span class="o">^</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">apic_id_mask</span><span class="p">);</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting ID: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg1</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg1</span> <span class="o">!=</span> <span class="p">(</span><span class="n">reg0</span> <span class="o">^</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">apic_id_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next two are just to see if we have sane values.</span>
<span class="cm">	 * They&#39;re only really relevant if we&#39;re in Virtual Wire</span>
<span class="cm">	 * compatibility mode, but most boxes are anymore.</span>
<span class="cm">	 */</span>
	<span class="n">reg0</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting LVT0: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg0</span><span class="p">);</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Getting LVT1: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sync_Arb_IDs - synchronize APIC bus arbitration IDs</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sync_Arb_IDs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unsupported on P4 - see Intel Dev. Manual Vol. 3, Ch. 8.6.1 And not</span>
<span class="cm">	 * needed on AMD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modern_apic</span><span class="p">()</span> <span class="o">||</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_AMD</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for idle.</span>
<span class="cm">	 */</span>
	<span class="n">apic_wait_icr_idle</span><span class="p">();</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="s">&quot;Synchronizing Arb IDs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ICR</span><span class="p">,</span> <span class="n">APIC_DEST_ALLINC</span> <span class="o">|</span>
			<span class="n">APIC_INT_LEVELTRIG</span> <span class="o">|</span> <span class="n">APIC_DM_INIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * An initial setup of the virtual wire mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_bsp_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t do the setup now if we have a SMP BIOS as the</span>
<span class="cm">	 * through-I/O-APIC virtual wire mode might be active.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_found_config</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not trust the local APIC being empty at bootup.</span>
<span class="cm">	 */</span>
	<span class="n">clear_local_APIC</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable APIC.</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_SPIV_APIC_ENABLED</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* This bit is reserved on P4/Xeon and should be cleared */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_INTEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">15</span><span class="p">))</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_SPIV_FOCUS_DISABLED</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_SPIV_FOCUS_DISABLED</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">SPURIOUS_APIC_VECTOR</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the virtual wire mode.</span>
<span class="cm">	 */</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_DM_EXTINT</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">APIC_DM_NMI</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lapic_is_integrated</span><span class="p">())</span>		<span class="cm">/* 82489DX */</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_LVT_LEVEL_TRIGGER</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">lapic_setup_esr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldvalue</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">maxlvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lapic_is_integrated</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;No ESR for 82489DX.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">disable_esr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Something untraceable is creating bad interrupts on</span>
<span class="cm">		 * secondary quads ... for the moment, just leave the</span>
<span class="cm">		 * ESR disabled - we can&#39;t do anything useful with the</span>
<span class="cm">		 * errors anyway - mbligh</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Leaving ESR disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>		<span class="cm">/* Due to the Pentium erratum 3AP. */</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">oldvalue</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>

	<span class="cm">/* enables sending errors */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">ERROR_APIC_VECTOR</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * spec says clear errors after enabling vector.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="n">oldvalue</span><span class="p">)</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;ESR value before enabling &quot;</span>
			<span class="s">&quot;vector: 0x%08x  after: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">oldvalue</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * setup_local_APIC - setup the local APIC</span>
<span class="cm"> *</span>
<span class="cm"> * Used to setup local APIC while initializing BSP or bringin up APs.</span>
<span class="cm"> * Always called with preemption disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">setup_local_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">queued</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ntsc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">max_loops</span> <span class="o">=</span> <span class="n">cpu_khz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span>
		<span class="n">rdtscll</span><span class="p">(</span><span class="n">tsc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_ioapic_support</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/* Pound the ESR really hard over the head with a big hammer - mbligh */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lapic_is_integrated</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">disable_esr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">perf_events_lapic_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Double-check whether this APIC is really registered.</span>
<span class="cm">	 * This is meaningless in clustered apic mode, so we skip it.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">apic_id_registered</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Intel recommends to set DFR, LDR and TPR before enabling</span>
<span class="cm">	 * an APIC.  See e.g. &quot;AP-388 82489DX User&#39;s Manual&quot; (Intel</span>
<span class="cm">	 * document number 292116).  So here it goes...</span>
<span class="cm">	 */</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">init_apic_ldr</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * APIC LDR is initialized.  If logical_apicid mapping was</span>
<span class="cm">	 * initialized during get_smp_config(), make sure it matches the</span>
<span class="cm">	 * actual value.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_logical_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">BAD_APICID</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">logical_smp_processor_id</span><span class="p">());</span>
	<span class="cm">/* always use the value from LDR */</span>
	<span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_logical_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">logical_smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some NUMA implementations (NUMAQ) don&#39;t initialize apicid to</span>
<span class="cm">	 * node mapping during NUMA init.  Now that logical apicid is</span>
<span class="cm">	 * guaranteed to be known, give it another chance.  This is already</span>
<span class="cm">	 * a bit too late - percpu allocation has already happened without</span>
<span class="cm">	 * proper NUMA affinity.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">x86_32_numa_cpu_node</span><span class="p">)</span>
		<span class="n">set_apicid_to_node</span><span class="p">(</span><span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span>
				   <span class="n">apic</span><span class="o">-&gt;</span><span class="n">x86_32_numa_cpu_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set Task Priority to &#39;accept all&#39;. We never change this</span>
<span class="cm">	 * later on.</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TASKPRI</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_TPRI_MASK</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TASKPRI</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After a crash, we no longer service the interrupts and a pending</span>
<span class="cm">	 * interrupt from previous kernel might still have ISR bit set.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Most probably by now CPU has serviced that pending interrupt and</span>
<span class="cm">	 * it might not have done the ack_APIC_irq() because it thought,</span>
<span class="cm">	 * interrupt came from i8259 as ExtInt. LAPIC did not get EOI so it</span>
<span class="cm">	 * does not clear the ISR bit and cpu thinks it has already serivced</span>
<span class="cm">	 * the interrupt. Hence a vector might get locked. It was noticed</span>
<span class="cm">	 * for timer irq (vector 0x31). Issue an extra EOI to clear ISR.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">APIC_ISR_NR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">queued</span> <span class="o">|=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_IRR</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x10</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">APIC_ISR_NR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ISR</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x10</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ack_APIC_irq</span><span class="p">();</span>
					<span class="n">acked</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acked</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LAPIC pending interrupts after %d EOI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">acked</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rdtscll</span><span class="p">(</span><span class="n">ntsc</span><span class="p">);</span>
				<span class="n">max_loops</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu_khz</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">ntsc</span> <span class="o">-</span> <span class="n">tsc</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">max_loops</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">queued</span> <span class="o">&amp;&amp;</span> <span class="n">max_loops</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">max_loops</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we are all set up, enable the APIC</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_VECTOR_MASK</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable APIC</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_SPIV_APIC_ENABLED</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some unknown Intel IO/APIC (or APIC) errata is biting us with</span>
<span class="cm">	 * certain networking cards. If high frequency interrupts are</span>
<span class="cm">	 * happening on a particular IOAPIC pin, plus the IOAPIC routing</span>
<span class="cm">	 * entry is masked/unmasked at a high rate as well then sooner or</span>
<span class="cm">	 * later IOAPIC line gets &#39;stuck&#39;, no more interrupts are received</span>
<span class="cm">	 * from the device. If focus CPU is disabled then the hang goes</span>
<span class="cm">	 * away, oh well :-(</span>
<span class="cm">	 *</span>
<span class="cm">	 * [ This bug can be reproduced easily with a level-triggered</span>
<span class="cm">	 *   PCI Ne2000 networking cards and PII/PIII processors, dual</span>
<span class="cm">	 *   BX chipset. ]</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Actually disabling the focus CPU check just makes the hang less</span>
<span class="cm">	 * frequent as it makes the interrupt distributon model be more</span>
<span class="cm">	 * like LRU than MRU (the short-term load is more even across CPUs).</span>
<span class="cm">	 * See also the comment in end_level_ioapic_irq().  --macro</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * - enable focus processor (bit==0)</span>
<span class="cm">	 * - 64bit mode always use processor focus</span>
<span class="cm">	 *   so no need to set it</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_SPIV_FOCUS_DISABLED</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set spurious IRQ vector</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">SPURIOUS_APIC_VECTOR</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up LVT0, LVT1:</span>
<span class="cm">	 *</span>
<span class="cm">	 * set up through-local-APIC on the BP&#39;s LINT0. This is not</span>
<span class="cm">	 * strictly necessary in pure symmetric-IO mode, but sometimes</span>
<span class="cm">	 * we delegate interrupts to the 8259A.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * TODO: set up through-local-APIC from through-I/O-APIC? --macro</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">APIC_LVT_MASKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pic_mode</span> <span class="o">||</span> <span class="o">!</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">APIC_DM_EXTINT</span><span class="p">;</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;enabled ExtINT on CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">APIC_DM_EXTINT</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">;</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;masked ExtINT on CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * only the BP should see the LINT1 NMI signal, obviously.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">APIC_DM_NMI</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">APIC_DM_NMI</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lapic_is_integrated</span><span class="p">())</span>		<span class="cm">/* 82489DX */</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_LVT_LEVEL_TRIGGER</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_MCE_INTEL</span>
	<span class="cm">/* Recheck CMCI information after local APIC is up on CPU #0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">cmci_recheck</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">end_local_APIC_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lapic_setup_esr</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
		<span class="cm">/* Disable the local apic timer */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="p">(</span><span class="n">APIC_LVT_MASKED</span> <span class="o">|</span> <span class="n">LOCAL_TIMER_VECTOR</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">apic_pm_activate</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bsp_end_local_APIC_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">end_local_APIC_setup</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that local APIC setup is completed for BP, configure the fault</span>
<span class="cm">	 * handling for interrupt remapping.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
		<span class="n">irq_remap_enable_fault_handling</span><span class="p">();</span>

<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_X2APIC</span>
<span class="cm">/*</span>
<span class="cm"> * Need to disable xapic and x2apic at the same time and then enable xapic mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__disable_x2apic</span><span class="p">(</span><span class="n">u64</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span>
	       <span class="n">msr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">X2APIC_ENABLE</span> <span class="o">|</span> <span class="n">XAPIC_ENABLE</span><span class="p">));</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">msr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X2APIC_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">disable_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_x2apic</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">X2APIC_ENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">x2apic_id</span> <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_id</span> <span class="o">&gt;=</span> <span class="mi">255</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot disable x2apic, id: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x2apic_id</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Disabling x2apic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">__disable_x2apic</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nox2apic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_cpu_cap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">X86_FEATURE_X2APIC</span><span class="p">);</span>
			<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_X2APIC</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">x2apic_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">x2apic_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">register_lapic_address</span><span class="p">(</span><span class="n">mp_lapic_addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">check_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;x2apic enabled by BIOS, switching to x2apic ops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">x2apic_preenabled</span> <span class="o">=</span> <span class="n">x2apic_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">enable_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">msr</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__disable_x2apic</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msr</span> <span class="o">&amp;</span> <span class="n">X2APIC_ENABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Enabling x2apic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">msr</span> <span class="o">|</span> <span class="n">X2APIC_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_X2APIC */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">enable_IR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_IRQ_REMAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_remapping_supported</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;intr-remapping not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_preenabled</span> <span class="o">&amp;&amp;</span> <span class="n">skip_ioapic_setup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Skipped enabling intr-remap because of skipping &quot;</span>
			<span class="s">&quot;io-apic setup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq_remapping_enable</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">enable_IR_x2apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">x2apic_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hardware_init_ret</span><span class="p">;</span>

	<span class="cm">/* Make sure irq_remap_ops are initialized */</span>
	<span class="n">setup_irq_remapping_ops</span><span class="p">();</span>

	<span class="n">hardware_init_ret</span> <span class="o">=</span> <span class="n">irq_remapping_prepare</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hardware_init_ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">x2apic_supported</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">save_ioapic_entries</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Saving IO-APIC state failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask_all</span><span class="p">();</span>
	<span class="n">mask_ioapic_entries</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_preenabled</span> <span class="o">&amp;&amp;</span> <span class="n">nox2apic</span><span class="p">)</span>
		<span class="n">disable_x2apic</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hardware_init_ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">enable_IR</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_supported</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">skip_x2apic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* IR is required if there is APIC ID &gt; 255 even when running</span>
<span class="cm">		 * under KVM</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_physical_apicid</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">hypervisor_x2apic_available</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_preenabled</span><span class="p">)</span>
				<span class="n">disable_x2apic</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">skip_x2apic</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * without IR all CPUs can be addressed by IOAPIC/MSI</span>
<span class="cm">		 * only in physical mode</span>
<span class="cm">		 */</span>
		<span class="n">x2apic_force_phys</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">IRQ_REMAP_XAPIC_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;x2apic not enabled, IRQ remapping is in xapic mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">skip_x2apic</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">x2apic_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_supported</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">x2apic_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x2apic_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enable_x2apic</span><span class="p">();</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Enabled x2apic</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">skip_x2apic:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* IR enabling failed */</span>
		<span class="n">restore_ioapic_entries</span><span class="p">();</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">restore_mask</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="cm">/*</span>
<span class="cm"> * Detect and enable local APICs on non-SMP boards.</span>
<span class="cm"> * Original code written by Keir Fraser.</span>
<span class="cm"> * On AMD64 we trust the BIOS - if it says no APIC it is likely</span>
<span class="cm"> * not correctly set up (usually the APIC timer won&#39;t work etc.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">detect_init_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;No local APIC present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mp_lapic_addr</span> <span class="o">=</span> <span class="n">APIC_DEFAULT_PHYS_BASE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apic_verify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">features</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The APIC feature bit should now be enabled</span>
<span class="cm">	 * in `cpuid&#39;</span>
<span class="cm">	 */</span>
	<span class="n">features</span> <span class="o">=</span> <span class="n">cpuid_edx</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">X86_FEATURE_APIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not enable APIC!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_cpu_cap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">,</span> <span class="n">X86_FEATURE_APIC</span><span class="p">);</span>
	<span class="n">mp_lapic_addr</span> <span class="o">=</span> <span class="n">APIC_DEFAULT_PHYS_BASE</span><span class="p">;</span>

	<span class="cm">/* The BIOS may have set up the APIC at some other address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span> <span class="n">MSR_IA32_APICBASE_ENABLE</span><span class="p">)</span>
			<span class="n">mp_lapic_addr</span> <span class="o">=</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="n">MSR_IA32_APICBASE_BASE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Found and enabled local APIC!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">apic_force_enable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some BIOSes disable the local APIC in the APIC_BASE</span>
<span class="cm">	 * MSR. This can only be done in software for Intel P6 or later</span>
<span class="cm">	 * and AMD K7 (Model &gt; 1) or later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span> <span class="n">MSR_IA32_APICBASE_ENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Local APIC disabled by BIOS -- reenabling.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">l</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_IA32_APICBASE_BASE</span><span class="p">;</span>
			<span class="n">l</span> <span class="o">|=</span> <span class="n">MSR_IA32_APICBASE_ENABLE</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">enabled_via_apicbase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">apic_verify</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Detect and initialize APIC</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">detect_init_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disabled by kernel option? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_AMD</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_apic</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_INTEL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has_apic</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_apic</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">no_apic</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Over-ride BIOS and try to enable the local APIC only if</span>
<span class="cm">		 * &quot;lapic&quot; specified.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_enable_local_apic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Local APIC disabled by BIOS -- &quot;</span>
				<span class="s">&quot;you can enable it with </span><span class="se">\&quot;</span><span class="s">lapic</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apic_force_enable</span><span class="p">(</span><span class="n">APIC_DEFAULT_PHYS_BASE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apic_verify</span><span class="p">())</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">apic_pm_activate</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_apic:</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;No local APIC present or hardware disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * init_apic_mappings - initialize APIC mappings</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_apic_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_apicid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boot_cpu_physical_apicid</span> <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If no local APIC can be found return early */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp_found_config</span> <span class="o">&amp;&amp;</span> <span class="n">detect_init_APIC</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* lets NOP&#39;ify apic operations */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;APIC: disable apic facility</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">apic_disable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">apic_phys</span> <span class="o">=</span> <span class="n">mp_lapic_addr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * acpi lapic path already maps that address in</span>
<span class="cm">		 * acpi_register_lapic_address()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_lapic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">smp_found_config</span><span class="p">)</span>
			<span class="n">register_lapic_address</span><span class="p">(</span><span class="n">apic_phys</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the APIC ID of the BSP in case we have a</span>
<span class="cm">	 * default configuration (or the MP table is broken).</span>
<span class="cm">	 */</span>
	<span class="n">new_apicid</span> <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_physical_apicid</span> <span class="o">!=</span> <span class="n">new_apicid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boot_cpu_physical_apicid</span> <span class="o">=</span> <span class="n">new_apicid</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * yeah -- we lie about apic_version</span>
<span class="cm">		 * in case if apic was disabled via boot option</span>
<span class="cm">		 * but it&#39;s not a problem for SMP compiled kernel</span>
<span class="cm">		 * since smp_sanity_check is prepared for such a case</span>
<span class="cm">		 * and disable smp mode</span>
<span class="cm">		 */</span>
		<span class="n">apic_version</span><span class="p">[</span><span class="n">new_apicid</span><span class="p">]</span> <span class="o">=</span>
			 <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">register_lapic_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mp_lapic_addr</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_fixmap_nocache</span><span class="p">(</span><span class="n">FIX_APIC_BASE</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;mapped APIC to %16lx (%16lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">APIC_BASE</span><span class="p">,</span> <span class="n">mp_lapic_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_physical_apicid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1U</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boot_cpu_physical_apicid</span>  <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>
		<span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]</span> <span class="o">=</span>
			 <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This initializes the IO-APIC and APIC hardware if this is</span>
<span class="cm"> * a UP kernel.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">apic_version</span><span class="p">[</span><span class="n">MAX_LOCAL_APIC</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">APIC_init_uniprocessor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Apic disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_apic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Apic disabled by BIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp_found_config</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has_apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complain if the BIOS pretends there is one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span> <span class="o">&amp;&amp;</span>
	    <span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;BIOS bug, local APIC 0x%x not detected!...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">boot_cpu_physical_apicid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">default_setup_apic_routing</span><span class="p">();</span>

	<span class="n">verify_local_APIC</span><span class="p">();</span>
	<span class="n">connect_bsp_APIC</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">,</span> <span class="n">SET_APIC_ID</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hack: In case of kdump, after a crash, kernel might be booting</span>
<span class="cm">	 * on a cpu with non-zero lapic id. But boot_cpu_physical_apicid</span>
<span class="cm">	 * might be zero if read from MP tables. Get it from LAPIC.</span>
<span class="cm">	 */</span>
<span class="cp"># ifdef CONFIG_CRASH_DUMP</span>
	<span class="n">boot_cpu_physical_apicid</span> <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
	<span class="n">physid_set_mask_of_physid</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="n">setup_local_APIC</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now enable IO-APICs, actually call clear_IO_APIC</span>
<span class="cm">	 * We need clear_IO_APIC before enabling error vector</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_ioapic_setup</span> <span class="o">&amp;&amp;</span> <span class="n">nr_ioapics</span><span class="p">)</span>
		<span class="n">enable_IO_APIC</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="n">bsp_end_local_APIC_setup</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smp_found_config</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_ioapic_setup</span> <span class="o">&amp;&amp;</span> <span class="n">nr_ioapics</span><span class="p">)</span>
		<span class="n">setup_IO_APIC</span><span class="p">();</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">nr_ioapics</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">x86_init</span><span class="p">.</span><span class="n">timers</span><span class="p">.</span><span class="n">setup_percpu_clockev</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local APIC interrupts</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This interrupt should _never_ happen with our APIC/SMP architecture</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_spurious_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">exit_idle</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if this really is a spurious interrupt and ACK it</span>
<span class="cm">	 * if it is a vectored one.  Just in case...</span>
<span class="cm">	 * Spurious interrupts should not be ACKed.</span>
<span class="cm">	 */</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ISR</span> <span class="o">+</span> <span class="p">((</span><span class="n">SPURIOUS_APIC_VECTOR</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1f</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">SPURIOUS_APIC_VECTOR</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)))</span>
		<span class="n">ack_APIC_irq</span><span class="p">();</span>

	<span class="n">inc_irq_stat</span><span class="p">(</span><span class="n">irq_spurious_count</span><span class="p">);</span>

	<span class="cm">/* see sw-dev-man vol 3, chapter 7.4.13.5 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;spurious APIC interrupt on CPU#%d, &quot;</span>
		<span class="s">&quot;should never happen.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This interrupt should never happen with our APIC/SMP architecture</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">smp_error_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">error_interrupt_reason</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Send CS error&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 0 */</span>
		<span class="s">&quot;Receive CS error&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 1 */</span>
		<span class="s">&quot;Send accept error&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 2 */</span>
		<span class="s">&quot;Receive accept error&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 3 */</span>
		<span class="s">&quot;Redirectable IPI&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 4 */</span>
		<span class="s">&quot;Send illegal vector&quot;</span><span class="p">,</span>		<span class="cm">/* APIC Error Bit 5 */</span>
		<span class="s">&quot;Received illegal vector&quot;</span><span class="p">,</span>	<span class="cm">/* APIC Error Bit 6 */</span>
		<span class="s">&quot;Illegal register address&quot;</span><span class="p">,</span>	<span class="cm">/* APIC Error Bit 7 */</span>
	<span class="p">};</span>

	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">exit_idle</span><span class="p">();</span>
	<span class="cm">/* First tickle the hardware, only then report what went on. -- REW */</span>
	<span class="n">v0</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">v1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_err_count</span><span class="p">);</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;APIC error on CPU%d: %02x(%02x)&quot;</span><span class="p">,</span>
		    <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">v0</span> <span class="p">,</span> <span class="n">v1</span><span class="p">);</span>

	<span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="n">KERN_CONT</span> <span class="s">&quot; : %s&quot;</span><span class="p">,</span> <span class="n">error_interrupt_reason</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">v1</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span> <span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * connect_bsp_APIC - attach the APIC to the interrupt system</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">connect_bsp_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pic_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not trust the local APIC being empty at bootup.</span>
<span class="cm">		 */</span>
		<span class="n">clear_local_APIC</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * PIC mode, enable APIC mode in the IMCR, i.e.  connect BSP&#39;s</span>
<span class="cm">		 * local APIC to INT and NMI lines.</span>
<span class="cm">		 */</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;leaving PIC mode, &quot;</span>
				<span class="s">&quot;enabling APIC mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">imcr_pic_to_apic</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">enable_apic_mode</span><span class="p">)</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">enable_apic_mode</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disconnect_bsp_APIC - detach the APIC from the interrupt system</span>
<span class="cm"> * @virt_wire_setup:	indicates, whether virtual wire mode is selected</span>
<span class="cm"> *</span>
<span class="cm"> * Virtual wire mode is necessary to deliver legacy interrupts even when the</span>
<span class="cm"> * APIC is disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disconnect_bsp_APIC</span><span class="p">(</span><span class="kt">int</span> <span class="n">virt_wire_setup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pic_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Put the board back into PIC mode (has an effect only on</span>
<span class="cm">		 * certain older boards).  Note that APIC interrupts, including</span>
<span class="cm">		 * IPIs, won&#39;t work beyond this point!  The only exception are</span>
<span class="cm">		 * INIT IPIs.</span>
<span class="cm">		 */</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;disabling APIC mode, &quot;</span>
				<span class="s">&quot;entering PIC mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">imcr_apic_to_pic</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Go back to Virtual Wire compatibility mode */</span>

	<span class="cm">/* For the spurious interrupt use vector F, and enable it */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APIC_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_SPIV_APIC_ENABLED</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virt_wire_setup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For LVT0 make it edge triggered, active high,</span>
<span class="cm">		 * external and enabled</span>
<span class="cm">		 */</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">APIC_MODE_MASK</span> <span class="o">|</span> <span class="n">APIC_SEND_PENDING</span> <span class="o">|</span>
			<span class="n">APIC_INPUT_POLARITY</span> <span class="o">|</span> <span class="n">APIC_LVT_REMOTE_IRR</span> <span class="o">|</span>
			<span class="n">APIC_LVT_LEVEL_TRIGGER</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_LVT_REMOTE_IRR</span> <span class="o">|</span> <span class="n">APIC_SEND_PENDING</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">SET_APIC_DELIVERY_MODE</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">APIC_MODE_EXTINT</span><span class="p">);</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Disable LVT0 */</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For LVT1 make it edge triggered, active high,</span>
<span class="cm">	 * nmi and enabled</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">APIC_MODE_MASK</span> <span class="o">|</span> <span class="n">APIC_SEND_PENDING</span> <span class="o">|</span>
			<span class="n">APIC_INPUT_POLARITY</span> <span class="o">|</span> <span class="n">APIC_LVT_REMOTE_IRR</span> <span class="o">|</span>
			<span class="n">APIC_LVT_LEVEL_TRIGGER</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">|=</span> <span class="n">APIC_LVT_REMOTE_IRR</span> <span class="o">|</span> <span class="n">APIC_SEND_PENDING</span><span class="p">;</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">SET_APIC_DELIVERY_MODE</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">APIC_MODE_NMI</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">generic_processor_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">apicid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">boot_cpu_detected</span> <span class="o">=</span> <span class="n">physid_isset</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">,</span>
				<span class="n">phys_cpu_present_map</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If boot cpu has not been detected yet, then only allow upto</span>
<span class="cm">	 * nr_cpu_ids - 1 processors and keep one slot free for boot cpu</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_detected</span> <span class="o">&amp;&amp;</span> <span class="n">num_processors</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">apicid</span> <span class="o">!=</span> <span class="n">boot_cpu_physical_apicid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">thiscpu</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="n">disabled_cpus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">pr_warning</span><span class="p">(</span>
			<span class="s">&quot;ACPI: NR_CPUS/possible_cpus limit of %i almost&quot;</span>
			<span class="s">&quot; reached. Keeping one slot for boot cpu.&quot;</span>
			<span class="s">&quot;  Processor %d/0x%x ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">thiscpu</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>

		<span class="n">disabled_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_processors</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">thiscpu</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="n">disabled_cpus</span><span class="p">;</span>

		<span class="n">pr_warning</span><span class="p">(</span>
			<span class="s">&quot;ACPI: NR_CPUS/possible_cpus limit of %i reached.&quot;</span>
			<span class="s">&quot;  Processor %d/0x%x ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">thiscpu</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>

		<span class="n">disabled_cpus</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_processors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">==</span> <span class="n">boot_cpu_physical_apicid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * x86_bios_cpu_apicid is required to have processors listed</span>
<span class="cm">		 * in same order as logical cpu numbers. Hence the first</span>
<span class="cm">		 * entry is BSP, and so on.</span>
<span class="cm">		 * boot_cpu_init() already hold bit 0 in cpu_present_mask</span>
<span class="cm">		 * for BSP.</span>
<span class="cm">		 */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_next_zero</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cpu_present_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate version</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;BIOS bug: APIC version is 0 for CPU %d/0x%x, fixing up to 0x10</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">cpu</span><span class="p">,</span> <span class="n">apicid</span><span class="p">);</span>
		<span class="n">version</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apic_version</span><span class="p">[</span><span class="n">apicid</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">!=</span> <span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">],</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">physid_set</span><span class="p">(</span><span class="n">apicid</span><span class="p">,</span> <span class="n">phys_cpu_present_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apicid</span> <span class="o">&gt;</span> <span class="n">max_physical_apicid</span><span class="p">)</span>
		<span class="n">max_physical_apicid</span> <span class="o">=</span> <span class="n">apicid</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SMP) || defined(CONFIG_X86_64)</span>
	<span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">apicid</span><span class="p">;</span>
	<span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_bios_cpu_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">apicid</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">early_per_cpu</span><span class="p">(</span><span class="n">x86_cpu_to_logical_apicid</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">x86_32_early_logical_apicid</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hard_smp_processor_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_apic_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">default_init_apic_ldr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_DFR</span><span class="p">,</span> <span class="n">APIC_DFR_VALUE</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LDR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">APIC_LDR_MASK</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">SET_APIC_LOGICAL_ID</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LDR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power management</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;active&#39; is true if the local APIC was enabled by us and</span>
<span class="cm">	 * not the BIOS; this signifies that we are also responsible</span>
<span class="cm">	 * for disabling it before entering apm/acpi suspend</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">;</span>
	<span class="cm">/* r/w apic fields */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_taskpri</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_ldr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_dfr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_spiv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_lvtt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_lvtpc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_lvt0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_lvt1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_lvterr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_tmict</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_tdcr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic_thmr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">apic_pm_state</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lapic_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxlvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic_pm_state</span><span class="p">.</span><span class="n">active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>

	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_id</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_taskpri</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TASKPRI</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_ldr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LDR</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_dfr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_DFR</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_spiv</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvtt</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvtpc</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvt0</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvt1</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvterr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_tmict</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">);</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_tdcr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TDCR</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_THERMAL_VECTOR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_thmr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTTHMR</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">disable_local_APIC</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
		<span class="n">irq_remapping_disable</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxlvt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic_pm_state</span><span class="p">.</span><span class="n">active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * IO-APIC and PIC have their own resume routines.</span>
<span class="cm">		 * We just mask them here to make sure the interrupt</span>
<span class="cm">		 * subsystem is completely quiet while we enable x2apic</span>
<span class="cm">		 * and interrupt-remapping.</span>
<span class="cm">		 */</span>
		<span class="n">mask_ioapic_entries</span><span class="p">();</span>
		<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask_all</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_mode</span><span class="p">)</span>
		<span class="n">enable_x2apic</span><span class="p">();</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure the APICBASE points to the right address</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME! This will be wrong if we ever support suspend on</span>
<span class="cm">		 * SMP! We&#39;ll need to do this as part of the CPU restore!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">l</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSR_IA32_APICBASE_BASE</span><span class="p">;</span>
			<span class="n">l</span> <span class="o">|=</span> <span class="n">MSR_IA32_APICBASE_ENABLE</span> <span class="o">|</span> <span class="n">mp_lapic_addr</span><span class="p">;</span>
			<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_APICBASE</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">,</span> <span class="n">ERROR_APIC_VECTOR</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_id</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_DFR</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_dfr</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LDR</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_ldr</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TASKPRI</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_taskpri</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_spiv</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvt0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvt1</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_X86_MCE_P4THERMAL) || defined(CONFIG_X86_MCE_INTEL)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTTHMR</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_thmr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvtpc</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvtt</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TDCR</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_tdcr</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_tmict</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">,</span> <span class="n">apic_pm_state</span><span class="p">.</span><span class="n">apic_lvterr</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
		<span class="n">irq_remapping_reenable</span><span class="p">(</span><span class="n">x2apic_mode</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This device has no shutdown method - fully functioning local APICs</span>
<span class="cm"> * are needed on every CPU up until machine_halt/restart/poweroff.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">lapic_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">lapic_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">lapic_suspend</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">apic_pm_activate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apic_pm_state</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_lapic_sysfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX: remove suspend/resume procs if !apic_pm_state.active? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_apic</span><span class="p">)</span>
		<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lapic_syscore_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* local apic needs to resume before other devices access its registers. */</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">init_lapic_sysfs</span><span class="p">);</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apic_pm_activate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_X86_64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">apic_cluster_num</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">zeros</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">bios_cpu_apicid</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">clustermap</span><span class="p">,</span> <span class="n">NUM_APIC_CLUSTERS</span><span class="p">);</span>

	<span class="n">bios_cpu_apicid</span> <span class="o">=</span> <span class="n">early_per_cpu_ptr</span><span class="p">(</span><span class="n">x86_bios_cpu_apicid</span><span class="p">);</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">clustermap</span><span class="p">,</span> <span class="n">NUM_APIC_CLUSTERS</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* are we being called early in kernel startup? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bios_cpu_apicid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">bios_cpu_apicid</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_present</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
				<span class="n">id</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">x86_bios_cpu_apicid</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="n">BAD_APICID</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">APIC_CLUSTERID</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">clustermap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Problem:  Partially populated chassis may not have CPUs in some of</span>
<span class="cm">	 * the APIC clusters they have been allocated.  Only present CPUs have</span>
<span class="cm">	 * x86_bios_cpu_apicid entries, thus causing zeroes in the bitmap.</span>
<span class="cm">	 * Since clusters are allocated sequentially, count zeros only if</span>
<span class="cm">	 * they are bounded by ones.</span>
<span class="cm">	 */</span>
	<span class="n">clusters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">zeros</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_APIC_CLUSTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">clustermap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clusters</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">zeros</span><span class="p">;</span>
			<span class="n">zeros</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">++</span><span class="n">zeros</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">clusters</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinitdata</span> <span class="n">multi_checked</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinitdata</span> <span class="n">multi</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">set_multi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">multi</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;APIC: %s detected, Multi Chassis</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="n">multi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">__cpuinitconst</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">multi_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">set_multi</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="s">&quot;IBM System Summit2&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;IBM&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Summit2&quot;</span><span class="p">),</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">dmi_check_multi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">multi_checked</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dmi_check_system</span><span class="p">(</span><span class="n">multi_dmi_table</span><span class="p">);</span>
	<span class="n">multi_checked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * apic_is_clustered_box() -- Check if we can expect good TSC</span>
<span class="cm"> *</span>
<span class="cm"> * Thus far, the major user of this is IBM&#39;s Summit2 series:</span>
<span class="cm"> * Clustered boxes may have unsynced TSC problems if they are</span>
<span class="cm"> * multi-chassis.</span>
<span class="cm"> * Use DMI to check them</span>
<span class="cm"> */</span>
<span class="n">__cpuinit</span> <span class="kt">int</span> <span class="nf">apic_is_clustered_box</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dmi_check_multi</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">multi</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vsmp_box</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ScaleMP vSMPowered boxes have one cluster per board and TSCs are</span>
<span class="cm">	 * not guaranteed to be synced between boards</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic_cluster_num</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * APIC command line parameters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_disableapic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_apic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_APIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;disableapic&quot;</span><span class="p">,</span> <span class="n">setup_disableapic</span><span class="p">);</span>

<span class="cm">/* same as disableapic, for compatibility */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_nolapic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">setup_disableapic</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nolapic&quot;</span><span class="p">,</span> <span class="n">setup_nolapic</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_lapic_timer_c2_ok</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_apic_timer_c2_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;lapic_timer_c2_ok&quot;</span><span class="p">,</span> <span class="n">parse_lapic_timer_c2_ok</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_disable_apic_timer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_apic_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;noapictimer&quot;</span><span class="p">,</span> <span class="n">parse_disable_apic_timer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_nolapic_timer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_apic_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;nolapic_timer&quot;</span><span class="p">,</span> <span class="n">parse_nolapic_timer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apic_set_verbosity</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>  <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="n">skip_ioapic_setup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">apic_verbosity</span> <span class="o">=</span> <span class="n">APIC_DEBUG</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;verbose&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">apic_verbosity</span> <span class="o">=</span> <span class="n">APIC_VERBOSE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;APIC Verbosity level %s not recognised&quot;</span>
			<span class="s">&quot; use apic=verbose or apic=debug</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;apic&quot;</span><span class="p">,</span> <span class="n">apic_set_verbosity</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lapic_insert_resource</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic_phys</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Put local APIC into the resource map. */</span>
	<span class="n">lapic_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">apic_phys</span><span class="p">;</span>
	<span class="n">lapic_resource</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">lapic_resource</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_resource</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * need call insert after e820_reserve_resources()</span>
<span class="cm"> * that is using request_resource</span>
<span class="cm"> */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">lapic_insert_resource</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
