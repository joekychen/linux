<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › apic › io_apic.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>io_apic.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Intel IO-APIC support for multi-Pentium hosts.</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1997, 1998, 1999, 2000, 2009 Ingo Molnar, Hajnalka Szabo</span>
<span class="cm"> *</span>
<span class="cm"> *	Many thanks to Stig Venaas for trying out countless experimental</span>
<span class="cm"> *	patches and reporting/debugging problems patiently!</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) 1999, Multiple IO-APIC support, developed by</span>
<span class="cm"> *	Ken-ichi Yaku &lt;yaku@css1.kbnes.nec.co.jp&gt; and</span>
<span class="cm"> *      Hidemi Kishimoto &lt;kisimoto@css1.kbnes.nec.co.jp&gt;,</span>
<span class="cm"> *	further tested and cleaned up by Zach Brown &lt;zab@redhat.com&gt;</span>
<span class="cm"> *	and Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes</span>
<span class="cm"> *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs;</span>
<span class="cm"> *					thanks to Eric Gilmore</span>
<span class="cm"> *					and Rolf G. Tews</span>
<span class="cm"> *					for testing these extensively</span>
<span class="cm"> *	Paul Diefenbaugh	:	Added full ACPI support</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mc146818rtc.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/msi.h&gt;</span>
<span class="cp">#include &lt;linux/htirq.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;	</span><span class="cm">/* time_after() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="cp">#include &lt;acpi/acpi_bus.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/dmar.h&gt;</span>
<span class="cp">#include &lt;linux/hpet.h&gt;</span>

<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/acpi.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>
<span class="cp">#include &lt;asm/i8259.h&gt;</span>
<span class="cp">#include &lt;asm/msidef.h&gt;</span>
<span class="cp">#include &lt;asm/hypertransport.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/irq_remapping.h&gt;</span>
<span class="cp">#include &lt;asm/hpet.h&gt;</span>
<span class="cp">#include &lt;asm/hw_irq.h&gt;</span>

<span class="cp">#include &lt;asm/apic.h&gt;</span>

<span class="cp">#define __apicdebuginit(type) static type __init</span>

<span class="cp">#define for_each_irq_pin(entry, head) \</span>
<span class="cp">	for (entry = head; entry; entry = entry-&gt;next)</span>

<span class="cp">#ifdef CONFIG_IRQ_REMAP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_remapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_iommu</span><span class="p">.</span><span class="n">iommu</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_remapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *      Is the SiS APIC rmw bug present ?</span>
<span class="cm"> *      -1 = don&#39;t know, 0 = no, 1 = yes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sis_apic_bug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">ioapic_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">vector_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioapic</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * # of IRQ routing registers</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">nr_registers</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Saved state during suspend/resume, or while enabling intr-remap.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="o">*</span><span class="n">saved_registers</span><span class="p">;</span>
	<span class="cm">/* I/O APIC config */</span>
	<span class="k">struct</span> <span class="n">mpc_ioapic</span> <span class="n">mp_config</span><span class="p">;</span>
	<span class="cm">/* IO APIC gsi routing info */</span>
	<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span>  <span class="n">gsi_config</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">pin_programmed</span><span class="p">,</span> <span class="n">MP_MAX_IOAPIC_PIN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">MAX_IO_APICS</span><span class="p">];</span>

<span class="cp">#define mpc_ioapic_ver(ioapic_idx)	ioapics[ioapic_idx].mp_config.apicver</span>

<span class="kt">int</span> <span class="nf">mpc_ioapic_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mpc_ioapic_addr</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span> <span class="o">*</span><span class="nf">mp_ioapic_gsi_routing</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">gsi_config</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">nr_ioapics</span><span class="p">;</span>

<span class="cm">/* The one past the highest gsi number used */</span>
<span class="n">u32</span> <span class="n">gsi_top</span><span class="p">;</span>

<span class="cm">/* MP IRQ source entries */</span>
<span class="k">struct</span> <span class="n">mpc_intsrc</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">MAX_IRQ_SOURCES</span><span class="p">];</span>

<span class="cm">/* # of MP IRQ source entries */</span>
<span class="kt">int</span> <span class="n">mp_irq_entries</span><span class="p">;</span>

<span class="cm">/* GSI interrupts */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nr_irqs_gsi</span> <span class="o">=</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EISA</span>
<span class="kt">int</span> <span class="n">mp_bus_id_to_type</span><span class="p">[</span><span class="n">MAX_MP_BUSSES</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">mp_bus_not_pci</span><span class="p">,</span> <span class="n">MAX_MP_BUSSES</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">skip_ioapic_setup</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * disable_ioapic_support() - disables ioapic support at runtime</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disable_ioapic_support</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">noioapicquirk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">noioapicreroute</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">skip_ioapic_setup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_noapic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* disable IO-APIC */</span>
	<span class="n">disable_ioapic_support</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;noapic&quot;</span><span class="p">,</span> <span class="n">parse_noapic</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">io_apic_setup_irq_pin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="cm">/* Will be called in mpparse/acpi/sfi codes for saving IRQ info */</span>
<span class="kt">void</span> <span class="nf">mp_save_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">mpc_intsrc</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;Int: type %d, pol %d, trig %d, bus %02x,&quot;</span>
		<span class="s">&quot; IRQ %02x, APIC ID %x, APIC INT %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">irqtype</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">irqflag</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">irqflag</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">srcbus</span><span class="p">,</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">srcbusirq</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dstapic</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dstirq</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">mp_irq_entries</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">mp_irq_entries</span> <span class="o">==</span> <span class="n">MAX_IRQ_SOURCES</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Max # of irq sources exceeded!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="nf">alloc_irq_pin_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_pin_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* irq_cfg is indexed by the sum of all RTEs in all I/O APICs. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="n">irq_cfgx</span><span class="p">[</span><span class="n">NR_IRQS_LEGACY</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">arch_early_irq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="n">io_apic_irqs</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioapics</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">saved_registers</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">IO_APIC_route_entry</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">ioapics</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioapics</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;IOAPIC %d: suspend/resume impossible!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_cfgx</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">irq_cfgx</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Make sure the legacy interrupts are marked in the bitmap */</span>
	<span class="n">irq_reserve_irqs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">domain</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * For legacy IRQ&#39;s, start with assigning irq0 to irq15 to</span>
<span class="cm">		 * IRQ0_VECTOR to IRQ15_VECTOR on cpu 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span> <span class="o">=</span> <span class="n">IRQ0_VECTOR</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">domain</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="nf">irq_cfg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="nf">alloc_irq_cfg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cfg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cfg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_domain</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cfg</span><span class="p">;</span>
<span class="nl">out_domain:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
<span class="nl">out_cfg:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_irq_cfg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">at</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="nf">alloc_irq_and_cfg_at</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">at</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">irq_alloc_desc_at</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">at</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">alloc_irq_cfg</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
		<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">irq_free_desc</span><span class="p">(</span><span class="n">at</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cfg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_irq_from</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_alloc_desc_from</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_irq_at</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">at</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_irq_cfg</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="n">irq_free_desc</span><span class="p">(</span><span class="n">at</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">io_apic</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unused2</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eoi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__attribute_const__</span> <span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">io_apic_base</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_IO_APIC_BASE_0</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">mpc_ioapic_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">io_apic_eoi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_apic</span> <span class="o">=</span> <span class="n">io_apic_base</span><span class="p">(</span><span class="n">apic</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">eoi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">native_io_apic_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_apic</span> <span class="o">=</span> <span class="n">io_apic_base</span><span class="p">(</span><span class="n">apic</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_io_apic_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_apic</span> <span class="o">=</span> <span class="n">io_apic_base</span><span class="p">(</span><span class="n">apic</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Re-write a value: to be used for read-modify-write</span>
<span class="cm"> * cycles where the read already set up the index register.</span>
<span class="cm"> *</span>
<span class="cm"> * Older SiS APIC requires we rewrite the index register</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">native_io_apic_modify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_apic</span> <span class="o">=</span> <span class="n">io_apic_base</span><span class="p">(</span><span class="n">apic</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sis_apic_bug</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">union</span> <span class="n">entry_union</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="n">u32</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="nf">__ioapic_read_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">entry_union</span> <span class="n">eu</span><span class="p">;</span>

	<span class="n">eu</span><span class="p">.</span><span class="n">w1</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pin</span><span class="p">);</span>
	<span class="n">eu</span><span class="p">.</span><span class="n">w2</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x11</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pin</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eu</span><span class="p">.</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="nf">ioapic_read_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">entry_union</span> <span class="n">eu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">eu</span><span class="p">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">__ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eu</span><span class="p">.</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we write a new IO APIC routing entry, we need to write the high</span>
<span class="cm"> * word first! If the mask bit in the low word is clear, we will enable</span>
<span class="cm"> * the interrupt, and we need to make sure the entry is fully populated</span>
<span class="cm"> * before that happens.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ioapic_write_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">entry_union</span> <span class="n">eu</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>

	<span class="n">eu</span><span class="p">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">io_apic_write</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x11</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pin</span><span class="p">,</span> <span class="n">eu</span><span class="p">.</span><span class="n">w2</span><span class="p">);</span>
	<span class="n">io_apic_write</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pin</span><span class="p">,</span> <span class="n">eu</span><span class="p">.</span><span class="n">w1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioapic_write_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we mask an IO APIC routing entry, we need to write the low</span>
<span class="cm"> * word first, in order to set the mask bit before we change the</span>
<span class="cm"> * high bits!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioapic_mask_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">entry_union</span> <span class="n">eu</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">entry</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_apic_write</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pin</span><span class="p">,</span> <span class="n">eu</span><span class="p">.</span><span class="n">w1</span><span class="p">);</span>
	<span class="n">io_apic_write</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x11</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pin</span><span class="p">,</span> <span class="n">eu</span><span class="p">.</span><span class="n">w2</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The common case is 1:1 IRQ&lt;-&gt;pin mappings. Sometimes there are</span>
<span class="cm"> * shared ISA-space IRQs, so we have to support them. We are super</span>
<span class="cm"> * fast in the common case, and fast for shared ISA-space IRQs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_pin_to_irq_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">**</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* don&#39;t allow duplicates */</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">;</span>
	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span> <span class="o">==</span> <span class="n">apic</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span> <span class="o">==</span> <span class="n">pin</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">alloc_irq_pin_list</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can not alloc irq_pin_list (%d,%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">node</span><span class="p">,</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span> <span class="o">=</span> <span class="n">apic</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>

	<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_pin_to_irq_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__add_pin_to_irq_node</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;IO-APIC: failed to add irq-pin. Can not proceed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reroute an IRQ to a different pin.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">replace_pin_at_irq_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">oldapic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oldpin</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">newapic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newpin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span> <span class="o">==</span> <span class="n">oldapic</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span> <span class="o">==</span> <span class="n">oldpin</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span> <span class="o">=</span> <span class="n">newapic</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span> <span class="o">=</span> <span class="n">newpin</span><span class="p">;</span>
			<span class="cm">/* every one is different, right? */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* old apic/pin didn&#39;t exist, so just add new ones */</span>
	<span class="n">add_pin_to_irq_node</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">newapic</span><span class="p">,</span> <span class="n">newpin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__io_apic_modify_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">mask_and</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask_or</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">final</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>

	<span class="n">pin</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pin</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="n">mask_and</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="n">mask_or</span><span class="p">;</span>
	<span class="n">io_apic_modify</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pin</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">final</span><span class="p">)</span>
		<span class="n">final</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">io_apic_modify_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">mask_and</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask_or</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">final</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span>
		<span class="n">__io_apic_modify_irq</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">mask_and</span><span class="p">,</span> <span class="n">mask_or</span><span class="p">,</span> <span class="n">final</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">io_apic_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Synchronize the IO-APIC and the CPU by doing</span>
<span class="cm">	 * a dummy read from the IO-APIC</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">io_apic</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">io_apic</span><span class="p">;</span>

	<span class="n">io_apic</span> <span class="o">=</span> <span class="n">io_apic_base</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_apic</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">io_apic_modify_irq</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">IO_APIC_REDIR_MASKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_apic_sync</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_ioapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mask_ioapic</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unmask_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">io_apic_modify_irq</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="o">~</span><span class="n">IO_APIC_REDIR_MASKED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmask_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__unmask_ioapic</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmask_ioapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unmask_ioapic</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IO-APIC versions below 0x20 don&#39;t support EOI register.</span>
<span class="cm"> * For the record, here is the information about various versions:</span>
<span class="cm"> *     0Xh     82489DX</span>
<span class="cm"> *     1Xh     I/OAPIC or I/O(x)APIC which are not PCI 2.2 Compliant</span>
<span class="cm"> *     2Xh     I/O(x)APIC which is PCI 2.2 Compliant</span>
<span class="cm"> *     30h-FFh Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * Some of the Intel ICH Specs (ICH2 to ICH5) documents the io-apic</span>
<span class="cm"> * version as 0x2. This is an error with documentation and these ICH chips</span>
<span class="cm"> * use io-apic&#39;s of version 0x20.</span>
<span class="cm"> *</span>
<span class="cm"> * For IO-APIC&#39;s with EOI register, we use that to do an explicit EOI.</span>
<span class="cm"> * Otherwise, we simulate the EOI message manually by changing the trigger</span>
<span class="cm"> * mode to edge and then back to level, with RTE being masked during this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__eoi_ioapic_pin</span><span class="p">(</span><span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpc_ioapic_ver</span><span class="p">(</span><span class="n">apic</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Intr-remapping uses pin number as the virtual vector</span>
<span class="cm">		 * in the RTE. Actual vector is programmed in</span>
<span class="cm">		 * intr-remapping table entry. Hence for the io-apic</span>
<span class="cm">		 * EOI we use the pin number.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;&amp;</span> <span class="n">irq_remapped</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>
			<span class="n">io_apic_eoi</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">io_apic_eoi</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">,</span> <span class="n">entry1</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">entry1</span> <span class="o">=</span> <span class="n">__ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mask the entry and change the trigger mode to edge.</span>
<span class="cm">		 */</span>
		<span class="n">entry1</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">entry1</span><span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">IOAPIC_EDGE</span><span class="p">;</span>

		<span class="n">__ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Restore the previous level triggered entry.</span>
<span class="cm">		 */</span>
		<span class="n">__ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">eoi_ioapic_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span>
		<span class="n">__eoi_ioapic_pin</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_IO_APIC_pin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* Check delivery_mode to be sure we&#39;re not clearing an SMI pin */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">delivery_mode</span> <span class="o">==</span> <span class="n">dest_SMI</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the entry is masked and re-read the contents to check</span>
<span class="cm">	 * if it is a level triggered pin and if the remote-IRR is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">irr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure the trigger mode is set to level. Explicit EOI</span>
<span class="cm">		 * doesn&#39;t clear the remote-IRR if the trigger mode is not</span>
<span class="cm">		 * set to level.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">trigger</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span><span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">IOAPIC_LEVEL</span><span class="p">;</span>
			<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">__eoi_ioapic_pin</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">vector</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the rest of the bits in the IO-APIC RTE except for the mask</span>
<span class="cm">	 * bit.</span>
<span class="cm">	 */</span>
	<span class="n">ioapic_mask_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">irr</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to reset IRR for apic: %d, pin :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">apic</span><span class="p">),</span> <span class="n">pin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_IO_APIC</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span>
			<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/*</span>
<span class="cm"> * support for broken MP BIOSs, enables hand-redirection of PIRQ0-7 to</span>
<span class="cm"> * specific CPU-side IRQs.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_PIRQS 8</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pirq_entries</span><span class="p">[</span><span class="n">MAX_PIRQS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">MAX_PIRQS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ioapic_pirq_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="n">MAX_PIRQS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">ints</span><span class="p">);</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			<span class="s">&quot;PIRQ redirection, working around broken MP-BIOS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">MAX_PIRQS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MAX_PIRQS</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_DEBUG</span>
				<span class="s">&quot;... PIRQ%d -&gt; IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * PIRQs are mapped upside down, usually.</span>
<span class="cm">		 */</span>
		<span class="n">pirq_entries</span><span class="p">[</span><span class="n">MAX_PIRQS</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;pirq=&quot;</span><span class="p">,</span> <span class="n">ioapic_pirq_setup</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Saves all the IO-APIC RTE&#39;s</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">save_ioapic_entries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">[</span><span class="n">pin</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mask all IO APIC entries.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mask_ioapic_entries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">[</span><span class="n">pin</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restore IO APIC entries which was saved in the ioapic structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">restore_ioapic_entries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span>
					   <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">saved_registers</span><span class="p">[</span><span class="n">pin</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the IRQ entry number of a certain pin.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_irq_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irqtype</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span> <span class="o">==</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span> <span class="o">==</span> <span class="n">MP_APIC_ALL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstirq</span> <span class="o">==</span> <span class="n">pin</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the pin to which IRQ[irq] (ISA) is connected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_isa_irq_pin</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lbus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">lbus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irqtype</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbusirq</span> <span class="o">==</span> <span class="n">irq</span><span class="p">))</span>

			<span class="k">return</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstirq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_isa_irq_apic</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lbus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">lbus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irqtype</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbusirq</span> <span class="o">==</span> <span class="n">irq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ioapic_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_EISA</span>
<span class="cm">/*</span>
<span class="cm"> * EISA Edge/Level control register, ELCR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">EISA_ELCR</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mh">0x4d0</span> <span class="o">+</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			<span class="s">&quot;Broken MPtable reports ISA irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/* ISA interrupts are always polarity zero edge triggered,</span>
<span class="cm"> * when listed as conforming in the MP table. */</span>

<span class="cp">#define default_ISA_trigger(idx)	(0)</span>
<span class="cp">#define default_ISA_polarity(idx)	(0)</span>

<span class="cm">/* EISA interrupts are always polarity zero and can be edge or level</span>
<span class="cm"> * trigger depending on the ELCR value.  If an interrupt is listed as</span>
<span class="cm"> * EISA conforming in the MP table, that means its trigger type must</span>
<span class="cm"> * be read in from the ELCR */</span>

<span class="cp">#define default_EISA_trigger(idx)	(EISA_ELCR(mp_irqs[idx].srcbusirq))</span>
<span class="cp">#define default_EISA_polarity(idx)	default_ISA_polarity(idx)</span>

<span class="cm">/* PCI interrupts are always polarity one level triggered,</span>
<span class="cm"> * when listed as conforming in the MP table. */</span>

<span class="cp">#define default_PCI_trigger(idx)	(1)</span>
<span class="cp">#define default_PCI_polarity(idx)	(1)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq_polarity</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">polarity</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine IRQ line polarity (high active or low active):</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">irqflag</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* conforms, ie. bus-type dependent polarity */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">))</span>
				<span class="n">polarity</span> <span class="o">=</span> <span class="n">default_ISA_polarity</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">polarity</span> <span class="o">=</span> <span class="n">default_PCI_polarity</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* high active */</span>
		<span class="p">{</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* reserved */</span>
		<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;broken BIOS!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* low active */</span>
		<span class="p">{</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span> <span class="cm">/* invalid */</span>
		<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;broken BIOS!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">polarity</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq_trigger</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trigger</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine IRQ trigger mode (edge or level sensitive):</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">irqflag</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* conforms, ie. bus-type dependent */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">))</span>
				<span class="n">trigger</span> <span class="o">=</span> <span class="n">default_ISA_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">trigger</span> <span class="o">=</span> <span class="n">default_PCI_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_EISA</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">mp_bus_id_to_type</span><span class="p">[</span><span class="n">bus</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">MP_BUS_ISA</span>: <span class="cm">/* ISA pin */</span>
				<span class="p">{</span>
					<span class="cm">/* set before the switch */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">case</span> <span class="n">MP_BUS_EISA</span>: <span class="cm">/* EISA pin */</span>
				<span class="p">{</span>
					<span class="n">trigger</span> <span class="o">=</span> <span class="n">default_EISA_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">case</span> <span class="n">MP_BUS_PCI</span>: <span class="cm">/* PCI pin */</span>
				<span class="p">{</span>
					<span class="cm">/* set before the switch */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="nl">default:</span>
				<span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;broken BIOS!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">trigger</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* edge */</span>
		<span class="p">{</span>
			<span class="n">trigger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* reserved */</span>
		<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;broken BIOS!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">trigger</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* level */</span>
		<span class="p">{</span>
			<span class="n">trigger</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span> <span class="cm">/* invalid */</span>
		<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;broken BIOS!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">trigger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">trigger</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pin_2_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span> <span class="o">*</span><span class="n">gsi_cfg</span> <span class="o">=</span> <span class="n">mp_ioapic_gsi_routing</span><span class="p">(</span><span class="n">apic</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Debugging check, we are in big trouble if this message pops up!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">dstirq</span> <span class="o">!=</span> <span class="n">pin</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;broken BIOS or MPTABLE parser, ayiee!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">srcbusirq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">gsi</span> <span class="o">=</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_base</span> <span class="o">+</span> <span class="n">pin</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gsi</span> <span class="o">&gt;=</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">)</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">gsi</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">irq</span> <span class="o">=</span> <span class="n">gsi_top</span> <span class="o">+</span> <span class="n">gsi</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="cm">/*</span>
<span class="cm">	 * PCI IRQ command line redirection. Yes, limits are hardcoded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pin</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pin</span> <span class="o">&lt;=</span> <span class="mi">23</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pirq_entries</span><span class="p">[</span><span class="n">pin</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pirq_entries</span><span class="p">[</span><span class="n">pin</span><span class="o">-</span><span class="mi">16</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_DEBUG</span>
						<span class="s">&quot;disabling PIRQ%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pin</span><span class="o">-</span><span class="mi">16</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">irq</span> <span class="o">=</span> <span class="n">pirq_entries</span><span class="p">[</span><span class="n">pin</span><span class="o">-</span><span class="mi">16</span><span class="p">];</span>
				<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_DEBUG</span>
						<span class="s">&quot;using PIRQ%d -&gt; IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">pin</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a specific PCI IRQ entry.</span>
<span class="cm"> * Not an __init, possibly needed by modules</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">IO_APIC_get_PCI_irq_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">irq_attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">best_guess</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_DEBUG</span><span class="p">,</span>
		    <span class="s">&quot;querying PCI -&gt; IRQ mapping bus:%d, slot:%d, pin:%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bus</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span>
			    <span class="s">&quot;PCI BIOS passed nonexistent PCI bus %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lbus</span> <span class="o">=</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbus</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span> <span class="o">||</span>
			    <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span> <span class="o">==</span> <span class="n">MP_APIC_ALL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">lbus</span><span class="p">,</span> <span class="n">mp_bus_not_pci</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irqtype</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="n">lbus</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="p">((</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbusirq</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">pin_2_irq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstirq</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">||</span> <span class="n">IO_APIC_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">==</span> <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">srcbusirq</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_io_apic_irq_attr</span><span class="p">(</span><span class="n">irq_attr</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span>
						     <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstirq</span><span class="p">,</span>
						     <span class="n">irq_trigger</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
						     <span class="n">irq_polarity</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
				<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Use the first all-but-pin matching entry as a</span>
<span class="cm">			 * best-guess fuzzy result for broken mptables.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">best_guess</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_io_apic_irq_attr</span><span class="p">(</span><span class="n">irq_attr</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span>
						     <span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstirq</span><span class="p">,</span>
						     <span class="n">irq_trigger</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
						     <span class="n">irq_polarity</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
				<span class="n">best_guess</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">best_guess</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">IO_APIC_get_PCI_irq_vector</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lock_vector_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Used to the online set of cpus does not change</span>
<span class="cm">	 * during assign_irq_vector.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock_vector_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__assign_irq_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE! The local APIC isn&#39;t very good at handling</span>
<span class="cm">	 * multiple interrupts at the same interrupt level.</span>
<span class="cm">	 * As the interrupt level is determined by taking the</span>
<span class="cm">	 * vector number and shifting that right by 4, we</span>
<span class="cm">	 * want to spread these out a bit so that they don&#39;t</span>
<span class="cm">	 * all fall in the same interrupt level.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, we&#39;ve got to be careful not to trash gate</span>
<span class="cm">	 * 0x80, because int 0x80 is hm, kind of importantish. ;)</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">current_vector</span> <span class="o">=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span> <span class="o">+</span> <span class="n">VECTOR_OFFSET_START</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">current_offset</span> <span class="o">=</span> <span class="n">VECTOR_OFFSET_START</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_vector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">tmp_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_mask</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">old_vector</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">tmp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Only try and allocate irqs on cpus that are present */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">new_cpu</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">vector_allocation_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp_mask</span><span class="p">);</span>

		<span class="n">vector</span> <span class="o">=</span> <span class="n">current_vector</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">current_offset</span><span class="p">;</span>
<span class="nl">next:</span>
		<span class="n">vector</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vector</span> <span class="o">&gt;=</span> <span class="n">first_system_vector</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If out of vectors on large boxen, must share them. */</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">vector</span> <span class="o">=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current_vector</span> <span class="o">==</span> <span class="n">vector</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">used_vectors</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">new_cpu</span><span class="p">,</span> <span class="n">tmp_mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="cm">/* Found one! */</span>
		<span class="n">current_vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
		<span class="n">current_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_vector</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">new_cpu</span><span class="p">,</span> <span class="n">tmp_mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">)</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">tmp_mask</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">assign_irq_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_irq_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">vector</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>

	<span class="n">vector</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">;</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="n">NR_VECTORS</span><span class="p">;</span>
								<span class="n">vector</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">!=</span> <span class="n">irq</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__setup_vector_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize vector_irq on a new cpu */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * vector_lock will make sure that we don&#39;t run into irq vector</span>
<span class="cm">	 * assignments that might be happening on another cpu in parallel,</span>
<span class="cm">	 * while we setup our initial vector to irq mappings.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
	<span class="cm">/* Mark the inuse vectors */</span>
	<span class="n">for_each_active_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it is a legacy IRQ handled by the legacy PIC, this cpu</span>
<span class="cm">		 * will be part of the irq_cfg&#39;s domain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IO_APIC_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">vector</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">;</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Mark the free vectors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="n">NR_VECTORS</span><span class="p">;</span> <span class="o">++</span><span class="n">vector</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_cfg</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">))</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">vector</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">ioapic_chip</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">IO_APIC_irq_trigger</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">pin_2_irq</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">irq_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">         * nonexistent IRQs are edge default</span>
<span class="cm">         */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">IO_APIC_irq_trigger</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioapic_register_intr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioapic_chip</span><span class="p">;</span>
	<span class="n">irq_flow_handler_t</span> <span class="n">hdl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fasteoi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">trigger</span> <span class="o">==</span> <span class="n">IOAPIC_AUTO</span> <span class="o">&amp;&amp;</span> <span class="n">IO_APIC_irq_trigger</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">trigger</span> <span class="o">==</span> <span class="n">IOAPIC_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_LEVEL</span><span class="p">);</span>
		<span class="n">fasteoi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">irq_clear_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_LEVEL</span><span class="p">);</span>
		<span class="n">fasteoi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_MOVE_PCNTXT</span><span class="p">);</span>
		<span class="n">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">fasteoi</span> <span class="o">=</span> <span class="n">trigger</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdl</span> <span class="o">=</span> <span class="n">fasteoi</span> <span class="o">?</span> <span class="n">handle_fasteoi_irq</span> <span class="o">:</span> <span class="n">handle_edge_irq</span><span class="p">;</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">hdl</span><span class="p">,</span>
				      <span class="n">fasteoi</span> <span class="o">?</span> <span class="s">&quot;fasteoi&quot;</span> <span class="o">:</span> <span class="s">&quot;edge&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_ioapic_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">setup_ioapic_remapped_entry</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
						   <span class="n">vector</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">));</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">delivery_mode</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_delivery_mode</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dest_mode</span>     <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_dest_mode</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dest</span>	     <span class="o">=</span> <span class="n">destination</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">vector</span>	     <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mask</span>	     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* enable IRQ */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">trigger</span>	     <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">polarity</span>	     <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">polarity</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mask level triggered irqs.</span>
<span class="cm">	 * Use IRQ_DELAYED_DISABLE for edge triggered irqs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_ioapic_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IO_APIC_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For legacy irqs, cfg-&gt;domain starts with cpu 0 for legacy</span>
<span class="cm">	 * controllers like 8259. Now that IO-APIC can handle this irq, update</span>
<span class="cm">	 * the cfg-&gt;domain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">))</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">vector_allocation_domain</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">()))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_mask_to_apicid_and</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span><span class="n">KERN_DEBUG</span>
		    <span class="s">&quot;IOAPIC[%d]: Set routing entry (%d-%d -&gt; 0x%x -&gt; &quot;</span>
		    <span class="s">&quot;IRQ %d Mode:%i Active:%i Dest:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">),</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic_pin</span><span class="p">,</span>
		    <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">polarity</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">setup_ioapic_entry</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Failed to setup ioapic entry for ioapic  %d, pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">),</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic_pin</span><span class="p">);</span>
		<span class="n">__clear_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioapic_register_intr</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic_pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__init</span> <span class="nf">io_apic_pin_not_connected</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot; apic %d pin %d not connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">),</span> <span class="n">pin</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">__io_apic_setup_irqs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io_apic_pin_not_connected</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">irq</span> <span class="o">=</span> <span class="n">pin_2_irq</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ioapic_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Skip the timer IRQ if there&#39;s a quirk handler</span>
<span class="cm">		 * installed and if it returns 1:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">multi_timer_check</span> <span class="o">&amp;&amp;</span>
		    <span class="n">apic</span><span class="o">-&gt;</span><span class="n">multi_timer_check</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">irq</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">set_io_apic_irq_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">irq_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
				     <span class="n">irq_polarity</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>

		<span class="n">io_apic_setup_irq_pin</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_IO_APIC_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_DEBUG</span> <span class="s">&quot;init IO_APIC IRQs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__io_apic_setup_irqs</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * for the gsit that is not in first ioapic</span>
<span class="cm"> * but could not use acpi_register_gsi()</span>
<span class="cm"> * like some special sci in IBM x3330</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">setup_IO_APIC_irq_extra</span><span class="p">(</span><span class="n">u32</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="n">attr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert &#39;gsi&#39; to &#39;ioapic.pin&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">ioapic_idx</span> <span class="o">=</span> <span class="n">mp_find_ioapic</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pin</span> <span class="o">=</span> <span class="n">mp_find_ioapic_pin</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">pin_2_irq</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

	<span class="cm">/* Only handle the non legacy irqs on secondary ioapics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_io_apic_irq_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">irq_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
			     <span class="n">irq_polarity</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>

	<span class="n">io_apic_setup_irq_pin_once</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the timer pin, possibly with the 8259A-master behind.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_timer_IRQ0_pin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use logical delivery to get the timer IRQ</span>
<span class="cm">	 * to the first CPU.</span>
<span class="cm">	 */</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">dest_mode</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_dest_mode</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* don&#39;t mask IRQ for edge */</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">dest</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_mask_to_apicid</span><span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">delivery_mode</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_delivery_mode</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The timer IRQ doesn&#39;t have to know that behind the</span>
<span class="cm">	 * scene we may have a 8259A-master in AEOI mode ...</span>
<span class="cm">	 */</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioapic_chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span>
				      <span class="s">&quot;edge&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add it to the IO-APIC irq-routing table:</span>
<span class="cm">	 */</span>
	<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_IO_APIC</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_00</span> <span class="n">reg_00</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_01</span> <span class="n">reg_01</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_02</span> <span class="n">reg_02</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_03</span> <span class="n">reg_03</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x10</span><span class="p">)</span>
		<span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="n">reg_03</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;IO APIC #%d......</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.... register #00: %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......    : physical APIC id: %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......    : Delivery Type: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">delivery_type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......    : LTS          : %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">LTS</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.... register #01: %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">reg_01</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......     : max redirection entries: %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......     : PRQ implemented: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">PRQ</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......     : IO APIC version: %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some Intel chipsets with IO APIC VERSION of 0x1? don&#39;t have reg_02,</span>
<span class="cm">	 * but the value of reg_02 is read as the previous read register</span>
<span class="cm">	 * value, so ignore it if reg_02 == reg_01.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span> <span class="o">!=</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.... register #02: %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......     : arbitration: %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_02</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">arbitration</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some Intel chipsets with IO APIC VERSION of 0x2? don&#39;t have reg_02</span>
<span class="cm">	 * or reg_03, but the value of reg_0[23] is read as the previous read</span>
<span class="cm">	 * register value, so ignore it if reg_03 == reg_0[12].</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span> <span class="n">reg_03</span><span class="p">.</span><span class="n">raw</span> <span class="o">!=</span> <span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span> <span class="o">&amp;&amp;</span>
	    <span class="n">reg_03</span><span class="p">.</span><span class="n">raw</span> <span class="o">!=</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.... register #03: %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_03</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.......     : Boot DT    : %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_03</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">boot_DT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.... IRQ redirection table:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; NR Indx Fmt Mask Trig IRR&quot;</span>
			<span class="s">&quot; Pol Stat Indx2 Zero Vect:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; NR Dst Mask Trig IRR Pol&quot;</span>
			<span class="s">&quot; Stat Dmod Deli Vect:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">IR_IO_APIC_route_entry</span> <span class="o">*</span><span class="n">ir_entry</span><span class="p">;</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ir_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">IR_IO_APIC_route_entry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %02x %04X &quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">index</span>
			<span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%1d   %1d    %1d    %1d   %1d   &quot;</span>
				<span class="s">&quot;%1d    %1d     %X    %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">irr</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">polarity</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">delivery_status</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">zero</span><span class="p">,</span>
				<span class="n">ir_entry</span><span class="o">-&gt;</span><span class="n">vector</span>
			<span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>

			<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot; %02x %02X  &quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">dest</span>
			<span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%1d    %1d    %1d   %1d   %1d    &quot;</span>
				<span class="s">&quot;%1d    %1d    %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">mask</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">trigger</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">irr</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">polarity</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">delivery_status</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">dest_mode</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">delivery_mode</span><span class="p">,</span>
				<span class="n">entry</span><span class="p">.</span><span class="n">vector</span>
			<span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_IO_APICs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;number of MP IRQ sources: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mp_irq_entries</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;number of IO-APIC #%d registers: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">),</span>
		       <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are a bit conservative about what we expect.  We have to</span>
<span class="cm">	 * know about every hardware change ASAP.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;testing the IO APIC.......................</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">print_IO_APIC</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;IRQ to pin mappings:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_active_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="n">irq_get_chip</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ioapic_chip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;IRQ%d &quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;-&gt; %d:%d&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;.................................... done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_APIC_field</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mh">0x10</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_local_APIC</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ver</span><span class="p">,</span> <span class="n">maxlvt</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">icr</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;printing local APIC contents on CPU#%d/%d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">hard_smp_processor_id</span><span class="p">());</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ID</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;... APIC ID:      %08x (%01x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">read_apic_id</span><span class="p">());</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVR</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;... APIC VERSION: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">ver</span> <span class="o">=</span> <span class="n">GET_APIC_VERSION</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="n">maxlvt</span> <span class="o">=</span> <span class="n">lapic_get_maxlvt</span><span class="p">();</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TASKPRI</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC TASKPRI: %08x (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="n">APIC_TPRI_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">ver</span><span class="p">))</span> <span class="p">{</span>                     <span class="cm">/* !82489DX */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">APIC_XAPIC</span><span class="p">(</span><span class="n">ver</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ARBPRI</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ARBPRI: %08x (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
			       <span class="n">v</span> <span class="o">&amp;</span> <span class="n">APIC_ARBPRI_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_PROCPRI</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC PROCPRI: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remote read supported only in the 82489DX and local APIC for</span>
<span class="cm">	 * Pentium processors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">ver</span><span class="p">)</span> <span class="o">||</span> <span class="n">maxlvt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_RRR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC RRR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LDR</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LDR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x2apic_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_DFR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC DFR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_SPIV</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC SPIV: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ISR field:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_APIC_field</span><span class="p">(</span><span class="n">APIC_ISR</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC TMR field:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_APIC_field</span><span class="p">(</span><span class="n">APIC_TMR</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC IRR field:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_APIC_field</span><span class="p">(</span><span class="n">APIC_IRR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">APIC_INTEGRATED</span><span class="p">(</span><span class="n">ver</span><span class="p">))</span> <span class="p">{</span>             <span class="cm">/* !82489DX */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>         <span class="cm">/* Due to the Pentium erratum 3AP. */</span>
			<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ESR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ESR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">icr</span> <span class="o">=</span> <span class="n">apic_icr_read</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ICR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">icr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ICR2: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">icr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTT</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LVTT: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>                       <span class="cm">/* PC is LVT#4. */</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LVTPC: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LVT0: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT1</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LVT1: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxlvt</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* ERR is LVT#3. */</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVTERR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC LVTERR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TMICT</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC TMICT: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TMCCT</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC TMCCT: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TDCR</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC TDCR: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_EXTAPIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_EFEAT</span><span class="p">);</span>
		<span class="n">maxlvt</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC EFEAT: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_ECTRL</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC ECTRL: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxlvt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_EILVTn</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... APIC EILVT%d: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_local_APICs</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maxcpu</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">maxcpu</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">print_local_APIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">print_PIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">printing PIC contents</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i8259A_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0xa1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x21</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... PIC  IMR: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... PIC  IRR: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0b</span><span class="p">,</span><span class="mh">0xa0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0b</span><span class="p">,</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span><span class="mh">0xa0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span><span class="mh">0x20</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i8259A_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... PIC  ISR: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x4d1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x4d0</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;... PIC ELCR: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">show_lapic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_show_lapic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;all&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">show_lapic</span> <span class="o">=</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">show_lapic</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;show_lapic=&quot;</span><span class="p">,</span> <span class="n">setup_show_lapic</span><span class="p">);</span>

<span class="n">__apicdebuginit</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">print_ICs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic_verbosity</span> <span class="o">==</span> <span class="n">APIC_QUIET</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">print_PIC</span><span class="p">();</span>

	<span class="cm">/* don&#39;t print out if apic is not there */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_apic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">apic_from_smp_config</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">print_local_APICs</span><span class="p">(</span><span class="n">show_lapic</span><span class="p">);</span>
	<span class="n">print_IO_APICs</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">print_ICs</span><span class="p">);</span>


<span class="cm">/* Where if anywhere is the i8259 connect in external int mode */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="n">apic</span><span class="p">;</span> <span class="p">}</span> <span class="n">ioapic_i8259</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">enable_IO_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i8259_apic</span><span class="p">,</span> <span class="n">i8259_pin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">apic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">apic</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pin</span><span class="p">;</span>
		<span class="cm">/* See if any of the pins is in ExtINT mode */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">apic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

			<span class="cm">/* If the interrupt line is enabled and in ExtInt mode</span>
<span class="cm">			 * I have found the pin where the i8259 is connected.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="p">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">delivery_mode</span> <span class="o">==</span> <span class="n">dest_ExtINT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">apic</span> <span class="o">=</span> <span class="n">apic</span><span class="p">;</span>
				<span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span>  <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">found_i8259</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">found_i8259:</span>
	<span class="cm">/* Look to see what if the MP table has reported the ExtINT */</span>
	<span class="cm">/* If we could not find the appropriate pin by looking at the ioapic</span>
<span class="cm">	 * the i8259 probably is not connected the ioapic but give the</span>
<span class="cm">	 * mptable a chance anyway.</span>
<span class="cm">	 */</span>
	<span class="n">i8259_pin</span>  <span class="o">=</span> <span class="n">find_isa_irq_pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp_ExtINT</span><span class="p">);</span>
	<span class="n">i8259_apic</span> <span class="o">=</span> <span class="n">find_isa_irq_apic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp_ExtINT</span><span class="p">);</span>
	<span class="cm">/* Trust the MP table if nothing is setup in the hardware */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i8259_pin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ExtINT not setup in hardware but reported by MP table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span>  <span class="o">=</span> <span class="n">i8259_pin</span><span class="p">;</span>
		<span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">apic</span> <span class="o">=</span> <span class="n">i8259_apic</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Complain if the MP table and the hardware disagree */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">apic</span> <span class="o">!=</span> <span class="n">i8259_apic</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span> <span class="o">!=</span> <span class="n">i8259_pin</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">i8259_pin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ExtINT in hardware and MP table differ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not trust the IO-APIC being empty at bootup</span>
<span class="cm">	 */</span>
	<span class="n">clear_IO_APIC</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Not an __init, needed by the reboot code</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disable_IO_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear the IO-APIC before rebooting:</span>
<span class="cm">	 */</span>
	<span class="n">clear_IO_APIC</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the i8259 is routed through an IOAPIC</span>
<span class="cm">	 * Put that IOAPIC in virtual wire mode</span>
<span class="cm">	 * so legacy interrupts can be delivered.</span>
<span class="cm">	 *</span>
<span class="cm">	 * With interrupt-remapping, for now we will use virtual wire A mode,</span>
<span class="cm">	 * as virtual wire B is little complex (need to configure both</span>
<span class="cm">	 * IOAPIC RTE as well as interrupt-remapping table entry).</span>
<span class="cm">	 * As this gets called during crash dump, keep this simple for now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">irq_remapping_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">mask</span>            <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Enabled */</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">trigger</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Edge */</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">irr</span>             <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">polarity</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* High */</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">delivery_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">dest_mode</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Physical */</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">delivery_mode</span>   <span class="o">=</span> <span class="n">dest_ExtINT</span><span class="p">;</span> <span class="cm">/* ExtInt */</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">vector</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="p">.</span><span class="n">dest</span>            <span class="o">=</span> <span class="n">read_apic_id</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add it to the IO-APIC irq-routing table:</span>
<span class="cm">		 */</span>
		<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">apic</span><span class="p">,</span> <span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use virtual wire A mode when interrupt remapping is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_apic</span> <span class="o">||</span> <span class="n">apic_from_smp_config</span><span class="p">())</span>
		<span class="n">disconnect_bsp_APIC</span><span class="p">(</span><span class="o">!</span><span class="n">irq_remapping_enabled</span> <span class="o">&amp;&amp;</span>
				<span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cm">/*</span>
<span class="cm"> * function to set the IO-APIC physical IDs based on the</span>
<span class="cm"> * values stored in the MPC table.</span>
<span class="cm"> *</span>
<span class="cm"> * by Matt Domsch &lt;Matt_Domsch@dell.com&gt;  Tue Dec 21 12:25:05 CST 1999</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_ioapic_ids_from_mpc_nocheck</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_00</span> <span class="n">reg_00</span><span class="p">;</span>
	<span class="n">physid_mask_t</span> <span class="n">phys_id_present_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">old_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is broken; anything with a real cpu count has to</span>
<span class="cm">	 * circumvent this idiocy regardless.</span>
<span class="cm">	 */</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">ioapic_phys_id_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_id_present_map</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the IOAPIC ID to the value stored in the MPC table.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the register 0 value */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">old_id</span> <span class="o">=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">get_physical_broadcast</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">));</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;... fixing up to %d. (tell your hw vendor)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">);</span>
			<span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sanity check, is the ID really free? Every APIC in a</span>
<span class="cm">		 * system must have a unique ID or we get lots of nice</span>
<span class="cm">		 * &#39;stuck on smp_invalidate_needed IPI wait&#39; messages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">check_apicid_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phys_id_present_map</span><span class="p">,</span>
					    <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BIOS bug, IO-APIC#%d ID %d is already used!...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ioapic_idx</span><span class="p">,</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_physical_broadcast</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physid_isset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">phys_id_present_map</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">get_physical_broadcast</span><span class="p">())</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Max APIC ID exceeded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;... fixing up to %d. (tell your hw vendor)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">);</span>
			<span class="n">physid_set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">phys_id_present_map</span><span class="p">);</span>
			<span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">physid_mask_t</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">apic</span><span class="o">-&gt;</span><span class="n">apicid_to_cpu_present</span><span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">),</span>
						    <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;Setting %d in the &quot;</span>
					<span class="s">&quot;phys_id_present_map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">));</span>
			<span class="n">physids_or</span><span class="p">(</span><span class="n">phys_id_present_map</span><span class="p">,</span> <span class="n">phys_id_present_map</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to adjust the IRQ routing table</span>
<span class="cm">		 * if the ID changed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_id</span> <span class="o">!=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">))</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp_irq_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span> <span class="o">==</span> <span class="n">old_id</span><span class="p">)</span>
					<span class="n">mp_irqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dstapic</span>
						<span class="o">=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update the ID register according to the right value</span>
<span class="cm">		 * from the MPC table if they are different.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			<span class="s">&quot;...changing IO-APIC physical APIC ID to %d ...&quot;</span><span class="p">,</span>
			<span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">));</span>

		<span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_apic_write</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Sanity check</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;could not set ID!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot; ok.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_ioapic_ids_from_mpc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_ioapic</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t check I/O APIC IDs for xAPIC systems.  They have</span>
<span class="cm">	 * no meaning without the serial APIC bus.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_INTEL</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">APIC_XAPIC</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">setup_ioapic_ids_from_mpc_nocheck</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">no_timer_check</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">notimercheck</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">no_timer_check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;no_timer_check&quot;</span><span class="p">,</span> <span class="n">notimercheck</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * There is a nasty bug in some older SMP boards, their mptable lies</span>
<span class="cm"> * about the timer IRQ. We do the following to work around the situation:</span>
<span class="cm"> *</span>
<span class="cm"> *	- timer IRQ defaults to IO-APIC IRQ</span>
<span class="cm"> *	- if this function detects that timer IRQs are defunct, then we fall</span>
<span class="cm"> *	  back to ISA timer IRQs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">timer_irq_works</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_timer_check</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="cm">/* Let ten ticks pass... */</span>
	<span class="n">mdelay</span><span class="p">((</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Expect a few ticks at least, to be sure some possible</span>
<span class="cm">	 * glue logic does not lock up after one or two first</span>
<span class="cm">	 * ticks in a non-ExtINT mode.  Also the local APIC</span>
<span class="cm">	 * might have cached one ExtINT interrupt.  Finally, at</span>
<span class="cm">	 * least one tick may be lost due to delays.</span>
<span class="cm">	 */</span>

	<span class="cm">/* jiffies wrap? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In the SMP+IOAPIC case it might happen that there are an unspecified</span>
<span class="cm"> * number of pending IRQ events unhandled. These cases are very rare,</span>
<span class="cm"> * so we &#39;resend&#39; these IRQs via IPIs, to the same CPU. It&#39;s much</span>
<span class="cm"> * better to do it this way as thus we do not have to be aware of</span>
<span class="cm"> * &#39;pending&#39; interrupts in the IRQ path, except at this point.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Edge triggered needs to resend any interrupt</span>
<span class="cm"> * that was delayed but this is now handled in the device</span>
<span class="cm"> * independent code.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Starting up a edge-triggered IO-APIC interrupt is</span>
<span class="cm"> * nasty - we need to make sure that we get the edge.</span>
<span class="cm"> * If it is already asserted for some reason, we need</span>
<span class="cm"> * return 1 to indicate that is was pending.</span>
<span class="cm"> *</span>
<span class="cm"> * This is not complete - we should be able to fake</span>
<span class="cm"> * an edge even if it isn&#39;t on the 8259A...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">startup_ioapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">was_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">irq_pending</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
			<span class="n">was_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__unmask_ioapic</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">was_pending</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioapic_retrigger_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">)),</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Level and edge triggered IO-APIC interrupts need different handling,</span>
<span class="cm"> * so we use two separate IRQ descriptors. Edge triggered IRQs can be</span>
<span class="cm"> * handled with the level-triggered descriptor, but that one has slightly</span>
<span class="cm"> * more overhead. Level-triggered interrupts cannot be handled with the</span>
<span class="cm"> * edge-triggered handler, without risking IRQ storms and other ugly</span>
<span class="cm"> * races.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="nf">send_cleanup_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">cleanup_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_mask</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">)</span>
			<span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">IRQ_MOVE_CLEANUP_VECTOR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpumask_and</span><span class="p">(</span><span class="n">cleanup_mask</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">old_domain</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_mask</span><span class="p">(</span><span class="n">cleanup_mask</span><span class="p">,</span> <span class="n">IRQ_MOVE_CLEANUP_VECTOR</span><span class="p">);</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cleanup_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__target_IO_APIC_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">;</span>

	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

		<span class="n">apic</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">;</span>
		<span class="n">pin</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * With interrupt-remapping, destination information comes</span>
<span class="cm">		 * from interrupt-remapping table entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>
			<span class="n">io_apic_write</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x11</span> <span class="o">+</span> <span class="n">pin</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pin</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IO_APIC_REDIR_VECTOR_MASK</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">vector</span><span class="p">;</span>
		<span class="n">io_apic_modify</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pin</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Either sets data-&gt;affinity to a valid value, and returns</span>
<span class="cm"> * -&gt;cpu_mask_to_apicid of that in dest_id, or returns -1 and</span>
<span class="cm"> * leaves data-&gt;affinity untouched.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ioapic_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dest_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assign_irq_vector</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dest_id</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_mask_to_apicid_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ioapic_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		    <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ioapic_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Only the high 8 bits are valid. */</span>
		<span class="n">dest</span> <span class="o">=</span> <span class="n">SET_APIC_LOGICAL_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
		<span class="n">__target_IO_APIC_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="nf">smp_irq_move_cleanup_interrupt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">vector</span><span class="p">,</span> <span class="n">me</span><span class="p">;</span>

	<span class="n">ack_APIC_irq</span><span class="p">();</span>
	<span class="n">irq_enter</span><span class="p">();</span>
	<span class="n">exit_idle</span><span class="p">();</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="n">FIRST_EXTERNAL_VECTOR</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="n">NR_VECTORS</span><span class="p">;</span> <span class="n">vector</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">[</span><span class="n">vector</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_cfg</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the irq migration is in progress. If so, we</span>
<span class="cm">		 * haven&#39;t received the cleanup request yet for this irq.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vector</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="n">irr</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_IRR</span> <span class="o">+</span> <span class="p">(</span><span class="n">vector</span> <span class="o">/</span> <span class="mi">32</span> <span class="o">*</span> <span class="mh">0x10</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if the vector that needs to be cleanedup is</span>
<span class="cm">		 * registered at the cpu&#39;s IRR. If so, then this is not</span>
<span class="cm">		 * the best time to clean it up. Lets clean it up in the</span>
<span class="cm">		 * next attempt by sending another IRQ_MOVE_CLEANUP_VECTOR</span>
<span class="cm">		 * to myself.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irr</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vector</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_self</span><span class="p">(</span><span class="n">IRQ_MOVE_CLEANUP_VECTOR</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">vector_irq</span><span class="p">[</span><span class="n">vector</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nl">unlock:</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">irq_exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__irq_complete_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">me</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">move_in_progress</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vector</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">))</span>
		<span class="n">send_cleanup_vector</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_complete_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__irq_complete_move</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="o">~</span><span class="n">get_irq_regs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">orig_ax</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">irq_force_complete_move</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__irq_complete_move</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_complete_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_apic_edge</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_complete_move</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
	<span class="n">irq_move_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">atomic_t</span> <span class="n">irq_mis_count</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_GENERIC_PENDING_IRQ</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">io_apic_level_ack_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_pin_list</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">for_each_irq_pin</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">irq_2_pin</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pin</span><span class="p">;</span>

		<span class="n">pin</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">apic</span><span class="p">,</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pin</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* Is the remote IRR bit set? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">IO_APIC_REDIR_REMOTE_IRR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ioapic_irqd_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we are moving the irq we need to mask it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irqd_is_setaffinity_pending</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mask_ioapic</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ioapic_irqd_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">masked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">masked</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Only migrate the irq if the ack has been received.</span>
<span class="cm">		 *</span>
<span class="cm">		 * On rare occasions the broadcast level triggered ack gets</span>
<span class="cm">		 * delayed going to ioapics, and if we reprogram the</span>
<span class="cm">		 * vector while Remote IRR is still set the irq will never</span>
<span class="cm">		 * fire again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * To prevent this scenario we read the Remote IRR bit</span>
<span class="cm">		 * of the ioapic.  This has two effects.</span>
<span class="cm">		 * - On any sane system the read of the ioapic will</span>
<span class="cm">		 *   flush writes (and acks) going to the ioapic from</span>
<span class="cm">		 *   this cpu.</span>
<span class="cm">		 * - We get to see if the ACK has actually been delivered.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Based on failed experiments of reprogramming the</span>
<span class="cm">		 * ioapic entry from outside of irq context starting</span>
<span class="cm">		 * with masking the ioapic entry and then polling until</span>
<span class="cm">		 * Remote IRR was clear before reprogramming the</span>
<span class="cm">		 * ioapic I don&#39;t trust the Remote IRR bit to be</span>
<span class="cm">		 * completey accurate.</span>
<span class="cm">		 *</span>
<span class="cm">		 * However there appears to be no other way to plug</span>
<span class="cm">		 * this race, so if the Remote IRR bit is not</span>
<span class="cm">		 * accurate and is causing problems then it is a hardware bug</span>
<span class="cm">		 * and you can go talk to the chipset vendor about it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">io_apic_level_ack_pending</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>
			<span class="n">irq_move_masked_irq</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">unmask_ioapic</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ioapic_irqd_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ioapic_irqd_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">masked</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_apic_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">masked</span><span class="p">;</span>

	<span class="n">irq_complete_move</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
	<span class="n">masked</span> <span class="o">=</span> <span class="n">ioapic_irqd_mask</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It appears there is an erratum which affects at least version 0x11</span>
<span class="cm">	 * of I/O APIC (that&#39;s the 82093AA and cores integrated into various</span>
<span class="cm">	 * chipsets).  Under certain conditions a level-triggered interrupt is</span>
<span class="cm">	 * erroneously delivered as edge-triggered one but the respective IRR</span>
<span class="cm">	 * bit gets set nevertheless.  As a result the I/O unit expects an EOI</span>
<span class="cm">	 * message but it will never arrive and further interrupts are blocked</span>
<span class="cm">	 * from the source.  The exact reason is so far unknown, but the</span>
<span class="cm">	 * phenomenon was observed when two consecutive interrupt requests</span>
<span class="cm">	 * from a given source get delivered to the same CPU and the source is</span>
<span class="cm">	 * temporarily disabled in between.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A workaround is to simulate an EOI message manually.  We achieve it</span>
<span class="cm">	 * by setting the trigger mode to edge and then to level when the edge</span>
<span class="cm">	 * trigger mode gets detected in the TMR of a local APIC for a</span>
<span class="cm">	 * level-triggered interrupt.  We mask the source for the time of the</span>
<span class="cm">	 * operation to prevent an edge-triggered interrupt escaping meanwhile.</span>
<span class="cm">	 * The idea is from Manfred Spraul.  --macro</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also in the case when cpu goes offline, fixup_irqs() will forward</span>
<span class="cm">	 * any unhandled interrupt on the offlined cpu to the new cpu</span>
<span class="cm">	 * destination that is handling the corresponding interrupt. This</span>
<span class="cm">	 * interrupt forwarding is done via IPI&#39;s. Hence, in this case also</span>
<span class="cm">	 * level-triggered io-apic interrupt will be seen as an edge</span>
<span class="cm">	 * interrupt in the IRR. And we can&#39;t rely on the cpu&#39;s EOI</span>
<span class="cm">	 * to be broadcasted to the IO-APIC&#39;s which will clear the remoteIRR</span>
<span class="cm">	 * corresponding to the level-triggered interrupt. Hence on IO-APIC&#39;s</span>
<span class="cm">	 * supporting EOI register, we do an explicit EOI to clear the</span>
<span class="cm">	 * remote IRR and on IO-APIC&#39;s which don&#39;t have an EOI register,</span>
<span class="cm">	 * we use the above logic (mask+edge followed by unmask+level) from</span>
<span class="cm">	 * Manfred Spraul to clear the remote IRR.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_TMR</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1f</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must acknowledge the irq before we move it or the acknowledge will</span>
<span class="cm">	 * not propagate properly.</span>
<span class="cm">	 */</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tail end of clearing remote IRR bit (either by delivering the EOI</span>
<span class="cm">	 * message via io-apic EOI register write or simulating it using</span>
<span class="cm">	 * mask+edge followed by unnask+level logic) manually when the</span>
<span class="cm">	 * level triggered interrupt is seen as the edge triggered interrupt</span>
<span class="cm">	 * at the cpu.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq_mis_count</span><span class="p">);</span>

		<span class="n">eoi_ioapic_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ioapic_irqd_unmask</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">masked</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IRQ_REMAP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_ack_apic_edge</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_ack_apic_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
	<span class="n">eoi_ioapic_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ir_print_prefix</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot; IR-%s&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_print_chip</span> <span class="o">=</span> <span class="n">ir_print_prefix</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_ack</span> <span class="o">=</span> <span class="n">ir_ack_apic_edge</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_eoi</span> <span class="o">=</span> <span class="n">ir_ack_apic_level</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_affinity</span> <span class="o">=</span> <span class="n">set_remapped_irq_affinity</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IRQ_REMAP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">ioapic_chip</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;IO-APIC&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_startup</span>		<span class="o">=</span> <span class="n">startup_ioapic_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">mask_ioapic_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">unmask_ioapic_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_apic_edge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_eoi</span>		<span class="o">=</span> <span class="n">ack_apic_level</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">ioapic_set_affinity</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">ioapic_retrigger_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_IO_APIC_traps</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE! The local APIC isn&#39;t very good at handling</span>
<span class="cm">	 * multiple interrupts at the same interrupt level.</span>
<span class="cm">	 * As the interrupt level is determined by taking the</span>
<span class="cm">	 * vector number and shifting that right by 4, we</span>
<span class="cm">	 * want to spread these out a bit so that they don&#39;t</span>
<span class="cm">	 * all fall in the same interrupt level.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, we&#39;ve got to be careful not to trash gate</span>
<span class="cm">	 * 0x80, because int 0x80 is hm, kind of importantish. ;)</span>
<span class="cm">	 */</span>
	<span class="n">for_each_active_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IO_APIC_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cfg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Hmm.. We don&#39;t have an entry for this,</span>
<span class="cm">			 * so default to an old-fashioned 8259</span>
<span class="cm">			 * interrupt if we can..</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
				<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">make_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* Strange. Oh, well.. */</span>
				<span class="n">irq_set_chip</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">no_irq_chip</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The local APIC irq-chip implementation:</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mask_lapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">v</span> <span class="o">|</span> <span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmask_lapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">apic_read</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">APIC_LVT_MASKED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ack_lapic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ack_APIC_irq</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">lapic_chip</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;local-APIC&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">mask_lapic_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">unmask_lapic_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>	<span class="o">=</span> <span class="n">ack_lapic_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_register_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_clear_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_LEVEL</span><span class="p">);</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lapic_chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span>
				      <span class="s">&quot;edge&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This looks a bit hackish but it&#39;s about the only one way of sending</span>
<span class="cm"> * a few INTA cycles to 8259As and any associated glue logic.  ICR does</span>
<span class="cm"> * not support the ExtINT mode, unfortunately.  We need to send these</span>
<span class="cm"> * cycles as some i82489DX-based boards have glue logic that keeps the</span>
<span class="cm"> * 8259A interrupt line asserted until INTA.  --macro</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">unlock_ExtINT_logic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">IO_APIC_route_entry</span> <span class="n">entry0</span><span class="p">,</span> <span class="n">entry1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">save_control</span><span class="p">,</span> <span class="n">save_freq_select</span><span class="p">;</span>

	<span class="n">pin</span>  <span class="o">=</span> <span class="n">find_isa_irq_pin</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">apic</span> <span class="o">=</span> <span class="n">find_isa_irq_apic</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry0</span> <span class="o">=</span> <span class="n">ioapic_read_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry1</span><span class="p">));</span>

	<span class="n">entry1</span><span class="p">.</span><span class="n">dest_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* physical delivery */</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* unmask IRQ now */</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">dest</span> <span class="o">=</span> <span class="n">hard_smp_processor_id</span><span class="p">();</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">delivery_mode</span> <span class="o">=</span> <span class="n">dest_ExtINT</span><span class="p">;</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="n">entry0</span><span class="p">.</span><span class="n">polarity</span><span class="p">;</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry1</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry1</span><span class="p">);</span>

	<span class="n">save_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">save_freq_select</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">((</span><span class="n">save_freq_select</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RTC_RATE_SELECT</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x6</span><span class="p">,</span>
		   <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_control</span> <span class="o">|</span> <span class="n">RTC_PIE</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RTC_PF</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTC_PF</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">save_freq_select</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>
	<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

	<span class="n">ioapic_write_entry</span><span class="p">(</span><span class="n">apic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">entry0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_timer_pin_1</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="cm">/* Actually the next is obsolete, but keep it for paranoid reasons -AK */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disable_timer_pin_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_timer_pin_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;disable_timer_pin_1&quot;</span><span class="p">,</span> <span class="n">disable_timer_pin_setup</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">timer_through_8259</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This code may look a bit paranoid, but it&#39;s supposed to cooperate with</span>
<span class="cm"> * a wide range of boards and BIOS bugs.  Fortunately only the timer IRQ</span>
<span class="cm"> * is so screwy.  Thanks to Brian Perkins for testing/hacking this beast</span>
<span class="cm"> * fanatically on his truly buggy board.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: really need to revamp this for all platforms.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_pin1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * get/set the timer IRQ vector:</span>
<span class="cm">	 */</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">assign_irq_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * As IRQ0 is to be enabled in the 8259A, the virtual</span>
<span class="cm">	 * wire has to be disabled in the local APIC.  Also</span>
<span class="cm">	 * timer interrupts need to be acknowledged manually in</span>
<span class="cm">	 * the 8259A for the i82489DX when using the NMI</span>
<span class="cm">	 * watchdog as that APIC treats NMIs as level-triggered.</span>
<span class="cm">	 * The AEOI mode will finish them in the 8259A</span>
<span class="cm">	 * automatically.</span>
<span class="cm">	 */</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span> <span class="o">|</span> <span class="n">APIC_DM_EXTINT</span><span class="p">);</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">pin1</span>  <span class="o">=</span> <span class="n">find_isa_irq_pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="n">apic1</span> <span class="o">=</span> <span class="n">find_isa_irq_apic</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="n">pin2</span>  <span class="o">=</span> <span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">pin</span><span class="p">;</span>
	<span class="n">apic2</span> <span class="o">=</span> <span class="n">ioapic_i8259</span><span class="p">.</span><span class="n">apic</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;..TIMER: vector=0x%02X &quot;</span>
		    <span class="s">&quot;apic1=%d pin1=%d apic2=%d pin2=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some BIOS writers are clueless and report the ExtINTA</span>
<span class="cm">	 * I/O APIC input from the cascaded 8259A as the timer</span>
<span class="cm">	 * interrupt input.  So just in case, if only one pin</span>
<span class="cm">	 * was found above, try it both directly and through the</span>
<span class="cm">	 * 8259A.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;BIOS bug: timer not connected to IO-APIC&quot;</span><span class="p">);</span>
		<span class="n">pin1</span> <span class="o">=</span> <span class="n">pin2</span><span class="p">;</span>
		<span class="n">apic1</span> <span class="o">=</span> <span class="n">apic2</span><span class="p">;</span>
		<span class="n">no_pin1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pin2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pin2</span> <span class="o">=</span> <span class="n">pin1</span><span class="p">;</span>
		<span class="n">apic2</span> <span class="o">=</span> <span class="n">apic1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pin1</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok, does IRQ0 through the IOAPIC work?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">no_pin1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_pin_to_irq_node</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">);</span>
			<span class="n">setup_timer_IRQ0_pin</span><span class="p">(</span><span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* for edge trigger, setup_ioapic_irq already</span>
<span class="cm">			 * leave it unmasked.</span>
<span class="cm">			 * so only need to unmask if it is level-trigger</span>
<span class="cm">			 * do we really have level trigger timer?</span>
<span class="cm">			 */</span>
			<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">irq_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
				<span class="n">unmask_ioapic</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_irq_works</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disable_timer_pin_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pin1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;timer doesn&#39;t work through Interrupt-remapped IO-APIC&quot;</span><span class="p">);</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_pin1</span><span class="p">)</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;..MP-BIOS bug: &quot;</span>
				    <span class="s">&quot;8254 timer not connected to IO-APIC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;...trying to set up timer &quot;</span>
			    <span class="s">&quot;(IRQ0) through the 8259A ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			    <span class="s">&quot;..... (found apic %d pin %d) ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * legacy devices should be connected to IO APIC #0</span>
<span class="cm">		 */</span>
		<span class="n">replace_pin_at_irq_node</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">apic1</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">);</span>
		<span class="n">setup_timer_IRQ0_pin</span><span class="p">(</span><span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
		<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">unmask</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_irq_works</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;....... works.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">timer_through_8259</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Cleanup, just in case ...</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">clear_IO_APIC_pin</span><span class="p">(</span><span class="n">apic2</span><span class="p">,</span> <span class="n">pin2</span><span class="p">);</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;....... failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span>
		    <span class="s">&quot;...trying to set up timer as Virtual Wire IRQ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lapic_register_intr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_DM_FIXED</span> <span class="o">|</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>	<span class="cm">/* Fixed mode */</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">unmask</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_irq_works</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;..... works.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_LVT_MASKED</span> <span class="o">|</span> <span class="n">APIC_DM_FIXED</span> <span class="o">|</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;..... failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span>
		    <span class="s">&quot;...trying to set up timer as ExtINT IRQ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">make_irq</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVT0</span><span class="p">,</span> <span class="n">APIC_DM_EXTINT</span><span class="p">);</span>

	<span class="n">unlock_ExtINT_logic</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_irq_works</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;..... works.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span> <span class="s">&quot;..... failed :(.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_preenabled</span><span class="p">)</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			    <span class="s">&quot;Perhaps problem with the pre-enabled x2apic mode</span><span class="se">\n</span><span class="s">&quot;</span>
			    <span class="s">&quot;Try booting with x2apic and interrupt-remapping disabled in the bios.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;IO-APIC + timer doesn&#39;t work!  Boot with apic=debug and send a &quot;</span>
		<span class="s">&quot;report.  Then try booting with the &#39;noapic&#39; option.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Traditionally ISA IRQ2 is the cascade IRQ, and is not available</span>
<span class="cm"> * to devices.  However there may be an I/O APIC pin available for</span>
<span class="cm"> * this interrupt regardless.  The pin may be left unconnected, but</span>
<span class="cm"> * typically it will be reused as an ExtINT cascade interrupt for</span>
<span class="cm"> * the master 8259A.  In the MPS case such a pin will normally be</span>
<span class="cm"> * reported as an ExtINT interrupt in the MP table.  With ACPI</span>
<span class="cm"> * there is no provision for ExtINT interrupts, and in the absence</span>
<span class="cm"> * of an override it would be treated as an ordinary ISA I/O APIC</span>
<span class="cm"> * interrupt, that is edge-triggered and unmasked by default.  We</span>
<span class="cm"> * used to do this, but it caused problems on some systems because</span>
<span class="cm"> * of the NMI watchdog and sometimes IRQ0 of the 8254 timer using</span>
<span class="cm"> * the same ExtINT cascade interrupt to drive the local APIC of the</span>
<span class="cm"> * bootstrap processor.  Therefore we refrain from routing IRQ2 to</span>
<span class="cm"> * the I/O APIC in all cases now.  No actual device should request</span>
<span class="cm"> * it anyway.  --macro</span>
<span class="cm"> */</span>
<span class="cp">#define PIC_IRQS	(1UL &lt;&lt; PIC_CASCADE_IR)</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_IO_APIC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * calling enable_IO_APIC() is moved to setup_local_APIC for BP</span>
<span class="cm">	 */</span>
	<span class="n">io_apic_irqs</span> <span class="o">=</span> <span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span> <span class="o">?</span> <span class="o">~</span><span class="n">PIC_IRQS</span> <span class="o">:</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;ENABLING IO-APIC IRQs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">         * Set up IO-APIC IRQ routing.</span>
<span class="cm">         */</span>
	<span class="n">x86_init</span><span class="p">.</span><span class="n">mpparse</span><span class="p">.</span><span class="n">setup_ioapic_ids</span><span class="p">();</span>

	<span class="n">sync_Arb_IDs</span><span class="p">();</span>
	<span class="n">setup_IO_APIC_irqs</span><span class="p">();</span>
	<span class="n">init_IO_APIC_traps</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">legacy_pic</span><span class="o">-&gt;</span><span class="n">nr_legacy_irqs</span><span class="p">)</span>
		<span class="n">check_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *      Called after all the initialization is done. If we didn&#39;t find any</span>
<span class="cm"> *      APIC bugs then we can allow the modify fast path</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">io_apic_bug_finalize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sis_apic_bug</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">sis_apic_bug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">io_apic_bug_finalize</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">resume_ioapic_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_00</span> <span class="n">reg_00</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>
		<span class="n">io_apic_write</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioapic_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioapic_idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic_idx</span> <span class="o">=</span> <span class="n">nr_ioapics</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ioapic_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic_idx</span><span class="o">--</span><span class="p">)</span>
		<span class="n">resume_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">);</span>

	<span class="n">restore_ioapic_entries</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">ioapic_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">save_ioapic_entries</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">ioapic_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ioapic_init_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_syscore_ops</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">ioapic_init_ops</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamic irq allocate and deallocation</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">create_irq_nr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">nr_irqs_gsi</span><span class="p">)</span>
		<span class="n">from</span> <span class="o">=</span> <span class="n">nr_irqs_gsi</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">alloc_irq_from</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">alloc_irq_cfg</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq_at</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">()))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_set_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="n">irq_clear_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NOREQUEST</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">free_irq_at</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">create_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_want</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">irq_want</span> <span class="o">=</span> <span class="n">nr_irqs_gsi</span><span class="p">;</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">create_irq_nr</span><span class="p">(</span><span class="n">irq_want</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroy_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_NOREQUEST</span><span class="o">|</span><span class="n">IRQ_NOPROBE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>
		<span class="n">free_remapped_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__clear_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">free_irq_at</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * MSI message composition</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msi_compose_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">msi_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">hpet_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dest</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_cfg</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_mask_to_apicid_and</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">compose_remapped_msi_msg</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">hpet_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x2apic_enabled</span><span class="p">())</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">MSI_ADDR_BASE_HI</span> <span class="o">|</span>
				  <span class="n">MSI_ADDR_EXT_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">MSI_ADDR_BASE_HI</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">address_lo</span> <span class="o">=</span>
		<span class="n">MSI_ADDR_BASE_LO</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_dest_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="nl">MSI_ADDR_DEST_MODE_PHYSICAL:</span>
			<span class="n">MSI_ADDR_DEST_MODE_LOGICAL</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_delivery_mode</span> <span class="o">!=</span> <span class="n">dest_LowestPrio</span><span class="p">)</span> <span class="o">?</span>
			<span class="nl">MSI_ADDR_REDIRECTION_CPU:</span>
			<span class="n">MSI_ADDR_REDIRECTION_LOWPRI</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">MSI_ADDR_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span>
		<span class="n">MSI_DATA_TRIGGER_EDGE</span> <span class="o">|</span>
		<span class="n">MSI_DATA_LEVEL_ASSERT</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_delivery_mode</span> <span class="o">!=</span> <span class="n">dest_LowestPrio</span><span class="p">)</span> <span class="o">?</span>
			<span class="nl">MSI_DATA_DELIVERY_FIXED:</span>
			<span class="n">MSI_DATA_DELIVERY_LOWPRI</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">MSI_DATA_VECTOR</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">msi_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ioapic_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">__get_cached_msi_msg</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">msi_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_DATA_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">|=</span> <span class="n">MSI_DATA_VECTOR</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_ADDR_DEST_ID_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">|=</span> <span class="n">MSI_ADDR_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="n">__write_msi_msg</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">msi_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * IRQ Chip for MSI PCI/PCI-X/PCI-Express Devices,</span>
<span class="cm"> * which implement the MSI or MSI-X Capability Structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">msi_chip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;PCI-MSI&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">unmask_msi_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">mask_msi_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_apic_edge</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">msi_set_affinity</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">ioapic_retrigger_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_msi_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="n">msidesc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msi_chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msi_compose_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">irq_set_msi_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">msidesc</span><span class="p">);</span>
	<span class="n">write_msi_msg</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_MOVE_PCNTXT</span><span class="p">);</span>
		<span class="n">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span> <span class="s">&quot;edge&quot;</span><span class="p">);</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;irq %d for MSI/MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">native_setup_msi_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nvec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">sub_handle</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_want</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_desc</span> <span class="o">*</span><span class="n">msidesc</span><span class="p">;</span>

	<span class="cm">/* x86 doesn&#39;t support multiple MSI yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">PCI_CAP_ID_MSI</span> <span class="o">&amp;&amp;</span> <span class="n">nvec</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">irq_want</span> <span class="o">=</span> <span class="n">nr_irqs_gsi</span><span class="p">;</span>
	<span class="n">sub_handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">msidesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">msi_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">create_irq_nr</span><span class="p">(</span><span class="n">irq_want</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">irq_want</span> <span class="o">=</span> <span class="n">irq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_ir</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sub_handle</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * allocate the consecutive block of IRTE&#39;s</span>
<span class="cm">			 * for &#39;nvec&#39;</span>
<span class="cm">			 */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">msi_alloc_remapped_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">nvec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">msi_setup_remapped_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
						     <span class="n">sub_handle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">no_ir:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">setup_msi_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msidesc</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">sub_handle</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">destroy_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">native_teardown_msi_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DMAR_TABLE</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dmar_msi_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ioapic_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dmar_msi_read</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_DATA_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">|=</span> <span class="n">MSI_DATA_VECTOR</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_ADDR_DEST_ID_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">|=</span> <span class="n">MSI_ADDR_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">MSI_ADDR_BASE_HI</span> <span class="o">|</span> <span class="n">MSI_ADDR_EXT_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="n">dmar_msi_write</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">dmar_msi_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;DMAR_MSI&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">dmar_msi_unmask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">dmar_msi_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_apic_edge</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">dmar_msi_set_affinity</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">ioapic_retrigger_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">arch_setup_dmar_msi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msi_compose_msg</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">dmar_msi_write</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmar_msi_type</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span>
				      <span class="s">&quot;edge&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_HPET_TIMER</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpet_msi_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ioapic_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">hpet_msi_read</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">handler_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_DATA_VECTOR_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">data</span> <span class="o">|=</span> <span class="n">MSI_DATA_VECTOR</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSI_ADDR_DEST_ID_MASK</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">|=</span> <span class="n">MSI_ADDR_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="n">hpet_msi_write</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">handler_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">hpet_msi_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;HPET_MSI&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span> <span class="o">=</span> <span class="n">hpet_msi_unmask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span> <span class="o">=</span> <span class="n">hpet_msi_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span> <span class="o">=</span> <span class="n">ack_apic_edge</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span> <span class="o">=</span> <span class="n">hpet_msi_set_affinity</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">irq_retrigger</span> <span class="o">=</span> <span class="n">ioapic_retrigger_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">arch_setup_hpet_msi</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hpet_msi_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msi_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">setup_hpet_msi_remapped</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">msi_compose_msg</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hpet_msi_write</span><span class="p">(</span><span class="n">irq_get_handler_data</span><span class="p">(</span><span class="n">irq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">irq_set_status_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQ_MOVE_PCNTXT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapped</span><span class="p">(</span><span class="n">irq_get_chip_data</span><span class="p">(</span><span class="n">irq</span><span class="p">)))</span>
		<span class="n">irq_remap_modify_chip_defaults</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span> <span class="s">&quot;edge&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Hypertransport interrupt support</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HT_IRQ</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">target_ht_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">,</span> <span class="n">u8</span> <span class="n">vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ht_irq_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">fetch_ht_irq_msg</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HT_IRQ_LOW_VECTOR_MASK</span> <span class="o">|</span> <span class="n">HT_IRQ_LOW_DEST_ID_MASK</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HT_IRQ_HIGH_DEST_ID_MASK</span><span class="p">);</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">|=</span> <span class="n">HT_IRQ_LOW_VECTOR</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="o">|</span> <span class="n">HT_IRQ_LOW_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">|=</span> <span class="n">HT_IRQ_HIGH_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="n">write_ht_irq_msg</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ht_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">chip_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ioapic_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">target_ht_irq</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">ht_irq_chip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;PCI-HT&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>		<span class="o">=</span> <span class="n">mask_ht_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>		<span class="o">=</span> <span class="n">unmask_ht_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>		<span class="o">=</span> <span class="n">ack_apic_edge</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="p">.</span><span class="n">irq_set_affinity</span>	<span class="o">=</span> <span class="n">ht_set_affinity</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">irq_retrigger</span>		<span class="o">=</span> <span class="n">ioapic_retrigger_irq</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">arch_setup_ht_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable_apic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">irq_cfg</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">assign_irq_vector</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ht_irq_msg</span> <span class="n">msg</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">dest</span><span class="p">;</span>

		<span class="n">dest</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">cpu_mask_to_apicid_and</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">,</span>
						    <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">());</span>

		<span class="n">msg</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">HT_IRQ_HIGH_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

		<span class="n">msg</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">=</span>
			<span class="n">HT_IRQ_LOW_BASE</span> <span class="o">|</span>
			<span class="n">HT_IRQ_LOW_DEST_ID</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">HT_IRQ_LOW_VECTOR</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">vector</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_dest_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">HT_IRQ_LOW_DM_PHYSICAL</span> <span class="o">:</span>
				<span class="n">HT_IRQ_LOW_DM_LOGICAL</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">HT_IRQ_LOW_RQEOI_EDGE</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">irq_delivery_mode</span> <span class="o">!=</span> <span class="n">dest_LowestPrio</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">HT_IRQ_LOW_MT_FIXED</span> <span class="o">:</span>
				<span class="n">HT_IRQ_LOW_MT_ARBITRATED</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">HT_IRQ_LOW_IRQ_MASKED</span><span class="p">;</span>

		<span class="n">write_ht_irq_msg</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

		<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ht_irq_chip</span><span class="p">,</span>
					      <span class="n">handle_edge_irq</span><span class="p">,</span> <span class="s">&quot;edge&quot;</span><span class="p">);</span>

		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;irq %d for HT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HT_IRQ */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">io_apic_setup_irq_pin</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_cfg</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">alloc_irq_and_cfg_at</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_pin_to_irq_node</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic_pin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">setup_ioapic_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">io_apic_setup_irq_pin_once</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ioapic_idx</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ioapic_pin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Avoid redundant programming */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">pin_programmed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Pin %d-%d already programmed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">ioapic_idx</span><span class="p">),</span> <span class="n">pin</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">io_apic_setup_irq_pin</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic_idx</span><span class="p">].</span><span class="n">pin_programmed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">io_apic_get_redir_entries</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_01</span>	<span class="n">reg_01</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* The register returns the maximum index redir index</span>
<span class="cm">	 * supported, which is one less than the total number of redir</span>
<span class="cm">	 * entries.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">probe_nr_irqs_gsi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">gsi_top</span> <span class="o">+</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="n">nr_irqs_gsi</span><span class="p">)</span>
		<span class="n">nr_irqs_gsi</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;nr_irqs_gsi: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_irqs_gsi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_nr_irqs_gsi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nr_irqs_gsi</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">arch_probe_nr_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_irqs</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NR_VECTORS</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">))</span>
		<span class="n">nr_irqs</span> <span class="o">=</span> <span class="n">NR_VECTORS</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">nr_irqs_gsi</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)</span>
	<span class="cm">/*</span>
<span class="cm">	 * for MSI and HT dyn irq</span>
<span class="cm">	 */</span>
	<span class="n">nr</span> <span class="o">+=</span> <span class="n">nr_irqs_gsi</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">nr_irqs</span><span class="p">)</span>
		<span class="n">nr_irqs</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NR_IRQS_LEGACY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">io_apic_set_pci_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="o">*</span><span class="n">irq_attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IO_APIC_IRQ</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_QUIET</span><span class="p">,</span><span class="n">KERN_ERR</span> <span class="s">&quot;IOAPIC[%d]: Invalid reference to IRQ 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">irq_attr</span><span class="o">-&gt;</span><span class="n">ioapic</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">io_apic_setup_irq_pin_once</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">irq_attr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">io_apic_get_unique_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apic_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_00</span> <span class="n">reg_00</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">physid_mask_t</span> <span class="n">apic_id_map</span> <span class="o">=</span> <span class="n">PHYSID_MASK_NONE</span><span class="p">;</span>
	<span class="n">physid_mask_t</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The P4 platform supports up to 256 APIC IDs on two separate APIC</span>
<span class="cm">	 * buses (one for LAPICs, one for IOAPICs), where predecessors only</span>
<span class="cm">	 * supports up to 16 on one shared APIC bus.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TBD: Expand LAPIC/IOAPIC support on P4-class systems to take full</span>
<span class="cm">	 *      advantage of new APIC bus architecture.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">physids_empty</span><span class="p">(</span><span class="n">apic_id_map</span><span class="p">))</span>
		<span class="n">apic</span><span class="o">-&gt;</span><span class="n">ioapic_phys_id_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">apic_id_map</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apic_id</span> <span class="o">&gt;=</span> <span class="n">get_physical_broadcast</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IOAPIC[%d]: Invalid apic_id %d, trying &quot;</span>
			<span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">apic_id</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">);</span>
		<span class="n">apic_id</span> <span class="o">=</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Every APIC in a system must have a unique ID or we get lots of nice</span>
<span class="cm">	 * &#39;stuck on smp_invalidate_needed IPI wait&#39; messages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">check_apicid_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apic_id_map</span><span class="p">,</span> <span class="n">apic_id</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_physical_broadcast</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apic</span><span class="o">-&gt;</span><span class="n">check_apicid_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apic_id_map</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">get_physical_broadcast</span><span class="p">())</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Max apic_id exceeded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IOAPIC[%d]: apic_id %d already used, &quot;</span>
			<span class="s">&quot;trying %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">apic_id</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">apic_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">apic</span><span class="o">-&gt;</span><span class="n">apicid_to_cpu_present</span><span class="p">(</span><span class="n">apic_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">physids_or</span><span class="p">(</span><span class="n">apic_id_map</span><span class="p">,</span> <span class="n">apic_id_map</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">apic_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">apic_id</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_apic_write</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span><span class="p">);</span>
		<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_00</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">apic_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IOAPIC[%d]: Unable to change apic_id!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="n">KERN_INFO</span>
			<span class="s">&quot;IOAPIC[%d]: Assigned apic_id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">apic_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">apic_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">__init</span> <span class="nf">io_apic_unique_id</span><span class="p">(</span><span class="n">u8</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_INTEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">APIC_XAPIC</span><span class="p">(</span><span class="n">apic_version</span><span class="p">[</span><span class="n">boot_cpu_physical_apicid</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">io_apic_get_unique_id</span><span class="p">(</span><span class="n">nr_ioapics</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">__init</span> <span class="nf">io_apic_unique_id</span><span class="p">(</span><span class="n">u8</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">used</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">used</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">io_apic_get_version</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_01</span>	<span class="n">reg_01</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioapic_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">bits</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_get_override_irq</span><span class="p">(</span><span class="n">u32</span> <span class="n">gsi</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">trigger</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">polarity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip_ioapic_setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ioapic</span> <span class="o">=</span> <span class="n">mp_find_ioapic</span><span class="p">(</span><span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioapic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">pin</span> <span class="o">=</span> <span class="n">mp_find_ioapic_pin</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">irq_trigger</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="o">*</span><span class="n">polarity</span> <span class="o">=</span> <span class="n">irq_polarity</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function currently is only a helper for the i386 smp boot process where</span>
<span class="cm"> * we need to reprogram the ioredtbls to cater for the cpus which have come online</span>
<span class="cm"> * so mask in all cases should simply be apic-&gt;target_cpus()</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_ioapic_dest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pin</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_entry</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">idata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip_ioapic_setup</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ioapic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ioapic</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">ioapic</span><span class="o">++</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pin</span> <span class="o">&lt;</span> <span class="n">ioapics</span><span class="p">[</span><span class="n">ioapic</span><span class="p">].</span><span class="n">nr_registers</span><span class="p">;</span> <span class="n">pin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq_entry</span> <span class="o">=</span> <span class="n">find_irq_entry</span><span class="p">(</span><span class="n">ioapic</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">mp_INT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_entry</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">pin_2_irq</span><span class="p">(</span><span class="n">irq_entry</span><span class="p">,</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ioapic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">idata</span> <span class="o">=</span> <span class="n">irq_get_irq_data</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Honour affinities which have been set in early boot</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqd_can_balance</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span> <span class="o">||</span> <span class="n">irqd_affinity_was_set</span><span class="p">(</span><span class="n">idata</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">idata</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">target_cpus</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irq_remapping_enabled</span><span class="p">)</span>
			<span class="n">set_remapped_irq_affinity</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ioapic_set_affinity</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define IOAPIC_RESOURCE_NAME_SIZE 11</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ioapic_resources</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">ioapic_setup_resources</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr_ioapics</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_ioapics</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">IOAPIC_RESOURCE_NAME_SIZE</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">*=</span> <span class="n">nr_ioapics</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_ioapics</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
		<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_BUSY</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">IOAPIC_RESOURCE_NAME_SIZE</span><span class="p">,</span> <span class="s">&quot;IOAPIC %u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mem</span> <span class="o">+=</span> <span class="n">IOAPIC_RESOURCE_NAME_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioapic_resources</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">native_io_apic_init_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ioapic_phys</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">FIX_IO_APIC_BASE_0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ioapic_res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ioapic_res</span> <span class="o">=</span> <span class="n">ioapic_setup_resources</span><span class="p">(</span><span class="n">nr_ioapics</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smp_found_config</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioapic_phys</span> <span class="o">=</span> <span class="n">mpc_ioapic_addr</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioapic_phys</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;WARNING: bogus zero IO-APIC &quot;</span>
				       <span class="s">&quot;address found in MPTABLE, &quot;</span>
				       <span class="s">&quot;disabling IO/APIC support!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">smp_found_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">skip_ioapic_setup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fake_ioapic_page</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="nl">fake_ioapic_page:</span>
<span class="cp">#endif</span>
			<span class="n">ioapic_phys</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">alloc_bootmem_pages</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">ioapic_phys</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">ioapic_phys</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_fixmap_nocache</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ioapic_phys</span><span class="p">);</span>
		<span class="n">apic_printk</span><span class="p">(</span><span class="n">APIC_VERBOSE</span><span class="p">,</span> <span class="s">&quot;mapped IOAPIC to %08lx (%08lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ioapic_phys</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">),</span>
			<span class="n">ioapic_phys</span><span class="p">);</span>
		<span class="n">idx</span><span class="o">++</span><span class="p">;</span>

		<span class="n">ioapic_res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">ioapic_phys</span><span class="p">;</span>
		<span class="n">ioapic_res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">ioapic_phys</span> <span class="o">+</span> <span class="n">IO_APIC_SLOT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ioapic_res</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">probe_nr_irqs_gsi</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">ioapic_insert_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">ioapic_resources</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_ioapics</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;IO APIC resources couldn&#39;t be allocated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">r</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mp_find_ioapic</span><span class="p">(</span><span class="n">u32</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_ioapics</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find the IOAPIC that manages this GSI. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_ioapics</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span> <span class="o">*</span><span class="n">gsi_cfg</span> <span class="o">=</span> <span class="n">mp_ioapic_gsi_routing</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">gsi</span> <span class="o">&gt;=</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_base</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gsi</span> <span class="o">&lt;=</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ERROR: Unable to locate IOAPIC for GSI %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gsi</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mp_find_ioapic_pin</span><span class="p">(</span><span class="kt">int</span> <span class="n">ioapic</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span> <span class="o">*</span><span class="n">gsi_cfg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">ioapic</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">gsi_cfg</span> <span class="o">=</span> <span class="n">mp_ioapic_gsi_routing</span><span class="p">(</span><span class="n">ioapic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">gsi</span> <span class="o">&gt;</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">gsi</span> <span class="o">-</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">bad_ioapic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_ioapics</span> <span class="o">&gt;=</span> <span class="n">MAX_IO_APICS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;WARNING: Max # of I/O APICs (%d) exceeded (found %d), skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">MAX_IO_APICS</span><span class="p">,</span> <span class="n">nr_ioapics</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;WARNING: Bogus (zero) I/O APIC address found in table, skipping!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">bad_ioapic_register</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_00</span> <span class="n">reg_00</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_01</span> <span class="n">reg_01</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">IO_APIC_reg_02</span> <span class="n">reg_02</span><span class="p">;</span>

	<span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">io_apic_read</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_00</span><span class="p">.</span><span class="n">raw</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">reg_01</span><span class="p">.</span><span class="n">raw</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">reg_02</span><span class="p">.</span><span class="n">raw</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;I/O APIC 0x%x registers return all ones, skipping!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mpc_ioapic_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">mp_register_ioapic</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">gsi_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mp_ioapic_gsi</span> <span class="o">*</span><span class="n">gsi_cfg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_ioapic</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">nr_ioapics</span><span class="p">;</span>

	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MP_IOAPIC</span><span class="p">;</span>
	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MPC_APIC_USABLE</span><span class="p">;</span>
	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicaddr</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>

	<span class="n">set_fixmap_nocache</span><span class="p">(</span><span class="n">FIX_IO_APIC_BASE_0</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bad_ioapic_register</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_fixmap</span><span class="p">(</span><span class="n">FIX_IO_APIC_BASE_0</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">io_apic_unique_id</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">mp_config</span><span class="p">.</span><span class="n">apicver</span> <span class="o">=</span> <span class="n">io_apic_get_version</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build basic GSI lookup table to facilitate gsi-&gt;io_apic lookups</span>
<span class="cm">	 * and to prevent reprogramming of IOAPIC pins (PCI GSIs).</span>
<span class="cm">	 */</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">io_apic_get_redir_entries</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="n">gsi_cfg</span> <span class="o">=</span> <span class="n">mp_ioapic_gsi_routing</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_base</span> <span class="o">=</span> <span class="n">gsi_base</span><span class="p">;</span>
	<span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span> <span class="o">=</span> <span class="n">gsi_base</span> <span class="o">+</span> <span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The number of IO-APIC IRQ registers (== #pins):</span>
<span class="cm">	 */</span>
	<span class="n">ioapics</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">nr_registers</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span> <span class="o">&gt;=</span> <span class="n">gsi_top</span><span class="p">)</span>
		<span class="n">gsi_top</span> <span class="o">=</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IOAPIC[%d]: apic_id %d, version %d, address 0x%x, GSI %d-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">idx</span><span class="p">,</span> <span class="n">mpc_ioapic_id</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
		<span class="n">mpc_ioapic_ver</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">mpc_ioapic_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
		<span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_base</span><span class="p">,</span> <span class="n">gsi_cfg</span><span class="o">-&gt;</span><span class="n">gsi_end</span><span class="p">);</span>

	<span class="n">nr_ioapics</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enable IOAPIC early just for system timer */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pre_init_apic_IRQ0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_apic_irq_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Early APIC setup for system timer0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="n">physid_set_mask_of_physid</span><span class="p">(</span><span class="n">boot_cpu_physical_apicid</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">phys_cpu_present_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">setup_local_APIC</span><span class="p">();</span>

	<span class="n">io_apic_setup_irq_pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">irq_set_chip_and_handler_name</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioapic_chip</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">,</span>
				      <span class="s">&quot;edge&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
