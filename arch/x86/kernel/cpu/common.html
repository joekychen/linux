<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › cpu › common.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>common.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;asm/stackprotector.h&gt;</span>
<span class="cp">#include &lt;asm/perf_event.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/archrandom.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/debugreg.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/fpu-internal.h&gt;</span>
<span class="cp">#include &lt;asm/mtrr.h&gt;</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;asm/asm.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>
<span class="cp">#include &lt;asm/pat.h&gt;</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="cp">#include &lt;asm/uv/uv.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;cpu.h&quot;</span>

<span class="cm">/* all of these masks are initialized in setup_cpu_local_masks() */</span>
<span class="n">cpumask_var_t</span> <span class="n">cpu_initialized_mask</span><span class="p">;</span>
<span class="n">cpumask_var_t</span> <span class="n">cpu_callout_mask</span><span class="p">;</span>
<span class="n">cpumask_var_t</span> <span class="n">cpu_callin_mask</span><span class="p">;</span>

<span class="cm">/* representing cpus for which sibling maps can be computed */</span>
<span class="n">cpumask_var_t</span> <span class="n">cpu_sibling_setup_mask</span><span class="p">;</span>

<span class="cm">/* correctly size the local cpu masks */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_cpu_local_masks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_initialized_mask</span><span class="p">);</span>
	<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_callin_mask</span><span class="p">);</span>
	<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_callout_mask</span><span class="p">);</span>
	<span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_sibling_setup_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">default_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">cpu_detect_cache_sizes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/* Not much we can do here... */</span>
	<span class="cm">/* Check if at least it has cpuid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No cpuid. It must be an ancient CPU */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">,</span> <span class="s">&quot;486&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">,</span> <span class="s">&quot;386&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_dev</span> <span class="n">__cpuinitconst</span> <span class="n">default_cpu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">c_init</span>		<span class="o">=</span> <span class="n">default_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_vendor</span>	<span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_x86_vendor</span>	<span class="o">=</span> <span class="n">X86_VENDOR_UNKNOWN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_dev</span> <span class="o">*</span><span class="n">this_cpu</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_cpu</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">gdt_page</span><span class="p">,</span> <span class="n">gdt_page</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">gdt</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need valid kernel segments for data and code in long mode too</span>
<span class="cm">	 * IRET will check the segment types  kkeil 2000/10/28</span>
<span class="cm">	 * Also sysret mandates a special GDT layout</span>
<span class="cm">	 *</span>
<span class="cm">	 * TLS descriptors are currently at a different place compared to i386.</span>
<span class="cm">	 * Hopefully nobody expects them at a fixed place (Wine?)</span>
<span class="cm">	 */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_KERNEL32_CS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc09b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_CS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xa09b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_DS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc093</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER32_CS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_DS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0f3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_CS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xa0fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
<span class="cp">#else</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_CS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc09a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_DS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_CS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0fa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_DS</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0f2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * Segments used for calling PnP BIOS have byte granularity.</span>
<span class="cm">	 * They code segments and data segments have fixed 64k limits,</span>
<span class="cm">	 * the transfer segment sizes are set at run time.</span>
<span class="cm">	 */</span>
	<span class="cm">/* 32-bit code */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_CS32</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x409a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="cm">/* 16-bit code */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_CS16</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x009a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="cm">/* 16-bit data */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_DS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="cm">/* 16-bit data */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_TS1</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/* 16-bit data */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_TS2</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * The APM segments have byte granularity and their bases</span>
<span class="cm">	 * are set at run time.  All have 64k limits.</span>
<span class="cm">	 */</span>
	<span class="cm">/* 32-bit code */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x409a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="cm">/* 16-bit code */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x009a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
	<span class="cm">/* data */</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x4092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>

	<span class="p">[</span><span class="n">GDT_ENTRY_ESPFIX_SS</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="p">[</span><span class="n">GDT_ENTRY_PERCPU</span><span class="p">]</span>		<span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
	<span class="n">GDT_STACK_CANARY_INIT</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="p">};</span>
<span class="n">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="p">(</span><span class="n">gdt_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">x86_xsave_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_XSAVE</span><span class="p">);</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_XSAVEOPT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noxsave&quot;</span><span class="p">,</span> <span class="n">x86_xsave_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">x86_xsaveopt_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_XSAVEOPT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noxsaveopt&quot;</span><span class="p">,</span> <span class="n">x86_xsaveopt_setup</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cachesize_override</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_x86_serial_nr</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cachesize_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cachesize_override</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;cachesize=&quot;</span><span class="p">,</span> <span class="n">cachesize_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">x86_fxsr_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_FXSR</span><span class="p">);</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_XMM</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nofxsr&quot;</span><span class="p">,</span> <span class="n">x86_fxsr_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">x86_sep_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_SEP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nosep&quot;</span><span class="p">,</span> <span class="n">x86_sep_setup</span><span class="p">);</span>

<span class="cm">/* Standard macro to see if a specific flag is changeable */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">flag_is_changeable_p</span><span class="p">(</span><span class="n">u32</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cyrix and IDT cpus allow disabling of CPUID</span>
<span class="cm">	 * so the code below may return different results</span>
<span class="cm">	 * when it is executed before and after enabling</span>
<span class="cm">	 * the CPUID. Add &quot;volatile&quot; to not allow gcc to</span>
<span class="cm">	 * optimize the subsequent calls to this function.</span>
<span class="cm">	 */</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;pushfl		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;pushfl		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;popl %0		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;movl %0, %1	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;xorl %2, %0	</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;pushl %0		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;popfl		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;pushfl		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;popl %0		</span><span class="se">\n\t</span><span class="s">&quot;</span>
		      <span class="s">&quot;popfl		</span><span class="se">\n\t</span><span class="s">&quot;</span>

		      <span class="o">:</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">f1</span><span class="p">),</span> <span class="s">&quot;=&amp;r&quot;</span> <span class="p">(</span><span class="n">f2</span><span class="p">)</span>
		      <span class="o">:</span> <span class="s">&quot;ir&quot;</span> <span class="p">(</span><span class="n">flag</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">f1</span><span class="o">^</span><span class="n">f2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Probe for the CPUID instruction */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">have_cpuid_p</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">flag_is_changeable_p</span><span class="p">(</span><span class="n">X86_EFLAGS_ID</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">squash_the_stupid_serial_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_PN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">disable_x86_serial_nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Disable processor serial number: */</span>

	<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_IA32_BBL_CR_CTL</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">|=</span> <span class="mh">0x200000</span><span class="p">;</span>
	<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_BBL_CR_CTL</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;CPU serial number disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">clear_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_PN</span><span class="p">);</span>

	<span class="cm">/* Disabling the serial number may affect the cpuid level */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">=</span> <span class="n">cpuid_eax</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">x86_serial_nr_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_x86_serial_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;serialnumber&quot;</span><span class="p">,</span> <span class="n">x86_serial_nr_setup</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">flag_is_changeable_p</span><span class="p">(</span><span class="n">u32</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Probe for the CPUID instruction */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">have_cpuid_p</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">squash_the_stupid_serial_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_smep</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_disable_smep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_smep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nosmep&quot;</span><span class="p">,</span> <span class="n">setup_disable_smep</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">setup_smep</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_SMEP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">disable_smep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_SMEP</span><span class="p">);</span>
			<span class="n">clear_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_SMEP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">set_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_SMEP</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some CPU features depend on higher CPUID levels, which may not always</span>
<span class="cm"> * be available due to CPUID level capping or broken virtualization</span>
<span class="cm"> * software.  Add those features to this table to auto-disable them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpuid_dependent_feature</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">feature</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">level</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpuid_dependent_feature</span> <span class="n">__cpuinitconst</span>
<span class="n">cpuid_dependent_features</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">X86_FEATURE_MWAIT</span><span class="p">,</span>		<span class="mh">0x00000005</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">X86_FEATURE_DCA</span><span class="p">,</span>		<span class="mh">0x00000009</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">X86_FEATURE_XSAVE</span><span class="p">,</span>		<span class="mh">0x0000000d</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">filter_cpuid_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">bool</span> <span class="n">warn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpuid_dependent_feature</span> <span class="o">*</span><span class="n">df</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">df</span> <span class="o">=</span> <span class="n">cpuid_dependent_features</span><span class="p">;</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">;</span> <span class="n">df</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: cpuid_level is set to -1 if unavailable, but</span>
<span class="cm">		 * extended_extended_level is set to 0 if unavailable</span>
<span class="cm">		 * and the legitimate extended levels are all negative</span>
<span class="cm">		 * when signed; hence the weird messing around with</span>
<span class="cm">		 * signs here...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">s32</span><span class="p">)</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span>
		     <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">:</span>
		     <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">clear_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warn</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;CPU: CPU feature %s disabled, no CPUID level 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">x86_cap_flags</span><span class="p">[</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">],</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Naming convention should be: &lt;Name&gt; [(&lt;Codename&gt;)]</span>
<span class="cm"> * This table only is used unless init_&lt;vendor&gt;() below doesn&#39;t set it;</span>
<span class="cm"> * in particular, if CPUID levels 0x80000002..4 are supported, this</span>
<span class="cm"> * isn&#39;t used</span>
<span class="cm"> */</span>

<span class="cm">/* Look up CPU names by table lookup. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__cpuinit</span> <span class="nf">table_lookup_model</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_model_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Range check */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_cpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_models</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">model_names</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span><span class="p">];</span>
		<span class="n">info</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* Not found */</span>
<span class="p">}</span>

<span class="n">__u32</span> <span class="n">cpu_caps_cleared</span><span class="p">[</span><span class="n">NCAPINTS</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>
<span class="n">__u32</span> <span class="n">cpu_caps_set</span><span class="p">[</span><span class="n">NCAPINTS</span><span class="p">]</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">load_percpu_segment</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">loadsegment</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">__KERNEL_PERCPU</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">loadsegment</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_GS_BASE</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">irq_stack_union</span><span class="p">.</span><span class="n">gs_base</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">load_stack_canary_segment</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Current gdt points %fs at the &quot;master&quot; per-cpu area: after this,</span>
<span class="cm"> * it&#39;s on the real one.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">switch_to_new_gdt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">gdt_descr</span><span class="p">;</span>

	<span class="n">gdt_descr</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">gdt_descr</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">GDT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">load_gdt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdt_descr</span><span class="p">);</span>
	<span class="cm">/* Reload the per-cpu base */</span>

	<span class="n">load_percpu_segment</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_dev</span> <span class="o">*</span><span class="n">__cpuinitdata</span> <span class="n">cpu_devs</span><span class="p">[</span><span class="n">X86_VENDOR_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">get_model_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">&lt;</span> <span class="mh">0x80000004</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">;</span>
	<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x80000002</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x80000003</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x80000004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">11</span><span class="p">]);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Intel chips right-justify this string for some dumb reason;</span>
<span class="cm">	 * undo that brain damage:</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
			<span class="o">*</span><span class="n">q</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">48</span><span class="p">])</span>
			<span class="o">*</span><span class="n">q</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* Zero-pad the rest */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cpu_detect_cache_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">,</span> <span class="n">l2size</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mh">0x80000005</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x80000005</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecx</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">edx</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
		<span class="cm">/* On K8 L1 TLB is inclusive, so don&#39;t count it */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_tlbsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mh">0x80000006</span><span class="p">)</span>	<span class="cm">/* Some chips just has a large L1. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x80000006</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>
	<span class="n">l2size</span> <span class="o">=</span> <span class="n">ecx</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_tlbsize</span> <span class="o">+=</span> <span class="p">((</span><span class="n">ebx</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ebx</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/* do processor-specific cache resizing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_size_cache</span><span class="p">)</span>
		<span class="n">l2size</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_size_cache</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l2size</span><span class="p">);</span>

	<span class="cm">/* Allow user to override all this if necessary. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachesize_override</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">l2size</span> <span class="o">=</span> <span class="n">cachesize_override</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l2size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* Again, no L2 cache is possible */</span>
<span class="cp">#endif</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_size</span> <span class="o">=</span> <span class="n">l2size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">detect_ht</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_HT</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index_msb</span><span class="p">,</span> <span class="n">core_bits</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">printed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_HT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_CMP_LEGACY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_XTOPOLOGY</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

	<span class="n">smp_num_siblings</span> <span class="o">=</span> <span class="p">(</span><span class="n">ebx</span> <span class="o">&amp;</span> <span class="mh">0xff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_num_siblings</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU0: Hyper-Threading is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smp_num_siblings</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">index_msb</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">smp_num_siblings</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">phys_pkg_id</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">,</span> <span class="n">index_msb</span><span class="p">);</span>

	<span class="n">smp_num_siblings</span> <span class="o">=</span> <span class="n">smp_num_siblings</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_max_cores</span><span class="p">;</span>

	<span class="n">index_msb</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">smp_num_siblings</span><span class="p">);</span>

	<span class="n">core_bits</span> <span class="o">=</span> <span class="n">get_count_order</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_max_cores</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_core_id</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">phys_pkg_id</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">,</span> <span class="n">index_msb</span><span class="p">)</span> <span class="o">&amp;</span>
				       <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">core_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_max_cores</span> <span class="o">*</span> <span class="n">smp_num_siblings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>  <span class="s">&quot;CPU: Physical Processor ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>  <span class="s">&quot;CPU: Processor Core ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_core_id</span><span class="p">);</span>
		<span class="n">printed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">get_cpu_vendor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">X86_VENDOR_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">c_ident</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">c_ident</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">c_ident</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="p">{</span>

			<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_x86_vendor</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;CPU: vendor_id &#39;%s&#39; unknown, using generic init.</span><span class="se">\n</span><span class="s">&quot;</span> \
			<span class="s">&quot;CPU: Your system may be unstable.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">=</span> <span class="n">X86_VENDOR_UNKNOWN</span><span class="p">;</span>
	<span class="n">this_cpu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cpu_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Get vendor name */</span>
	<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span><span class="p">,</span>
	      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
	      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* Intel-defined flags: level 0x00000001 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">junk</span><span class="p">,</span> <span class="n">tfms</span><span class="p">,</span> <span class="n">cap0</span><span class="p">,</span> <span class="n">misc</span><span class="p">;</span>

		<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">misc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">junk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap0</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">=</span> <span class="p">(</span><span class="n">tfms</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">tfms</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_mask</span> <span class="o">=</span> <span class="n">tfms</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0xf</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tfms</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">&gt;=</span> <span class="mh">0x6</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">+=</span> <span class="p">((</span><span class="n">tfms</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cap0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">19</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">misc</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_alignment</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">get_cpu_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tfms</span><span class="p">,</span> <span class="n">xlvl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ebx</span><span class="p">;</span>

	<span class="cm">/* Intel-defined flags: level 0x00000001 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">capability</span><span class="p">,</span> <span class="n">excap</span><span class="p">;</span>

		<span class="n">cpuid</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">excap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">capability</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">capability</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">excap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Additional Intel-defined flags: level 0x00000007 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x00000007</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

		<span class="n">cpuid_count</span><span class="p">(</span><span class="mh">0x00000007</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* AMD-defined flags: level 0x80000001 */</span>
	<span class="n">xlvl</span> <span class="o">=</span> <span class="n">cpuid_eax</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">=</span> <span class="n">xlvl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xlvl</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xlvl</span> <span class="o">&gt;=</span> <span class="mh">0x80000001</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuid_edx</span><span class="p">(</span><span class="mh">0x80000001</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuid_ecx</span><span class="p">(</span><span class="mh">0x80000001</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x80000008</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">eax</span> <span class="o">=</span> <span class="n">cpuid_eax</span><span class="p">(</span><span class="mh">0x80000008</span><span class="p">);</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_virt_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">eax</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="n">eax</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_PAE</span><span class="p">)</span> <span class="o">||</span> <span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_PSE36</span><span class="p">))</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x80000007</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_power</span> <span class="o">=</span> <span class="n">cpuid_edx</span><span class="p">(</span><span class="mh">0x80000007</span><span class="p">);</span>

	<span class="n">init_scattered_cpuid_features</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">identify_cpu_without_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First of all, decide if this is a 486 or higher</span>
<span class="cm">	 * It&#39;s a 486 if we can modify the AC flag</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag_is_changeable_p</span><span class="p">(</span><span class="n">X86_EFLAGS_AC</span><span class="p">))</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">X86_VENDOR_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">c_identify</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cpu_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">c_identify</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">get_cpu_vendor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do minimum CPU detection early.</span>
<span class="cm"> * Fields really needed: vendor, cpuid_level, family, model, mask,</span>
<span class="cm"> * cache alignment.</span>
<span class="cm"> * The others are not touched to avoid unwanted side effects.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: this function is only called on the BP.  Don&#39;t add code here</span>
<span class="cm"> * that is supposed to run on all CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_identify_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_virt_bits</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_virt_bits</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_alignment</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_cpuid_p</span><span class="p">())</span>
		<span class="n">identify_cpu_without_cpuid</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* cyrix could have cpuid enabled via c_identify()*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_cpuid_p</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_detect</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">get_cpu_vendor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">get_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_early_init</span><span class="p">)</span>
		<span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_early_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">filter_cpuid_features</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">setup_smep</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_bsp_init</span><span class="p">)</span>
		<span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_bsp_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">early_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_dev</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">cdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROCESSOR_SELECT</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;KERNEL supported cpus:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">__x86_cpu_dev_start</span><span class="p">;</span> <span class="n">cdev</span> <span class="o">&lt;</span> <span class="n">__x86_cpu_dev_end</span><span class="p">;</span> <span class="n">cdev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_dev</span> <span class="o">*</span><span class="n">cpudev</span> <span class="o">=</span> <span class="o">*</span><span class="n">cdev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">X86_VENDOR_NUM</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpu_devs</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpudev</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROCESSOR_SELECT</span>
		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpudev</span><span class="o">-&gt;</span><span class="n">c_ident</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpudev</span><span class="o">-&gt;</span><span class="n">c_vendor</span><span class="p">,</span>
					<span class="n">cpudev</span><span class="o">-&gt;</span><span class="n">c_ident</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">early_identify_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The NOPL instruction is supposed to exist on all CPUs of family &gt;= 6;</span>
<span class="cm"> * unfortunately, that&#39;s not true in practice because of early VIA</span>
<span class="cm"> * chips and (more importantly) broken virtualizers that are not easy</span>
<span class="cm"> * to detect. In the latter case it doesn&#39;t even *fail* reliably, so</span>
<span class="cm"> * probing for it doesn&#39;t even work. Disable it completely on 32-bit</span>
<span class="cm"> * unless we can find a reliable way to detect all the broken cases.</span>
<span class="cm"> * Enable it explicitly on 64-bit for non-constant inputs of cpu_has().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">detect_nopl</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">clear_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_NOPL</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">set_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_NOPL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">generic_identify</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">extended_cpuid_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_cpuid_p</span><span class="p">())</span>
		<span class="n">identify_cpu_without_cpuid</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* cyrix could have cpuid enabled via c_identify()*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_cpuid_p</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_detect</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">get_cpu_vendor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">get_cpu_cap</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpuid_ebx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp"># ifdef CONFIG_X86_HT</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">phys_pkg_id</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp"># else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">;</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">phys_proc_id</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setup_smep</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">get_model_name</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="cm">/* Default name */</span>

	<span class="n">detect_nopl</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This does the hard work of actually picking apart the CPU stuff...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">identify_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">=</span> <span class="n">X86_VENDOR_UNKNOWN</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* So far unknown... */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* Unset */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>  <span class="cm">/* Unset */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_max_cores</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_coreid_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_virt_bits</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* CPUID not detected */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_phys_bits</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_virt_bits</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_cache_alignment</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_clflush_size</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">);</span>

	<span class="n">generic_identify</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_identify</span><span class="p">)</span>
		<span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_identify</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Clear/Set all flags overriden by options, after probe */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCAPINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_caps_cleared</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_caps_set</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">apic</span><span class="o">-&gt;</span><span class="n">phys_pkg_id</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initial_apicid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Vendor-specific initialization.  In this section we</span>
<span class="cm">	 * canonicalize the feature flags, meaning if there are</span>
<span class="cm">	 * features a certain CPU supports which CPUID doesn&#39;t</span>
<span class="cm">	 * tell us, CPUID claiming incorrect flags, or other bugs,</span>
<span class="cm">	 * we handle them here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * At the end of this section, c-&gt;x86_capability better</span>
<span class="cm">	 * indicate the features this CPU genuinely supports!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_init</span><span class="p">)</span>
		<span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Disable the PN if appropriate */</span>
	<span class="n">squash_the_stupid_serial_number</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The vendor-specific functions might have changed features.</span>
<span class="cm">	 * Now we do &quot;generic changes.&quot;</span>
<span class="cm">	 */</span>

	<span class="cm">/* Filter out anything that depends on CPUID levels we don&#39;t have */</span>
	<span class="n">filter_cpuid_features</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* If the model name is still unset, do table lookup. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">table_lookup_model</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* Last resort... */</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">,</span> <span class="s">&quot;%02x/%02x&quot;</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">detect_ht</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">init_hypervisor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">x86_init_rdrand</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear/Set all flags overriden by options, need do it</span>
<span class="cm">	 * before following smp all cpus cap AND.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCAPINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_caps_cleared</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_caps_set</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * On SMP, boot_cpu_data holds the common feature set between</span>
<span class="cm">	 * all CPUs; so make sure that we indicate which features are</span>
<span class="cm">	 * common between the CPUs.  The first time this routine gets</span>
<span class="cm">	 * executed, c == &amp;boot_cpu_data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* AND the already accumulated flags with these */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NCAPINTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_capability</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* Init Machine Check Exception if available. */</span>
	<span class="n">mcheck_cpu_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">select_idle_routine</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">numa_add_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vgetcpu_set_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">,</span> <span class="n">X86_FEATURE_RDTSCP</span><span class="p">))</span>
		<span class="n">vgetcpu_mode</span> <span class="o">=</span> <span class="n">VGETCPU_RDTSCP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vgetcpu_mode</span> <span class="o">=</span> <span class="n">VGETCPU_LSL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">identify_boot_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">identify_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">);</span>
	<span class="n">init_amd_e400_c1e_mask</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">sysenter_setup</span><span class="p">();</span>
	<span class="n">enable_sep_cpu</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">vgetcpu_set_mode</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">identify_secondary_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">);</span>
	<span class="n">identify_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">enable_sep_cpu</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">mtrr_ap_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">msr_range</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">min</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">msr_range</span> <span class="n">msr_range_array</span><span class="p">[]</span> <span class="n">__cpuinitconst</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000418</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0xc0000000</span><span class="p">,</span> <span class="mh">0xc000040b</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0xc0010000</span><span class="p">,</span> <span class="mh">0xc0010142</span><span class="p">},</span>
	<span class="p">{</span> <span class="mh">0xc0011000</span><span class="p">,</span> <span class="mh">0xc001103b</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">__print_cpu_msr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">index_min</span><span class="p">,</span> <span class="n">index_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">msr_range_array</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index_min</span> <span class="o">=</span> <span class="n">msr_range_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span><span class="p">;</span>
		<span class="n">index_max</span> <span class="o">=</span> <span class="n">msr_range_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">max</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">index_min</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">index_max</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rdmsrl_amd_safe</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot; MSR%08x: %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">show_msr</span> <span class="n">__cpuinitdata</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_show_msr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">show_msr</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;show_msr=&quot;</span><span class="p">,</span> <span class="n">setup_show_msr</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_noclflush</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_CLFLSH</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;noclflush&quot;</span><span class="p">,</span> <span class="n">setup_noclflush</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">print_cpu_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">&lt;</span> <span class="n">X86_VENDOR_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vendor</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="o">-&gt;</span><span class="n">c_vendor</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">vendor</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vendor</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">,</span> <span class="n">vendor</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">vendor</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%d86&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_mask</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; stepping %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">print_cpu_msr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">print_cpu_msr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">&lt;</span> <span class="n">show_msr</span><span class="p">)</span>
		<span class="n">__print_cpu_msr</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">setup_disablecpuid</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="n">NCAPINTS</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span>
		<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;clearcpuid=&quot;</span><span class="p">,</span> <span class="n">setup_disablecpuid</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">idt_descr</span> <span class="o">=</span> <span class="p">{</span> <span class="n">NR_VECTORS</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">idt_table</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">nmi_idt_descr</span> <span class="o">=</span> <span class="p">{</span> <span class="n">NR_VECTORS</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nmi_idt_table</span> <span class="p">};</span>

<span class="n">DEFINE_PER_CPU_FIRST</span><span class="p">(</span><span class="k">union</span> <span class="n">irq_stack_union</span><span class="p">,</span>
		     <span class="n">irq_stack_union</span><span class="p">)</span> <span class="n">__aligned</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The following four percpu variables are hot.  Align current_task to</span>
<span class="cm"> * cacheline size such that all four fall in the same cacheline.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_task</span><span class="p">)</span> <span class="n">____cacheline_aligned</span> <span class="o">=</span>
	<span class="o">&amp;</span><span class="n">init_task</span><span class="p">;</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">current_task</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">kernel_stack</span><span class="p">)</span> <span class="o">=</span>
	<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">init_thread_union</span> <span class="o">-</span> <span class="n">KERNEL_STACK_OFFSET</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">;</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">kernel_stack</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">irq_stack_ptr</span><span class="p">)</span> <span class="o">=</span>
	<span class="n">init_per_cpu_var</span><span class="p">(</span><span class="n">irq_stack_union</span><span class="p">.</span><span class="n">irq_stack</span><span class="p">)</span> <span class="o">+</span> <span class="n">IRQ_STACK_SIZE</span> <span class="o">-</span> <span class="mi">64</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">irq_count</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">fpu_owner_task</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Special IST stacks which the CPU switches to when it calls</span>
<span class="cm"> * an IST-marked descriptor entry. Up to 7 stacks (hardware</span>
<span class="cm"> * limit), all of them are 4K, except the debug stack which</span>
<span class="cm"> * is 8K.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exception_stack_sizes</span><span class="p">[</span><span class="n">N_EXCEPTION_STACKS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	  <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">N_EXCEPTION_STACKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXCEPTION_STKSZ</span><span class="p">,</span>
	  <span class="p">[</span><span class="n">DEBUG_STACK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>			<span class="o">=</span> <span class="n">DEBUG_STKSZ</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">exception_stacks</span>
	<span class="p">[(</span><span class="n">N_EXCEPTION_STACKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">EXCEPTION_STKSZ</span> <span class="o">+</span> <span class="n">DEBUG_STKSZ</span><span class="p">]);</span>

<span class="cm">/* May not be marked __init: used by software suspend */</span>
<span class="kt">void</span> <span class="nf">syscall_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * LSTAR and STAR live in a bit strange symbiosis.</span>
<span class="cm">	 * They both write to the same internal register. STAR allows to</span>
<span class="cm">	 * set CS/DS but only a 32bit target. LSTAR sets the 64bit rip.</span>
<span class="cm">	 */</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_STAR</span><span class="p">,</span>  <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">__USER32_CS</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">48</span>  <span class="o">|</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">__KERNEL_CS</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_LSTAR</span><span class="p">,</span> <span class="n">system_call</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_CSTAR</span><span class="p">,</span> <span class="n">ignore_sysret</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IA32_EMULATION</span>
	<span class="n">syscall32_cpu_init</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* Flags to clear on syscall */</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_SYSCALL_MASK</span><span class="p">,</span>
	       <span class="n">X86_EFLAGS_TF</span><span class="o">|</span><span class="n">X86_EFLAGS_DF</span><span class="o">|</span><span class="n">X86_EFLAGS_IF</span><span class="o">|</span><span class="n">X86_EFLAGS_IOPL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_eflags</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Copies of the original ist values from the tss are only accessed during</span>
<span class="cm"> * debugging, no special alignment required.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">orig_ist</span><span class="p">,</span> <span class="n">orig_ist</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">debug_stack_addr</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">debug_stack_usage</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_debug_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">debug_stack_usage</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">debug_stack_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">addr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">debug_stack_addr</span><span class="p">)</span> <span class="o">-</span> <span class="n">DEBUG_STKSZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">debug_stack_use_ctr</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_stack_set_zero</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">debug_stack_use_ctr</span><span class="p">);</span>
	<span class="n">load_idt</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nmi_idt_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_stack_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_read</span><span class="p">(</span><span class="n">debug_stack_use_ctr</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu_dec_return</span><span class="p">(</span><span class="n">debug_stack_use_ctr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">load_idt</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_task</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_task</span><span class="p">;</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">current_task</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">fpu_owner_task</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR</span>
<span class="n">DEFINE_PER_CPU_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">stack_canary</span><span class="p">,</span> <span class="n">stack_canary</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Make sure %fs and %gs are initialized properly in idle threads */</span>
<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">__cpuinit</span> <span class="nf">idle_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">=</span> <span class="n">__KERNEL_PERCPU</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gs</span> <span class="o">=</span> <span class="n">__KERNEL_STACK_CANARY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">regs</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86_64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Clear all 6 debug registers:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_all_debug_regs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ignore db4, db5 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">set_debugreg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KGDB</span>
<span class="cm">/*</span>
<span class="cm"> * Restore debug regs if using kgdbwait and you have a kernel debugger</span>
<span class="cm"> * connection established.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbg_restore_debug_regs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kgdb_connected</span> <span class="o">&amp;&amp;</span> <span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">correct_hw_break</span><span class="p">))</span>
		<span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">correct_hw_break</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* ! CONFIG_KGDB */</span><span class="cp"></span>
<span class="cp">#define dbg_restore_debug_regs()</span>
<span class="cp">#endif </span><span class="cm">/* ! CONFIG_KGDB */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * cpu_init() initializes state that is per-CPU. Some data is already</span>
<span class="cm"> * initialized (naturally) in the bootstrap process, such as the GDT</span>
<span class="cm"> * and IDT. We reload them nevertheless, this function acts as a</span>
<span class="cm"> * &#39;CPU state barrier&#39;, nothing should get across.</span>
<span class="cm"> * A lot of state is already set up in PDA init for 64 bit</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">orig_ist</span> <span class="o">*</span><span class="n">oist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">stack_smp_processor_id</span><span class="p">();</span>
	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">init_tss</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">oist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">orig_ist</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">numa_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">set_numa_node</span><span class="p">(</span><span class="n">early_cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">me</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_and_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_initialized_mask</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;CPU#%d already initialized!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Initializing CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">clear_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_VME</span><span class="o">|</span><span class="n">X86_CR4_PVI</span><span class="o">|</span><span class="n">X86_CR4_TSD</span><span class="o">|</span><span class="n">X86_CR4_DE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the per-CPU GDT with the boot GDT,</span>
<span class="cm">	 * and set up the GDT descriptor:</span>
<span class="cm">	 */</span>

	<span class="n">switch_to_new_gdt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">loadsegment</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">load_idt</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tls_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GDT_ENTRY_TLS_ENTRIES</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">syscall_init</span><span class="p">();</span>

	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_FS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_KERNEL_GS_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">x86_configure_nx</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">enable_x2apic</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * set up and load the per-CPU TSS</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oist</span><span class="o">-&gt;</span><span class="n">ist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">estacks</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">exception_stacks</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">N_EXCEPTION_STACKS</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">estacks</span> <span class="o">+=</span> <span class="n">exception_stack_sizes</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
			<span class="n">oist</span><span class="o">-&gt;</span><span class="n">ist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">ist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">estacks</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">DEBUG_STACK</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">per_cpu</span><span class="p">(</span><span class="n">debug_stack_addr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">estacks</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">io_bitmap_base</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span><span class="p">,</span> <span class="n">io_bitmap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * &lt;= is required because the CPU will access up to</span>
<span class="cm">	 * 8 bits beyond the end of the IO permission bitmap.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">IO_BITMAP_LONGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">me</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">me</span><span class="p">);</span>

	<span class="n">load_sp0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="n">set_tss_desc</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">load_TR_desc</span><span class="p">();</span>
	<span class="n">load_LDT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>

	<span class="n">clear_all_debug_regs</span><span class="p">();</span>
	<span class="n">dbg_restore_debug_regs</span><span class="p">();</span>

	<span class="n">fpu_init</span><span class="p">();</span>
	<span class="n">xsave_init</span><span class="p">();</span>

	<span class="n">raw_local_save_flags</span><span class="p">(</span><span class="n">kernel_eflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_uv_system</span><span class="p">())</span>
		<span class="n">uv_cpu_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">init_tss</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_and_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_initialized_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;CPU#%d already initialized!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Initializing CPU#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_vme</span> <span class="o">||</span> <span class="n">cpu_has_tsc</span> <span class="o">||</span> <span class="n">cpu_has_de</span><span class="p">)</span>
		<span class="n">clear_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_VME</span><span class="o">|</span><span class="n">X86_CR4_PVI</span><span class="o">|</span><span class="n">X86_CR4_TSD</span><span class="o">|</span><span class="n">X86_CR4_DE</span><span class="p">);</span>

	<span class="n">load_idt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>
	<span class="n">switch_to_new_gdt</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up and load the per-CPU TSS and LDT</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_count</span><span class="p">);</span>
	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>

	<span class="n">load_sp0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
	<span class="n">set_tss_desc</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">load_TR_desc</span><span class="p">();</span>
	<span class="n">load_LDT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">x86_tss</span><span class="p">.</span><span class="n">io_bitmap_base</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span><span class="p">,</span> <span class="n">io_bitmap</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DOUBLEFAULT</span>
	<span class="cm">/* Set up doublefault TSS pointer in the GDT */</span>
	<span class="n">__set_tss_desc</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">GDT_ENTRY_DOUBLEFAULT_TSS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doublefault_tss</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">clear_all_debug_regs</span><span class="p">();</span>
	<span class="n">dbg_restore_debug_regs</span><span class="p">();</span>

	<span class="n">fpu_init</span><span class="p">();</span>
	<span class="n">xsave_init</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
