<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › cpu › perf_event_intel_lbr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>perf_event_intel_lbr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &lt;asm/perf_event.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>
<span class="cp">#include &lt;asm/insn.h&gt;</span>

<span class="cp">#include &quot;perf_event.h&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LBR_FORMAT_32</span>		<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">LBR_FORMAT_LIP</span>		<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">LBR_FORMAT_EIP</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">LBR_FORMAT_EIP_FLAGS</span>	<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Intel LBR_SELECT bits</span>
<span class="cm"> * Intel Vol3a, April 2011, Section 16.7 Table 16-10</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware branch filter (not available on all CPUs)</span>
<span class="cm"> */</span>
<span class="cp">#define LBR_KERNEL_BIT		0 </span><span class="cm">/* do not capture at ring0 */</span><span class="cp"></span>
<span class="cp">#define LBR_USER_BIT		1 </span><span class="cm">/* do not capture at ring &gt; 0 */</span><span class="cp"></span>
<span class="cp">#define LBR_JCC_BIT		2 </span><span class="cm">/* do not capture conditional branches */</span><span class="cp"></span>
<span class="cp">#define LBR_REL_CALL_BIT	3 </span><span class="cm">/* do not capture relative calls */</span><span class="cp"></span>
<span class="cp">#define LBR_IND_CALL_BIT	4 </span><span class="cm">/* do not capture indirect calls */</span><span class="cp"></span>
<span class="cp">#define LBR_RETURN_BIT		5 </span><span class="cm">/* do not capture near returns */</span><span class="cp"></span>
<span class="cp">#define LBR_IND_JMP_BIT		6 </span><span class="cm">/* do not capture indirect jumps */</span><span class="cp"></span>
<span class="cp">#define LBR_REL_JMP_BIT		7 </span><span class="cm">/* do not capture relative jumps */</span><span class="cp"></span>
<span class="cp">#define LBR_FAR_BIT		8 </span><span class="cm">/* do not capture far branches */</span><span class="cp"></span>

<span class="cp">#define LBR_KERNEL	(1 &lt;&lt; LBR_KERNEL_BIT)</span>
<span class="cp">#define LBR_USER	(1 &lt;&lt; LBR_USER_BIT)</span>
<span class="cp">#define LBR_JCC		(1 &lt;&lt; LBR_JCC_BIT)</span>
<span class="cp">#define LBR_REL_CALL	(1 &lt;&lt; LBR_REL_CALL_BIT)</span>
<span class="cp">#define LBR_IND_CALL	(1 &lt;&lt; LBR_IND_CALL_BIT)</span>
<span class="cp">#define LBR_RETURN	(1 &lt;&lt; LBR_RETURN_BIT)</span>
<span class="cp">#define LBR_REL_JMP	(1 &lt;&lt; LBR_REL_JMP_BIT)</span>
<span class="cp">#define LBR_IND_JMP	(1 &lt;&lt; LBR_IND_JMP_BIT)</span>
<span class="cp">#define LBR_FAR		(1 &lt;&lt; LBR_FAR_BIT)</span>

<span class="cp">#define LBR_PLM (LBR_KERNEL | LBR_USER)</span>

<span class="cp">#define LBR_SEL_MASK	0x1ff	</span><span class="cm">/* valid bits in LBR_SELECT */</span><span class="cp"></span>
<span class="cp">#define LBR_NOT_SUPP	-1	</span><span class="cm">/* LBR filter not supported */</span><span class="cp"></span>
<span class="cp">#define LBR_IGN		0	</span><span class="cm">/* ignored */</span><span class="cp"></span>

<span class="cp">#define LBR_ANY		 \</span>
<span class="cp">	(LBR_JCC	|\</span>
<span class="cp">	 LBR_REL_CALL	|\</span>
<span class="cp">	 LBR_IND_CALL	|\</span>
<span class="cp">	 LBR_RETURN	|\</span>
<span class="cp">	 LBR_REL_JMP	|\</span>
<span class="cp">	 LBR_IND_JMP	|\</span>
<span class="cp">	 LBR_FAR)</span>

<span class="cp">#define LBR_FROM_FLAG_MISPRED  (1ULL &lt;&lt; 63)</span>

<span class="cp">#define for_each_branch_sample_type(x) \</span>
<span class="cp">	for ((x) = PERF_SAMPLE_BRANCH_USER; \</span>
<span class="cp">	     (x) &lt; PERF_SAMPLE_BRANCH_MAX; (x) &lt;&lt;= 1)</span>

<span class="cm">/*</span>
<span class="cm"> * x86control flow change classification</span>
<span class="cm"> * x86control flow changes include branches, interrupts, traps, faults</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">X86_BR_NONE</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* unknown */</span>

	<span class="n">X86_BR_USER</span>     <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* branch target is user */</span>
	<span class="n">X86_BR_KERNEL</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* branch target is kernel */</span>

	<span class="n">X86_BR_CALL</span>     <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* call */</span>
	<span class="n">X86_BR_RET</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* return */</span>
	<span class="n">X86_BR_SYSCALL</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* syscall */</span>
	<span class="n">X86_BR_SYSRET</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* syscall return */</span>
	<span class="n">X86_BR_INT</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* sw interrupt */</span>
	<span class="n">X86_BR_IRET</span>     <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/* return from interrupt */</span>
	<span class="n">X86_BR_JCC</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/* conditional */</span>
	<span class="n">X86_BR_JMP</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">,</span> <span class="cm">/* jump */</span>
	<span class="n">X86_BR_IRQ</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span><span class="cm">/* hw interrupt or trap or fault */</span>
	<span class="n">X86_BR_IND_CALL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">,</span><span class="cm">/* indirect calls */</span>
<span class="p">};</span>

<span class="cp">#define X86_BR_PLM (X86_BR_USER | X86_BR_KERNEL)</span>

<span class="cp">#define X86_BR_ANY       \</span>
<span class="cp">	(X86_BR_CALL    |\</span>
<span class="cp">	 X86_BR_RET     |\</span>
<span class="cp">	 X86_BR_SYSCALL |\</span>
<span class="cp">	 X86_BR_SYSRET  |\</span>
<span class="cp">	 X86_BR_INT     |\</span>
<span class="cp">	 X86_BR_IRET    |\</span>
<span class="cp">	 X86_BR_JCC     |\</span>
<span class="cp">	 X86_BR_JMP	 |\</span>
<span class="cp">	 X86_BR_IRQ	 |\</span>
<span class="cp">	 X86_BR_IND_CALL)</span>

<span class="cp">#define X86_BR_ALL (X86_BR_PLM | X86_BR_ANY)</span>

<span class="cp">#define X86_BR_ANY_CALL		 \</span>
<span class="cp">	(X86_BR_CALL		|\</span>
<span class="cp">	 X86_BR_IND_CALL	|\</span>
<span class="cp">	 X86_BR_SYSCALL		|\</span>
<span class="cp">	 X86_BR_IRQ		|\</span>
<span class="cp">	 X86_BR_INT)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">intel_pmu_lbr_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We only support LBR implementations that have FREEZE_LBRS_ON_PMI</span>
<span class="cm"> * otherwise it becomes near impossible to get a reliable stack.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__intel_pmu_lbr_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">debugctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_sel</span><span class="p">)</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_LBR_SELECT</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_sel</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctl</span><span class="p">);</span>
	<span class="n">debugctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DEBUGCTLMSR_LBR</span> <span class="o">|</span> <span class="n">DEBUGCTLMSR_FREEZE_LBRS_ON_PMI</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__intel_pmu_lbr_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">debugctl</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctl</span><span class="p">);</span>
	<span class="n">debugctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DEBUGCTLMSR_LBR</span> <span class="o">|</span> <span class="n">DEBUGCTLMSR_FREEZE_LBRS_ON_PMI</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_DEBUGCTLMSR</span><span class="p">,</span> <span class="n">debugctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_pmu_lbr_reset_32</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_pmu_lbr_reset_64</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>   <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_cap</span><span class="p">.</span><span class="n">lbr_format</span> <span class="o">==</span> <span class="n">LBR_FORMAT_32</span><span class="p">)</span>
		<span class="n">intel_pmu_lbr_reset_32</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">intel_pmu_lbr_reset_64</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the LBR stack if we changed task context to</span>
<span class="cm">	 * avoid data leaks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_context</span> <span class="o">!=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intel_pmu_lbr_reset</span><span class="p">();</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_context</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">br_sel</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">branch_reg</span><span class="p">.</span><span class="n">reg</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="o">--</span><span class="p">;</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__intel_pmu_lbr_disable</span><span class="p">();</span>
		<span class="cm">/* avoid stale pointer */</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_enable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="p">)</span>
		<span class="n">__intel_pmu_lbr_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_disable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="p">)</span>
		<span class="n">__intel_pmu_lbr_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TOS = most recently recorded branch</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">intel_pmu_lbr_tos</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tos</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_tos</span><span class="p">,</span> <span class="n">tos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_pmu_lbr_read_32</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tos</span> <span class="o">=</span> <span class="n">intel_pmu_lbr_tos</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lbr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tos</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">from</span><span class="p">;</span>
				<span class="n">u32</span> <span class="n">to</span><span class="p">;</span>
			<span class="p">};</span>
			<span class="n">u64</span>     <span class="n">lbr</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">msr_lastbranch</span><span class="p">;</span>

		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span> <span class="o">+</span> <span class="n">lbr_idx</span><span class="p">,</span> <span class="n">msr_lastbranch</span><span class="p">.</span><span class="n">lbr</span><span class="p">);</span>

		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span>	<span class="o">=</span> <span class="n">msr_lastbranch</span><span class="p">.</span><span class="n">from</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span>		<span class="o">=</span> <span class="n">msr_lastbranch</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mispred</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">predicted</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reserved</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Due to lack of segmentation in Linux the effective address (offset)</span>
<span class="cm"> * is the same as the linear address, allowing us to merge the LIP and EIP</span>
<span class="cm"> * LBR formats.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_pmu_lbr_read_64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lbr_format</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_cap</span><span class="p">.</span><span class="n">lbr_format</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tos</span> <span class="o">=</span> <span class="n">intel_pmu_lbr_tos</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lbr_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tos</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span> <span class="o">+</span> <span class="n">lbr_idx</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>   <span class="o">+</span> <span class="n">lbr_idx</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lbr_format</span> <span class="o">==</span> <span class="n">LBR_FORMAT_EIP_FLAGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mis</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">from</span> <span class="o">&amp;</span> <span class="n">LBR_FROM_FLAG_MISPRED</span><span class="p">);</span>
			<span class="n">pred</span> <span class="o">=</span> <span class="o">!</span><span class="n">mis</span><span class="p">;</span>
			<span class="n">from</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)((((</span><span class="n">s64</span><span class="p">)</span><span class="n">from</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span>	<span class="o">=</span> <span class="n">from</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span>		<span class="o">=</span> <span class="n">to</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mispred</span>	<span class="o">=</span> <span class="n">mis</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">predicted</span>	<span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reserved</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">intel_pmu_lbr_read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_users</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_cap</span><span class="p">.</span><span class="n">lbr_format</span> <span class="o">==</span> <span class="n">LBR_FORMAT_32</span><span class="p">)</span>
		<span class="n">intel_pmu_lbr_read_32</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">intel_pmu_lbr_read_64</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>

	<span class="n">intel_pmu_lbr_filter</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SW filter is used:</span>
<span class="cm"> * - in case there is no HW filter</span>
<span class="cm"> * - in case the HW filter has errata or limitations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_pmu_setup_sw_lbr_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">br_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">branch_sample_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_USER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_KERNEL</span><span class="p">;</span>

	<span class="cm">/* we ignore BRANCH_HV here */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_ANY</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_ANY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_ANY_CALL</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_ANY_CALL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_ANY_RETURN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_RET</span> <span class="o">|</span> <span class="n">X86_BR_IRET</span> <span class="o">|</span> <span class="n">X86_BR_SYSRET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_IND_CALL</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">X86_BR_IND_CALL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * stash actual user request into reg, it may</span>
<span class="cm">	 * be used by fixup code for some CPU</span>
<span class="cm">	 */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">branch_reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setup the HW LBR filter</span>
<span class="cm"> * Used only when available, may not be enough to disambiguate</span>
<span class="cm"> * all branches, may need the help of the SW filter</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_pmu_setup_hw_lbr_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event_extra</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">br_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">branch_sample_type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">for_each_branch_sample_type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">br_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">v</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_map</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">LBR_NOT_SUPP</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">LBR_IGN</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">v</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">branch_reg</span><span class="p">;</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">EXTRA_REG_LBR</span><span class="p">;</span>

	<span class="cm">/* LBR_SELECT operates in suppress mode so invert mask */</span>
	<span class="n">reg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">intel_pmu_setup_lbr_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no LBR on this PMU</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup SW LBR filter</span>
<span class="cm">	 */</span>
	<span class="n">intel_pmu_setup_sw_lbr_filter</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup HW LBR filter, if any</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_map</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">intel_pmu_setup_hw_lbr_filter</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return the type of control flow change at address &quot;from&quot;</span>
<span class="cm"> * intruction is not necessarily a branch (in case of interrupt).</span>
<span class="cm"> *</span>
<span class="cm"> * The branch type returned also includes the priv level of the</span>
<span class="cm"> * target of the control flow change (X86_BR_USER, X86_BR_KERNEL).</span>
<span class="cm"> *</span>
<span class="cm"> * If a branch type is unknown OR the instruction cannot be</span>
<span class="cm"> * decoded (e.g., text page not present), then X86_BR_NONE is</span>
<span class="cm"> * returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">branch_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">insn</span> <span class="n">insn</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">MAX_INSN_SIZE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ext</span><span class="p">,</span> <span class="n">to_plm</span><span class="p">,</span> <span class="n">from_plm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_INSN_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">is64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">to_plm</span> <span class="o">=</span> <span class="n">kernel_ip</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">?</span> <span class="n">X86_BR_KERNEL</span> <span class="o">:</span> <span class="n">X86_BR_USER</span><span class="p">;</span>
	<span class="n">from_plm</span> <span class="o">=</span> <span class="n">kernel_ip</span><span class="p">(</span><span class="n">from</span><span class="p">)</span> <span class="o">?</span> <span class="n">X86_BR_KERNEL</span> <span class="o">:</span> <span class="n">X86_BR_USER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * maybe zero if lbr did not fill up after a reset by the time</span>
<span class="cm">	 * we get a PMU interrupt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from_plm</span> <span class="o">==</span> <span class="n">X86_BR_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * can happen if measuring at the user level only</span>
<span class="cm">		 * and we interrupt in a kernel thread, e.g., idle.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>

		<span class="cm">/* may fail if text not present */</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">copy_from_user_nmi</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * decoder needs to know the ABI especially</span>
<span class="cm">	 * on 64-bit systems running 32-bit apps</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">is64</span> <span class="o">=</span> <span class="n">kernel_ip</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_IA32</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">insn_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">is64</span><span class="p">);</span>
	<span class="n">insn_get_opcode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">insn</span><span class="p">.</span><span class="n">opcode</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xf</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">insn</span><span class="p">.</span><span class="n">opcode</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x05</span>: <span class="cm">/* syscall */</span>
		<span class="k">case</span> <span class="mh">0x34</span>: <span class="cm">/* sysenter */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_SYSCALL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x07</span>: <span class="cm">/* sysret */</span>
		<span class="k">case</span> <span class="mh">0x35</span>: <span class="cm">/* sysexit */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_SYSRET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x80</span> <span class="p">...</span> <span class="mh">0x8f</span>: <span class="cm">/* conditional */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_JCC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x70</span> <span class="p">...</span> <span class="mh">0x7f</span>: <span class="cm">/* conditional */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_JCC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xc2</span>: <span class="cm">/* near ret */</span>
	<span class="k">case</span> <span class="mh">0xc3</span>: <span class="cm">/* near ret */</span>
	<span class="k">case</span> <span class="mh">0xca</span>: <span class="cm">/* far ret */</span>
	<span class="k">case</span> <span class="mh">0xcb</span>: <span class="cm">/* far ret */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_RET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xcf</span>: <span class="cm">/* iret */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_IRET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xcc</span> <span class="p">...</span> <span class="mh">0xce</span>: <span class="cm">/* int */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_INT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe8</span>: <span class="cm">/* call near rel */</span>
	<span class="k">case</span> <span class="mh">0x9a</span>: <span class="cm">/* call far absolute */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_CALL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe0</span> <span class="p">...</span> <span class="mh">0xe3</span>: <span class="cm">/* loop jmp */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_JCC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe9</span> <span class="p">...</span> <span class="mh">0xeb</span>: <span class="cm">/* jmp */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_JMP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xff</span>: <span class="cm">/* call near absolute, call far absolute ind */</span>
		<span class="n">insn_get_modrm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>
		<span class="n">ext</span> <span class="o">=</span> <span class="p">(</span><span class="n">insn</span><span class="p">.</span><span class="n">modrm</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* near ind call */</span>
		<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* far ind call */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_IND_CALL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
		<span class="k">case</span> <span class="mi">5</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_JMP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * interrupts, traps, faults (and thus ring transition) may</span>
<span class="cm">	 * occur on any instructions. Thus, to classify them correctly,</span>
<span class="cm">	 * we need to first look at the from and to priv levels. If they</span>
<span class="cm">	 * are different and to is in the kernel, then it indicates</span>
<span class="cm">	 * a ring transition. If the from instruction is not a ring</span>
<span class="cm">	 * transition instr (syscall, systenter, int), then it means</span>
<span class="cm">	 * it was a irq, trap or fault.</span>
<span class="cm">	 *</span>
<span class="cm">	 * we have no way of detecting kernel to kernel faults.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from_plm</span> <span class="o">==</span> <span class="n">X86_BR_USER</span> <span class="o">&amp;&amp;</span> <span class="n">to_plm</span> <span class="o">==</span> <span class="n">X86_BR_KERNEL</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="n">X86_BR_SYSCALL</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="n">X86_BR_INT</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">X86_BR_IRQ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * branch priv level determined by target as</span>
<span class="cm">	 * is done by HW when LBR_SELECT is implemented</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">X86_BR_NONE</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">to_plm</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * implement actual branch filter based on user demand.</span>
<span class="cm"> * Hardware may not exactly satisfy that request, thus</span>
<span class="cm"> * we need to inspect opcodes. Mismatched branches are</span>
<span class="cm"> * discarded. Therefore, the number of branches returned</span>
<span class="cm"> * in PERF_SAMPLE_BRANCH_STACK sample may vary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">intel_pmu_lbr_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">br_sel</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">br_sel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">compress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* if sampling all branches, then nothing to filter */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">br_sel</span> <span class="o">&amp;</span> <span class="n">X86_BR_ALL</span><span class="p">)</span> <span class="o">==</span> <span class="n">X86_BR_ALL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">from</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">branch_type</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

		<span class="cm">/* if type does not correspond, then discard */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">X86_BR_NONE</span> <span class="o">||</span> <span class="p">(</span><span class="n">br_sel</span> <span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">compress</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compress</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* remove all entries with from=0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span>
				<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_stack</span><span class="p">.</span><span class="n">nr</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">lbr_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map interface branch filters onto LBR filters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nhm_lbr_sel_map</span><span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_ANY</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_USER</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_KERNEL</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_HV</span><span class="p">]</span>		<span class="o">=</span> <span class="n">LBR_IGN</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY_RETURN</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_RETURN</span> <span class="o">|</span> <span class="n">LBR_REL_JMP</span>
					<span class="o">|</span> <span class="n">LBR_IND_JMP</span> <span class="o">|</span> <span class="n">LBR_FAR</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * NHM/WSM erratum: must include REL_JMP+IND_JMP to get CALL branches</span>
<span class="cm">	 */</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY_CALL</span><span class="p">]</span> <span class="o">=</span>
	 <span class="n">LBR_REL_CALL</span> <span class="o">|</span> <span class="n">LBR_IND_CALL</span> <span class="o">|</span> <span class="n">LBR_REL_JMP</span> <span class="o">|</span> <span class="n">LBR_IND_JMP</span> <span class="o">|</span> <span class="n">LBR_FAR</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * NHM/WSM erratum: must include IND_JMP to capture IND_CALL</span>
<span class="cm">	 */</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_IND_CALL</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBR_IND_CALL</span> <span class="o">|</span> <span class="n">LBR_IND_JMP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">snb_lbr_sel_map</span><span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_ANY</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_USER</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_KERNEL</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_HV</span><span class="p">]</span>		<span class="o">=</span> <span class="n">LBR_IGN</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY_RETURN</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_RETURN</span> <span class="o">|</span> <span class="n">LBR_FAR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_ANY_CALL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_REL_CALL</span> <span class="o">|</span> <span class="n">LBR_IND_CALL</span>
					<span class="o">|</span> <span class="n">LBR_FAR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PERF_SAMPLE_BRANCH_IND_CALL</span><span class="p">]</span>	<span class="o">=</span> <span class="n">LBR_IND_CALL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* core */</span>
<span class="kt">void</span> <span class="nf">intel_pmu_lbr_init_core</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span>     <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_tos</span>    <span class="o">=</span> <span class="n">MSR_LBR_TOS</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span>   <span class="o">=</span> <span class="n">MSR_LBR_CORE_FROM</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>     <span class="o">=</span> <span class="n">MSR_LBR_CORE_TO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SW branch filter usage:</span>
<span class="cm">	 * - compensate for lack of HW filter</span>
<span class="cm">	 */</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;4-deep LBR, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* nehalem/westmere */</span>
<span class="kt">void</span> <span class="nf">intel_pmu_lbr_init_nhm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span>     <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_tos</span>    <span class="o">=</span> <span class="n">MSR_LBR_TOS</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span>   <span class="o">=</span> <span class="n">MSR_LBR_NHM_FROM</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>     <span class="o">=</span> <span class="n">MSR_LBR_NHM_TO</span><span class="p">;</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_mask</span> <span class="o">=</span> <span class="n">LBR_SEL_MASK</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_map</span>  <span class="o">=</span> <span class="n">nhm_lbr_sel_map</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SW branch filter usage:</span>
<span class="cm">	 * - workaround LBR_SEL errata (see above)</span>
<span class="cm">	 * - support syscall, sysret capture.</span>
<span class="cm">	 *   That requires LBR_FAR but that means far</span>
<span class="cm">	 *   jmp need to be filtered out</span>
<span class="cm">	 */</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;16-deep LBR, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* sandy bridge */</span>
<span class="kt">void</span> <span class="nf">intel_pmu_lbr_init_snb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span>	 <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_tos</span>	 <span class="o">=</span> <span class="n">MSR_LBR_TOS</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span> <span class="o">=</span> <span class="n">MSR_LBR_NHM_FROM</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>   <span class="o">=</span> <span class="n">MSR_LBR_NHM_TO</span><span class="p">;</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_mask</span> <span class="o">=</span> <span class="n">LBR_SEL_MASK</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_sel_map</span>  <span class="o">=</span> <span class="n">snb_lbr_sel_map</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SW branch filter usage:</span>
<span class="cm">	 * - support syscall, sysret capture.</span>
<span class="cm">	 *   That requires LBR_FAR but that means far</span>
<span class="cm">	 *   jmp need to be filtered out</span>
<span class="cm">	 */</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;16-deep LBR, &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* atom */</span>
<span class="kt">void</span> <span class="nf">intel_pmu_lbr_init_atom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * only models starting at stepping 10 seems</span>
<span class="cm">	 * to have an operational LBR which can freeze</span>
<span class="cm">	 * on PMU interrupt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_mask</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;LBR disabled due to erratum&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span>	   <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_tos</span>    <span class="o">=</span> <span class="n">MSR_LBR_TOS</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_from</span>   <span class="o">=</span> <span class="n">MSR_LBR_CORE_FROM</span><span class="p">;</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_to</span>     <span class="o">=</span> <span class="n">MSR_LBR_CORE_TO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SW branch filter usage:</span>
<span class="cm">	 * - compensate for lack of HW filter</span>
<span class="cm">	 */</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;8-deep LBR, &quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
