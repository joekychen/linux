<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › cpu › perf_event.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>perf_event.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Performance events x86 architecture code</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2008 Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *  Copyright (C) 2008-2009 Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *  Copyright (C) 2009 Jaswinder Singh Rajput</span>
<span class="cm"> *  Copyright (C) 2009 Advanced Micro Devices, Inc., Robert Richter</span>
<span class="cm"> *  Copyright (C) 2008-2009 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> *  Copyright (C) 2009 Intel Corporation, &lt;markus.t.metzger@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2009 Google, Inc., Stephane Eranian</span>
<span class="cm"> *</span>
<span class="cm"> *  For licencing details see kernel-base/COPYING</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>

<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/stacktrace.h&gt;</span>
<span class="cp">#include &lt;asm/nmi.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#include &lt;asm/alternative.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>

<span class="cp">#include &quot;perf_event.h&quot;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#undef wrmsrl</span>
<span class="c">#define wrmsrl(msr, val) 					\</span>
<span class="c">do {								\</span>
<span class="c">	trace_printk(&quot;wrmsrl(%lx, %lx)\n&quot;, (unsigned long)(msr),\</span>
<span class="c">			(unsigned long)(val));			\</span>
<span class="c">	native_write_msr((msr), (u32)((u64)(val)), 		\</span>
<span class="c">			(u32)((u64)(val) &gt;&gt; 32));		\</span>
<span class="c">} while (0)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">x86_pmu</span> <span class="n">x86_pmu</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu_hw_events</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">hw_cache_event_ids</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_MAX</span><span class="p">]</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span><span class="p">]</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">];</span>
<span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">hw_cache_extra_regs</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_MAX</span><span class="p">]</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span><span class="p">]</span>
				<span class="p">[</span><span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Propagate event elapsed time into the generic event.</span>
<span class="cm"> * Can only be executed on the CPU where the event is active.</span>
<span class="cm"> * Returns the delta events processed.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">x86_perf_event_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">-</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">prev_raw_count</span><span class="p">,</span> <span class="n">new_raw_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">X86_PMC_IDX_FIXED_BTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Careful: an NMI might modify the previous event value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Our tactic to handle this is to first atomically read and</span>
<span class="cm">	 * exchange a new raw count - then add that new-prev delta</span>
<span class="cm">	 * count to the generic event atomically:</span>
<span class="cm">	 */</span>
<span class="nl">again:</span>
	<span class="n">prev_raw_count</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">);</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span><span class="p">,</span> <span class="n">new_raw_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local64_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">prev_raw_count</span><span class="p">,</span>
					<span class="n">new_raw_count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_raw_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we have the new raw value and have updated the prev</span>
<span class="cm">	 * timestamp already. We can now calculate the elapsed delta</span>
<span class="cm">	 * (event-)time and add that to the generic event.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Careful, not all hw sign-extends above the physical width</span>
<span class="cm">	 * of the count.</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_raw_count</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">prev_raw_count</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">local64_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_raw_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find and validate any extra registers to set up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">x86_pmu_extra_regs</span><span class="p">(</span><span class="n">u64</span> <span class="n">config</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event_extra</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extra_reg</span> <span class="o">*</span><span class="n">er</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">extra_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">extra_regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">er</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">extra_regs</span><span class="p">;</span> <span class="n">er</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">;</span> <span class="n">er</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">!=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">er</span><span class="o">-&gt;</span><span class="n">config_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">valid_mask</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">er</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config1</span><span class="p">;</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">=</span> <span class="n">er</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">active_events</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">reserve_pmc_hardware</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reserve_perfctr_nmi</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">perfctr_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reserve_evntsel_nmi</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">eventsel_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">eventsel_fail:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">release_evntsel_nmi</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span>

<span class="nl">perfctr_fail:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">release_perfctr_nmi</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_pmc_hardware</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_perfctr_nmi</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">release_evntsel_nmi</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">reserve_pmc_hardware</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_pmc_hardware</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_hw_exists</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">val_new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if the BIOS enabled any of the counters, if so</span>
<span class="cm">	 * complain and bail.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">msr_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ARCH_PERFMON_EVENTSEL_ENABLE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bios_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">MSR_ARCH_PERFMON_FIXED_CTR_CTRL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">msr_fail</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bios_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now write a value and read it back to see if it matches,</span>
<span class="cm">	 * this is needed to detect certain hardware emulators (qemu/kvm)</span>
<span class="cm">	 * that don&#39;t trap on the MSR access and always return 0s.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mh">0xabcdUL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">checking_wrmsrl</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">val_new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">val_new</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">msr_fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">bios_fail:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We still allow the PMU driver to operate:</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;Broken BIOS detected, complain to your hardware vendor.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">FW_BUG</span> <span class="s">&quot;the BIOS has corrupted hw-PMU resources (MSR %x is %Lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">msr_fail:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;Broken PMU hardware detected, using software events only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hw_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active_events</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">release_pmc_hardware</span><span class="p">();</span>
		<span class="n">release_ds_buffers</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">x86_pmu_initialized</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">handle_irq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">set_ext_hw_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cache_type</span><span class="p">,</span> <span class="n">cache_op</span><span class="p">,</span> <span class="n">cache_result</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">config</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">config</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">;</span>

	<span class="n">cache_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_type</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cache_op</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_op</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_OP_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cache_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_result</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_HW_CACHE_RESULT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">hw_cache_event_ids</span><span class="p">[</span><span class="n">cache_type</span><span class="p">][</span><span class="n">cache_op</span><span class="p">][</span><span class="n">cache_result</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">|=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">config1</span> <span class="o">=</span> <span class="n">hw_cache_extra_regs</span><span class="p">[</span><span class="n">cache_type</span><span class="p">][</span><span class="n">cache_op</span><span class="p">][</span><span class="n">cache_result</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">x86_pmu_extra_regs</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x86_setup_perfctr</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">config</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">max_period</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have a PMU initialized but no APIC</span>
<span class="cm">		 * interrupts, we cannot sample hardware</span>
<span class="cm">		 * events (user-space has to fall back and</span>
<span class="cm">		 * sample via a hrtimer based software event):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">apic</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_RAW</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">x86_pmu_extra_regs</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_HW_CACHE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">set_ext_hw_attr</span><span class="p">(</span><span class="n">hwc</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">&gt;=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">max_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The generic map:</span>
<span class="cm">	 */</span>
	<span class="n">config</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">event_map</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Branch tracing:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">==</span> <span class="n">PERF_COUNT_HW_BRANCH_INSTRUCTIONS</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">&amp;&amp;</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* BTS is not supported by this architecture. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">bts_active</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="cm">/* BTS is currently only allowed for user-mode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_kernel</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config</span> <span class="o">|=</span> <span class="n">config</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check that branch_sample_type is compatible with</span>
<span class="cm"> * settings needed for precise_ip &gt; 1 which implies</span>
<span class="cm"> * using the LBR to capture ALL taken branches at the</span>
<span class="cm"> * priv levels of the measurement</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">precise_br_compat</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">m</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">branch_sample_type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* must capture all branches */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_ANY</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">&amp;=</span> <span class="n">PERF_SAMPLE_BRANCH_KERNEL</span> <span class="o">|</span> <span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">)</span>
		<span class="n">b</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
		<span class="n">b</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ignore PERF_SAMPLE_BRANCH_HV, not supported on x86</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">m</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x86_pmu_hw_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">precise_ip</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">precise</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Support for constant skid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">pebs_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">precise</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* Support for IP fixup */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">lbr_nr</span><span class="p">)</span>
				<span class="n">precise</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">precise_ip</span> <span class="o">&gt;</span> <span class="n">precise</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * check that PEBS LBR correction does not conflict with</span>
<span class="cm">		 * whatever the user is asking with attr-&gt;branch_sample_type</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">precise_ip</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="o">*</span><span class="n">br_type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">branch_sample_type</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">precise_br_compat</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

				<span class="cm">/* branch_sample_type is compatible */</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * user did not specify  branch_sample_type</span>
<span class="cm">				 *</span>
<span class="cm">				 * For PEBS fixups, we capture all</span>
<span class="cm">				 * the branches at the priv level of the</span>
<span class="cm">				 * event.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">br_type</span> <span class="o">=</span> <span class="n">PERF_SAMPLE_BRANCH_ANY</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">)</span>
					<span class="o">*</span><span class="n">br_type</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
					<span class="o">*</span><span class="n">br_type</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate PMC IRQs:</span>
<span class="cm">	 * (keep &#39;enabled&#39; bit clear for now)</span>
<span class="cm">	 */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">ARCH_PERFMON_EVENTSEL_INT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count user and OS events unless requested not to</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">|=</span> <span class="n">ARCH_PERFMON_EVENTSEL_USR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">|=</span> <span class="n">ARCH_PERFMON_EVENTSEL_OS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_RAW</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">config</span> <span class="o">|=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">X86_RAW_EVENT_MASK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">x86_setup_perfctr</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the hardware configuration for a given attr_type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__x86_pmu_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu_initialized</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active_events</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active_events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reserve_pmc_hardware</span><span class="p">())</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">reserve_ds_buffers</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active_events</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmc_reserve_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">hw_perf_event_destroy</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_tag</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">;</span>

	<span class="cm">/* mark unused */</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">extra_reg</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">EXTRA_REG_NONE</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">branch_reg</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">EXTRA_REG_NONE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">hw_config</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">x86_pmu_disable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ARCH_PERFMON_EVENTSEL_ENABLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ARCH_PERFMON_EVENTSEL_ENABLE</span><span class="p">;</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu_initialized</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">disable_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">x86_pmu_enable_all</span><span class="p">(</span><span class="kt">int</span> <span class="n">added</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">__x86_pmu_enable_event</span><span class="p">(</span><span class="n">hwc</span><span class="p">,</span> <span class="n">ARCH_PERFMON_EVENTSEL_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">pmu</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_x86_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">pmu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Event scheduler state:</span>
<span class="cm"> *</span>
<span class="cm"> * Assign events iterating over all events and counters, beginning</span>
<span class="cm"> * with events with least weights first. Keep the current iterator</span>
<span class="cm"> * state in struct sched_state.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sched_state</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">weight</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">event</span><span class="p">;</span>		<span class="cm">/* event index */</span>
	<span class="kt">int</span>	<span class="n">counter</span><span class="p">;</span>	<span class="cm">/* counter index */</span>
	<span class="kt">int</span>	<span class="n">unassigned</span><span class="p">;</span>	<span class="cm">/* number of events to be assigned left */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">)];</span>
<span class="p">};</span>

<span class="cm">/* Total max is X86_PMC_IDX_MAX, but we are O(n!) limited */</span>
<span class="cp">#define	SCHED_STATES_MAX	2</span>

<span class="k">struct</span> <span class="n">perf_sched</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">max_weight</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">max_events</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_constraint</span>	<span class="o">**</span><span class="n">constraints</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">saved_states</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_state</span>	<span class="n">saved</span><span class="p">[</span><span class="n">SCHED_STATES_MAX</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize interator that runs through all events and counters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_sched_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">**</span><span class="n">c</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wmin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wmax</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sched</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sched</span><span class="p">));</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">max_events</span>	<span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">max_weight</span>	<span class="o">=</span> <span class="n">wmax</span><span class="p">;</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">constraints</span>	<span class="o">=</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">==</span> <span class="n">wmin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span>	<span class="o">=</span> <span class="n">idx</span><span class="p">;</span>		<span class="cm">/* start with min weight */</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">weight</span>	<span class="o">=</span> <span class="n">wmin</span><span class="p">;</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">unassigned</span>	<span class="o">=</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_sched_save_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span> <span class="o">&gt;=</span> <span class="n">SCHED_STATES_MAX</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved</span><span class="p">[</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span><span class="p">]</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">perf_sched_restore_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span><span class="o">--</span><span class="p">;</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved</span><span class="p">[</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">saved_states</span><span class="p">];</span>

	<span class="cm">/* continue with next counter: */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">counter</span><span class="o">++</span><span class="p">,</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">used</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Select a counter for the current event to schedule. Return true on</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__perf_sched_find_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">unassigned</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">max_events</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">constraints</span><span class="p">[</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">];</span>

	<span class="cm">/* Prefer fixed purpose counters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">;</span>
		<span class="n">for_each_set_bit_from</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idxmsk</span><span class="p">,</span> <span class="n">X86_PMC_IDX_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">used</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Grab the first unused counter starting with idx */</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">counter</span><span class="p">;</span>
	<span class="n">for_each_set_bit_from</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idxmsk</span><span class="p">,</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">used</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">overlap</span><span class="p">)</span>
		<span class="n">perf_sched_save_state</span><span class="p">(</span><span class="n">sched</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">perf_sched_find_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__perf_sched_find_counter</span><span class="p">(</span><span class="n">sched</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">perf_sched_restore_state</span><span class="p">(</span><span class="n">sched</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Go through all unassigned events and find the next one to schedule.</span>
<span class="cm"> * Take events with the least weight first. Return true on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">perf_sched_next_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_sched</span> <span class="o">*</span><span class="n">sched</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">unassigned</span> <span class="o">||</span> <span class="o">!--</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">unassigned</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* next event */</span>
		<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">max_events</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* next weight */</span>
			<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">weight</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">max_weight</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">constraints</span><span class="p">[</span><span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">!=</span> <span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>

	<span class="n">sched</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* start with first counter */</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assign a counter for each event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_assign_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">**</span><span class="n">constraints</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">wmin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wmax</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">assign</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sched</span> <span class="n">sched</span><span class="p">;</span>

	<span class="n">perf_sched_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">perf_sched_find_counter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* failed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assign</span><span class="p">)</span>
			<span class="n">assign</span><span class="p">[</span><span class="n">sched</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">]</span> <span class="o">=</span> <span class="n">sched</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">counter</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">perf_sched_next_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">sched</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">unassigned</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x86_schedule_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">assign</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">constraints</span><span class="p">[</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used_mask</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">)];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">used_mask</span><span class="p">,</span> <span class="n">X86_PMC_IDX_MAX</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wmin</span> <span class="o">=</span> <span class="n">X86_PMC_IDX_MAX</span><span class="p">,</span> <span class="n">wmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">get_event_constraints</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">wmin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">wmin</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>
		<span class="n">wmax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * fastpath, try to reuse previous register</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/* never assigned */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* constraint still honored */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idxmsk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* not already used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">used_mask</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">__set_bit</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">used_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assign</span><span class="p">)</span>
			<span class="n">assign</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* slow path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">perf_assign_events</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span><span class="p">,</span> <span class="n">assign</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * scheduling failed or is just a simulation,</span>
<span class="cm">	 * free resources if necessary</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assign</span> <span class="o">||</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">)</span>
				<span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dogrp: true if must collect siblings events (group)</span>
<span class="cm"> * returns total number of events and error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">collect_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dogrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">max_count</span><span class="p">;</span>

	<span class="n">max_count</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">+</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">;</span>

	<span class="cm">/* current number of events already accepted */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_x86_event</span><span class="p">(</span><span class="n">leader</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">leader</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dogrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_x86_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_assign_hw_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_tag</span> <span class="o">=</span> <span class="o">++</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="n">X86_PMC_IDX_FIXED_BTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">MSR_ARCH_PERFMON_FIXED_CTR_CTRL</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span> <span class="o">=</span> <span class="n">MSR_ARCH_PERFMON_FIXED_CTR0</span> <span class="o">+</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">-</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">config_base</span> <span class="o">=</span> <span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span>  <span class="o">=</span> <span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">match_prev_assignment</span><span class="p">(</span><span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_tag</span> <span class="o">==</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">tags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">x86_pmu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">added</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu_initialized</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n_running</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">-</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * apply assignment obtained either from</span>
<span class="cm">		 * hw_perf_group_sched_in() or x86_pmu_enable()</span>
<span class="cm">		 *</span>
<span class="cm">		 * step1: save events moving to new counters</span>
<span class="cm">		 * step2: reprogram moved events into new counters</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_running</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * we can avoid reprogramming counter if:</span>
<span class="cm">			 * - assigned same counter as last time</span>
<span class="cm">			 * - running on same CPU as last time</span>
<span class="cm">			 * - no other event has used the counter since</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
			    <span class="n">match_prev_assignment</span><span class="p">(</span><span class="n">hwc</span><span class="p">,</span> <span class="n">cpuc</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Ensure we don&#39;t accidentally enable a stopped</span>
<span class="cm">			 * counter simply because we rescheduled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
				<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_ARCH</span><span class="p">;</span>

			<span class="n">x86_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_UPDATE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_prev_assignment</span><span class="p">(</span><span class="n">hwc</span><span class="p">,</span> <span class="n">cpuc</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">x86_assign_hw_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_running</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_ARCH</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">x86_pmu_start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_RELOAD</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">perf_events_lapic_init</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">enable_all</span><span class="p">(</span><span class="n">added</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span> <span class="p">[</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">],</span> <span class="n">pmc_prev_left</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set the next IRQ period, based on the hwc-&gt;period_left value.</span>
<span class="cm"> * To be called with the event disabled in hw:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">x86_perf_event_set_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">left</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>
	<span class="n">s64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">X86_PMC_IDX_FIXED_BTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are way outside a reasonable range then just skip forward:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">period</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Quirk: certain CPUs dont like it if just 1 hw_event is left:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">left</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">max_period</span><span class="p">)</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">max_period</span><span class="p">;</span>

	<span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_prev_left</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hw event starts counting from this event offset,</span>
<span class="cm">	 * mark it to be able to extra future deltas:</span>
<span class="cm">	 */</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">prev_count</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="n">left</span><span class="p">);</span>

	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="o">-</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_mask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Due to erratum on certan cpu we need</span>
<span class="cm">	 * a second write to be sure the register</span>
<span class="cm">	 * is updated properly</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">perfctr_second_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">event_base</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="o">-</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">x86_pmu_enable_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">enabled</span><span class="p">))</span>
		<span class="n">__x86_pmu_enable_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span>
				       <span class="n">ARCH_PERFMON_EVENTSEL_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a single event to the PMU.</span>
<span class="cm"> *</span>
<span class="cm"> * The event is added to the group of enabled events</span>
<span class="cm"> * but only if it can be scehduled with existing events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">x86_pmu_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">assign</span><span class="p">[</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">n0</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_HES_UPTODATE</span> <span class="o">|</span> <span class="n">PERF_HES_STOPPED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">))</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_ARCH</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If group events scheduling transaction was started,</span>
<span class="cm">	 * skip the schedulability test here, it will be performed</span>
<span class="cm">	 * at commit time (-&gt;commit_txn) as a whole</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;</span> <span class="n">PERF_EVENT_TXN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done_collect</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">schedule_events</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">assign</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * copy new assignment, now we know it is possible</span>
<span class="cm">	 * will be used by hw_perf_enable()</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="nl">done_collect:</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_added</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n0</span><span class="p">;</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_txn</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_RELOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">));</span>
		<span class="n">x86_perf_event_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">);</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">enable</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_print_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">overflow</span><span class="p">,</span> <span class="n">pmc_ctrl</span><span class="p">,</span> <span class="n">pmc_count</span><span class="p">,</span> <span class="n">prev_left</span><span class="p">,</span> <span class="n">fixed</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pebs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_CORE_PERF_GLOBAL_CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_CORE_PERF_GLOBAL_STATUS</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_CORE_PERF_GLOBAL_OVF_CTRL</span><span class="p">,</span> <span class="n">overflow</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_ARCH_PERFMON_FIXED_CTR_CTRL</span><span class="p">,</span> <span class="n">fixed</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_PEBS_ENABLE</span><span class="p">,</span> <span class="n">pebs</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: ctrl:       %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: status:     %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: overflow:   %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">overflow</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: fixed:      %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">fixed</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: pebs:       %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">pebs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: active:     %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu_config_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">pmc_ctrl</span><span class="p">);</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">x86_pmu_event_addr</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">pmc_count</span><span class="p">);</span>

		<span class="n">prev_left</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">pmc_prev_left</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d:   gen-PMC%d ctrl:  %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pmc_ctrl</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d:   gen-PMC%d count: %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pmc_count</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d:   gen-PMC%d left:  %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prev_left</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_ARCH_PERFMON_FIXED_CTR0</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pmc_count</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;CPU#%d: fixed-PMC%d count: %016llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pmc_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">x86_pmu_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">disable</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_STOPPED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_UPDATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drain the remaining delta count out of a event</span>
<span class="cm">		 * that we are disabling:</span>
<span class="cm">		 */</span>
		<span class="n">x86_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">PERF_HES_UPTODATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re called during a txn, we don&#39;t need to do anything.</span>
<span class="cm">	 * The events never got scheduled and -&gt;cancel_txn will truncate</span>
<span class="cm">	 * the event_list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;</span> <span class="n">PERF_EVENT_TXN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">x86_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_UPDATE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">)</span>
				<span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

			<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">)</span>
				<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="o">--</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">x86_pmu_handle_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some chipsets need to unmask the LVTPC in a particular spot</span>
<span class="cm">	 * inside the nmi handler.  As a result, the unmasking was pushed</span>
<span class="cm">	 * into all the nmi handlers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This generic handler doesn&#39;t seem to have any issues where the</span>
<span class="cm">	 * unmasking occurs so it was left at the top.</span>
<span class="cm">	 */</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">,</span> <span class="n">APIC_DM_NMI</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Though we deactivated the counter some cpus</span>
<span class="cm">			 * might still deliver spurious interrupts still</span>
<span class="cm">			 * in flight. Catch them:</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">))</span>
				<span class="n">handled</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">event</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">x86_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * event overflow</span>
<span class="cm">		 */</span>
		<span class="n">handled</span><span class="o">++</span><span class="p">;</span>
		<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_perf_event_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">x86_pmu_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handled</span><span class="p">)</span>
		<span class="n">inc_irq_stat</span><span class="p">(</span><span class="n">apic_perf_irqs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_events_lapic_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">apic</span> <span class="o">||</span> <span class="o">!</span><span class="n">x86_pmu_initialized</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always use NMI for PMU</span>
<span class="cm">	 */</span>
	<span class="n">apic_write</span><span class="p">(</span><span class="n">APIC_LVTPC</span><span class="p">,</span> <span class="n">APIC_DM_NMI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">perf_event_nmi_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">active_events</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NMI_DONE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">handle_irq</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">event_constraint</span> <span class="n">emptyconstraint</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">event_constraint</span> <span class="n">unconstrained</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">x86_pmu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">kfree_on_online</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_prepare</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_prepare</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_STARTING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span><span class="p">)</span>
			<span class="n">set_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_PCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_starting</span><span class="p">)</span>
			<span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_starting</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">kfree_on_online</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_DYING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_dying</span><span class="p">)</span>
			<span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_dying</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_dead</span><span class="p">)</span>
			<span class="n">x86_pmu</span><span class="p">.</span><span class="n">cpu_dead</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pmu_check_apic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_apic</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">apic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;no APIC, boot with the </span><span class="se">\&quot;</span><span class="s">lapic</span><span class="se">\&quot;</span><span class="s"> boot parameter to force-enable it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;no hardware sampling interrupt available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">x86_pmu_format_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;format&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_hw_perf_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">x86_pmu_quirk</span> <span class="o">*</span><span class="n">quirk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Performance Events: &quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_INTEL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">intel_pmu_init</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_AMD</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">amd_pmu_init</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;no PMU driver, software events only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pmu_check_apic</span><span class="p">();</span>

	<span class="cm">/* sanity check that the hardware exists or is emulated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_hw_exists</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;%s PMU driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">quirk</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">quirks</span><span class="p">;</span> <span class="n">quirk</span><span class="p">;</span> <span class="n">quirk</span> <span class="o">=</span> <span class="n">quirk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">quirk</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">&gt;</span> <span class="n">X86_PMC_MAX_GENERIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;hw perf events %d &gt; max(%d), clipping!&quot;</span><span class="p">,</span>
		     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="n">X86_PMC_MAX_GENERIC</span><span class="p">);</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span> <span class="o">=</span> <span class="n">X86_PMC_MAX_GENERIC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span> <span class="o">&gt;</span> <span class="n">X86_PMC_MAX_FIXED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;hw perf events fixed %d &gt; max(%d), clipping!&quot;</span><span class="p">,</span>
		     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">,</span> <span class="n">X86_PMC_MAX_FIXED</span><span class="p">);</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span> <span class="o">=</span> <span class="n">X86_PMC_MAX_FIXED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_ctrl</span> <span class="o">|=</span>
		<span class="p">((</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">;</span>

	<span class="n">perf_events_lapic_init</span><span class="p">();</span>
	<span class="n">register_nmi_handler</span><span class="p">(</span><span class="n">NMI_LOCAL</span><span class="p">,</span> <span class="n">perf_event_nmi_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;PMI&quot;</span><span class="p">);</span>

	<span class="n">unconstrained</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">event_constraint</span><span class="p">)</span>
		<span class="n">__EVENT_CONSTRAINT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">event_constraints</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * event on fixed counter2 (REF_CYCLES) only works on this</span>
<span class="cm">		 * counter, so do not extend mask to generic counters</span>
<span class="cm">		 */</span>
		<span class="n">for_each_event_constraint</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">event_constraints</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmask</span> <span class="o">!=</span> <span class="n">X86_RAW_EVENT_MASK</span>
			    <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idxmsk64</span> <span class="o">==</span> <span class="n">X86_PMC_MSK_FIXED_REF_CYCLES</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">c</span><span class="o">-&gt;</span><span class="n">idxmsk64</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">+=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* enable userspace RDPMC usage by default */</span>
	<span class="n">x86_pmu_format_group</span><span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">format_attrs</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... version:                %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... bit width:              %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... generic registers:      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... value mask:             %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_mask</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... max period:             %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">max_period</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... fixed-purpose events:   %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>     <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;... event mask:             %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">intel_ctrl</span><span class="p">);</span>

	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_RAW</span><span class="p">);</span>
	<span class="n">perf_cpu_notifier</span><span class="p">(</span><span class="n">x86_pmu_notifier</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">init_hw_perf_events</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_pmu_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x86_perf_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start group events scheduling transaction</span>
<span class="cm"> * Set the flag to make pmu::enable() not perform the</span>
<span class="cm"> * schedulability test, it will be performed at commit time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_start_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">__this_cpu_or</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">group_flag</span><span class="p">,</span> <span class="n">PERF_EVENT_TXN</span><span class="p">);</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">n_txn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop group events scheduling transaction</span>
<span class="cm"> * Clear the flag and pmu::enable() will perform the</span>
<span class="cm"> * schedulability test.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_cancel_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_and</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">group_flag</span><span class="p">,</span> <span class="o">~</span><span class="n">PERF_EVENT_TXN</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Truncate the collected events.</span>
<span class="cm">	 */</span>
	<span class="n">__this_cpu_sub</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">n_added</span><span class="p">,</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">n_txn</span><span class="p">));</span>
	<span class="n">__this_cpu_sub</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">n_events</span><span class="p">,</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">.</span><span class="n">n_txn</span><span class="p">));</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commit group events scheduling transaction</span>
<span class="cm"> * Perform the group schedulability test as a whole</span>
<span class="cm"> * Return 0 if success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">x86_pmu_commit_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">cpu_hw_events</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">assign</span><span class="p">[</span><span class="n">X86_PMC_IDX_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu_initialized</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">schedule_events</span><span class="p">(</span><span class="n">cpuc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">assign</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy new assignment, now we know it is possible</span>
<span class="cm">	 * will be used by hw_perf_enable()</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">,</span> <span class="n">assign</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">group_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_EVENT_TXN</span><span class="p">;</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * a fake_cpuc is used to validate event groups. Due to</span>
<span class="cm"> * the extra reg logic, we need to also allocate a fake</span>
<span class="cm"> * per_core and per_cpu structure. Otherwise, group events</span>
<span class="cm"> * using extra reg may conflict without the kernel being</span>
<span class="cm"> * able to catch this when the last event gets added to</span>
<span class="cm"> * the group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_fake_cpuc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">shared_regs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="nf">allocate_fake_cpuc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">cpuc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

	<span class="n">cpuc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cpuc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/* only needed, if we have extra_regs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">extra_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">shared_regs</span> <span class="o">=</span> <span class="n">allocate_shared_regs</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">shared_regs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpuc</span><span class="o">-&gt;</span><span class="n">is_fake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cpuc</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">free_fake_cpuc</span><span class="p">(</span><span class="n">cpuc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * validate that we can schedule this event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">fake_cpuc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">event_constraint</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fake_cpuc</span> <span class="o">=</span> <span class="n">allocate_fake_cpuc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">get_event_constraints</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span> <span class="o">||</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">)</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">put_event_constraints</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">free_fake_cpuc</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * validate a single event group</span>
<span class="cm"> *</span>
<span class="cm"> * validation include:</span>
<span class="cm"> *	- check events are compatible which each other</span>
<span class="cm"> *	- events do not compete for the same counter</span>
<span class="cm"> *	- number of events &lt;= number of counters</span>
<span class="cm"> *</span>
<span class="cm"> * validation ensures the group can be loaded onto the</span>
<span class="cm"> * PMU if it was the only group available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_hw_events</span> <span class="o">*</span><span class="n">fake_cpuc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">fake_cpuc</span> <span class="o">=</span> <span class="n">allocate_fake_cpuc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * the event is not yet connected with its</span>
<span class="cm">	 * siblings therefore we must first collect</span>
<span class="cm">	 * existing siblings, then add the new event</span>
<span class="cm">	 * before we can simulate the scheduling</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fake_cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">collect_events</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fake_cpuc</span><span class="o">-&gt;</span><span class="n">n_events</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">schedule_events</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">free_fake_cpuc</span><span class="p">(</span><span class="n">fake_cpuc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">x86_pmu_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_TYPE_RAW</span>:
	<span class="k">case</span> <span class="n">PERF_TYPE_HARDWARE</span>:
	<span class="k">case</span> <span class="n">PERF_TYPE_HW_CACHE</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__x86_pmu_event_init</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we temporarily connect event to its pmu</span>
<span class="cm">		 * such that validate_group() can classify</span>
<span class="cm">		 * it as an x86 event using is_x86_event()</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmu</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">validate_group</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">validate_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">x86_pmu_event_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">-=</span> <span class="n">X86_PMC_IDX_FIXED</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">get_attr_rdpmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">change_rdpmc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">enable</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">set_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_PCE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_PCE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">set_attr_rdpmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">val</span> <span class="o">!=</span> <span class="o">!!</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span> <span class="o">=</span> <span class="o">!!</span><span class="n">val</span><span class="p">;</span>
		<span class="n">smp_call_function</span><span class="p">(</span><span class="n">change_rdpmc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">rdpmc</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">get_attr_rdpmc</span><span class="p">,</span> <span class="n">set_attr_rdpmc</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">x86_pmu_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_rdpmc</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">x86_pmu_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">x86_pmu_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">x86_pmu_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">x86_pmu_attr_group</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">x86_pmu_format_group</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">x86_pmu_flush_branch_stack</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">flush_branch_stack</span><span class="p">)</span>
		<span class="n">x86_pmu</span><span class="p">.</span><span class="n">flush_branch_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">pmu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pmu_enable</span>		<span class="o">=</span> <span class="n">x86_pmu_enable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmu_disable</span>		<span class="o">=</span> <span class="n">x86_pmu_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">attr_groups</span>	<span class="o">=</span> <span class="n">x86_pmu_attr_groups</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">x86_pmu_event_init</span><span class="p">,</span>

	<span class="p">.</span><span class="n">add</span>			<span class="o">=</span> <span class="n">x86_pmu_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>			<span class="o">=</span> <span class="n">x86_pmu_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>			<span class="o">=</span> <span class="n">x86_pmu_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>			<span class="o">=</span> <span class="n">x86_pmu_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">x86_pmu_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">start_txn</span>	<span class="o">=</span> <span class="n">x86_pmu_start_txn</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_txn</span>	<span class="o">=</span> <span class="n">x86_pmu_cancel_txn</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit_txn</span>	<span class="o">=</span> <span class="n">x86_pmu_commit_txn</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">x86_pmu_event_idx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_branch_stack</span>	<span class="o">=</span> <span class="n">x86_pmu_flush_branch_stack</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">arch_perf_update_userpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_mmap_page</span> <span class="o">*</span><span class="n">userpg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">cap_usr_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">cap_usr_rdpmc</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">attr_rdpmc</span><span class="p">;</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">pmc_width</span> <span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_NONSTOP_TSC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">cap_usr_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">time_mult</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cyc2ns</span><span class="p">);</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">time_shift</span> <span class="o">=</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">;</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">time_offset</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">cyc2ns_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * callchain support</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">backtrace_stack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">backtrace_address</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reliable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_callchain_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">perf_callchain_store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">stacktrace_ops</span> <span class="n">backtrace_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">stack</span>			<span class="o">=</span> <span class="n">backtrace_stack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">address</span>		<span class="o">=</span> <span class="n">backtrace_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">walk_stack</span>		<span class="o">=</span> <span class="n">print_context_stack_bp</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">perf_callchain_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_callchain_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">perf_guest_cbs</span> <span class="o">&amp;&amp;</span> <span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">is_in_guest</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* TODO: We don&#39;t support guest os callchain now */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">perf_callchain_store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">dump_trace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">backtrace_ops</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">valid_user_frame</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__range_not_ok</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">TASK_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>

<span class="cp">#include &lt;asm/compat.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">perf_callchain_user32</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_callchain_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 32-bit process in 64-bit kernel. */</span>
	<span class="k">struct</span> <span class="n">stack_frame_ia32</span> <span class="n">frame</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_IA32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">PERF_MAX_STACK_DEPTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">.</span><span class="n">next_frame</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">.</span><span class="n">return_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">bytes</span> <span class="o">=</span> <span class="n">copy_from_user_nmi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_user_frame</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">perf_callchain_store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">frame</span><span class="p">.</span><span class="n">return_address</span><span class="p">);</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">next_frame</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">perf_callchain_user32</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_callchain_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span>
<span class="nf">perf_callchain_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_callchain_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stack_frame</span> <span class="n">frame</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_guest_cbs</span> <span class="o">&amp;&amp;</span> <span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">is_in_guest</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/* TODO: We don&#39;t support guest os callchain now */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">perf_callchain_store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_callchain_user32</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">PERF_MAX_STACK_DEPTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">.</span><span class="n">next_frame</span>	     <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">frame</span><span class="p">.</span><span class="n">return_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">bytes</span> <span class="o">=</span> <span class="n">copy_from_user_nmi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_user_frame</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">perf_callchain_store</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">frame</span><span class="p">.</span><span class="n">return_address</span><span class="p">);</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">next_frame</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_instruction_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_guest_cbs</span> <span class="o">&amp;&amp;</span> <span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">is_in_guest</span><span class="p">())</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">get_guest_ip</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">perf_misc_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_guest_cbs</span> <span class="o">&amp;&amp;</span> <span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">is_in_guest</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_guest_cbs</span><span class="o">-&gt;</span><span class="n">is_user_mode</span><span class="p">())</span>
			<span class="n">misc</span> <span class="o">|=</span> <span class="n">PERF_RECORD_MISC_GUEST_USER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">misc</span> <span class="o">|=</span> <span class="n">PERF_RECORD_MISC_GUEST_KERNEL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="n">misc</span> <span class="o">|=</span> <span class="n">PERF_RECORD_MISC_USER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">misc</span> <span class="o">|=</span> <span class="n">PERF_RECORD_MISC_KERNEL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EFLAGS_EXACT</span><span class="p">)</span>
		<span class="n">misc</span> <span class="o">|=</span> <span class="n">PERF_RECORD_MISC_EXACT_IP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">misc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_get_x86_pmu_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">x86_pmu_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">version</span>		<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">num_counters_gp</span>	<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">num_counters_fixed</span>	<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">num_counters_fixed</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">bit_width_gp</span>	<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">bit_width_fixed</span>	<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">cntval_bits</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">events_mask</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">x86_pmu</span><span class="p">.</span><span class="n">events_maskl</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">events_mask_len</span>	<span class="o">=</span> <span class="n">x86_pmu</span><span class="p">.</span><span class="n">events_mask_len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_get_x86_pmu_capability</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
