<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › cpu › mcheck › mce.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>mce.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Machine check handler.</span>
<span class="cm"> *</span>
<span class="cm"> * K8 parts Copyright 2002,2003 Andi Kleen, SuSE Labs.</span>
<span class="cm"> * Rest from unknown author(s).</span>
<span class="cm"> * 2004 Andi Kleen. Rewrote most of it.</span>
<span class="cm"> * Copyright 2008 Intel Corporation</span>
<span class="cm"> * Author: Andi Kleen</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/irq_work.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>
<span class="cp">#include &lt;asm/mce.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>

<span class="cp">#include &quot;mce-internal.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">mce_chrdev_read_mutex</span><span class="p">);</span>

<span class="cp">#define rcu_dereference_check_mce(p) \</span>
<span class="cp">	rcu_dereference_index_check((p), \</span>
<span class="cp">			      rcu_read_lock_sched_held() || \</span>
<span class="cp">			      lockdep_is_held(&amp;mce_chrdev_read_mutex))</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/mce.h&gt;</span>

<span class="kt">int</span> <span class="n">mce_disabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#define MISC_MCELOG_MINOR	227</span>

<span class="cp">#define SPINUNIT 100	</span><span class="cm">/* 100ns */</span><span class="cp"></span>

<span class="n">atomic_t</span> <span class="n">mce_entry</span><span class="p">;</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">mce_exception_count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Tolerant levels:</span>
<span class="cm"> *   0: always panic on uncorrected errors, log corrected errors</span>
<span class="cm"> *   1: panic or SIGBUS on uncorrected errors, log corrected errors</span>
<span class="cm"> *   2: SIGBUS or log uncorrected errors (if possible), log corrected errors</span>
<span class="cm"> *   3: never panic or SIGBUS, log all errors (for testing only)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">tolerant</span>		<span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">banks</span>			<span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">rip_msr</span>			<span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">mce_bootlog</span>		<span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">monarch_timeout</span>		<span class="n">__read_mostly</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">mce_panic_timeout</span>	<span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">mce_dont_log_ce</span>		<span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span>				<span class="n">mce_cmci_disabled</span>	<span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span>				<span class="n">mce_ignore_ce</span>		<span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span>				<span class="n">mce_ser</span>			<span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">mce_bank</span>                <span class="o">*</span><span class="n">mce_banks</span>		<span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* User mode helper program triggered by machine check event */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mce_need_notify</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span>			<span class="n">mce_helper</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">mce_helper_argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">mce_helper</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">mce_chrdev_wait</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">mces_seen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">cpu_missing</span><span class="p">;</span>

<span class="cm">/* MCA banks polled by the period polling timer for corrected events */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">mce_banks_t</span><span class="p">,</span> <span class="n">mce_poll_banks</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">MAX_NR_BANKS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">,</span> <span class="n">mce_work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CPU/chipset specific EDAC code can register a notifier call here to print</span>
<span class="cm"> * MCE errors in a human-readable form.</span>
<span class="cm"> */</span>
<span class="n">ATOMIC_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">x86_mce_decoder_chain</span><span class="p">);</span>

<span class="cm">/* Do initial initialization of a struct mce */</span>
<span class="kt">void</span> <span class="nf">mce_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">));</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">rdtscll</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">tsc</span><span class="p">);</span>
	<span class="cm">/* We hope get_seconds stays lockless */</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">cpuvendor</span> <span class="o">=</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">cpuid</span> <span class="o">=</span> <span class="n">cpuid_eax</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">socketid</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">).</span><span class="n">phys_proc_id</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">apicid</span> <span class="o">=</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">).</span><span class="n">initial_apicid</span><span class="p">;</span>
	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCG_CAP</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgcap</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">injectm</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="p">(</span><span class="n">injectm</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Lockless MCE logging infrastructure.</span>
<span class="cm"> * This avoids deadlocks on printk locks without having to break locks. Also</span>
<span class="cm"> * separate MCEs from kernel messages to avoid bogus bug reports.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mce_log</span> <span class="n">mcelog</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">signature</span>	<span class="o">=</span> <span class="n">MCE_LOG_SIGNATURE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">len</span>		<span class="o">=</span> <span class="n">MCE_LOG_LEN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recordlen</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">mce_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">mce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">next</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Emit the trace record: */</span>
	<span class="n">trace_mce_record</span><span class="p">(</span><span class="n">mce</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_mce_decoder_chain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mce</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mce</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rcu_dereference_check_mce</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * When the buffer fills up discard new entries.</span>
<span class="cm">			 * Assume that the earlier errors are the more</span>
<span class="cm">			 * interesting ones:</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;=</span> <span class="n">MCE_LOG_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">MCE_OVERFLOW</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Old left over entry. Skip: */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">entry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="n">entry</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span> <span class="o">+</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mce</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">));</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">mce</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_need_notify</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_mcelog_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

		<span class="cm">/* drain what was logged during boot */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">next</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">retries</span><span class="p">))</span>
					<span class="n">retries</span><span class="o">++</span><span class="p">;</span>

				<span class="n">cpu_relax</span><span class="p">();</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">&amp;&amp;</span> <span class="n">retries</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;MCE: skipping error being logged currently!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_mce_decoder_chain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span> <span class="o">+</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">next</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">mce_register_decode_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_mce_decoder_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="n">drain_mcelog_buffer</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mce_register_decode_chain</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mce_unregister_decode_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_mce_decoder_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mce_unregister_decode_chain</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;CPU %d: Machine Check Exception: %Lx Bank %d: %016Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgstatus</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">bank</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;RIP%s %02x:&lt;%016Lx&gt; &quot;</span><span class="p">,</span>
			<span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgstatus</span> <span class="o">&amp;</span> <span class="n">MCG_STATUS_EIPV</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; !INEXACT!&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				<span class="n">m</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">==</span> <span class="n">__KERNEL_CS</span><span class="p">)</span>
			<span class="n">print_symbol</span><span class="p">(</span><span class="s">&quot;{%s}&quot;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;TSC %llx &quot;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tsc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;ADDR %llx &quot;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;MISC %llx &quot;</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">);</span>

	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note this output is parsed by external tools and old fields</span>
<span class="cm">	 * should not be changed.</span>
<span class="cm">	 */</span>
	<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;PROCESSOR %u:%x TIME %llu SOCKET %u APIC %x microcode %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">cpuvendor</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cpuid</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">socketid</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">apicid</span><span class="p">,</span>
		<span class="n">cpu_data</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">extcpu</span><span class="p">).</span><span class="n">microcode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Print out human-readable details about the MCE error,</span>
<span class="cm">	 * (if the CPU has an implementation for that)</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x86_mce_decoder_chain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NOTIFY_STOP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_emerg_ratelimited</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;Run the above through &#39;mcelog --ascii&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PANIC_TIMEOUT 5 </span><span class="cm">/* 5 seconds */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">mce_paniced</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fake_panic</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">mce_fake_paniced</span><span class="p">;</span>

<span class="cm">/* Panic in progress. Enable interrupts and wait for final IPI */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_for_panic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">PANIC_TIMEOUT</span><span class="o">*</span><span class="n">USEC_PER_SEC</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">panic_timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic_timeout</span> <span class="o">=</span> <span class="n">mce_panic_timeout</span><span class="p">;</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Panicing machine check CPU died&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_panic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">final</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">exp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">apei_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fake_panic</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure only one CPU runs in machine check panic</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_paniced</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">wait_for_panic</span><span class="p">();</span>
		<span class="n">barrier</span><span class="p">();</span>

		<span class="n">bust_spinlocks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">console_verbose</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t log too much for fake panic */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_fake_paniced</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* First print corrected ones that are still unlogged */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MCE_LOG_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">print_mce</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apei_err</span><span class="p">)</span>
				<span class="n">apei_err</span> <span class="o">=</span> <span class="n">apei_write_mce</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Now print uncorrected but with the final one last */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MCE_LOG_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_UC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">final</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">print_mce</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apei_err</span><span class="p">)</span>
				<span class="n">apei_err</span> <span class="o">=</span> <span class="n">apei_write_mce</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_mce</span><span class="p">(</span><span class="n">final</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">apei_err</span><span class="p">)</span>
			<span class="n">apei_err</span> <span class="o">=</span> <span class="n">apei_write_mce</span><span class="p">(</span><span class="n">final</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_missing</span><span class="p">)</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;Some CPUs didn&#39;t answer in synchronization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="p">)</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;Machine check: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fake_panic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">panic_timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic_timeout</span> <span class="o">=</span> <span class="n">mce_panic_timeout</span><span class="p">;</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;Fake kernel panic: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Support code for software error injection */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msr_to_offset</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">bank</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">injectm</span><span class="p">.</span><span class="n">bank</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">rip_msr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">bank</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_MCx_ADDR</span><span class="p">(</span><span class="n">bank</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_MCx_MISC</span><span class="p">(</span><span class="n">bank</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">misc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msr</span> <span class="o">==</span> <span class="n">MSR_IA32_MCG_STATUS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">,</span> <span class="n">mcgstatus</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* MSR access wrappers used for error injection */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">mce_rdmsrl</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">injectm</span><span class="p">.</span><span class="n">finished</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">msr_to_offset</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">injectm</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdmsrl_safe</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;mce: Unable to read msr %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Return zero in case the access faulted. This should</span>
<span class="cm">		 * not happen normally but can happen if the CPU does</span>
<span class="cm">		 * something weird, or if the code is buggy.</span>
<span class="cm">		 */</span>
		<span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_wrmsrl</span><span class="p">(</span><span class="n">u32</span> <span class="n">msr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">injectm</span><span class="p">.</span><span class="n">finished</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">msr_to_offset</span><span class="p">(</span><span class="n">msr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">injectm</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">msr</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Collect all global (w.r.t. this processor) status about this machine</span>
<span class="cm"> * check into our &quot;mce&quot; struct so that we can use it later to assess</span>
<span class="cm"> * the severity of the problem as we read per-bank specific details.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mce_gather_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_setup</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgstatus</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCG_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get the address of the instruction at the time of</span>
<span class="cm">		 * the machine check error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mcgstatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MCG_STATUS_RIPV</span><span class="o">|</span><span class="n">MCG_STATUS_EIPV</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * When in VM86 mode make the cs look like ring 3</span>
<span class="cm">			 * always. This is a lie, but it&#39;s better than passing</span>
<span class="cm">			 * the additional vm86 bit around everywhere.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v8086_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
				<span class="n">m</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">|=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Use accurate RIP reporting if available. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rip_msr</span><span class="p">)</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">rip_msr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Simple lockless ring to communicate PFNs from the exception handler with the</span>
<span class="cm"> * process context work function. This is vastly simplified because there&#39;s</span>
<span class="cm"> * only a single reader and a single writer.</span>
<span class="cm"> */</span>
<span class="cp">#define MCE_RING_SIZE 16	</span><span class="cm">/* we use one entry less */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">mce_ring</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ring</span><span class="p">[</span><span class="n">MCE_RING_SIZE</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce_ring</span><span class="p">,</span> <span class="n">mce_ring</span><span class="p">);</span>

<span class="cm">/* Runs with CPU affinity in workqueue */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_ring_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce_ring</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_ring</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_ring_get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce_ring</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">];</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MCE_RING_SIZE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Always runs in MCE context with preempt off */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_ring_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce_ring</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_ring</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MCE_RING_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mce_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_MCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_MCA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_schedule_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_ring_empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="n">work</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_work</span><span class="p">,</span> <span class="n">mce_irq_work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_irq_work_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_work</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_notify_irq</span><span class="p">();</span>
	<span class="n">mce_schedule_work</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_report_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X86_VM_MASK</span><span class="o">|</span><span class="n">X86_EFLAGS_IF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mce_notify_irq</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Triggering the work queue here is just an insurance</span>
<span class="cm">		 * policy in case the syscall exit notify handler</span>
<span class="cm">		 * doesn&#39;t run soon enough or ends up running on the</span>
<span class="cm">		 * wrong CPU (can happen when audit sleeps)</span>
<span class="cm">		 */</span>
		<span class="n">mce_schedule_work</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irq_work_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_irq_work</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read ADDR and MISC registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_read_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_MISCV</span><span class="p">)</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_MISC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_ADDRV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_ADDR</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mask the reported address by the reported granularity.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mce_ser</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_MISCV</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">MCI_MISC_ADDR_LSB</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">);</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">mce_poll_count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Poll for corrected events or events that happened before reset.</span>
<span class="cm"> * Those are just logged through /dev/mcelog.</span>
<span class="cm"> *</span>
<span class="cm"> * This is executed in standard interrupt context.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: spec recommends to panic for fatal unsignalled</span>
<span class="cm"> * errors here. However this would be quite problematic --</span>
<span class="cm"> * we would need to reimplement the Monarch handling and</span>
<span class="cm"> * it would mess up the exclusion between exception handler</span>
<span class="cm"> * and poll hander -- * so we skip this for now.</span>
<span class="cm"> * These cases should not happen anyways, or only when the CPU</span>
<span class="cm"> * is already totally * confused. In this case it&#39;s likely it will</span>
<span class="cm"> * not fully execute the machine check handler either.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">machine_check_poll</span><span class="p">(</span><span class="k">enum</span> <span class="n">mcp_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mce_banks_t</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">mce_poll_count</span><span class="p">);</span>

	<span class="n">mce_gather_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ctl</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">m</span><span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">bank</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Uncorrected or signalled events are handled by the exception</span>
<span class="cm">		 * handler when it is enabled, so don&#39;t process those here.</span>
<span class="cm">		 *</span>
<span class="cm">		 * TBD do the same check for MCI_STATUS_EN here?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MCP_UC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mce_ser</span> <span class="o">?</span> <span class="n">MCI_STATUS_S</span> <span class="o">:</span> <span class="n">MCI_STATUS_UC</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mce_read_aux</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MCP_TIMESTAMP</span><span class="p">))</span>
			<span class="n">m</span><span class="p">.</span><span class="n">tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t get the IP here because it&#39;s unlikely to</span>
<span class="cm">		 * have anything to do with the actual error location.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MCP_DONTLOG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mce_dont_log_ce</span><span class="p">)</span>
			<span class="n">mce_log</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear state for this bank.</span>
<span class="cm">		 */</span>
		<span class="n">mce_wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t clear MCG_STATUS here because it&#39;s only defined for</span>
<span class="cm">	 * exceptions.</span>
<span class="cm">	 */</span>

	<span class="n">sync_core</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">machine_check_poll</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Do a quick check if any of the events requires a panic.</span>
<span class="cm"> * This decides if we keep the events around or clear them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_no_way_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">msg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">validp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">validp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mce_severity</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tolerant</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MCE_PANIC_SEVERITY</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Variable to establish order between CPUs while scanning.</span>
<span class="cm"> * Each CPU spins initially until executing is equal its number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">mce_executing</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Defines order of CPUs on entry. First CPU becomes Monarch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">mce_callin</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Check if a timeout waiting for other CPUs happened.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_timed_out</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The others already did panic for some reason.</span>
<span class="cm">	 * Bail out like in a timeout.</span>
<span class="cm">	 * rmb() to tell the compiler that system_state</span>
<span class="cm">	 * might have been modified by someone else.</span>
<span class="cm">	 */</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_paniced</span><span class="p">))</span>
		<span class="n">wait_for_panic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">monarch_timeout</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">SPINUNIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CHECKME: Make panic default for 1 too? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tolerant</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Timeout synchronizing machine check over CPUs&quot;</span><span class="p">,</span>
				  <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">cpu_missing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">t</span> <span class="o">-=</span> <span class="n">SPINUNIT</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The Monarch&#39;s reign.  The Monarch is the CPU who entered</span>
<span class="cm"> * the machine check handler first. It waits for the others to</span>
<span class="cm"> * raise the exception too and then grades them. When any</span>
<span class="cm"> * error is fatal panic. Only then let the others continue.</span>
<span class="cm"> *</span>
<span class="cm"> * The other CPUs entering the MCE handler will be controlled by the</span>
<span class="cm"> * Monarch. They are called Subjects.</span>
<span class="cm"> *</span>
<span class="cm"> * This way we prevent any potential data corruption in a unrecoverable case</span>
<span class="cm"> * and also makes sure always all CPU&#39;s errors are examined.</span>
<span class="cm"> *</span>
<span class="cm"> * Also this detects the case of a machine check event coming from outer</span>
<span class="cm"> * space (not detected by any CPUs) In this case some external agent wants</span>
<span class="cm"> * us to shut down, so panic too.</span>
<span class="cm"> *</span>
<span class="cm"> * The other CPUs might still decide to panic if the handler happens</span>
<span class="cm"> * in a unrecoverable place, but in this case the system is in a semi-stable</span>
<span class="cm"> * state and won&#39;t corrupt anything by itself. It&#39;s ok to let the others</span>
<span class="cm"> * continue for a bit first.</span>
<span class="cm"> *</span>
<span class="cm"> * All the spin loops have timeouts; when a timeout happens a CPU</span>
<span class="cm"> * typically elects itself to be Monarch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_reign</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">global_worst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nmsg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This CPU is the Monarch and the other CPUs have run</span>
<span class="cm">	 * through their handlers.</span>
<span class="cm">	 * Grade the severity of the errors of all the CPUs.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">severity</span> <span class="o">=</span> <span class="n">mce_severity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mces_seen</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="n">tolerant</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">nmsg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">severity</span> <span class="o">&gt;</span> <span class="n">global_worst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="n">nmsg</span><span class="p">;</span>
			<span class="n">global_worst</span> <span class="o">=</span> <span class="n">severity</span><span class="p">;</span>
			<span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mces_seen</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cannot recover? Panic here then.</span>
<span class="cm">	 * This dumps all the mces in the log buffer and stops the</span>
<span class="cm">	 * other CPUs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">global_worst</span> <span class="o">&gt;=</span> <span class="n">MCE_PANIC_SEVERITY</span> <span class="o">&amp;&amp;</span> <span class="n">tolerant</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Fatal Machine check&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For UC somewhere we let the CPU who detects it handle it.</span>
<span class="cm">	 * Also must let continue the others, otherwise the handling</span>
<span class="cm">	 * CPU could deadlock on a lock.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * No machine check event found. Must be some external</span>
<span class="cm">	 * source or one CPU is hung. Panic.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_worst</span> <span class="o">&lt;=</span> <span class="n">MCE_KEEP_SEVERITY</span> <span class="o">&amp;&amp;</span> <span class="n">tolerant</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Machine check from unknown source&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now clear all the mces_seen so that they don&#39;t reappear on</span>
<span class="cm">	 * the next mce.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mces_seen</span><span class="p">,</span> <span class="n">cpu</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">global_nwo</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Start of Monarch synchronization. This waits until all CPUs have</span>
<span class="cm"> * entered the exception handler and then determines if any of them</span>
<span class="cm"> * saw a fatal event that requires panic. Then it executes them</span>
<span class="cm"> * in the entry order.</span>
<span class="cm"> * TBD double check parallel CPU hotunplug</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_start</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">no_way_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">monarch_timeout</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="o">*</span><span class="n">no_way_out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * global_nwo should be updated before mce_callin</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_callin</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for everyone.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_callin</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mce_timed_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ndelay</span><span class="p">(</span><span class="n">SPINUNIT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * mce_callin should be read before global_nwo</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Monarch: Starts executing now, the others wait.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Subject: Now start the scanning loop one by one in</span>
<span class="cm">		 * the original callin order.</span>
<span class="cm">		 * This way when there are any shared banks it will be</span>
<span class="cm">		 * only seen by one CPU before cleared, avoiding duplicates.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mce_timed_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ndelay</span><span class="p">(</span><span class="n">SPINUNIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cache the global no_way_out state.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">no_way_out</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronize between CPUs after main scanning loop.</span>
<span class="cm"> * This invokes the bulk of the Monarch processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_end</span><span class="p">(</span><span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">monarch_timeout</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow others to run.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CHECKME: Can this race with a parallel hotplug? */</span>
		<span class="kt">int</span> <span class="n">cpus</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Monarch: Wait for everyone to go through their scanning</span>
<span class="cm">		 * loops.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mce_timed_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
			<span class="n">ndelay</span><span class="p">(</span><span class="n">SPINUNIT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mce_reign</span><span class="p">();</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Subject: Wait for Monarch to finish.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mce_timed_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>
			<span class="n">ndelay</span><span class="p">(</span><span class="n">SPINUNIT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t reset anything. That&#39;s done by the Monarch.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset all global state.</span>
<span class="cm">	 */</span>
<span class="nl">reset:</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_callin</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let others run again.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the address reported by the CPU is in a format we can parse.</span>
<span class="cm"> * It would be possible to add code for most other cases, but all would</span>
<span class="cm"> * be somewhat complicated (e.g. segment offset would require an instruction</span>
<span class="cm"> * parser). So only support physical addresses up to page granuality for now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_usable_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_MISCV</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_ADDRV</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MCI_MISC_ADDR_LSB</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MCI_MISC_ADDR_MODE</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">misc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MCI_MISC_ADDR_PHYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_clear_state</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">toclear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">toclear</span><span class="p">))</span>
			<span class="n">mce_wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Need to save faulting physical address associated with a process</span>
<span class="cm"> * in the machine check handler some place where we can grab it back</span>
<span class="cm"> * later in mce_notify_process()</span>
<span class="cm"> */</span>
<span class="cp">#define	MCE_INFO_MAX	16</span>

<span class="k">struct</span> <span class="n">mce_info</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">inuse</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">__u64</span>			<span class="n">paddr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">restartable</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mce_info</span><span class="p">[</span><span class="n">MCE_INFO_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_save_info</span><span class="p">(</span><span class="n">__u64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce_info</span> <span class="o">*</span><span class="n">mi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mi</span> <span class="o">=</span> <span class="n">mce_info</span><span class="p">;</span> <span class="n">mi</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">mce_info</span><span class="p">[</span><span class="n">MCE_INFO_MAX</span><span class="p">];</span> <span class="n">mi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mi</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
			<span class="n">mi</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">mi</span><span class="o">-&gt;</span><span class="n">restartable</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Too many concurrent recoverable errors&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mce_info</span> <span class="o">*</span><span class="nf">mce_find_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce_info</span> <span class="o">*</span><span class="n">mi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mi</span> <span class="o">=</span> <span class="n">mce_info</span><span class="p">;</span> <span class="n">mi</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">mce_info</span><span class="p">[</span><span class="n">MCE_INFO_MAX</span><span class="p">];</span> <span class="n">mi</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mi</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_clear_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce_info</span> <span class="o">*</span><span class="n">mi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The actual machine check handler. This only handles real</span>
<span class="cm"> * exceptions when something got corrupted coming in through int 18.</span>
<span class="cm"> *</span>
<span class="cm"> * This is executed in NMI context not subject to normal locking rules. This</span>
<span class="cm"> * implies that most kernel services cannot be safely used. Don&#39;t even</span>
<span class="cm"> * think about putting a printk in there!</span>
<span class="cm"> *</span>
<span class="cm"> * On Intel systems this is entered on all CPUs in parallel through</span>
<span class="cm"> * MCE broadcast. However some CPUs might be broken beyond repair,</span>
<span class="cm"> * so be always careful when synchronizing with others.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_machine_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">final</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">worst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">severity</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Establish sequential order between the CPUs entering the machine</span>
<span class="cm">	 * check handler.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If no_way_out gets set, there is no safe way to recover from this</span>
<span class="cm">	 * MCE.  If tolerant is cranked up, we&#39;ll try anyway.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">no_way_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If kill_it gets set, there might be a way to recover from this</span>
<span class="cm">	 * error.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">kill_it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">toclear</span><span class="p">,</span> <span class="n">MAX_NR_BANKS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">valid_banks</span><span class="p">,</span> <span class="n">MAX_NR_BANKS</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_entry</span><span class="p">);</span>

	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">mce_exception_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">banks</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mce_gather_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">final</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mces_seen</span><span class="p">);</span>
	<span class="o">*</span><span class="n">final</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">valid_banks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">valid_banks</span><span class="p">));</span>
	<span class="n">no_way_out</span> <span class="o">=</span> <span class="n">mce_no_way_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">valid_banks</span><span class="p">);</span>

	<span class="n">barrier</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * When no restart IP might need to kill or panic.</span>
<span class="cm">	 * Assume the worst for now, but if we find the</span>
<span class="cm">	 * severity is MCE_AR_SEVERITY we have other options.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">mcgstatus</span> <span class="o">&amp;</span> <span class="n">MCG_STATUS_RIPV</span><span class="p">))</span>
		<span class="n">kill_it</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Go through all the banks in exclusion of the other CPUs.</span>
<span class="cm">	 * This way we don&#39;t report duplicated events on shared banks</span>
<span class="cm">	 * because the first one to see it will clear it.</span>
<span class="cm">	 */</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">mce_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">no_way_out</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">toclear</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">valid_banks</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ctl</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">m</span><span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">bank</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">mce_rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MCI_STATUS_VAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Non uncorrected or non signaled errors are handled by</span>
<span class="cm">		 * machine_check_poll. Leave them alone, unless this panics.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mce_ser</span> <span class="o">?</span> <span class="n">MCI_STATUS_S</span> <span class="o">:</span> <span class="n">MCI_STATUS_UC</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">no_way_out</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set taint even when machine check was not enabled.</span>
<span class="cm">		 */</span>
		<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_MACHINE_CHECK</span><span class="p">);</span>

		<span class="n">severity</span> <span class="o">=</span> <span class="n">mce_severity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">tolerant</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * When machine check was for corrected handler don&#39;t touch,</span>
<span class="cm">		 * unless we&#39;re panicing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">severity</span> <span class="o">==</span> <span class="n">MCE_KEEP_SEVERITY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">no_way_out</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">toclear</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">severity</span> <span class="o">==</span> <span class="n">MCE_NO_SEVERITY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Machine check event was not enabled. Clear, but</span>
<span class="cm">			 * ignore.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mce_read_aux</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Action optional error. Queue address for later processing.</span>
<span class="cm">		 * When the ring overflows we just ignore the AO error.</span>
<span class="cm">		 * RED-PEN add some logging mechanism when</span>
<span class="cm">		 * usable_address or mce_add_ring fails.</span>
<span class="cm">		 * RED-PEN don&#39;t ignore overflow for tolerant == 0</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">severity</span> <span class="o">==</span> <span class="n">MCE_AO_SEVERITY</span> <span class="o">&amp;&amp;</span> <span class="n">mce_usable_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">))</span>
			<span class="n">mce_ring_add</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

		<span class="n">mce_log</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">severity</span> <span class="o">&gt;</span> <span class="n">worst</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">final</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">worst</span> <span class="o">=</span> <span class="n">severity</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* mce_clear_state will clear *final, save locally for use later */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="o">*</span><span class="n">final</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_way_out</span><span class="p">)</span>
		<span class="n">mce_clear_state</span><span class="p">(</span><span class="n">toclear</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do most of the synchronization with other CPUs.</span>
<span class="cm">	 * When there&#39;s any problem use only local no_way_out state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_end</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">no_way_out</span> <span class="o">=</span> <span class="n">worst</span> <span class="o">&gt;=</span> <span class="n">MCE_PANIC_SEVERITY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At insane &quot;tolerant&quot; levels we take no action. Otherwise</span>
<span class="cm">	 * we only die if we have no other choice. For less serious</span>
<span class="cm">	 * issues we try to recover, or limit damage to the current</span>
<span class="cm">	 * process.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tolerant</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">no_way_out</span><span class="p">)</span>
			<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Fatal machine check on current CPU&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">worst</span> <span class="o">==</span> <span class="n">MCE_AR_SEVERITY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* schedule action before return to userland */</span>
			<span class="n">mce_save_info</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">mcgstatus</span> <span class="o">&amp;</span> <span class="n">MCG_STATUS_RIPV</span><span class="p">);</span>
			<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_MCE_NOTIFY</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kill_it</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">worst</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mce_report_event</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">mce_wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCG_STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_entry</span><span class="p">);</span>
	<span class="n">sync_core</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">do_machine_check</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_MEMORY_FAILURE</span>
<span class="kt">int</span> <span class="nf">memory_failure</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mce_severity() should not hand us an ACTION_REQUIRED error */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MF_ACTION_REQUIRED</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Uncorrected memory error in page 0x%lx ignored</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Rebuild kernel with CONFIG_MEMORY_FAILURE=y for smarter handling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called in process context that interrupted by MCE and marked with</span>
<span class="cm"> * TIF_MCE_NOTIFY, just before returning to erroneous userland.</span>
<span class="cm"> * This code is allowed to sleep.</span>
<span class="cm"> * Attempt possible recovery such as calling the high level VM handler to</span>
<span class="cm"> * process any corrupted pages, and kill/signal current process if required.</span>
<span class="cm"> * Action required errors are handled here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mce_notify_process</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mce_info</span> <span class="o">*</span><span class="n">mi</span> <span class="o">=</span> <span class="n">mce_find_info</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mi</span><span class="p">)</span>
		<span class="n">mce_panic</span><span class="p">(</span><span class="s">&quot;Lost physical address for unconsumed uncorrectable error&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="n">mi</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_MCE_NOTIFY</span><span class="p">);</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Uncorrected hardware memory error in user-access at %llx&quot;</span><span class="p">,</span>
		 <span class="n">mi</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must call memory_failure() here even if the current process is</span>
<span class="cm">	 * doomed. We still need to mark the page as poisoned and alert any</span>
<span class="cm">	 * other users of the page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memory_failure</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">MCE_VECTOR</span><span class="p">,</span> <span class="n">MF_ACTION_REQUIRED</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">mi</span><span class="o">-&gt;</span><span class="n">restartable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Memory error not recovered&quot;</span><span class="p">);</span>
		<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mce_clear_info</span><span class="p">(</span><span class="n">mi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Action optional processing happens here (picking up</span>
<span class="cm"> * from the list of faulting pages that do_machine_check()</span>
<span class="cm"> * placed into the &quot;ring&quot;).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_process_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mce_ring_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfn</span><span class="p">))</span>
		<span class="n">memory_failure</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">MCE_VECTOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_MCE_INTEL</span>
<span class="cm">/***</span>
<span class="cm"> * mce_log_therm_throt_event - Logs the thermal throttling event to mcelog</span>
<span class="cm"> * @cpu: The CPU on which the event occurred.</span>
<span class="cm"> * @status: Event status information</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called by the thermal interrupt after the</span>
<span class="cm"> * event has been processed and the decision was made to log the event</span>
<span class="cm"> * further.</span>
<span class="cm"> *</span>
<span class="cm"> * The status parameter will be saved to the &#39;status&#39; field of &#39;struct mce&#39;</span>
<span class="cm"> * and historically has been the register value of the</span>
<span class="cm"> * MSR_IA32_THERMAL_STATUS (Intel) msr.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mce_log_therm_throt_event</span><span class="p">(</span><span class="n">__u64</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="n">m</span><span class="p">;</span>

	<span class="n">mce_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">m</span><span class="p">.</span><span class="n">bank</span> <span class="o">=</span> <span class="n">MCE_THERMAL_BANK</span><span class="p">;</span>
	<span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">mce_log</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_MCE_INTEL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Periodic polling timer for &quot;silent&quot; machine check errors.  If the</span>
<span class="cm"> * poller finds an MCE, poll 2x faster.  When the poller finds no more</span>
<span class="cm"> * errors, poll 2x slower (up to check_interval seconds).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">check_interval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span> <span class="cm">/* 5 minutes */</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">mce_next_interval</span><span class="p">);</span> <span class="cm">/* in jiffies */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span><span class="p">,</span> <span class="n">mce_timer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_timer</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iv</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">!=</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">machine_check_poll</span><span class="p">(</span><span class="n">MCP_TIMESTAMP</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_poll_banks</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Alert userspace if needed.  If we logged an MCE, reduce the</span>
<span class="cm">	 * polling interval, otherwise increase the polling interval.</span>
<span class="cm">	 */</span>
	<span class="n">iv</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">mce_next_interval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_notify_irq</span><span class="p">())</span>
		<span class="n">iv</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">iv</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iv</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">iv</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">check_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">mce_next_interval</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">iv</span><span class="p">;</span>
	<span class="n">add_timer_on</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* Must not be called in IRQ context where del_timer_sync() can deadlock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_timer_delete_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_timer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_do_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_usermodehelper</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">,</span> <span class="n">mce_helper_argv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">UMH_NO_WAIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">mce_trigger_work</span><span class="p">,</span> <span class="n">mce_do_trigger</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Notify the user(s) about new machine check events.</span>
<span class="cm"> * Can be called from interrupt context, but not from machine check/NMI</span>
<span class="cm"> * context.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mce_notify_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Not more than two messages every minute */</span>
	<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">ratelimit</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="n">HZ</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_need_notify</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* wake processes polling /dev/mcelog */</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_wait</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * There is no risk of missing notifications because</span>
<span class="cm">		 * work_pending is always cleared before the function is</span>
<span class="cm">		 * executed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mce_helper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_trigger_work</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_trigger_work</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ratelimit</span><span class="p">))</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="n">HW_ERR</span> <span class="s">&quot;Machine check events logged</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mce_notify_irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__mcheck_cpu_mce_banks_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mce_banks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">banks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce_bank</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_banks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">b</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1ULL</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize Machine Checks for a CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__mcheck_cpu_cap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cap</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCG_CAP</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">&amp;</span> <span class="n">MCG_BANKCNT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">banks</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;mce: CPU supports %d MCE banks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">MAX_NR_BANKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;MCE: Using only %u machine check banks out of %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">MAX_NR_BANKS</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">MAX_NR_BANKS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t support asymmetric configurations today */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">banks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">banks</span><span class="p">);</span>
	<span class="n">banks</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_banks</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">__mcheck_cpu_mce_banks_init</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Use accurate RIP reporting if available. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">MCG_EXT_P</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">MCG_EXT_CNT</span><span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">)</span>
		<span class="n">rip_msr</span> <span class="o">=</span> <span class="n">MSR_IA32_MCG_EIP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">MCG_SER_P</span><span class="p">)</span>
		<span class="n">mce_ser</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mcheck_cpu_init_generic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_banks_t</span> <span class="n">all_banks</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Log the machine checks left over from the previous reset.</span>
<span class="cm">	 */</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">all_banks</span><span class="p">,</span> <span class="n">MAX_NR_BANKS</span><span class="p">);</span>
	<span class="n">machine_check_poll</span><span class="p">(</span><span class="n">MCP_UC</span><span class="o">|</span><span class="p">(</span><span class="o">!</span><span class="n">mce_bootlog</span> <span class="o">?</span> <span class="n">MCP_DONTLOG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">all_banks</span><span class="p">);</span>

	<span class="n">set_in_cr4</span><span class="p">(</span><span class="n">X86_CR4_MCE</span><span class="p">);</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCG_CAP</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">MCG_CTL_P</span><span class="p">)</span>
		<span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_MCG_CTL</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_CTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
		<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Add per CPU specific workarounds here */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__mcheck_cpu_apply_quirks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;MCE: unknown CPU type - not enabling MCE support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This should be disabled by the BIOS, but isn&#39;t always */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_AMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">&amp;&amp;</span> <span class="n">banks</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * disable GART TBL walk error reporting, which</span>
<span class="cm">			 * trips off incorrectly with the IOMMU &amp; 3ware</span>
<span class="cm">			 * &amp; Cerberus:</span>
<span class="cm">			 */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">ctl</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">&lt;=</span> <span class="mi">17</span> <span class="o">&amp;&amp;</span> <span class="n">mce_bootlog</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Lots of broken BIOS around that don&#39;t clear them</span>
<span class="cm">			 * by default and leave crap in there. Don&#39;t log:</span>
<span class="cm">			 */</span>
			<span class="n">mce_bootlog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Various K7s with broken bank 0 around. Always disable</span>
<span class="cm">		 * by default.</span>
<span class="cm">		 */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">banks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mce_banks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		 <span class="cm">/*</span>
<span class="cm">		  * Turn off MC4_MISC thresholding banks on those models since</span>
<span class="cm">		  * they&#39;re not supported there.</span>
<span class="cm">		  */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mh">0x15</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&gt;=</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&lt;=</span> <span class="mh">0x1f</span><span class="p">))</span> <span class="p">{</span>
			 <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			 <span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">hwcr</span><span class="p">;</span>
			 <span class="n">bool</span> <span class="n">need_toggle</span><span class="p">;</span>
			 <span class="n">u32</span> <span class="n">msrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
				<span class="mh">0x00000413</span><span class="p">,</span> <span class="cm">/* MC4_MISC0 */</span>
				<span class="mh">0xc0000408</span><span class="p">,</span> <span class="cm">/* MC4_MISC1 */</span>
			 <span class="p">};</span>

			 <span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_K7_HWCR</span><span class="p">,</span> <span class="n">hwcr</span><span class="p">);</span>

			 <span class="cm">/* McStatusWrEn has to be set */</span>
			 <span class="n">need_toggle</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">hwcr</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">));</span>

			 <span class="k">if</span> <span class="p">(</span><span class="n">need_toggle</span><span class="p">)</span>
				 <span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_K7_HWCR</span><span class="p">,</span> <span class="n">hwcr</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">18</span><span class="p">));</span>

			 <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">msrs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				 <span class="n">rdmsrl</span><span class="p">(</span><span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>

				 <span class="cm">/* CntP bit set? */</span>
				 <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BIT_64</span><span class="p">(</span><span class="mi">62</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT_64</span><span class="p">(</span><span class="mi">62</span><span class="p">);</span>
					<span class="n">wrmsrl</span><span class="p">(</span><span class="n">msrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
				 <span class="p">}</span>
			 <span class="p">}</span>

			 <span class="cm">/* restore old settings */</span>
			 <span class="k">if</span> <span class="p">(</span><span class="n">need_toggle</span><span class="p">)</span>
				 <span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_K7_HWCR</span><span class="p">,</span> <span class="n">hwcr</span><span class="p">);</span>
		 <span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_INTEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * SDM documents that on family 6 bank 0 should not be written</span>
<span class="cm">		 * because it aliases to another special BIOS controlled</span>
<span class="cm">		 * register.</span>
<span class="cm">		 * But it&#39;s not aliased anymore on model 0x1a+</span>
<span class="cm">		 * Don&#39;t ignore bank 0 completely because there could be a</span>
<span class="cm">		 * valid event later, merely don&#39;t write CTL0.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&lt;</span> <span class="mh">0x1A</span> <span class="o">&amp;&amp;</span> <span class="n">banks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mce_banks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * All newer Intel systems support MCE broadcasting. Enable</span>
<span class="cm">		 * synchronization with a one second timeout.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&gt;=</span> <span class="mh">0xe</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="n">monarch_timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">monarch_timeout</span> <span class="o">=</span> <span class="n">USEC_PER_SEC</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * There are also broken BIOSes on some Pentium M and</span>
<span class="cm">		 * earlier systems:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_model</span> <span class="o">&lt;=</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="n">mce_bootlog</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mce_bootlog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">monarch_timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">monarch_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_bootlog</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mce_panic_timeout</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">__mcheck_cpu_ancient_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_INTEL</span>:
		<span class="n">intel_p5_mcheck_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_CENTAUR</span>:
		<span class="n">winchip_mcheck_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mcheck_cpu_init_vendor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">x86_vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_INTEL</span>:
		<span class="n">mce_intel_feature_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_AMD</span>:
		<span class="n">mce_amd_feature_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mcheck_cpu_init_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_timer</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">check_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mce_timer_fn</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce_ignore_ce</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">mce_next_interval</span><span class="p">,</span> <span class="n">iv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iv</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">iv</span><span class="p">);</span>
	<span class="n">add_timer_on</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* Handle unconfigured int18 (should never happen) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unexpected_machine_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;CPU#%d: Unexpected int18 (Machine Check).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/* Call the installed machine check handler for this CPU setup. */</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">machine_check_vector</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">)</span> <span class="o">=</span>
						<span class="n">unexpected_machine_check</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each booted CPU to set up machine checks.</span>
<span class="cm"> * Must be called with preempt off:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">mcheck_cpu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__mcheck_cpu_ancient_init</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__mcheck_cpu_cap_init</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">__mcheck_cpu_apply_quirks</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mce_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">machine_check_vector</span> <span class="o">=</span> <span class="n">do_machine_check</span><span class="p">;</span>

	<span class="n">__mcheck_cpu_init_generic</span><span class="p">();</span>
	<span class="n">__mcheck_cpu_init_vendor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">__mcheck_cpu_init_timer</span><span class="p">();</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_work</span><span class="p">),</span> <span class="n">mce_process_work</span><span class="p">);</span>
	<span class="n">init_irq_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">mce_irq_work</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mce_irq_work_cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mce_chrdev: Character device /dev/mcelog to read and clear the MCE log.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mce_chrdev_open_count</span><span class="p">;</span>	<span class="cm">/* #times opened */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mce_chrdev_open_exclu</span><span class="p">;</span>	<span class="cm">/* already open exclusive? */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_chrdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce_chrdev_open_exclu</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">mce_chrdev_open_count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span>
		<span class="n">mce_chrdev_open_exclu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mce_chrdev_open_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_chrdev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>

	<span class="n">mce_chrdev_open_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">mce_chrdev_open_exclu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_tscs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cpu_tsc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">rdtscll</span><span class="p">(</span><span class="n">cpu_tsc</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mce_apei_read_done</span><span class="p">;</span>

<span class="cm">/* Collect MCE record of previous boot in persistent storage via APEI ERST. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mce_read_apei</span><span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">**</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">usize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">record_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mce</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usize</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">apei_read_mce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">record_id</span><span class="p">);</span>
	<span class="cm">/* Error or no more MCE record */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mce_apei_read_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * When ERST is disabled, mce_chrdev_read() should return</span>
<span class="cm">		 * &quot;no record&quot; instead of &quot;no device.&quot;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * In fact, we should have cleared the record after that has</span>
<span class="cm">	 * been flushed to the disk or sent to network in</span>
<span class="cm">	 * /sbin/mcelog, but we have no interface to support that now,</span>
<span class="cm">	 * so just clear it to avoid duplication.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">apei_clear_mce</span><span class="p">(</span><span class="n">record_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mce_apei_read_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ubuf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mce_chrdev_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">usize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ubuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cpu_tsc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cpu_tsc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_tsc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_read_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_apei_read_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__mce_read_apei</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">usize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">buf</span> <span class="o">!=</span> <span class="n">ubuf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">rcu_dereference_check_mce</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/* Only supports full reads right now */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">off</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">usize</span> <span class="o">&lt;</span> <span class="n">MCE_LOG_LEN</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">next</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
					<span class="k">goto</span> <span class="n">timeout</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="nl">timeout:</span>
			<span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span> <span class="o">+</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">next</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">));</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Collect entries that were still getting written before the</span>
<span class="cm">	 * synchronize.</span>
<span class="cm">	 */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">collect_tscs</span><span class="p">,</span> <span class="n">cpu_tsc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MCE_LOG_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tsc</span> <span class="o">&lt;</span> <span class="n">cpu_tsc</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">|=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_read_mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cpu_tsc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">buf</span> <span class="o">-</span> <span class="n">ubuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mce_chrdev_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_chrdev_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_index</span><span class="p">(</span><span class="n">mcelog</span><span class="p">.</span><span class="n">next</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_apei_read_done</span> <span class="o">&amp;&amp;</span> <span class="n">apei_check_mce</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">mce_chrdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MCE_GET_RECORD_LEN</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mce</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MCE_GET_LOG_LEN</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">MCE_LOG_LEN</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">MCE_GETCLEAR_FLAGS</span>: <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">mcelog</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcelog</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">mce_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">usize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">register_mce_write_callback</span><span class="p">(</span><span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">usize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">mce_write</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_mce_write_callback</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="nf">mce_chrdev_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">usize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mce_write</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mce_write</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">usize</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mce_chrdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">mce_chrdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">mce_chrdev_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">mce_chrdev_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="n">mce_chrdev_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>			<span class="o">=</span> <span class="n">mce_chrdev_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>		<span class="o">=</span> <span class="n">mce_chrdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>			<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">mce_chrdev_device</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MISC_MCELOG_MINOR</span><span class="p">,</span>
	<span class="s">&quot;mcelog&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">mce_chrdev_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mce=off Disables machine check</span>
<span class="cm"> * mce=no_cmci Disables CMCI</span>
<span class="cm"> * mce=dont_log_ce Clears corrected events silently, no log created for CEs.</span>
<span class="cm"> * mce=ignore_ce Disables polling and CMCI, corrected events are not cleared.</span>
<span class="cm"> * mce=TOLERANCELEVEL[,monarchtimeout] (number, see above)</span>
<span class="cm"> *	monarchtimeout is how long to wait for other CPUs on machine</span>
<span class="cm"> *	check, or 0 to not wait</span>
<span class="cm"> * mce=bootlog Log MCEs from before booting. Disabled by default on AMD.</span>
<span class="cm"> * mce=nobootlog Don&#39;t log MCEs from before booting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mcheck_enable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_p5_mce</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span>
		<span class="n">str</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">mce_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;no_cmci&quot;</span><span class="p">))</span>
		<span class="n">mce_cmci_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;dont_log_ce&quot;</span><span class="p">))</span>
		<span class="n">mce_dont_log_ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;ignore_ce&quot;</span><span class="p">))</span>
		<span class="n">mce_ignore_ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;bootlog&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nobootlog&quot;</span><span class="p">))</span>
		<span class="n">mce_bootlog</span> <span class="o">=</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;b&#39;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tolerant</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">str</span><span class="p">;</span>
			<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monarch_timeout</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;mce argument %s ignored. Please use /sys</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">str</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;mce&quot;</span><span class="p">,</span> <span class="n">mcheck_enable</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">mcheck_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcheck_intel_therm_init</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mce_syscore: PM support</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Disable machine checks on suspend and shutdown. We can&#39;t really handle</span>
<span class="cm"> * them later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_disable_error_reporting</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
			<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_CTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mce_syscore_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mce_disable_error_reporting</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_syscore_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_disable_error_reporting</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On resume clear all MCE state. Don&#39;t want to see leftovers from the BIOS.</span>
<span class="cm"> * Only one CPU is active at this time, the others get re-added later using</span>
<span class="cm"> * CPU hotplug:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_syscore_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mcheck_cpu_init_generic</span><span class="p">();</span>
	<span class="n">__mcheck_cpu_init_vendor</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">mce_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">mce_syscore_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">mce_syscore_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">mce_syscore_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * mce_device: Sysfs support</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_cpu_restart</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__mcheck_cpu_init_generic</span><span class="p">();</span>
	<span class="n">__mcheck_cpu_init_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Reinit MCEs after user configuration changes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_restart</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_timer_delete_all</span><span class="p">();</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">mce_cpu_restart</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Toggle features for corrected errors */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_disable_cmci</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cmci_clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_enable_ce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cmci_reenable</span><span class="p">();</span>
	<span class="n">cmci_recheck</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">)</span>
		<span class="n">__mcheck_cpu_init_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">mce_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;machinecheck&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span>	<span class="o">=</span> <span class="s">&quot;machinecheck&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">mce_device</span><span class="p">);</span>

<span class="n">__cpuinitdata</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">threshold_cpu_callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="nf">attr_to_bank</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mce_bank</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_bank</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">attr_to_bank</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">set_bank</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoull</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">attr_to_bank</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">mce_restart</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">mce_helper</span><span class="p">);</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">set_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">siz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">));</span>
	<span class="n">mce_helper</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">mce_helper</span><span class="p">)</span> <span class="o">+</span> <span class="o">!!</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">set_ignore_ce</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoull</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce_ignore_ce</span> <span class="o">^</span> <span class="o">!!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* disable ce features */</span>
			<span class="n">mce_timer_delete_all</span><span class="p">();</span>
			<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">mce_disable_cmci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mce_ignore_ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* enable ce features */</span>
			<span class="n">mce_ignore_ce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">mce_enable_ce</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">set_cmci_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoull</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mce_cmci_disabled</span> <span class="o">^</span> <span class="o">!!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* disable cmci */</span>
			<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">mce_disable_cmci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mce_cmci_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* enable cmci */</span>
			<span class="n">mce_cmci_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">mce_enable_ce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_int_with_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">device_store_int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">mce_restart</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">show_trigger</span><span class="p">,</span> <span class="n">set_trigger</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_INT_ATTR</span><span class="p">(</span><span class="n">tolerant</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">tolerant</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_INT_ATTR</span><span class="p">(</span><span class="n">monarch_timeout</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">monarch_timeout</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_INT_ATTR</span><span class="p">(</span><span class="n">dont_log_ce</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">mce_dont_log_ce</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_ext_attribute</span> <span class="n">dev_attr_check_interval</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">check_interval</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">device_show_int</span><span class="p">,</span> <span class="n">store_int_with_restart</span><span class="p">),</span>
	<span class="o">&amp;</span><span class="n">check_interval</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_ext_attribute</span> <span class="n">dev_attr_ignore_ce</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">ignore_ce</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">device_show_int</span><span class="p">,</span> <span class="n">set_ignore_ce</span><span class="p">),</span>
	<span class="o">&amp;</span><span class="n">mce_ignore_ce</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_ext_attribute</span> <span class="n">dev_attr_cmci_disabled</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">cmci_disabled</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">device_show_int</span><span class="p">,</span> <span class="n">set_cmci_disabled</span><span class="p">),</span>
	<span class="o">&amp;</span><span class="n">mce_cmci_disabled</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">mce_device_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_tolerant</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_check_interval</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_trigger</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_monarch_timeout</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_dont_log_ce</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ignore_ce</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_cmci_disabled</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">mce_device_initialized</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Per cpu device init. All of the cpus still share the same ctrl bank: */</span>
<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">int</span> <span class="nf">mce_device_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span>  <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_subsys</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_device_release</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mce_device_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mce_device_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mce_device_initialized</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_device</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error2:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">attr</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mce_device_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__cpuinit</span> <span class="kt">void</span> <span class="nf">mce_device_remove</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_device</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mce_device_initialized</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mce_device_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mce_device_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">attr</span><span class="p">);</span>

	<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mce_device_initialized</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_device</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Make sure there are no machine checks on offlined CPUs. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">mce_disable_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">CPU_TASKS_FROZEN</span><span class="p">))</span>
		<span class="n">cmci_clear</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
			<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_CTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">mce_reenable_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_info</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">CPU_TASKS_FROZEN</span><span class="p">))</span>
		<span class="n">cmci_reenable</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
			<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_IA32_MCx_CTL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get notified when a cpu comes on/off. Be hotplug friendly. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">mce_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_timer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">mce_device_create</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">threshold_cpu_callback</span><span class="p">)</span>
			<span class="n">threshold_cpu_callback</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">threshold_cpu_callback</span><span class="p">)</span>
			<span class="n">threshold_cpu_callback</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mce_device_remove</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mce_disable_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_ignore_ce</span> <span class="o">&amp;&amp;</span> <span class="n">check_interval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span>
					<span class="n">per_cpu</span><span class="p">(</span><span class="n">mce_next_interval</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
			<span class="n">add_timer_on</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mce_reenable_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_POST_DEAD</span>:
		<span class="cm">/* intentionally ignoring frozen here */</span>
		<span class="n">cmci_rediscover</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">mce_cpu_notifier</span> <span class="n">__cpuinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">mce_cpu_callback</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">mce_init_banks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mce_bank</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mce_banks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>

		<span class="n">sysfs_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">attrname</span><span class="p">;</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">attrname</span><span class="p">,</span> <span class="n">ATTR_LEN</span><span class="p">,</span> <span class="s">&quot;bank%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">a</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="mo">0644</span><span class="p">;</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">show</span>		<span class="o">=</span> <span class="n">show_bank</span><span class="p">;</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">store</span>	<span class="o">=</span> <span class="n">set_bank</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">mcheck_init_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mce_available</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_device_initialized</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">mce_init_banks</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">subsys_system_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">mce_device_create</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_syscore_ops</span><span class="p">);</span>
	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_cpu_notifier</span><span class="p">);</span>

	<span class="cm">/* register character device /dev/mcelog */</span>
	<span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_chrdev_device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">mcheck_init_device</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Old style boot options parsing. Only for compatibility.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mcheck_disable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nomce&quot;</span><span class="p">,</span> <span class="n">mcheck_disable</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mce_get_debugfs_dir</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dmce</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmce</span><span class="p">)</span>
		<span class="n">dmce</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;mce&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dmce</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mce_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_missing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_fake_paniced</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_executing</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mce_callin</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_nwo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fake_panic_get</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">fake_panic</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fake_panic_set</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mce_reset</span><span class="p">();</span>
	<span class="n">fake_panic</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DEFINE_SIMPLE_ATTRIBUTE</span><span class="p">(</span><span class="n">fake_panic_fops</span><span class="p">,</span> <span class="n">fake_panic_get</span><span class="p">,</span>
			<span class="n">fake_panic_set</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mcheck_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dmce</span><span class="p">,</span> <span class="o">*</span><span class="n">ffake_panic</span><span class="p">;</span>

	<span class="n">dmce</span> <span class="o">=</span> <span class="n">mce_get_debugfs_dir</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmce</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ffake_panic</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;fake_panic&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">dmce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">fake_panic_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ffake_panic</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">mcheck_debugfs_init</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
