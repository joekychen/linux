<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › process.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>process.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/prctl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/user-return-notifier.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/stackprotector.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/cpuidle.h&gt;</span>
<span class="cp">#include &lt;trace/events/power.h&gt;</span>
<span class="cp">#include &lt;linux/hw_breakpoint.h&gt;</span>
<span class="cp">#include &lt;asm/cpu.h&gt;</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#include &lt;asm/syscalls.h&gt;</span>
<span class="cp">#include &lt;asm/idle.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/i387.h&gt;</span>
<span class="cp">#include &lt;asm/fpu-internal.h&gt;</span>
<span class="cp">#include &lt;asm/debugreg.h&gt;</span>
<span class="cp">#include &lt;asm/nmi.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * per-CPU TSS segments. Threads are completely &#39;soft&#39; on Linux,</span>
<span class="cm"> * no more per-task TSS&#39;s. The TSS size is kept cacheline-aligned</span>
<span class="cm"> * so they are allowed to end up in the .data..cacheline_aligned</span>
<span class="cm"> * section. Since TSS&#39;s are completely CPU-local, we want them</span>
<span class="cm"> * on exact cacheline boundaries, to eliminate cacheline ping-pong.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">tss_struct</span><span class="p">,</span> <span class="n">init_tss</span><span class="p">)</span> <span class="o">=</span> <span class="n">INIT_TSS</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="n">is_idle</span><span class="p">);</span>
<span class="k">static</span> <span class="n">ATOMIC_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">idle_notifier</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">idle_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_notifier</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">idle_notifier_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">idle_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_notifier</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">idle_notifier_unregister</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">task_xstate_cachep</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">task_xstate_cachep</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * this gets called so that we can store lazy state into memory and copy the</span>
<span class="cm"> * current task into the new thread.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">arch_dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">unlazy_fpu</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>

	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fpu_allocated</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fpu_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">fpu_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_thread_xstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fpu_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">fpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_release_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_thread_xstate</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_task_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">task_xstate_cachep</span> <span class="o">=</span>
        	<span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;task_xstate&quot;</span><span class="p">,</span> <span class="n">xstate_size</span><span class="p">,</span>
				  <span class="n">__alignof__</span><span class="p">(</span><span class="k">union</span> <span class="n">thread_xstate</span><span class="p">),</span>
				  <span class="n">SLAB_PANIC</span> <span class="o">|</span> <span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">drop_fpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Forget coprocessor state..</span>
<span class="cm">	 */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">fpu_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clear_fpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">clear_used_math</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free current thread data structures etc..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">io_bitmap_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">init_tss</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">());</span>

		<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_bitmap_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_IO_BITMAP</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Careful, clear this in the TSS too:</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tss</span><span class="o">-&gt;</span><span class="n">io_bitmap</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">io_bitmap_max</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">io_bitmap_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">put_cpu</span><span class="p">();</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">drop_fpu</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_regs_common</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span><span class="p">,</span> <span class="o">*</span><span class="n">product</span><span class="p">,</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>

	<span class="n">vendor</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vendor</span><span class="p">)</span>
		<span class="n">vendor</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="n">product</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">product</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="cm">/* Board Name is optional */</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;Pid: %d, comm: %.20s %s %s %.*s&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">print_tainted</span><span class="p">(),</span>
		<span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strcspn</span><span class="p">(</span><span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span>
		<span class="n">init_utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; %s %s&quot;</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">product</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;/%s&quot;</span><span class="p">,</span> <span class="n">board</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">flush_ptrace_hw_breakpoint</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tls_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">tls_array</span><span class="p">));</span>
	<span class="n">drop_fpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hard_disable_TSC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">|</span> <span class="n">X86_CR4_TSD</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">disable_TSC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTSC</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * Must flip the CPU state synchronously with</span>
<span class="cm">		 * TIF_NOTSC in the current running context.</span>
<span class="cm">		 */</span>
		<span class="n">hard_disable_TSC</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hard_enable_TSC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_cr4</span><span class="p">(</span><span class="n">read_cr4</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">X86_CR4_TSD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_TSC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTSC</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * Must flip the CPU state synchronously with</span>
<span class="cm">		 * TIF_NOTSC in the current running context.</span>
<span class="cm">		 */</span>
		<span class="n">hard_enable_TSC</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_tsc_mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_NOTSC</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PR_TSC_SIGSEGV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PR_TSC_ENABLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">set_tsc_mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_TSC_SIGSEGV</span><span class="p">)</span>
		<span class="n">disable_TSC</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">PR_TSC_ENABLE</span><span class="p">)</span>
		<span class="n">enable_TSC</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__switch_to_xtra</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev_p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next_p</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">tss_struct</span> <span class="o">*</span><span class="n">tss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev_p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">next_p</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">prev_p</span><span class="p">,</span> <span class="n">TIF_BLOCKSTEP</span><span class="p">)</span> <span class="o">^</span>
	    <span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">next_p</span><span class="p">,</span> <span class="n">TIF_BLOCKSTEP</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugctl</span> <span class="o">=</span> <span class="n">get_debugctlmsr</span><span class="p">();</span>

		<span class="n">debugctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEBUGCTLMSR_BTF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">next_p</span><span class="p">,</span> <span class="n">TIF_BLOCKSTEP</span><span class="p">))</span>
			<span class="n">debugctl</span> <span class="o">|=</span> <span class="n">DEBUGCTLMSR_BTF</span><span class="p">;</span>

		<span class="n">update_debugctlmsr</span><span class="p">(</span><span class="n">debugctl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">prev_p</span><span class="p">,</span> <span class="n">TIF_NOTSC</span><span class="p">)</span> <span class="o">^</span>
	    <span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">next_p</span><span class="p">,</span> <span class="n">TIF_NOTSC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* prev and next are different */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">next_p</span><span class="p">,</span> <span class="n">TIF_NOTSC</span><span class="p">))</span>
			<span class="n">hard_disable_TSC</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">hard_enable_TSC</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">next_p</span><span class="p">,</span> <span class="n">TIF_IO_BITMAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy the relevant range of the IO bitmap.</span>
<span class="cm">		 * Normally this is 128 bytes or less:</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tss</span><span class="o">-&gt;</span><span class="n">io_bitmap</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">io_bitmap_ptr</span><span class="p">,</span>
		       <span class="n">max</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">io_bitmap_max</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">io_bitmap_max</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">prev_p</span><span class="p">,</span> <span class="n">TIF_IO_BITMAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear any possible leftover bits:</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tss</span><span class="o">-&gt;</span><span class="n">io_bitmap</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">io_bitmap_max</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">propagate_user_return_notify</span><span class="p">(</span><span class="n">prev_p</span><span class="p">,</span> <span class="n">next_p</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sys_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is trivial, and on the face of it looks like it</span>
<span class="cm"> * could equally well be done in user mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Not so, for quite unobvious reasons - register pressure.</span>
<span class="cm"> * In user mode vfork() cannot have a stack frame, and if</span>
<span class="cm"> * done by calling the &quot;clone()&quot; system call directly, you</span>
<span class="cm"> * do not have enough call-clobbered registers to hold all</span>
<span class="cm"> * the information you need.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sys_vfork</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">CLONE_VFORK</span> <span class="o">|</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span>
<span class="nf">sys_clone</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newsp</span><span class="p">,</span>
	  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">parent_tid</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsp</span><span class="p">)</span>
		<span class="n">newsp</span> <span class="o">=</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">newsp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent_tid</span><span class="p">,</span> <span class="n">child_tid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This gets run with %si containing the</span>
<span class="cm"> * function to call, and %di containing</span>
<span class="cm"> * the &quot;args&quot;.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kernel_thread_helper</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create a kernel thread</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>

	<span class="n">regs</span><span class="p">.</span><span class="n">si</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fn</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">di</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">__USER_DS</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">__USER_DS</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">__KERNEL_PERCPU</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">gs</span> <span class="o">=</span> <span class="n">__KERNEL_STACK_CANARY</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">__KERNEL_DS</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">regs</span><span class="p">.</span><span class="n">orig_ax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">kernel_thread_helper</span><span class="p">;</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">__KERNEL_CS</span> <span class="o">|</span> <span class="n">get_kernel_rpl</span><span class="p">();</span>
	<span class="n">regs</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">X86_EFLAGS_IF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_BIT1</span><span class="p">;</span>

	<span class="cm">/* Ok, create the new process.. */</span>
	<span class="k">return</span> <span class="n">do_fork</span><span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">CLONE_UNTRACED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_thread</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * sys_execve() executes a new program.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">sys_execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">envp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">do_execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure we don&#39;t return using sysenter.. */</span>
                <span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_IRET</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">putname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Idle related variables and functions</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_NO_OVERRIDE</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">boot_option_idle_override</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Powermanagement idle function, if any..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_APM_MODULE</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pm_idle</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hlt_use_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">play_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="kt">void</span> <span class="nf">enter_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_write</span><span class="p">(</span><span class="n">is_idle</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_notifier</span><span class="p">,</span> <span class="n">IDLE_START</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__exit_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x86_test_and_clear_bit_percpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_idle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">atomic_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_notifier</span><span class="p">,</span> <span class="n">IDLE_END</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called from interrupts to signify idle end */</span>
<span class="kt">void</span> <span class="nf">exit_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* idle loop has pid 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__exit_idle</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The idle thread. There&#39;s no useful work to be</span>
<span class="cm"> * done, so just try to conserve power and have a</span>
<span class="cm"> * low exit latency (ie sit in a loop waiting for</span>
<span class="cm"> * somebody to say that they&#39;d like to reschedule)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpu_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re the non-boot CPU, nothing set the stack canary up</span>
<span class="cm">	 * for us.  CPU0 already has it initialized but no harm in</span>
<span class="cm">	 * doing it again.  This is a good place for updating it, as</span>
<span class="cm">	 * we wont ever return from this function (so the invalid</span>
<span class="cm">	 * canaries already on the stack wont ever trigger).</span>
<span class="cm">	 */</span>
	<span class="n">boot_init_stack_canary</span><span class="p">();</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tick_nohz_idle_enter</span><span class="p">();</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">rmb</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()))</span>
				<span class="n">play_dead</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">			 * Idle routines should keep interrupts disabled</span>
<span class="cm">			 * from here on, until they go to idle.</span>
<span class="cm">			 * Otherwise, idle callbacks can misfire.</span>
<span class="cm">			 */</span>
			<span class="n">local_touch_nmi</span><span class="p">();</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>

			<span class="n">enter_idle</span><span class="p">();</span>

			<span class="cm">/* Don&#39;t trace irqs off for idle */</span>
			<span class="n">stop_critical_timings</span><span class="p">();</span>

			<span class="cm">/* enter_idle() needs rcu for notifiers */</span>
			<span class="n">rcu_idle_enter</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpuidle_idle_call</span><span class="p">())</span>
				<span class="n">pm_idle</span><span class="p">();</span>

			<span class="n">rcu_idle_exit</span><span class="p">();</span>
			<span class="n">start_critical_timings</span><span class="p">();</span>

			<span class="cm">/* In many cases the interrupt that ended idle</span>
<span class="cm">			   has already called exit_idle. But some idle</span>
<span class="cm">			   loops can be woken up without interrupt. */</span>
			<span class="n">__exit_idle</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">tick_nohz_idle_exit</span><span class="p">();</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use this if we don&#39;t have any better</span>
<span class="cm"> * idle routine..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">default_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlt_use_halt</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">trace_power_start_rcuidle</span><span class="p">(</span><span class="n">POWER_CSTATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * TS_POLLING-cleared state must be visible before we</span>
<span class="cm">		 * test NEED_RESCHED:</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="n">safe_halt</span><span class="p">();</span>	<span class="cm">/* enables interrupts racelessly */</span>
		<span class="k">else</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="n">trace_power_end_rcuidle</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="n">PWR_EVENT_EXIT</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="cm">/* loop is done by the caller */</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_APM_MODULE</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">default_idle</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">bool</span> <span class="nf">set_pm_idle_to_default</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">!!</span><span class="n">pm_idle</span><span class="p">;</span>

	<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">default_idle</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">stop_this_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove this CPU:</span>
<span class="cm">	 */</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">disable_local_APIC</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlt_works</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()))</span>
			<span class="n">halt</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Default MONITOR/MWAIT with no hints, used for default C1 state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mwait_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">trace_power_start_rcuidle</span><span class="p">(</span><span class="n">POWER_CSTATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CLFLUSH_MONITOR</span><span class="p">))</span>
			<span class="n">clflush</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">__monitor</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="n">__sti_mwait</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">trace_power_end_rcuidle</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
		<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="n">PWR_EVENT_EXIT</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On SMP it&#39;s slightly faster (but much more power-consuming!)</span>
<span class="cm"> * to poll the -&gt;work.need_resched flag instead of waiting for the</span>
<span class="cm"> * cross-CPU IPI to arrive. Use this option with caution.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">poll_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_power_start_rcuidle</span><span class="p">(</span><span class="n">POWER_CSTATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="n">trace_power_end_rcuidle</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">trace_cpu_idle_rcuidle</span><span class="p">(</span><span class="n">PWR_EVENT_EXIT</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mwait selection logic:</span>
<span class="cm"> *</span>
<span class="cm"> * It depends on the CPU. For AMD CPUs that support MWAIT this is</span>
<span class="cm"> * wrong. Family 0x10 and 0x11 CPUs will enter C1 on HLT. Powersavings</span>
<span class="cm"> * then depend on a clock divisor and current Pstate of the core. If</span>
<span class="cm"> * all cores of a processor are in halt state (C1) the processor can</span>
<span class="cm"> * enter the C1E (C1 enhanced) state. If mwait is used this will never</span>
<span class="cm"> * happen.</span>
<span class="cm"> *</span>
<span class="cm"> * idle=mwait overrides this decision and forces the usage of mwait.</span>
<span class="cm"> */</span>

<span class="cp">#define MWAIT_INFO			0x05</span>
<span class="cp">#define MWAIT_ECX_EXTENDED_INFO		0x01</span>
<span class="cp">#define MWAIT_EDX_C1			0xf0</span>

<span class="kt">int</span> <span class="nf">mwait_usable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="cm">/* Use mwait if idle=mwait boot option is given */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_option_idle_override</span> <span class="o">==</span> <span class="n">IDLE_FORCE_MWAIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any idle= boot option other than idle=mwait means that we must not</span>
<span class="cm">	 * use mwait. Eg: idle=halt or idle=poll or idle=nomwait</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_option_idle_override</span> <span class="o">!=</span> <span class="n">IDLE_NO_OVERRIDE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cpuid_level</span> <span class="o">&lt;</span> <span class="n">MWAIT_INFO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">MWAIT_INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">);</span>
	<span class="cm">/* Check, whether EDX has extended info about MWAIT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="n">MWAIT_ECX_EXTENDED_INFO</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * edx enumeratios MONITOR/MWAIT extensions. Check, whether</span>
<span class="cm">	 * C1  supports MWAIT</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">edx</span> <span class="o">&amp;</span> <span class="n">MWAIT_EDX_C1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="n">amd_e400_c1e_detected</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">amd_e400_c1e_detected</span><span class="p">);</span>

<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">amd_e400_c1e_mask</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">amd_e400_remove_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amd_e400_c1e_mask</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">amd_e400_c1e_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * AMD Erratum 400 aware idle routine. We check for C1E active in the interrupt</span>
<span class="cm"> * pending message MSR. If we detect C1E, then we handle it the same</span>
<span class="cm"> * way as C3 power states (local apic timer and TSC stop)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">amd_e400_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">amd_e400_c1e_detected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>

		<span class="n">rdmsr</span><span class="p">(</span><span class="n">MSR_K8_INT_PENDING_MSG</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&amp;</span> <span class="n">K8_INTP_C1E_ACTIVE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">amd_e400_c1e_detected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_NONSTOP_TSC</span><span class="p">))</span>
				<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;TSC halt in AMD C1E&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;System has AMD C1E enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd_e400_c1e_detected</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">amd_e400_c1e_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">amd_e400_c1e_mask</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Force broadcast so ACPI can not interfere.</span>
<span class="cm">			 */</span>
			<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_BROADCAST_FORCE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Switch to broadcast mode on CPU%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_BROADCAST_ENTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">default_idle</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * The switch back from broadcast mode needs to be</span>
<span class="cm">		 * called with interrupts disabled.</span>
<span class="cm">		 */</span>
		 <span class="n">local_irq_disable</span><span class="p">();</span>
		 <span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_BROADCAST_EXIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>
		 <span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">default_idle</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">select_idle_routine</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpuinfo_x86</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_idle</span> <span class="o">==</span> <span class="n">poll_idle</span> <span class="o">&amp;&amp;</span> <span class="n">smp_num_siblings</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;WARNING: polling idle and HT enabled,&quot;</span>
			<span class="s">&quot; performance may degrade.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_idle</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">X86_FEATURE_MWAIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mwait_usable</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * One CPU supports mwait =&gt; All CPUs supports mwait</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;using mwait in idle threads.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">mwait_idle</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_amd_erratum</span><span class="p">(</span><span class="n">amd_erratum_400</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* E400: APIC timer interrupt does not wake up CPU from C1e */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;using AMD E400 aware idle routine</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">amd_e400_idle</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">default_idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_amd_e400_c1e_mask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we&#39;re using amd_e400_idle, we need to allocate amd_e400_c1e_mask. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_idle</span> <span class="o">==</span> <span class="n">amd_e400_idle</span><span class="p">)</span>
		<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amd_e400_c1e_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">idle_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;poll&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;using polling idle threads.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">poll_idle</span><span class="p">;</span>
		<span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_POLL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;mwait&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_FORCE_MWAIT</span><span class="p">;</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">idle=mwait</span><span class="se">\&quot;</span><span class="s"> will be removed in 2012</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;halt&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When the boot option of idle=halt is added, halt is</span>
<span class="cm">		 * forced to be used for CPU idle. In such case CPU C2/C3</span>
<span class="cm">		 * won&#39;t be used again.</span>
<span class="cm">		 * To continue to load the CPU idle driver, don&#39;t touch</span>
<span class="cm">		 * the boot_option_idle_override.</span>
<span class="cm">		 */</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">default_idle</span><span class="p">;</span>
		<span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_HALT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;nomwait&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the boot option of &quot;idle=nomwait&quot; is added,</span>
<span class="cm">		 * it means that mwait will be disabled for CPU C2/C3</span>
<span class="cm">		 * states. In such case it won&#39;t touch the variable</span>
<span class="cm">		 * of boot_option_idle_override.</span>
<span class="cm">		 */</span>
		<span class="n">boot_option_idle_override</span> <span class="o">=</span> <span class="n">IDLE_NOMWAIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;idle&quot;</span><span class="p">,</span> <span class="n">idle_setup</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_align_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">randomize_va_space</span><span class="p">)</span>
		<span class="n">sp</span> <span class="o">-=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">8192</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_randomize_brk</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range_end</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">+</span> <span class="mh">0x02000000</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">randomize_range</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span> <span class="n">range_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">:</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
