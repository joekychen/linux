<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › tsc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tsc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/acpi_pmtmr.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>

<span class="cp">#include &lt;asm/hpet.h&gt;</span>
<span class="cp">#include &lt;asm/timer.h&gt;</span>
<span class="cp">#include &lt;asm/vgtod.h&gt;</span>
<span class="cp">#include &lt;asm/time.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>
<span class="cp">#include &lt;asm/hypervisor.h&gt;</span>
<span class="cp">#include &lt;asm/nmi.h&gt;</span>
<span class="cp">#include &lt;asm/x86_init.h&gt;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">cpu_khz</span><span class="p">;</span>	<span class="cm">/* TSC clocks / usec, not used here */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_khz</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">tsc_khz</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tsc_khz</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * TSC can be unstable due to cpufreq or due to unsynced TSCs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">tsc_unstable</span><span class="p">;</span>

<span class="cm">/* native_sched_clock() is called before tsc_init(), so</span>
<span class="cm">   we must start with the TSC soft disabled to prevent</span>
<span class="cm">   erroneous rdtsc usage on !cpu_has_tsc processors */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">tsc_disabled</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tsc_clocksource_reliable</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Scheduler clock - returns current time in nanosec units.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">native_sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">this_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fall back to jiffies if there&#39;s no TSC available:</span>
<span class="cm">	 * ( But note that we still use it if the TSC is marked</span>
<span class="cm">	 *   unstable. We do this because unlike Time Of Day,</span>
<span class="cm">	 *   the scheduler clock tolerates small errors and it&#39;s</span>
<span class="cm">	 *   very important for it to be as fast as the platform</span>
<span class="cm">	 *   can achieve it. )</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsc_disabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No locking but a rare wrong value is not a big deal: */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">jiffies_64</span> <span class="o">-</span> <span class="n">INITIAL_JIFFIES</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read the Time Stamp Counter: */</span>
	<span class="n">rdtscll</span><span class="p">(</span><span class="n">this_offset</span><span class="p">);</span>

	<span class="cm">/* return the value in ns */</span>
	<span class="k">return</span> <span class="n">__cycles_2_ns</span><span class="p">(</span><span class="n">this_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We need to define a real function for sched_clock, to override the</span>
<span class="cm">   weak default version */</span>
<span class="cp">#ifdef CONFIG_PARAVIRT</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">paravirt_sched_clock</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>
<span class="n">sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">alias</span><span class="p">(</span><span class="s">&quot;native_sched_clock&quot;</span><span class="p">)));</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">check_tsc_unstable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsc_unstable</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">check_tsc_unstable</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_TSC</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">notsc_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;notsc: Kernel compiled with CONFIG_X86_TSC, &quot;</span>
			<span class="s">&quot;cannot disable TSC completely.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">tsc_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * disable flag for tsc. Takes effect by clearing the TSC cpu flag</span>
<span class="cm"> * in cpu/common.c</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">notsc_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_TSC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;notsc&quot;</span><span class="p">,</span> <span class="n">notsc_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">no_sched_irq_time</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">tsc_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;reliable&quot;</span><span class="p">))</span>
		<span class="n">tsc_clocksource_reliable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;noirqtime&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
		<span class="n">no_sched_irq_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;tsc=&quot;</span><span class="p">,</span> <span class="n">tsc_setup</span><span class="p">);</span>

<span class="cp">#define MAX_RETRIES     5</span>
<span class="cp">#define SMI_TRESHOLD    50000</span>

<span class="cm">/*</span>
<span class="cm"> * Read TSC and the reference counters. Take care of SMI disturbance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">tsc_read_refs</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hpet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t1</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpet</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">hpet_readl</span><span class="p">(</span><span class="n">HPET_COUNTER</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">acpi_pm_read_early</span><span class="p">();</span>
		<span class="n">t2</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SMI_TRESHOLD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">t2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the TSC frequency from HPET reference</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">calc_hpet_ref</span><span class="p">(</span><span class="n">u64</span> <span class="n">deltatsc</span><span class="p">,</span> <span class="n">u64</span> <span class="n">hpet1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">hpet2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpet2</span> <span class="o">&lt;</span> <span class="n">hpet1</span><span class="p">)</span>
		<span class="n">hpet2</span> <span class="o">+=</span> <span class="mh">0x100000000ULL</span><span class="p">;</span>
	<span class="n">hpet2</span> <span class="o">-=</span> <span class="n">hpet1</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">hpet2</span> <span class="o">*</span> <span class="n">hpet_readl</span><span class="p">(</span><span class="n">HPET_PERIOD</span><span class="p">));</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">deltatsc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">deltatsc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the TSC frequency from PMTimer reference</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">calc_pmtimer_ref</span><span class="p">(</span><span class="n">u64</span> <span class="n">deltatsc</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pm1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pm2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pm2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ULONG_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm2</span> <span class="o">&lt;</span> <span class="n">pm1</span><span class="p">)</span>
		<span class="n">pm2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ACPI_PM_OVRRUN</span><span class="p">;</span>
	<span class="n">pm2</span> <span class="o">-=</span> <span class="n">pm1</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">pm2</span> <span class="o">*</span> <span class="mi">1000000000LL</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">PMTMR_TICKS_PER_SEC</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">deltatsc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">deltatsc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CAL_MS		10</span>
<span class="cp">#define CAL_LATCH	(PIT_TICK_RATE / (1000 / CAL_MS))</span>
<span class="cp">#define CAL_PIT_LOOPS	1000</span>

<span class="cp">#define CAL2_MS		50</span>
<span class="cp">#define CAL2_LATCH	(PIT_TICK_RATE / (1000 / CAL2_MS))</span>
<span class="cp">#define CAL2_PIT_LOOPS	5000</span>


<span class="cm">/*</span>
<span class="cm"> * Try to calibrate the TSC against the Programmable</span>
<span class="cm"> * Interrupt Timer and return the frequency of the TSC</span>
<span class="cm"> * in kHz.</span>
<span class="cm"> *</span>
<span class="cm"> * Return ULONG_MAX on failure to calibrate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pit_calibrate_tsc</span><span class="p">(</span><span class="n">u32</span> <span class="n">latch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopmin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tsc</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tscmin</span><span class="p">,</span> <span class="n">tscmax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pitcnt</span><span class="p">;</span>

	<span class="cm">/* Set the Gate high, disable speaker */</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup CTC channel 2* for mode 0, (interrupt on terminal</span>
<span class="cm">	 * count mode), binary count. Set the latch register to 50ms</span>
<span class="cm">	 * (LSB then MSB) to begin countdown.</span>
<span class="cm">	 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">latch</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">latch</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>

	<span class="n">tsc</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>

	<span class="n">pitcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tscmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tscmin</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t2</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">tsc</span><span class="p">;</span>
		<span class="n">tsc</span> <span class="o">=</span> <span class="n">t2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">tscmin</span><span class="p">)</span>
			<span class="n">tscmin</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tscmax</span><span class="p">)</span>
			<span class="n">tscmax</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">pitcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity checks:</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we were not able to read the PIT more than loopmin</span>
<span class="cm">	 * times, then we have been hit by a massive SMI</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the maximum is 10 times larger than the minimum,</span>
<span class="cm">	 * then we got hit by an SMI as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pitcnt</span> <span class="o">&lt;</span> <span class="n">loopmin</span> <span class="o">||</span> <span class="n">tscmax</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tscmin</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ULONG_MAX</span><span class="p">;</span>

	<span class="cm">/* Calculate the PIT value */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This reads the current MSB of the PIT counter, and</span>
<span class="cm"> * checks if we are running on sufficiently fast and</span>
<span class="cm"> * non-virtualized hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Our expectations are:</span>
<span class="cm"> *</span>
<span class="cm"> *  - the PIT is running at roughly 1.19MHz</span>
<span class="cm"> *</span>
<span class="cm"> *  - each IO is going to take about 1us on real hardware,</span>
<span class="cm"> *    but we allow it to be much faster (by a factor of 10) or</span>
<span class="cm"> *    _slightly_ slower (ie we allow up to a 2us read+counter</span>
<span class="cm"> *    update - anything else implies a unacceptably slow CPU</span>
<span class="cm"> *    or PIT for the fast calibration to work.</span>
<span class="cm"> *</span>
<span class="cm"> *  - with 256 PIT ticks to read the value, we have 214us to</span>
<span class="cm"> *    see the same MSB (and overhead like doing a single TSC</span>
<span class="cm"> *    read per MSB value etc).</span>
<span class="cm"> *</span>
<span class="cm"> *  - We&#39;re doing 2 reads per loop (LSB, MSB), and we expect</span>
<span class="cm"> *    them each to take about a microsecond on real hardware.</span>
<span class="cm"> *    So we expect a count value of around 100. But we&#39;ll be</span>
<span class="cm"> *    generous, and accept anything over 50.</span>
<span class="cm"> *</span>
<span class="cm"> *  - if the PIT is stuck, and we see *many* more reads, we</span>
<span class="cm"> *    return early (and the next caller of pit_expect_msb()</span>
<span class="cm"> *    then consider it a failure when they don&#39;t see the</span>
<span class="cm"> *    next expected value).</span>
<span class="cm"> *</span>
<span class="cm"> * These expectations mean that we know that we have seen the</span>
<span class="cm"> * transition from one expected value to another with a fairly</span>
<span class="cm"> * high accuracy, and we didn&#39;t miss any events. We can thus</span>
<span class="cm"> * use the TSC value at the transitions to calculate a pretty</span>
<span class="cm"> * good value for the TSC frequencty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pit_verify_msb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ignore LSB */</span>
	<span class="n">inb</span><span class="p">(</span><span class="mh">0x42</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x42</span><span class="p">)</span> <span class="o">==</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pit_expect_msb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">tscp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">deltap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prev_tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pit_verify_msb</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev_tsc</span> <span class="o">=</span> <span class="n">tsc</span><span class="p">;</span>
		<span class="n">tsc</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">deltap</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">()</span> <span class="o">-</span> <span class="n">prev_tsc</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tscp</span> <span class="o">=</span> <span class="n">tsc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We require _some_ success, but the quality control</span>
<span class="cm">	 * will be based on the error terms on the TSC values.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * How many MSB values do we want to see? We aim for</span>
<span class="cm"> * a maximum error rate of 500ppm (in practice the</span>
<span class="cm"> * real error is much smaller), but refuse to spend</span>
<span class="cm"> * more than 50ms on it.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_QUICK_PIT_MS 50</span>
<span class="cp">#define MAX_QUICK_PIT_ITERATIONS (MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000 / 256)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">quick_pit_calibrate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">;</span>

	<span class="cm">/* Set the Gate high, disable speaker */</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x02</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Counter 2, mode 0 (one-shot), binary count</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE! Mode 2 decrements by two (and then the</span>
<span class="cm">	 * output is flipped each time, giving the same</span>
<span class="cm">	 * final output frequency as a decrement-by-one),</span>
<span class="cm">	 * so mode 0 is much better when looking at the</span>
<span class="cm">	 * individual counts.</span>
<span class="cm">	 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">);</span>

	<span class="cm">/* Start at 0xffff */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PIT starts counting at the next edge, so we</span>
<span class="cm">	 * need to delay for a microsecond. The easiest way</span>
<span class="cm">	 * to do that is to just read back the 16-bit counter</span>
<span class="cm">	 * once from the PIT.</span>
<span class="cm">	 */</span>
	<span class="n">pit_verify_msb</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pit_expect_msb</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_QUICK_PIT_ITERATIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pit_expect_msb</span><span class="p">(</span><span class="mh">0xff</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Iterate until the error is less than 500 ppm</span>
<span class="cm">			 */</span>
			<span class="n">delta</span> <span class="o">-=</span> <span class="n">tsc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">d1</span><span class="o">+</span><span class="n">d2</span> <span class="o">&gt;=</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check the PIT one more time to verify that</span>
<span class="cm">			 * all TSC reads were stable wrt the PIT.</span>
<span class="cm">			 *</span>
<span class="cm">			 * This also guarantees serialization of the</span>
<span class="cm">			 * last cycle read (&#39;d2&#39;) in pit_expect_msb.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pit_verify_msb</span><span class="p">(</span><span class="mh">0xfe</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Fast TSC calibration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">success:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ok, if we get here, then we&#39;ve seen the</span>
<span class="cm">	 * MSB of the PIT decrement &#39;i&#39; times, and the</span>
<span class="cm">	 * error has shrunk to less than 500 ppm.</span>
<span class="cm">	 *</span>
<span class="cm">	 * As a result, we can depend on there not being</span>
<span class="cm">	 * any odd delays anywhere, and the TSC reads are</span>
<span class="cm">	 * reliable (within the error).</span>
<span class="cm">	 *</span>
<span class="cm">	 * kHz = ticks / time-in-seconds / 1000;</span>
<span class="cm">	 * kHz = (t2 - t1) / (I * 256 / PIT_TICK_RATE) / 1000</span>
<span class="cm">	 * kHz = ((t2 - t1) * PIT_TICK_RATE) / (I * 256 * 1000)</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">*=</span> <span class="n">PIT_TICK_RATE</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">256</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Fast TSC calibration using PIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * native_calibrate_tsc - calibrate the tsc on boot</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">native_calibrate_tsc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tsc1</span><span class="p">,</span> <span class="n">tsc2</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsc_pit_min</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">,</span> <span class="n">tsc_ref_min</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">latch</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">fast_calibrate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hpet</span> <span class="o">=</span> <span class="n">is_hpet_enabled</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">loopmin</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">fast_calibrate</span> <span class="o">=</span> <span class="n">quick_pit_calibrate</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fast_calibrate</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fast_calibrate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Run 5 calibration loops to get the lowest frequency value</span>
<span class="cm">	 * (the best estimate). We use two different calibration modes</span>
<span class="cm">	 * here:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) PIT loop. We set the PIT Channel 2 to oneshot mode and</span>
<span class="cm">	 * load a timeout of 50ms. We read the time right after we</span>
<span class="cm">	 * started the timer and wait until the PIT count down reaches</span>
<span class="cm">	 * zero. In each wait loop iteration we read the TSC and check</span>
<span class="cm">	 * the delta to the previous read. We keep track of the min</span>
<span class="cm">	 * and max values of that delta. The delta is mostly defined</span>
<span class="cm">	 * by the IO time of the PIT access, so we can detect when a</span>
<span class="cm">	 * SMI/SMM disturbance happened between the two reads. If the</span>
<span class="cm">	 * maximum time is significantly larger than the minimum time,</span>
<span class="cm">	 * then we discard the result and have another try.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2) Reference counter. If available we use the HPET or the</span>
<span class="cm">	 * PMTIMER as a reference to check the sanity of that value.</span>
<span class="cm">	 * We use separate TSC readouts and check inside of the</span>
<span class="cm">	 * reference read for a SMI/SMM disturbance. We dicard</span>
<span class="cm">	 * disturbed values here as well. We do that around the PIT</span>
<span class="cm">	 * calibration delay loop as we have to wait for a certain</span>
<span class="cm">	 * amount of time anyway.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Preset PIT loop values */</span>
	<span class="n">latch</span> <span class="o">=</span> <span class="n">CAL_LATCH</span><span class="p">;</span>
	<span class="n">ms</span> <span class="o">=</span> <span class="n">CAL_MS</span><span class="p">;</span>
	<span class="n">loopmin</span> <span class="o">=</span> <span class="n">CAL_PIT_LOOPS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsc_pit_khz</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the start value and the reference count of</span>
<span class="cm">		 * hpet/pmtimer when available. Then do the PIT</span>
<span class="cm">		 * calibration, which will take at least 50ms, and</span>
<span class="cm">		 * read the end value.</span>
<span class="cm">		 */</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">tsc1</span> <span class="o">=</span> <span class="n">tsc_read_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref1</span><span class="p">,</span> <span class="n">hpet</span><span class="p">);</span>
		<span class="n">tsc_pit_khz</span> <span class="o">=</span> <span class="n">pit_calibrate_tsc</span><span class="p">(</span><span class="n">latch</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">loopmin</span><span class="p">);</span>
		<span class="n">tsc2</span> <span class="o">=</span> <span class="n">tsc_read_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">,</span> <span class="n">hpet</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Pick the lowest PIT TSC calibration so far */</span>
		<span class="n">tsc_pit_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tsc_pit_min</span><span class="p">,</span> <span class="n">tsc_pit_khz</span><span class="p">);</span>

		<span class="cm">/* hpet or pmtimer available ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span> <span class="o">==</span> <span class="n">ref2</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check, whether the sampling was disturbed by an SMI */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsc1</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span> <span class="o">||</span> <span class="n">tsc2</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">tsc2</span> <span class="o">=</span> <span class="p">(</span><span class="n">tsc2</span> <span class="o">-</span> <span class="n">tsc1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000LL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpet</span><span class="p">)</span>
			<span class="n">tsc2</span> <span class="o">=</span> <span class="n">calc_hpet_ref</span><span class="p">(</span><span class="n">tsc2</span><span class="p">,</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">tsc2</span> <span class="o">=</span> <span class="n">calc_pmtimer_ref</span><span class="p">(</span><span class="n">tsc2</span><span class="p">,</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">);</span>

		<span class="n">tsc_ref_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tsc_ref_min</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">tsc2</span><span class="p">);</span>

		<span class="cm">/* Check the reference deviation */</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">tsc_pit_min</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">tsc_ref_min</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If both calibration results are inside a 10% window</span>
<span class="cm">		 * then we can be sure, that the calibration</span>
<span class="cm">		 * succeeded. We break out of the loop right away. We</span>
<span class="cm">		 * use the reference value, as it is more precise.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;=</span> <span class="mi">90</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">110</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;TSC: PIT calibration matches %s. %d loops</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">hpet</span> <span class="o">?</span> <span class="s">&quot;HPET&quot;</span> <span class="o">:</span> <span class="s">&quot;PMTIMER&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">tsc_ref_min</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check whether PIT failed more than once. This</span>
<span class="cm">		 * happens in virtualized environments. We need to</span>
<span class="cm">		 * give the virtual PC a slightly longer timeframe for</span>
<span class="cm">		 * the HPET/PMTIMER to make the result precise.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tsc_pit_min</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">latch</span> <span class="o">=</span> <span class="n">CAL2_LATCH</span><span class="p">;</span>
			<span class="n">ms</span> <span class="o">=</span> <span class="n">CAL2_MS</span><span class="p">;</span>
			<span class="n">loopmin</span> <span class="o">=</span> <span class="n">CAL2_PIT_LOOPS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now check the results.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_pit_min</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PIT gave no useful value */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;TSC: Unable to calibrate against PIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* We don&#39;t have an alternative source, disable TSC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpet</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TSC: No reference (HPET/PMTIMER) available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The alternative source failed as well, disable TSC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsc_ref_min</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;TSC: HPET/PMTIMER calibration &quot;</span>
			       <span class="s">&quot;failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Use the alternative source */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;TSC: using %s reference calibration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hpet</span> <span class="o">?</span> <span class="s">&quot;HPET&quot;</span> <span class="o">:</span> <span class="s">&quot;PMTIMER&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">tsc_ref_min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t have an alternative source, use the PIT calibration value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpet</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;TSC: Using PIT calibration value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tsc_pit_min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The alternative source failed, use the PIT calibration value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_ref_min</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;TSC: HPET/PMTIMER calibration failed. &quot;</span>
		       <span class="s">&quot;Using PIT calibration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tsc_pit_min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The calibration values differ too much. In doubt, we use</span>
<span class="cm">	 * the PIT value as we know that there are PMTIMERs around</span>
<span class="cm">	 * running at double speed. At least we let the user know:</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;TSC: PIT calibration deviates from %s: %lu %lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">hpet</span> <span class="o">?</span> <span class="s">&quot;HPET&quot;</span> <span class="o">:</span> <span class="s">&quot;PMTIMER&quot;</span><span class="p">,</span> <span class="n">tsc_pit_min</span><span class="p">,</span> <span class="n">tsc_ref_min</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;TSC: Using PIT calibration value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tsc_pit_min</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">recalibrate_cpu_khz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_khz_old</span> <span class="o">=</span> <span class="n">cpu_khz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has_tsc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsc_khz</span> <span class="o">=</span> <span class="n">x86_platform</span><span class="p">.</span><span class="n">calibrate_tsc</span><span class="p">();</span>
		<span class="n">cpu_khz</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>
		<span class="n">cpu_data</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">loops_per_jiffy</span> <span class="o">=</span>
			<span class="n">cpufreq_scale</span><span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">loops_per_jiffy</span><span class="p">,</span>
					<span class="n">cpu_khz_old</span><span class="p">,</span> <span class="n">cpu_khz</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">recalibrate_cpu_khz</span><span class="p">);</span>


<span class="cm">/* Accelerators for sched_clock()</span>
<span class="cm"> * convert from cycles(64bits) =&gt; nanoseconds (64bits)</span>
<span class="cm"> *  basic equation:</span>
<span class="cm"> *              ns = cycles / (freq / ns_per_sec)</span>
<span class="cm"> *              ns = cycles * (ns_per_sec / freq)</span>
<span class="cm"> *              ns = cycles * (10^9 / (cpu_khz * 10^3))</span>
<span class="cm"> *              ns = cycles * (10^6 / cpu_khz)</span>
<span class="cm"> *</span>
<span class="cm"> *      Then we use scaling math (suggested by george@mvista.com) to get:</span>
<span class="cm"> *              ns = cycles * (10^6 * SC / cpu_khz) / SC</span>
<span class="cm"> *              ns = cycles * cyc2ns_scale / SC</span>
<span class="cm"> *</span>
<span class="cm"> *      And since SC is a constant power of two, we can convert the div</span>
<span class="cm"> *  into a shift.</span>
<span class="cm"> *</span>
<span class="cm"> *  We can use khz divisor instead of mhz to keep a better precision, since</span>
<span class="cm"> *  cyc2ns_scale is limited to 10^6 * 2^10, which fits in 32 bits.</span>
<span class="cm"> *  (mathieu.desnoyers@polymtl.ca)</span>
<span class="cm"> *</span>
<span class="cm"> *                      -johnstul@us.ibm.com &quot;math is hard, lets go shopping!&quot;</span>
<span class="cm"> */</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">cyc2ns</span><span class="p">);</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">cyc2ns_offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cyc2ns_scale</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_khz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tsc_now</span><span class="p">,</span> <span class="n">ns_now</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="o">*</span><span class="n">scale</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sched_clock_idle_sleep_event</span><span class="p">();</span>

	<span class="n">scale</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns_offset</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">rdtscll</span><span class="p">(</span><span class="n">tsc_now</span><span class="p">);</span>
	<span class="n">ns_now</span> <span class="o">=</span> <span class="n">__cycles_2_ns</span><span class="p">(</span><span class="n">tsc_now</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_khz</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSEC_PER_MSEC</span> <span class="o">&lt;&lt;</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">)</span><span class="o">/</span><span class="n">cpu_khz</span><span class="p">;</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ns_now</span> <span class="o">-</span> <span class="n">mult_frac</span><span class="p">(</span><span class="n">tsc_now</span><span class="p">,</span> <span class="o">*</span><span class="n">scale</span><span class="p">,</span>
					     <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">CYC2NS_SCALE_FACTOR</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cyc2ns_suspend</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">tsc_save_sched_clock_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_clock_stable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cyc2ns_suspend</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Even on processors with invariant TSC, TSC gets reset in some the</span>
<span class="cm"> * ACPI system sleep states. And in some systems BIOS seem to reinit TSC to</span>
<span class="cm"> * arbitrary value (still sync&#39;d across cpu&#39;s) during resume from such sleep</span>
<span class="cm"> * states. To cope up with this, recompute the cyc2ns_offset for each cpu so</span>
<span class="cm"> * that sched_clock() continues from the point where it was left off during</span>
<span class="cm"> * suspend.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tsc_restore_sched_clock_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_clock_stable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">cyc2ns_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">cyc2ns_suspend</span> <span class="o">-</span> <span class="n">sched_clock</span><span class="p">();</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">per_cpu</span><span class="p">(</span><span class="n">cyc2ns_offset</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>

<span class="cm">/* Frequency scaling support. Adjust the TSC based timer when the cpu frequency</span>
<span class="cm"> * changes.</span>
<span class="cm"> *</span>
<span class="cm"> * RED-PEN: On SMP we assume all CPUs run with the same frequency.  It&#39;s</span>
<span class="cm"> * not that important because current Opteron setups do not support</span>
<span class="cm"> * scaling on SMP anyroads.</span>
<span class="cm"> *</span>
<span class="cm"> * Should fix up last_tsc too. Currently gettimeofday in the</span>
<span class="cm"> * first tick after the change will be slightly wrong.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">ref_freq</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">loops_per_jiffy_ref</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsc_khz_ref</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">time_cpufreq_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpufreq_freqs</span> <span class="o">*</span><span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lpj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">),</span> <span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">loops_per_jiffy</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPUFREQ_CONST_LOOPS</span><span class="p">))</span>
		<span class="n">lpj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">).</span><span class="n">loops_per_jiffy</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref_freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">;</span>
		<span class="n">loops_per_jiffy_ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">lpj</span><span class="p">;</span>
		<span class="n">tsc_khz_ref</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_PRECHANGE</span>  <span class="o">&amp;&amp;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&lt;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_POSTCHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">old</span> <span class="o">&gt;</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">CPUFREQ_RESUMECHANGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lpj</span> <span class="o">=</span> <span class="n">cpufreq_scale</span><span class="p">(</span><span class="n">loops_per_jiffy_ref</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">);</span>

		<span class="n">tsc_khz</span> <span class="o">=</span> <span class="n">cpufreq_scale</span><span class="p">(</span><span class="n">tsc_khz_ref</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">freq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPUFREQ_CONST_LOOPS</span><span class="p">))</span>
			<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;cpufreq changes&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_cyc2ns_scale</span><span class="p">(</span><span class="n">tsc_khz</span><span class="p">,</span> <span class="n">freq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">time_cpufreq_notifier_block</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>  <span class="o">=</span> <span class="n">time_cpufreq_notifier</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpufreq_tsc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_tsc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpufreq_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_cpufreq_notifier_block</span><span class="p">,</span>
				<span class="n">CPUFREQ_TRANSITION_NOTIFIER</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">cpufreq_tsc</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_CPU_FREQ */</span><span class="cp"></span>

<span class="cm">/* clocksource code */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">clocksource_tsc</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We compare the TSC to the cycle_last value in the clocksource</span>
<span class="cm"> * structure to avoid a nasty time-warp. This can be observed in a</span>
<span class="cm"> * very small window right after one CPU updated cycle_last under</span>
<span class="cm"> * xtime/vsyscall_gtod lock and the other CPU reads a TSC value which</span>
<span class="cm"> * is smaller than the cycle_last reference value due to a TSC which</span>
<span class="cm"> * is slighty behind. This delta is nowhere else observable, but in</span>
<span class="cm"> * that case it results in a forward time jump in the range of hours</span>
<span class="cm"> * due to the unsigned delta calculation of the time keeping core</span>
<span class="cm"> * code, which is necessary to support wrapping clocksources like pm</span>
<span class="cm"> * timer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">read_tsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_t</span><span class="p">)</span><span class="n">get_cycles</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">cycle_last</span> <span class="o">?</span>
		<span class="n">ret</span> <span class="o">:</span> <span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">cycle_last</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">resume_tsc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="n">clocksource_tsc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>                   <span class="o">=</span> <span class="s">&quot;tsc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rating</span>                 <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>                   <span class="o">=</span> <span class="n">read_tsc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>			<span class="o">=</span> <span class="n">resume_tsc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span>                   <span class="o">=</span> <span class="n">CLOCKSOURCE_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
	<span class="p">.</span><span class="n">flags</span>                  <span class="o">=</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span> <span class="o">|</span>
				  <span class="n">CLOCK_SOURCE_MUST_VERIFY</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="p">.</span><span class="n">archdata</span>               <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">vclock_mode</span> <span class="o">=</span> <span class="n">VCLOCK_TSC</span> <span class="p">},</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">mark_tsc_unstable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsc_unstable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsc_unstable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sched_clock_stable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">disable_sched_clock_irqtime</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Marking TSC unstable due to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
		<span class="cm">/* Change only the rating, when not registered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">mult</span><span class="p">)</span>
			<span class="n">clocksource_mark_unstable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_tsc</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_UNSTABLE</span><span class="p">;</span>
			<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">rating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mark_tsc_unstable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">check_system_tsc_reliable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MGEODE_LX</span>
	<span class="cm">/* RTSC counts during suspend */</span>
<span class="cp">#define RTSC_SUSP 0x100</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">res_low</span><span class="p">,</span> <span class="n">res_high</span><span class="p">;</span>

	<span class="n">rdmsr_safe</span><span class="p">(</span><span class="n">MSR_GEODE_BUSCONT_CONF0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res_low</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res_high</span><span class="p">);</span>
	<span class="cm">/* Geode_LX - the OLPC CPU has a very reliable TSC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_low</span> <span class="o">&amp;</span> <span class="n">RTSC_SUSP</span><span class="p">)</span>
		<span class="n">tsc_clocksource_reliable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_TSC_RELIABLE</span><span class="p">))</span>
		<span class="n">tsc_clocksource_reliable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make an educated guess if the TSC is trustworthy and synchronized</span>
<span class="cm"> * over all CPUs.</span>
<span class="cm"> */</span>
<span class="n">__cpuinit</span> <span class="kt">int</span> <span class="nf">unsynchronized_tsc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_tsc</span> <span class="o">||</span> <span class="n">tsc_unstable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apic_is_clustered_box</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_clocksource_reliable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Intel systems are normally all synchronized.</span>
<span class="cm">	 * Exceptions must mark TSC as unstable:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">!=</span> <span class="n">X86_VENDOR_INTEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* assume multi socket systems are not synchronized: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">tsc_refine_calibration_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">tsc_irqwork</span><span class="p">,</span> <span class="n">tsc_refine_calibration_work</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * tsc_refine_calibration_work - Further refine tsc freq calibration</span>
<span class="cm"> * @work - ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * This functions uses delayed work over a period of a</span>
<span class="cm"> * second to further refine the TSC freq value. Since this is</span>
<span class="cm"> * timer based, instead of loop based, we don&#39;t block the boot</span>
<span class="cm"> * process while this longer calibration is done.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are any calibration anomalies (too many SMIs, etc),</span>
<span class="cm"> * or the refined calibration is off by 1% of the fast early</span>
<span class="cm"> * calibration, we throw out the new calibration and use the</span>
<span class="cm"> * early calibration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsc_refine_calibration_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">u64</span> <span class="n">tsc_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ref_start</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">hpet</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tsc_stop</span><span class="p">,</span> <span class="n">ref_stop</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t bother refining TSC on unstable systems */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_tsc_unstable</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the work is started early in boot, we may be</span>
<span class="cm">	 * delayed the first time we expire. So set the workqueue</span>
<span class="cm">	 * again once we know timers are working.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only set hpet once, to avoid mixing hardware</span>
<span class="cm">		 * if the hpet becomes enabled later.</span>
<span class="cm">		 */</span>
		<span class="n">hpet</span> <span class="o">=</span> <span class="n">is_hpet_enabled</span><span class="p">();</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsc_irqwork</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">tsc_start</span> <span class="o">=</span> <span class="n">tsc_read_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_start</span><span class="p">,</span> <span class="n">hpet</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tsc_stop</span> <span class="o">=</span> <span class="n">tsc_read_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_stop</span><span class="p">,</span> <span class="n">hpet</span><span class="p">);</span>

	<span class="cm">/* hpet or pmtimer available ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_start</span> <span class="o">==</span> <span class="n">ref_stop</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check, whether the sampling was disturbed by an SMI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_start</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span> <span class="o">||</span> <span class="n">tsc_stop</span> <span class="o">==</span> <span class="n">ULLONG_MAX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">tsc_stop</span> <span class="o">-</span> <span class="n">tsc_start</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">*=</span> <span class="mi">1000000LL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpet</span><span class="p">)</span>
		<span class="n">freq</span> <span class="o">=</span> <span class="n">calc_hpet_ref</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">ref_start</span><span class="p">,</span> <span class="n">ref_stop</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">freq</span> <span class="o">=</span> <span class="n">calc_pmtimer_ref</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">ref_start</span><span class="p">,</span> <span class="n">ref_stop</span><span class="p">);</span>

	<span class="cm">/* Make sure we&#39;re within 1% */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">tsc_khz</span> <span class="o">-</span> <span class="n">freq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tsc_khz</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">tsc_khz</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Refined TSC clocksource calibration: &quot;</span>
		<span class="s">&quot;%lu.%03lu MHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tsc_khz</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tsc_khz</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">clocksource_register_khz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_tsc</span><span class="p">,</span> <span class="n">tsc_khz</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_tsc_clocksource</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_tsc</span> <span class="o">||</span> <span class="n">tsc_disabled</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">tsc_khz</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_clocksource_reliable</span><span class="p">)</span>
		<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_SOURCE_MUST_VERIFY</span><span class="p">;</span>
	<span class="cm">/* lower the rating if we already know its unstable: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_tsc_unstable</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">rating</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">clocksource_tsc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trust the results of the earlier calibration on systems</span>
<span class="cm">	 * exporting a reliable TSC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_TSC_RELIABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clocksource_register_khz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_tsc</span><span class="p">,</span> <span class="n">tsc_khz</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsc_irqwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * We use device_initcall here, to ensure we run after the hpet</span>
<span class="cm"> * is fully initialized, which may occur at fs_initcall time.</span>
<span class="cm"> */</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">init_tsc_clocksource</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">tsc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">lpj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">x86_init</span><span class="p">.</span><span class="n">timers</span><span class="p">.</span><span class="n">tsc_pre_init</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_has_tsc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tsc_khz</span> <span class="o">=</span> <span class="n">x86_platform</span><span class="p">.</span><span class="n">calibrate_tsc</span><span class="p">();</span>
	<span class="n">cpu_khz</span> <span class="o">=</span> <span class="n">tsc_khz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsc_khz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;could not calculate TSC khz&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Detected %lu.%03lu MHz processor.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_khz</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpu_khz</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Secondary CPUs do not run through tsc_init(), so set up</span>
<span class="cm">	 * all the scale factors for all CPUs, assuming the same</span>
<span class="cm">	 * speed as the bootup CPU. (cpufreq notifiers will fix this</span>
<span class="cm">	 * up if their speed diverges)</span>
<span class="cm">	 */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">set_cyc2ns_scale</span><span class="p">(</span><span class="n">cpu_khz</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsc_disabled</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* now allow native_sched_clock() to use rdtsc */</span>
	<span class="n">tsc_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_sched_irq_time</span><span class="p">)</span>
		<span class="n">enable_sched_clock_irqtime</span><span class="p">();</span>

	<span class="n">lpj</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">tsc_khz</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">lpj</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">lpj_fine</span> <span class="o">=</span> <span class="n">lpj</span><span class="p">;</span>

	<span class="n">use_tsc_delay</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unsynchronized_tsc</span><span class="p">())</span>
		<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;TSCs unsynchronized&quot;</span><span class="p">);</span>

	<span class="n">check_system_tsc_reliable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * If we have a constant TSC and are using the TSC for the delay loop,</span>
<span class="cm"> * we can skip clock calibration if another cpu in the same socket has already</span>
<span class="cm"> * been calibrated. This assumes that CONSTANT_TSC applies to all</span>
<span class="cm"> * cpus in the socket - this should be a safe assumption.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinit</span> <span class="nf">calibrate_delay_is_known</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsc_disabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_has</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">X86_FEATURE_CONSTANT_TSC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">phys_proc_id</span> <span class="o">==</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">cpu</span><span class="p">).</span><span class="n">phys_proc_id</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu_data</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">loops_per_jiffy</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
