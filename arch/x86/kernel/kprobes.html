<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › kprobes.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kprobes.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Kernel Probes (KProbes)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) IBM Corporation, 2002, 2004</span>
<span class="cm"> *</span>
<span class="cm"> * 2002-Oct	Created by Vamsi Krishna S &lt;vamsi_krishna@in.ibm.com&gt; Kernel</span>
<span class="cm"> *		Probes initial implementation ( includes contributions from</span>
<span class="cm"> *		Rusty Russell).</span>
<span class="cm"> * 2004-July	Suparna Bhattacharya &lt;suparna@in.ibm.com&gt; added jumper probes</span>
<span class="cm"> *		interface to access function arguments.</span>
<span class="cm"> * 2004-Oct	Jim Keniston &lt;jkenisto@us.ibm.com&gt; and Prasanna S Panchamukhi</span>
<span class="cm"> *		&lt;prasanna@in.ibm.com&gt; adapted for x86_64 from i386.</span>
<span class="cm"> * 2005-Mar	Roland McGrath &lt;roland@redhat.com&gt;</span>
<span class="cm"> *		Fixed to handle %rip-relative addressing mode correctly.</span>
<span class="cm"> * 2005-May	Hien Nguyen &lt;hien@us.ibm.com&gt;, Jim Keniston</span>
<span class="cm"> *		&lt;jkenisto@us.ibm.com&gt; and Prasanna S Panchamukhi</span>
<span class="cm"> *		&lt;prasanna@in.ibm.com&gt; added function-return probes.</span>
<span class="cm"> * 2005-May	Rusty Lynch &lt;rusty.lynch@intel.com&gt;</span>
<span class="cm"> *		Added function return probes functionality</span>
<span class="cm"> * 2006-Feb	Masami Hiramatsu &lt;hiramatu@sdl.hitachi.co.jp&gt; added</span>
<span class="cm"> *		kprobe-booster and kretprobe-booster for i386.</span>
<span class="cm"> * 2007-Dec	Masami Hiramatsu &lt;mhiramat@redhat.com&gt; added kprobe-booster</span>
<span class="cm"> *		and kretprobe-booster for x86-64</span>
<span class="cm"> * 2007-Dec	Masami Hiramatsu &lt;mhiramat@redhat.com&gt;, Arjan van de Ven</span>
<span class="cm"> *		&lt;arjan@infradead.org&gt; and Jim Keniston &lt;jkenisto@us.ibm.com&gt;</span>
<span class="cm"> *		unified x86 kprobes code.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/alternative.h&gt;</span>
<span class="cp">#include &lt;asm/insn.h&gt;</span>
<span class="cp">#include &lt;asm/debugreg.h&gt;</span>

<span class="cp">#include &quot;kprobes-common.h&quot;</span>

<span class="kt">void</span> <span class="n">jprobe_return_end</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="p">,</span> <span class="n">current_kprobe</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_ctlblk</span><span class="p">,</span> <span class="n">kprobe_ctlblk</span><span class="p">);</span>

<span class="cp">#define stack_addr(regs) ((unsigned long *)kernel_stack_pointer(regs))</span>

<span class="cp">#define W(row, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, ba, bb, bc, bd, be, bf)\</span>
<span class="cp">	(((b0##UL &lt;&lt; 0x0)|(b1##UL &lt;&lt; 0x1)|(b2##UL &lt;&lt; 0x2)|(b3##UL &lt;&lt; 0x3) |   \</span>
<span class="cp">	  (b4##UL &lt;&lt; 0x4)|(b5##UL &lt;&lt; 0x5)|(b6##UL &lt;&lt; 0x6)|(b7##UL &lt;&lt; 0x7) |   \</span>
<span class="cp">	  (b8##UL &lt;&lt; 0x8)|(b9##UL &lt;&lt; 0x9)|(ba##UL &lt;&lt; 0xa)|(bb##UL &lt;&lt; 0xb) |   \</span>
<span class="cp">	  (bc##UL &lt;&lt; 0xc)|(bd##UL &lt;&lt; 0xd)|(be##UL &lt;&lt; 0xe)|(bf##UL &lt;&lt; 0xf))    \</span>
<span class="cp">	 &lt;&lt; (row % 32))</span>
	<span class="cm">/*</span>
<span class="cm">	 * Undefined/reserved opcodes, conditional jump, Opcode Extension</span>
<span class="cm">	 * Groups, and some special opcodes can not boost.</span>
<span class="cm">	 * This is non-const and volatile to keep gcc from statically</span>
<span class="cm">	 * optimizing it out, as variable_test_bit makes gcc think only</span>
<span class="cm">	 * *(unsigned long*) is used. </span>
<span class="cm">	 */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">twobyte_is_boostable</span><span class="p">[</span><span class="mi">256</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f          */</span>
	<span class="cm">/*      ----------------------------------------------          */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* 00 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* 10 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* 20 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* 30 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* 40 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* 50 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x60</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* 60 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x70</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* 70 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* 80 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* 90 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* a0 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* b0 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* c0 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xd0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="cm">/* d0 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xe0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="cm">/* e0 */</span>
	<span class="n">W</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="cm">/* f0 */</span>
	<span class="cm">/*      -----------------------------------------------         */</span>
	<span class="cm">/*      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f          */</span>
<span class="p">};</span>
<span class="cp">#undef W</span>

<span class="k">struct</span> <span class="n">kretprobe_blackpoint</span> <span class="n">kretprobe_blacklist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;__switch_to&quot;</span><span class="p">,</span> <span class="p">},</span> <span class="cm">/* This function switches only current task, but</span>
<span class="cm">			      doesn&#39;t switch kernel stack.*/</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>	<span class="cm">/* Terminator */</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">kretprobe_blacklist_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">kretprobe_blacklist</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">__synthesize_relative_insn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">u8</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__arch_relative_insn</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">op</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">raddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="o">*</span><span class="n">insn</span><span class="p">;</span>

	<span class="n">insn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__arch_relative_insn</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">;</span>
	<span class="n">insn</span><span class="o">-&gt;</span><span class="n">raddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)((</span><span class="kt">long</span><span class="p">)(</span><span class="n">to</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">from</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">));</span>
	<span class="n">insn</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Insert a jump instruction at address &#39;from&#39;, which jumps to address &#39;to&#39;.*/</span>
<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">synthesize_reljump</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__synthesize_relative_insn</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">RELATIVEJUMP_OPCODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert a call instruction at address &#39;from&#39;, which calls address &#39;to&#39;.*/</span>
<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">synthesize_relcall</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__synthesize_relative_insn</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">RELATIVECALL_OPCODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Skip the prefixes of the instruction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">__kprobes</span> <span class="nf">skip_prefixes</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">insn_attr_t</span> <span class="n">attr</span><span class="p">;</span>

	<span class="n">attr</span> <span class="o">=</span> <span class="n">inat_get_opcode_attribute</span><span class="p">((</span><span class="n">insn_byte_t</span><span class="p">)</span><span class="o">*</span><span class="n">insn</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">inat_is_legacy_prefix</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">insn</span><span class="o">++</span><span class="p">;</span>
		<span class="n">attr</span> <span class="o">=</span> <span class="n">inat_get_opcode_attribute</span><span class="p">((</span><span class="n">insn_byte_t</span><span class="p">)</span><span class="o">*</span><span class="n">insn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inat_is_rex_prefix</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
		<span class="n">insn</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">insn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns non-zero if opcode is boostable.</span>
<span class="cm"> * RIP relative instructions are adjusted at copying time in 64 bits mode</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">can_boost</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">opcodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">orig_opcodes</span> <span class="o">=</span> <span class="n">opcodes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">search_exception_tables</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">opcodes</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Page fault may occur on this address. */</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opcodes</span> <span class="o">-</span> <span class="n">orig_opcodes</span> <span class="o">&gt;</span> <span class="n">MAX_INSN_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">opcodes</span><span class="o">++</span><span class="p">);</span>

	<span class="cm">/* 2nd-byte opcode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcodes</span> <span class="o">-</span> <span class="n">orig_opcodes</span> <span class="o">&gt;</span> <span class="n">MAX_INSN_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="o">*</span><span class="n">opcodes</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">twobyte_is_boostable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">case</span> <span class="mh">0x40</span>:
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="cm">/* REX prefix is boostable */</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="mh">0x60</span>:
		<span class="k">if</span> <span class="p">(</span><span class="mh">0x63</span> <span class="o">&lt;</span> <span class="n">opcode</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">&lt;</span> <span class="mh">0x67</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="cm">/* prefixes */</span>
		<span class="cm">/* can&#39;t boost Address-size override and bound */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="mh">0x62</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">!=</span> <span class="mh">0x67</span><span class="p">);</span>
	<span class="k">case</span> <span class="mh">0x70</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* can&#39;t boost conditional jump */</span>
	<span class="k">case</span> <span class="mh">0xc0</span>:
		<span class="cm">/* can&#39;t boost software-interruptions */</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0xc1</span> <span class="o">&lt;</span> <span class="n">opcode</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">&lt;</span> <span class="mh">0xcc</span><span class="p">)</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xcf</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xd0</span>:
		<span class="cm">/* can boost AA* and XLAT */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xd4</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xd5</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xd7</span><span class="p">);</span>
	<span class="k">case</span> <span class="mh">0xe0</span>:
		<span class="cm">/* can boost in/out and absolute jmps */</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xea</span><span class="p">);</span>
	<span class="k">case</span> <span class="mh">0xf0</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0x0c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">!=</span> <span class="mh">0xf1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="cm">/* lock/rep(ne) prefix */</span>
		<span class="cm">/* clear and set flags are boostable */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mh">0xf5</span> <span class="o">||</span> <span class="p">(</span><span class="mh">0xf7</span> <span class="o">&lt;</span> <span class="n">opcode</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">&lt;</span> <span class="mh">0xfe</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="cm">/* segment override prefixes are boostable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mh">0x26</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0x36</span> <span class="o">||</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mh">0x3e</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="cm">/* prefixes */</span>
		<span class="cm">/* CS override prefix and call are not boostable */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="mh">0x2e</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">!=</span> <span class="mh">0x9a</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">__recover_probed_insn</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">kp</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* There is no probe, return original address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Basically, kp-&gt;ainsn.insn has an original instruction.</span>
<span class="cm">	 *  However, RIP-relative instruction can not do single-stepping</span>
<span class="cm">	 *  at different place, __copy_instruction() tweaks the displacement of</span>
<span class="cm">	 *  that instruction. In that case, we can&#39;t recover the instruction</span>
<span class="cm">	 *  from the kp-&gt;ainsn.insn.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  On the other hand, kp-&gt;opcode has a copy of the first byte of</span>
<span class="cm">	 *  the probed instruction, which is overwritten by int3. And</span>
<span class="cm">	 *  the instruction at kp-&gt;addr is not modified by kprobes except</span>
<span class="cm">	 *  for the first byte, we can recover the original instruction</span>
<span class="cm">	 *  from it and kp-&gt;opcode.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">MAX_INSN_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recover the probed instruction at addr for further analysis.</span>
<span class="cm"> * Caller must lock kprobes by kprobe_mutex, or disable preemption</span>
<span class="cm"> * for preventing to release referencing kprobes.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">recover_probed_instruction</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__addr</span><span class="p">;</span>

	<span class="n">__addr</span> <span class="o">=</span> <span class="n">__recover_optprobed_insn</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__addr</span> <span class="o">!=</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__addr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__recover_probed_insn</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check if paddr is at an instruction boundary */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">can_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">__addr</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">insn</span> <span class="n">insn</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_INSN_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kallsyms_lookup_size_offset</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Decode instructions */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">paddr</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">paddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if the instruction has been modified by another</span>
<span class="cm">		 * kprobe, in which case we replace the breakpoint by the</span>
<span class="cm">		 * original instruction in our buffer.</span>
<span class="cm">		 * Also, jump optimization will change the breakpoint to</span>
<span class="cm">		 * relative-jump. Since the relative-jump itself is</span>
<span class="cm">		 * normally used, we just go through if there is no kprobe.</span>
<span class="cm">		 */</span>
		<span class="n">__addr</span> <span class="o">=</span> <span class="n">recover_probed_instruction</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">kernel_insn_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__addr</span><span class="p">);</span>
		<span class="n">insn_get_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Another debugging subsystem might insert this breakpoint.</span>
<span class="cm">		 * In that case, we can&#39;t recover it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="p">.</span><span class="n">opcode</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">insn</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">paddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns non-zero if opcode modifies the interrupt flag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">is_IF_modifier</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Skip prefixes */</span>
	<span class="n">insn</span> <span class="o">=</span> <span class="n">skip_prefixes</span><span class="p">(</span><span class="n">insn</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">insn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xfa</span>:		<span class="cm">/* cli */</span>
	<span class="k">case</span> <span class="mh">0xfb</span>:		<span class="cm">/* sti */</span>
	<span class="k">case</span> <span class="mh">0xcf</span>:		<span class="cm">/* iret/iretd */</span>
	<span class="k">case</span> <span class="mh">0x9d</span>:		<span class="cm">/* popf/popfd */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy an instruction and adjust the displacement if the instruction</span>
<span class="cm"> * uses the %rip-relative addressing mode.</span>
<span class="cm"> * If it does, Return the address of the 32-bit displacement word.</span>
<span class="cm"> * If not, return null.</span>
<span class="cm"> * Only applicable to 64-bit x86.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">__copy_instruction</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">insn</span> <span class="n">insn</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_INSN_SIZE</span><span class="p">];</span>

	<span class="n">kernel_insn_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">recover_probed_instruction</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">src</span><span class="p">));</span>
	<span class="n">insn_get_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>
	<span class="cm">/* Another subsystem puts a breakpoint, failed to recover */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn</span><span class="p">.</span><span class="n">opcode</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">insn</span><span class="p">.</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">insn</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insn_rip_relative</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">newdisp</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">disp</span><span class="p">;</span>
		<span class="n">kernel_insn_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
		<span class="n">insn_get_displacement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The copied instruction uses the %rip-relative addressing</span>
<span class="cm">		 * mode.  Adjust the displacement for the difference between</span>
<span class="cm">		 * the original location of this instruction and the location</span>
<span class="cm">		 * of the copy that will actually be run.  The tricky bit here</span>
<span class="cm">		 * is making sure that the sign extension happens correctly in</span>
<span class="cm">		 * this calculation, since we need a signed 32-bit result to</span>
<span class="cm">		 * be sign-extended to 64 bits when it&#39;s added to the %rip</span>
<span class="cm">		 * value and yield the same 64-bit result that the sign-</span>
<span class="cm">		 * extension of the original signed 32-bit displacement would</span>
<span class="cm">		 * have given.</span>
<span class="cm">		 */</span>
		<span class="n">newdisp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">src</span> <span class="o">+</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">insn</span><span class="p">.</span><span class="n">displacement</span><span class="p">.</span><span class="n">value</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">dest</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">newdisp</span> <span class="o">!=</span> <span class="n">newdisp</span><span class="p">);</span> <span class="cm">/* Sanity check.  */</span>
		<span class="n">disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">dest</span> <span class="o">+</span> <span class="n">insn_offset_displacement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">s32</span> <span class="o">*</span><span class="p">)</span> <span class="n">disp</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">newdisp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">insn</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_copy_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy an instruction with recovering if other optprobe modifies it.*/</span>
	<span class="n">__copy_instruction</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * __copy_instruction can modify the displacement of the instruction,</span>
<span class="cm">	 * but it doesn&#39;t affect boostable check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_boost</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Also, displacement change doesn&#39;t affect the first byte */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">arch_prepare_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alternatives_text_reserved</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_probe</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
	<span class="cm">/* insn: must be on special executable page on x86. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span> <span class="o">=</span> <span class="n">get_insn_slot</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">arch_copy_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_arm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">text_poke</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">[]){</span><span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">}),</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_disarm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">text_poke</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arch_remove_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_insn_slot</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">save_previous_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">kp</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span><span class="p">;</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">old_flags</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_old_flags</span><span class="p">;</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">saved_flags</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_saved_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">restore_previous_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">,</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">kp</span><span class="p">);</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_old_flags</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">old_flags</span><span class="p">;</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_saved_flags</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">prev_kprobe</span><span class="p">.</span><span class="n">saved_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">set_current_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_saved_flags</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_old_flags</span>
		<span class="o">=</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X86_EFLAGS_TF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_IF</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_IF_modifier</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">))</span>
		<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_saved_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_IF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">clear_btf</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_BLOCKSTEP</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugctl</span> <span class="o">=</span> <span class="n">get_debugctlmsr</span><span class="p">();</span>

		<span class="n">debugctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEBUGCTLMSR_BTF</span><span class="p">;</span>
		<span class="n">update_debugctlmsr</span><span class="p">(</span><span class="n">debugctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">restore_btf</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_BLOCKSTEP</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debugctl</span> <span class="o">=</span> <span class="n">get_debugctlmsr</span><span class="p">();</span>

		<span class="n">debugctl</span> <span class="o">|=</span> <span class="n">DEBUGCTLMSR_BTF</span><span class="p">;</span>
		<span class="n">update_debugctlmsr</span><span class="p">(</span><span class="n">debugctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">arch_prepare_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sara</span> <span class="o">=</span> <span class="n">stack_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">ri</span><span class="o">-&gt;</span><span class="n">ret_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">sara</span><span class="p">;</span>

	<span class="cm">/* Replace the return addr with trampoline addr */</span>
	<span class="o">*</span><span class="n">sara</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">kretprobe_trampoline</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">setup_singlestep</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reenter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_detour_execution</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">reenter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#if !defined(CONFIG_PREEMPT)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Boost up -- we can execute copied instructions directly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reenter</span><span class="p">)</span>
			<span class="n">reset_current_kprobe</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reentering boosted probe doesn&#39;t reset current_kprobe,</span>
<span class="cm">		 * nor set current_kprobe, because it doesn&#39;t use single</span>
<span class="cm">		 * stepping.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">;</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reenter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">save_previous_kprobe</span><span class="p">(</span><span class="n">kcb</span><span class="p">);</span>
		<span class="n">set_current_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">);</span>
		<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_REENTER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_SS</span><span class="p">;</span>
	<span class="cm">/* Prepare real single stepping */</span>
	<span class="n">clear_btf</span><span class="p">();</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_IF</span><span class="p">;</span>
	<span class="cm">/* single step inline if the instruction is an int3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We have reentered the kprobe_handler(), since another probe was hit while</span>
<span class="cm"> * within the handler. We save the original kprobes variables and just single</span>
<span class="cm"> * step on the instruction of the new probe without calling any user handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">reenter_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KPROBE_HIT_SSDONE</span>:
	<span class="k">case</span> <span class="n">KPROBE_HIT_ACTIVE</span>:
		<span class="n">kprobes_inc_nmissed_count</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">setup_singlestep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KPROBE_HIT_SS</span>:
		<span class="cm">/* A probe has been hit in the codepath leading up to, or just</span>
<span class="cm">		 * after, single-stepping of a probed instruction. This entire</span>
<span class="cm">		 * codepath should strictly reside in .kprobes.text section.</span>
<span class="cm">		 * Raise a BUG or we&#39;ll continue in an endless reentering loop</span>
<span class="cm">		 * and eventually a stack overflow.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Unrecoverable kprobe detected at %p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">dump_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="nl">default:</span>
		<span class="cm">/* impossible cases */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts are disabled on entry as trap3 is an interrupt gate and they</span>
<span class="cm"> * remain disabled throughout this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to be preempted for the entire</span>
<span class="cm">	 * duration of kprobe processing. We conditionally</span>
<span class="cm">	 * re-enable preemption at the end of this function,</span>
<span class="cm">	 * and also in reenter_kprobe() and setup_singlestep().</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_running</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reenter_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_current_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">);</span>
			<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_ACTIVE</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we have no pre-handler or it returned 0, we</span>
<span class="cm">			 * continue with normal processing.  If we have a</span>
<span class="cm">			 * pre-handler and it returned non-zero, it prepped</span>
<span class="cm">			 * for calling the break_handler below on re-entry</span>
<span class="cm">			 * for jprobe processing, so get out doing nothing</span>
<span class="cm">			 * more here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
				<span class="n">setup_singlestep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">BREAKPOINT_INSTRUCTION</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The breakpoint instruction was removed right</span>
<span class="cm">		 * after we hit it.  Another cpu has removed</span>
<span class="cm">		 * either a probepoint or a debugger breakpoint</span>
<span class="cm">		 * at this address.  In either case, no further</span>
<span class="cm">		 * handling of this interrupt is appropriate.</span>
<span class="cm">		 * Back up over the (now missing) int3 and run</span>
<span class="cm">		 * the original instruction.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kprobe_running</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">setup_singlestep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* else: not a kprobe fault; let the kernel handle it */</span>

	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a retprobed function returns, this code saves registers and</span>
<span class="cm"> * calls trampoline_handler() runs, which calls the kretprobe&#39;s handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__used</span> <span class="n">__kprobes</span> <span class="nf">kretprobe_trampoline_holder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
			<span class="s">&quot;.global kretprobe_trampoline</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;kretprobe_trampoline: </span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
			<span class="cm">/* We don&#39;t bother saving the ss register */</span>
			<span class="s">&quot;	pushq %rsp</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;	pushfq</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="n">SAVE_REGS_STRING</span>
			<span class="s">&quot;	movq %rsp, %rdi</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;	call trampoline_handler</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="cm">/* Replace saved sp with true return address. */</span>
			<span class="s">&quot;	movq %rax, 152(%rsp)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="n">RESTORE_REGS_STRING</span>
			<span class="s">&quot;	popfq</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#else</span>
			<span class="s">&quot;	pushf</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="n">SAVE_REGS_STRING</span>
			<span class="s">&quot;	movl %esp, %eax</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;	call trampoline_handler</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="cm">/* Move flags to cs */</span>
			<span class="s">&quot;	movl 56(%esp), %edx</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;	movl %edx, 52(%esp)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="cm">/* Replace saved flags with true return address. */</span>
			<span class="s">&quot;	movl %eax, 56(%esp)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="n">RESTORE_REGS_STRING</span>
			<span class="s">&quot;	popf</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
			<span class="s">&quot;	ret</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from kretprobe_trampoline</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__used</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">trampoline_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">empty_rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">orig_ret_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trampoline_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kretprobe_trampoline</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">correct_ret_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">);</span>
	<span class="n">kretprobe_hash_lock</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* fixup registers */</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">=</span> <span class="n">__KERNEL_CS</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">=</span> <span class="n">__KERNEL_CS</span> <span class="o">|</span> <span class="n">get_kernel_rpl</span><span class="p">();</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">gs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">trampoline_address</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">orig_ax</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible to have multiple instances associated with a given</span>
<span class="cm">	 * task either because multiple functions in the call path have</span>
<span class="cm">	 * return probes installed on them, and/or more than one</span>
<span class="cm">	 * return probe was registered for a target function.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can handle this because:</span>
<span class="cm">	 *     - instances are always pushed into the head of the list</span>
<span class="cm">	 *     - when multiple return probes are registered for the same</span>
<span class="cm">	 *	 function, the (chronologically) first instance&#39;s ret_addr</span>
<span class="cm">	 *	 will be the real return address, and all the rest will</span>
<span class="cm">	 *	 point to kretprobe_trampoline.</span>
<span class="cm">	 */</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
			<span class="cm">/* another task is sharing our hash bucket */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">orig_ret_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">ret_addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">orig_ret_address</span> <span class="o">!=</span> <span class="n">trampoline_address</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is the real return address. Any other</span>
<span class="cm">			 * instances associated with this task are for</span>
<span class="cm">			 * other calls deeper on the call stack</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kretprobe_assert</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">orig_ret_address</span><span class="p">,</span> <span class="n">trampoline_address</span><span class="p">);</span>

	<span class="n">correct_ret_addr</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">ret_addr</span><span class="p">;</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
			<span class="cm">/* another task is sharing our hash bucket */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">orig_ret_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">ret_addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">&amp;&amp;</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
			<span class="n">get_kprobe_ctlblk</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_ACTIVE</span><span class="p">;</span>
			<span class="n">ri</span><span class="o">-&gt;</span><span class="n">ret_addr</span> <span class="o">=</span> <span class="n">correct_ret_addr</span><span class="p">;</span>
			<span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">current_kprobe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">recycle_rp_inst</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">orig_ret_address</span> <span class="o">!=</span> <span class="n">trampoline_address</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is the real return address. Any other</span>
<span class="cm">			 * instances associated with this task are for</span>
<span class="cm">			 * other calls deeper on the call stack</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kretprobe_hash_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ri</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">orig_ret_address</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called after single-stepping.  p-&gt;addr is the address of the</span>
<span class="cm"> * instruction whose first byte has been replaced by the &quot;int 3&quot;</span>
<span class="cm"> * instruction.  To avoid the SMP problems that can occur when we</span>
<span class="cm"> * temporarily put back the original opcode to single-step, we</span>
<span class="cm"> * single-stepped a copy of the instruction.  The address of this</span>
<span class="cm"> * copy is p-&gt;ainsn.insn.</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares to return from the post-single-step</span>
<span class="cm"> * interrupt.  We have to fix up the stack as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 0) Except in the case of absolute or indirect jump or call instructions,</span>
<span class="cm"> * the new ip is relative to the copied instruction.  We need to make</span>
<span class="cm"> * it relative to the original instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * 1) If the single-stepped instruction was pushfl, then the TF and IF</span>
<span class="cm"> * flags are set in the just-pushed flags, and may need to be cleared.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) If the single-stepped instruction was a call, the return address</span>
<span class="cm"> * that is atop the stack is the address following the copied instruction.</span>
<span class="cm"> * We need to make it the address following the original instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is the first time we&#39;ve single-stepped the instruction at</span>
<span class="cm"> * this probepoint, and the instruction is boostable, boost it: add a</span>
<span class="cm"> * jump instruction after the copied instruction, that jumps to the next</span>
<span class="cm"> * instruction after the probepoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span>
<span class="nf">resume_execution</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">tos</span> <span class="o">=</span> <span class="n">stack_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">copy_ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">insn</span><span class="p">;</span>

	<span class="cm">/* Skip prefixes */</span>
	<span class="n">insn</span> <span class="o">=</span> <span class="n">skip_prefixes</span><span class="p">(</span><span class="n">insn</span><span class="p">);</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_TF</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">insn</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x9c</span>:	<span class="cm">/* pushfl */</span>
		<span class="o">*</span><span class="n">tos</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">X86_EFLAGS_TF</span> <span class="o">|</span> <span class="n">X86_EFLAGS_IF</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tos</span> <span class="o">|=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_old_flags</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xc2</span>:	<span class="cm">/* iret/ret/lret */</span>
	<span class="k">case</span> <span class="mh">0xc3</span>:
	<span class="k">case</span> <span class="mh">0xca</span>:
	<span class="k">case</span> <span class="mh">0xcb</span>:
	<span class="k">case</span> <span class="mh">0xcf</span>:
	<span class="k">case</span> <span class="mh">0xea</span>:	<span class="cm">/* jmp absolute -- ip is correct */</span>
		<span class="cm">/* ip is already adjusted, no more changes required */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0xe8</span>:	<span class="cm">/* call relative - Fix return addr */</span>
		<span class="o">*</span><span class="n">tos</span> <span class="o">=</span> <span class="n">orig_ip</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tos</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
	<span class="k">case</span> <span class="mh">0x9a</span>:	<span class="cm">/* call absolute -- same as call absolute, indirect */</span>
		<span class="o">*</span><span class="n">tos</span> <span class="o">=</span> <span class="n">orig_ip</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tos</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="mh">0xff</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * call absolute, indirect</span>
<span class="cm">			 * Fix return addr; ip is correct.</span>
<span class="cm">			 * But this is not boostable</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">tos</span> <span class="o">=</span> <span class="n">orig_ip</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tos</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x31</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">||</span>
			   <span class="p">((</span><span class="n">insn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x31</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x21</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * jmp near and far, absolute indirect</span>
<span class="cm">			 * ip is correct. And this is boostable</span>
<span class="cm">			 */</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">copy_ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="n">MAX_INSN_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * These instructions can be executed directly if it</span>
<span class="cm">			 * jumps back to correct address.</span>
<span class="cm">			 */</span>
			<span class="n">synthesize_reljump</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">orig_ip</span> <span class="o">+</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">));</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">.</span><span class="n">boostable</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">+=</span> <span class="n">orig_ip</span> <span class="o">-</span> <span class="n">copy_ip</span><span class="p">;</span>

<span class="nl">no_change:</span>
	<span class="n">restore_btf</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts are disabled on entry as trap1 is an interrupt gate and they</span>
<span class="cm"> * remain disabled throughout this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">post_kprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">resume_execution</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">kcb</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_saved_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">!=</span> <span class="n">KPROBE_REENTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">=</span> <span class="n">KPROBE_HIT_SSDONE</span><span class="p">;</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restore back the original saved kprobes variables and continue. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">==</span> <span class="n">KPROBE_REENTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">restore_previous_kprobe</span><span class="p">(</span><span class="n">kcb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reset_current_kprobe</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable_no_resched</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * if somebody else is singlestepping across a probe point, flags</span>
<span class="cm">	 * will have TF set, in which case, continue the remaining processing</span>
<span class="cm">	 * of do_debug, as if this is not a probe hit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_TF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_fault_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">kprobe_running</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KPROBE_HIT_SS</span>:
	<span class="k">case</span> <span class="n">KPROBE_REENTER</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We are here because the instruction being single</span>
<span class="cm">		 * stepped caused a page fault. We reset the current</span>
<span class="cm">		 * kprobe and the ip points back to the probe address</span>
<span class="cm">		 * and allow the page fault handler to continue as a</span>
<span class="cm">		 * normal page fault.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_old_flags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">kprobe_status</span> <span class="o">==</span> <span class="n">KPROBE_REENTER</span><span class="p">)</span>
			<span class="n">restore_previous_kprobe</span><span class="p">(</span><span class="n">kcb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">reset_current_kprobe</span><span class="p">();</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KPROBE_HIT_ACTIVE</span>:
	<span class="k">case</span> <span class="n">KPROBE_HIT_SSDONE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We increment the nmissed count for accounting,</span>
<span class="cm">		 * we can also use npre/npostfault count for accounting</span>
<span class="cm">		 * these specific fault cases.</span>
<span class="cm">		 */</span>
		<span class="n">kprobes_inc_nmissed_count</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We come here because instructions in the pre/post</span>
<span class="cm">		 * handler caused the page_fault, this could happen</span>
<span class="cm">		 * if handler tries to access user space by</span>
<span class="cm">		 * copy_from_user(), get_user() etc. Let the</span>
<span class="cm">		 * user-specified handler try to fix it first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * In case the user-specified fault handler returned</span>
<span class="cm">		 * zero, try to fix up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * fixup routine could not handle it,</span>
<span class="cm">		 * Let do_page_fault() fix it.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper routine for handling exceptions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__kprobes</span>
<span class="nf">kprobe_exceptions_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">die_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="n">user_mode_vm</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DIE_INT3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_handler</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DIE_DEBUG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">post_kprobe_handler</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reset the BS bit in dr6 (pointed by args-&gt;err) to</span>
<span class="cm">			 * denote completion of processing</span>
<span class="cm">			 */</span>
			<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ERR_PTR</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">))</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DR_STEP</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DIE_GPF</span>:
		<span class="cm">/*</span>
<span class="cm">		 * To be potentially processing a kprobe fault and to</span>
<span class="cm">		 * trust the result from kprobe_running(), we have</span>
<span class="cm">		 * be non-preemptible.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preemptible</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">kprobe_running</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		    <span class="n">kprobe_fault_handler</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trapnr</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_STOP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">setjmp_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>

	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_regs</span> <span class="o">=</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span> <span class="o">=</span> <span class="n">stack_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As Linus pointed out, gcc assumes that the callee</span>
<span class="cm">	 * owns the argument space and could overwrite it, e.g.</span>
<span class="cm">	 * tailcall optimization. So, to be absolutely safe</span>
<span class="cm">	 * we also save and restore enough stack bytes to cover</span>
<span class="cm">	 * the argument area.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobes_stack</span><span class="p">,</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span>
	       <span class="n">MIN_STACK_SIZE</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">X86_EFLAGS_IF</span><span class="p">;</span>
	<span class="n">trace_hardirqs_off</span><span class="p">();</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">jp</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">jprobe_return</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>

	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
			<span class="s">&quot;       xchg   %%rbx,%%rsp	</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#else</span>
			<span class="s">&quot;       xchgl   %%ebx,%%esp	</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="cp">#endif</span>
			<span class="s">&quot;       int3			</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;       .globl jprobe_return_end</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;       jprobe_return_end:	</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;       nop			</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">::</span><span class="s">&quot;b&quot;</span>
			<span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">)</span><span class="o">:</span><span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">longjmp_break_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_ctlblk</span> <span class="o">*</span><span class="n">kcb</span> <span class="o">=</span> <span class="n">get_kprobe_ctlblk</span><span class="p">();</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">jprobe_return</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">jprobe_return_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stack_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">saved_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_regs</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;current sp %p does not match saved sp %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">stack_addr</span><span class="p">(</span><span class="n">regs</span><span class="p">),</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Saved registers for jprobe %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jp</span><span class="p">);</span>
			<span class="n">show_regs</span><span class="p">(</span><span class="n">saved_regs</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Current registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_regs</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">),</span>
		       <span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobes_stack</span><span class="p">,</span>
		       <span class="n">MIN_STACK_SIZE</span><span class="p">(</span><span class="n">kcb</span><span class="o">-&gt;</span><span class="n">jprobe_saved_sp</span><span class="p">));</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">arch_init_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arch_init_optprobes</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">arch_trampoline_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
