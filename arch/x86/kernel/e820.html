<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › e820.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>e820.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Handle the memory map.</span>
<span class="cm"> * The functions here do the job until bootmem takes over.</span>
<span class="cm"> *</span>
<span class="cm"> *  Getting sanitize_e820_map() in sync with i386 version by applying change:</span>
<span class="cm"> *  -  Provisions for empty E820 memory regions (reported by certain BIOSes).</span>
<span class="cm"> *     Alex Achenbach &lt;xela@slit.de&gt;, December 2002.</span>
<span class="cm"> *  Venkatesh Pallipadi &lt;venkatesh.pallipadi@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/crash_dump.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/firmware-map.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>

<span class="cp">#include &lt;asm/e820.h&gt;</span>
<span class="cp">#include &lt;asm/proto.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The e820 map is the map that gets modified e.g. with command line parameters</span>
<span class="cm"> * and that is also registered with modifications in the kernel resource tree</span>
<span class="cm"> * with the iomem_resource as parent.</span>
<span class="cm"> *</span>
<span class="cm"> * The e820_saved is directly saved after the BIOS-provided memory map is</span>
<span class="cm"> * copied. It doesn&#39;t get modified afterwards. It&#39;s registered for the</span>
<span class="cm"> * /sys/firmware/memmap interface.</span>
<span class="cm"> *</span>
<span class="cm"> * That memory map is not modified and is used as base for kexec. The kexec&#39;d</span>
<span class="cm"> * kernel should get the same memory map as the firmware provides. Then the</span>
<span class="cm"> * user can e.g. boot the original kernel with mem=1G while still booting the</span>
<span class="cm"> * next kernel with full memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">e820map</span> <span class="n">e820</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">e820map</span> <span class="n">e820_saved</span><span class="p">;</span>

<span class="cm">/* For PCI or other memory-mapped resources */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_mem_start</span> <span class="o">=</span> <span class="mh">0xaeedbabe</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_mem_start</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This function checks if any part of the range &lt;start,end&gt; is mapped</span>
<span class="cm"> * with type.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">e820_any_mapped</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span> <span class="o">||</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">e820_any_mapped</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function checks if the entire range &lt;start,end&gt; is mapped with type.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: this function only works correct if the e820 table is sorted and</span>
<span class="cm"> * not-overlapping, which is the case</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">e820_all_mapped</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* is the region (part) in overlap with the current region ?*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">end</span> <span class="o">||</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* if the region is at the beginning of &lt;start,end&gt; we move</span>
<span class="cm">		 * start to the end of the region since it&#39;s ok until there</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * if start is now at or beyond end, we&#39;re done, full</span>
<span class="cm">		 * coverage</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a memory region to the kernel e820 map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">__e820_add_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820map</span> <span class="o">*</span><span class="n">e820x</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e820x</span><span class="o">-&gt;</span><span class="n">nr_map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">e820x</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;e820: too many entries; ignoring [mem %#010llx-%#010llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e820x</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">e820x</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">e820x</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">e820x</span><span class="o">-&gt;</span><span class="n">nr_map</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_add_region</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__e820_add_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e820</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_print_type</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E820_RAM</span>:
	<span class="k">case</span> <span class="n">E820_RESERVED_KERN</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;usable&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_RESERVED</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;reserved&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_ACPI</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;ACPI data&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_NVS</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;ACPI NVS&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_UNUSABLE</span>:
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;unusable&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;type %u&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_print_map</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">who</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: [mem %#018Lx-%#018Lx] &quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		       <span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">e820_print_type</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sanitize the BIOS e820 map.</span>
<span class="cm"> *</span>
<span class="cm"> * Some e820 responses include overlapping entries. The following</span>
<span class="cm"> * replaces the original e820 map with a new one, removing overlaps,</span>
<span class="cm"> * and resolving conflicting memory types in favor of highest</span>
<span class="cm"> * numbered type.</span>
<span class="cm"> *</span>
<span class="cm"> * The input parameter biosmap points to an array of &#39;struct</span>
<span class="cm"> * e820entry&#39; which on entry has elements in the range [0, *pnr_map)</span>
<span class="cm"> * valid, and which has space for up to max_nr_map entries.</span>
<span class="cm"> * On return, the resulting sanitized e820 map entries will be in</span>
<span class="cm"> * overwritten in the same location, starting at biosmap.</span>
<span class="cm"> *</span>
<span class="cm"> * The integer pointed to by pnr_map must be valid on entry (the</span>
<span class="cm"> * current number of valid entries located at biosmap) and will</span>
<span class="cm"> * be updated on return, with the new number of valid entries</span>
<span class="cm"> * (something no more than max_nr_map.)</span>
<span class="cm"> *</span>
<span class="cm"> * The return value from sanitize_e820_map() is zero if it</span>
<span class="cm"> * successfully &#39;sanitized&#39; the map entries passed in, and is -1</span>
<span class="cm"> * if it did nothing, which can happen if either of (1) it was</span>
<span class="cm"> * only passed one map entry, or (2) any of the input map entries</span>
<span class="cm"> * were invalid (start + size &lt; start, meaning that the size was</span>
<span class="cm"> * so big the described memory range wrapped around through zero.)</span>
<span class="cm"> *</span>
<span class="cm"> *	Visually we&#39;re performing the following</span>
<span class="cm"> *	(1,2,3,4 = memory types)...</span>
<span class="cm"> *</span>
<span class="cm"> *	Sample memory map (w/overlaps):</span>
<span class="cm"> *	   ____22__________________</span>
<span class="cm"> *	   ______________________4_</span>
<span class="cm"> *	   ____1111________________</span>
<span class="cm"> *	   _44_____________________</span>
<span class="cm"> *	   11111111________________</span>
<span class="cm"> *	   ____________________33__</span>
<span class="cm"> *	   ___________44___________</span>
<span class="cm"> *	   __________33333_________</span>
<span class="cm"> *	   ______________22________</span>
<span class="cm"> *	   ___________________2222_</span>
<span class="cm"> *	   _________111111111______</span>
<span class="cm"> *	   _____________________11_</span>
<span class="cm"> *	   _________________4______</span>
<span class="cm"> *</span>
<span class="cm"> *	Sanitized equivalent (no overlap):</span>
<span class="cm"> *	   1_______________________</span>
<span class="cm"> *	   _44_____________________</span>
<span class="cm"> *	   ___1____________________</span>
<span class="cm"> *	   ____22__________________</span>
<span class="cm"> *	   ______11________________</span>
<span class="cm"> *	   _________1______________</span>
<span class="cm"> *	   __________3_____________</span>
<span class="cm"> *	   ___________44___________</span>
<span class="cm"> *	   _____________33_________</span>
<span class="cm"> *	   _______________2________</span>
<span class="cm"> *	   ________________1_______</span>
<span class="cm"> *	   _________________4______</span>
<span class="cm"> *	   ___________________2____</span>
<span class="cm"> *	   ____________________33__</span>
<span class="cm"> *	   ______________________4_</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">change_member</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">pbios</span><span class="p">;</span> <span class="cm">/* pointer to original bios entry */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span> <span class="cm">/* address for this change point */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpcompare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">change_member</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">app</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">change_member</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">bpp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inputs are pointers to two elements of change_point[].  If their</span>
<span class="cm">	 * addresses are unequal, their difference dominates.  If the addresses</span>
<span class="cm">	 * are equal, then consider one that represents the end of its region</span>
<span class="cm">	 * to be greater than one that does not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">pbios</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">pbios</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">sanitize_e820_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">biosmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_nr_map</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="n">pnr_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">change_member</span> <span class="n">change_point_list</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">E820_X_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">change_member</span> <span class="o">*</span><span class="n">change_point</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">E820_X_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">E820_X_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">e820entry</span> <span class="n">new_bios</span><span class="p">[</span><span class="n">E820_X_MAX</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_type</span><span class="p">,</span> <span class="n">last_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chgidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overlap_entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_bios_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_nr</span><span class="p">,</span> <span class="n">new_nr</span><span class="p">,</span> <span class="n">chg_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* if there&#39;s only one memory region, don&#39;t bother */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pnr_map</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">old_nr</span> <span class="o">=</span> <span class="o">*</span><span class="n">pnr_map</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_nr</span> <span class="o">&gt;</span> <span class="n">max_nr_map</span><span class="p">);</span>

	<span class="cm">/* bail out if we find any unreasonable addresses in bios map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* create pointers for initial change-point information (for sorting) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">change_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">change_point_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* record all known change-points (starting and ending addresses),</span>
<span class="cm">	   omitting those that are for empty memory regions */</span>
	<span class="n">chgidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="o">++</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pbios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span>
				<span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
			<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="o">++</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pbios</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">biosmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">chg_nr</span> <span class="o">=</span> <span class="n">chgidx</span><span class="p">;</span>

	<span class="cm">/* sort change-point list by memory addresses (low -&gt; high) */</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">change_point</span><span class="p">,</span> <span class="n">chg_nr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">change_point</span><span class="p">,</span> <span class="n">cpcompare</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* create a new bios memory map, removing overlaps */</span>
	<span class="n">overlap_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	 <span class="cm">/* number of entries in the overlap table */</span>
	<span class="n">new_bios_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	 <span class="cm">/* index for creating new bios map entries */</span>
	<span class="n">last_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		 <span class="cm">/* start with undefined memory type */</span>
	<span class="n">last_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		 <span class="cm">/* start with 0 as last starting address */</span>

	<span class="cm">/* loop through change-points, determining affect on the new bios map */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chgidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chgidx</span> <span class="o">&lt;</span> <span class="n">chg_nr</span><span class="p">;</span> <span class="n">chgidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* keep track of all overlapping bios entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span>
		    <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pbios</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * add map entry to overlap list (&gt; 1 entry</span>
<span class="cm">			 * implies an overlap)</span>
<span class="cm">			 */</span>
			<span class="n">overlap_list</span><span class="p">[</span><span class="n">overlap_entries</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pbios</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * remove entry from list (order independent,</span>
<span class="cm">			 * so swap with last)</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">overlap_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span>
				    <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pbios</span><span class="p">)</span>
					<span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">overlap_list</span><span class="p">[</span><span class="n">overlap_entries</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">overlap_entries</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * if there are overlapping entries, decide which</span>
<span class="cm">		 * &quot;type&quot; to use (larger value takes precedence --</span>
<span class="cm">		 * 1=usable, 2,3,4,4+=unusable)</span>
<span class="cm">		 */</span>
		<span class="n">current_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">overlap_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">current_type</span><span class="p">)</span>
				<span class="n">current_type</span> <span class="o">=</span> <span class="n">overlap_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * continue building up new bios map based on this</span>
<span class="cm">		 * information</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_type</span> <span class="o">!=</span> <span class="n">last_type</span><span class="p">)</span>	<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>	 <span class="p">{</span>
				<span class="n">new_bios</span><span class="p">[</span><span class="n">new_bios_entry</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span>
					<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">-</span> <span class="n">last_addr</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * move forward only if the new size</span>
<span class="cm">				 * was non-zero</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_bios</span><span class="p">[</span><span class="n">new_bios_entry</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="cm">/*</span>
<span class="cm">					 * no more space left for new</span>
<span class="cm">					 * bios entries ?</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">new_bios_entry</span> <span class="o">&gt;=</span> <span class="n">max_nr_map</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>	<span class="p">{</span>
				<span class="n">new_bios</span><span class="p">[</span><span class="n">new_bios_entry</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span>
					<span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
				<span class="n">new_bios</span><span class="p">[</span><span class="n">new_bios_entry</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">current_type</span><span class="p">;</span>
				<span class="n">last_addr</span> <span class="o">=</span> <span class="n">change_point</span><span class="p">[</span><span class="n">chgidx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">last_type</span> <span class="o">=</span> <span class="n">current_type</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* retain count for new bios entries */</span>
	<span class="n">new_nr</span> <span class="o">=</span> <span class="n">new_bios_entry</span><span class="p">;</span>

	<span class="cm">/* copy new bios mapping into original location */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">biosmap</span><span class="p">,</span> <span class="n">new_bios</span><span class="p">,</span> <span class="n">new_nr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span><span class="p">));</span>
	<span class="o">*</span><span class="n">pnr_map</span> <span class="o">=</span> <span class="n">new_nr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">__append_e820_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">biosmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">biosmap</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">size</span> <span class="o">=</span> <span class="n">biosmap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">biosmap</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

		<span class="cm">/* Overflow in 64 bits? Ignore the memory map. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">e820_add_region</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

		<span class="n">biosmap</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nr_map</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the BIOS e820 map into a safe place.</span>
<span class="cm"> *</span>
<span class="cm"> * Sanity-check it while we&#39;re at it..</span>
<span class="cm"> *</span>
<span class="cm"> * If we&#39;re lucky and live on a modern system, the setup code</span>
<span class="cm"> * will have given us a memory map that we can use to properly</span>
<span class="cm"> * set up memory.  If we aren&#39;t, we&#39;ll fake a memory map.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">append_e820_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">biosmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only one memory region (or negative)? Ignore it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_map</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__append_e820_map</span><span class="p">(</span><span class="n">biosmap</span><span class="p">,</span> <span class="n">nr_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">__init</span> <span class="nf">__e820_update_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820map</span> <span class="o">*</span><span class="n">e820x</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">old_type</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">real_updated_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_type</span> <span class="o">==</span> <span class="n">new_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;e820: update [mem %#010Lx-%#010Lx] &quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">e820_print_type</span><span class="p">(</span><span class="n">old_type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; ==&gt; &quot;</span><span class="p">);</span>
	<span class="n">e820_print_type</span><span class="p">(</span><span class="n">new_type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820x</span><span class="o">-&gt;</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820x</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">final_start</span><span class="p">,</span> <span class="n">final_end</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ei_end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">old_type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ei_end</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="cm">/* totally covered by new range? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">ei_end</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">new_type</span><span class="p">;</span>
			<span class="n">real_updated_size</span> <span class="o">+=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* new range is totally covered? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">ei_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__e820_add_region</span><span class="p">(</span><span class="n">e820x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>
			<span class="n">__e820_add_region</span><span class="p">(</span><span class="n">e820x</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ei_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">real_updated_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* partially covered */</span>
		<span class="n">final_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">final_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">ei_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">final_start</span> <span class="o">&gt;=</span> <span class="n">final_end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">__e820_add_region</span><span class="p">(</span><span class="n">e820x</span><span class="p">,</span> <span class="n">final_start</span><span class="p">,</span> <span class="n">final_end</span> <span class="o">-</span> <span class="n">final_start</span><span class="p">,</span>
				  <span class="n">new_type</span><span class="p">);</span>

		<span class="n">real_updated_size</span> <span class="o">+=</span> <span class="n">final_end</span> <span class="o">-</span> <span class="n">final_start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * left range could be head or tail, so need to update</span>
<span class="cm">		 * size at first.</span>
<span class="cm">		 */</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">final_end</span> <span class="o">-</span> <span class="n">final_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">final_start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">final_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">real_updated_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="n">__init</span> <span class="nf">e820_update_range</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">old_type</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e820_update_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e820</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">old_type</span><span class="p">,</span> <span class="n">new_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">__init</span> <span class="nf">e820_update_range_saved</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="n">old_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">new_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e820_update_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e820_saved</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">old_type</span><span class="p">,</span>
				     <span class="n">new_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* make e820 not cover the range */</span>
<span class="n">u64</span> <span class="n">__init</span> <span class="nf">e820_remove_range</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">old_type</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">checktype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">real_removed_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;e820: remove [mem %#010Lx-%#010Lx] &quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checktype</span><span class="p">)</span>
		<span class="n">e820_print_type</span><span class="p">(</span><span class="n">old_type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">final_start</span><span class="p">,</span> <span class="n">final_end</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ei_end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">checktype</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">old_type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ei_end</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="cm">/* totally covered? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">ei_end</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">real_removed_size</span> <span class="o">+=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* new range is totally covered? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">ei_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e820_add_region</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">ei_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">real_removed_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* partially covered */</span>
		<span class="n">final_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">final_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">ei_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">final_start</span> <span class="o">&gt;=</span> <span class="n">final_end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">real_removed_size</span> <span class="o">+=</span> <span class="n">final_end</span> <span class="o">-</span> <span class="n">final_start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * left range could be head or tail, so need to update</span>
<span class="cm">		 * size at first.</span>
<span class="cm">		 */</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">final_end</span> <span class="o">-</span> <span class="n">final_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">final_start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">final_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">real_removed_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">update_e820</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nr_map</span><span class="p">;</span>

	<span class="n">nr_map</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sanitize_e820_map</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nr_map</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">=</span> <span class="n">nr_map</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: modified physical RAM map:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">e820_print_map</span><span class="p">(</span><span class="s">&quot;modified&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">update_e820_saved</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nr_map</span><span class="p">;</span>

	<span class="n">nr_map</span> <span class="o">=</span> <span class="n">e820_saved</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sanitize_e820_map</span><span class="p">(</span><span class="n">e820_saved</span><span class="p">.</span><span class="n">map</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">e820_saved</span><span class="p">.</span><span class="n">map</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nr_map</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">e820_saved</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">=</span> <span class="n">nr_map</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define MAX_GAP_END 0x100000000ull</span>
<span class="cm">/*</span>
<span class="cm"> * Search for a gap in the e820 memory space from start_addr to end_addr.</span>
<span class="cm"> */</span>
<span class="n">__init</span> <span class="kt">int</span> <span class="nf">e820_search_gap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gapstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gapsize</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_addr</span> <span class="o">&amp;&amp;</span> <span class="n">end_addr</span> <span class="o">&lt;</span> <span class="n">MAX_GAP_END</span><span class="p">)</span> <span class="o">?</span> <span class="n">end_addr</span> <span class="o">:</span> <span class="n">MAX_GAP_END</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start_addr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since &quot;last&quot; is at most 4GB, we know we&#39;ll</span>
<span class="cm">		 * fit in 32 bits if this condition is true</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">end</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">gapsize</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">gapsize</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span>
				<span class="o">*</span><span class="n">gapstart</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">)</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search for the biggest gap in the low 32 bits of the e820</span>
<span class="cm"> * memory space.  We pass this space to PCI to assign MMIO resources</span>
<span class="cm"> * for hotplug or unconfigured devices in.</span>
<span class="cm"> * Hopefully the BIOS let enough space left.</span>
<span class="cm"> */</span>
<span class="n">__init</span> <span class="kt">void</span> <span class="nf">e820_setup_gap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gapstart</span><span class="p">,</span> <span class="n">gapsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">gapstart</span> <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">;</span>
	<span class="n">gapsize</span> <span class="o">=</span> <span class="mh">0x400000</span><span class="p">;</span>
	<span class="n">found</span>  <span class="o">=</span> <span class="n">e820_search_gap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gapstart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gapsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_GAP_END</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gapstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
	<span class="s">&quot;e820: cannot find a gap in the 32bit address range</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;e820: PCI devices with unassigned 32bit BARs may break!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * e820_reserve_resources_late protect stolen RAM already</span>
<span class="cm">	 */</span>
	<span class="n">pci_mem_start</span> <span class="o">=</span> <span class="n">gapstart</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;e820: [mem %#010lx-%#010lx] available for PCI devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">gapstart</span><span class="p">,</span> <span class="n">gapstart</span> <span class="o">+</span> <span class="n">gapsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Because of the size limitation of struct boot_params, only first</span>
<span class="cm"> * 128 E820 memory entries are passed to kernel via</span>
<span class="cm"> * boot_params.e820_map, others are passed via SETUP_E820_EXT node of</span>
<span class="cm"> * linked list of struct setup_data, which is parsed here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">parse_e820_ext</span><span class="p">(</span><span class="k">struct</span> <span class="n">setup_data</span> <span class="o">*</span><span class="n">sdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">extmap</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span><span class="p">);</span>
	<span class="n">extmap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">__append_e820_map</span><span class="p">(</span><span class="n">extmap</span><span class="p">,</span> <span class="n">entries</span><span class="p">);</span>
	<span class="n">sanitize_e820_map</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: extended physical RAM map:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">e820_print_map</span><span class="p">(</span><span class="s">&quot;extended&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_X86_64) || \</span>
<span class="cp">	(defined(CONFIG_X86_32) &amp;&amp; defined(CONFIG_HIBERNATION))</span>
<span class="cm">/**</span>
<span class="cm"> * Find the ranges of physical addresses that do not correspond to</span>
<span class="cm"> * e820 RAM areas and mark the corresponding pages as nosave for</span>
<span class="cm"> * hibernation (32 bit) or software suspend and suspend to RAM (64 bit).</span>
<span class="cm"> *</span>
<span class="cm"> * This function requires the e820 map to be sorted and without any</span>
<span class="cm"> * overlapping entries and assumes the first e820 area to be RAM.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_mark_nosave_regions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
			<span class="n">register_nosave_region</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">));</span>

		<span class="n">pfn</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RAM</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RESERVED_KERN</span><span class="p">)</span>
			<span class="n">register_nosave_region</span><span class="p">(</span><span class="n">PFN_UP</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">),</span> <span class="n">pfn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&gt;=</span> <span class="n">limit_pfn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ACPI</span>
<span class="cm">/**</span>
<span class="cm"> * Mark ACPI NVS memory region, so that we can save/restore it during</span>
<span class="cm"> * hibernation and the subsequent resume.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">e820_mark_nvs_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">E820_NVS</span><span class="p">)</span>
			<span class="n">acpi_nvs_register</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">e820_mark_nvs_memory</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * pre allocated 4k and reserved it in memblock and e820_saved</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="n">__init</span> <span class="nf">early_reserve_e820</span><span class="p">(</span><span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">__memblock_alloc_base</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">MEMBLOCK_ALLOC_ACCESSIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e820_update_range_saved</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">,</span> <span class="n">E820_RESERVED</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: update e820_saved for early_reserve_e820</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">update_e820_saved</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_32</span>
<span class="cp"># ifdef CONFIG_X86_PAE</span>
<span class="cp">#  define MAX_ARCH_PFN		(1ULL&lt;&lt;(36-PAGE_SHIFT))</span>
<span class="cp"># else</span>
<span class="cp">#  define MAX_ARCH_PFN		(1ULL&lt;&lt;(32-PAGE_SHIFT))</span>
<span class="cp"># endif</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_X86_32 */</span><span class="cp"></span>
<span class="cp"># define MAX_ARCH_PFN MAXMEM&gt;&gt;PAGE_SHIFT</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Find the highest page frame number we have available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">e820_end_pfn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_pfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_arch_pfn</span> <span class="o">=</span> <span class="n">MAX_ARCH_PFN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&gt;=</span> <span class="n">limit_pfn</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">limit_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">limit_pfn</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">last_pfn</span><span class="p">)</span>
			<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_pfn</span> <span class="o">&gt;</span> <span class="n">max_arch_pfn</span><span class="p">)</span>
		<span class="n">last_pfn</span> <span class="o">=</span> <span class="n">max_arch_pfn</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: last_pfn = %#lx max_arch_pfn = %#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">last_pfn</span><span class="p">,</span> <span class="n">max_arch_pfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">last_pfn</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">e820_end_of_ram_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">e820_end_pfn</span><span class="p">(</span><span class="n">MAX_ARCH_PFN</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">e820_end_of_low_ram_pfn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">e820_end_pfn</span><span class="p">(</span><span class="mi">1UL</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">E820_RAM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">early_panic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">early_printk</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">userdef</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="cm">/* &quot;mem=nopentium&quot; disables the 4MB page tables. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_memopt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mem_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;nopentium&quot;</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
		<span class="n">setup_clear_cpu_cap</span><span class="p">(</span><span class="n">X86_FEATURE_PSE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;mem=nopentium ignored! (only supported on x86_32)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">userdef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mem_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* don&#39;t remove all of memory when handling &quot;mem={invalid}&quot; param */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">e820_remove_range</span><span class="p">(</span><span class="n">mem_size</span><span class="p">,</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;mem&quot;</span><span class="p">,</span> <span class="n">parse_memopt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parse_memmap_opt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">oldp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;exactmap&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_CRASH_DUMP</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are doing a crash dump, we still need to know</span>
<span class="cm">		 * the real mem size before original memory map is</span>
<span class="cm">		 * reset.</span>
<span class="cm">		 */</span>
		<span class="n">saved_max_pfn</span> <span class="o">=</span> <span class="n">e820_end_of_ram_pfn</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">userdef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oldp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">mem_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">oldp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">userdef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">e820_add_region</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">e820_add_region</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">E820_ACPI</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">e820_add_region</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">E820_RESERVED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">e820_remove_range</span><span class="p">(</span><span class="n">mem_size</span><span class="p">,</span> <span class="n">ULLONG_MAX</span> <span class="o">-</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;memmap&quot;</span><span class="p">,</span> <span class="n">parse_memmap_opt</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">finish_e820_parsing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdef</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sanitize_e820_map</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">early_panic</span><span class="p">(</span><span class="s">&quot;Invalid user supplied memory map&quot;</span><span class="p">);</span>
		<span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: user-defined physical RAM map:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">e820_print_map</span><span class="p">(</span><span class="s">&quot;user&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">e820_type_to_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">e820_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">e820_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E820_RESERVED_KERN</span>:
	<span class="k">case</span> <span class="n">E820_RAM</span>:	<span class="k">return</span> <span class="s">&quot;System RAM&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_ACPI</span>:	<span class="k">return</span> <span class="s">&quot;ACPI Tables&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_NVS</span>:	<span class="k">return</span> <span class="s">&quot;ACPI Non-volatile Storage&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E820_UNUSABLE</span>:	<span class="k">return</span> <span class="s">&quot;Unusable memory&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>	<span class="k">return</span> <span class="s">&quot;reserved&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark e820 reserved areas as busy for the resource manager.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">__initdata</span> <span class="o">*</span><span class="n">e820_res</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_reserve_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">resource</span><span class="p">)</span> <span class="o">*</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">);</span>
	<span class="n">e820_res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="p">(</span><span class="n">resource_size_t</span><span class="p">)</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">e820_type_to_string</span><span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * don&#39;t register the region that could be conflicted with</span>
<span class="cm">		 * pci device BAR resource and insert them later in</span>
<span class="cm">		 * pcibios_resource_survey()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RESERVED</span> <span class="o">||</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1ULL</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IORESOURCE_BUSY</span><span class="p">;</span>
			<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">res</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820_saved</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820_saved</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">firmware_map_add_early</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">e820_type_to_string</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* How much should we pad RAM ending depending on where it is? */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ram_alignment</span><span class="p">(</span><span class="n">resource_size_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mb</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">;</span>

	<span class="cm">/* To 64kB in the first megabyte */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>

	<span class="cm">/* To 1MB in the first 16MB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>

	<span class="cm">/* To 64MB for anything above that */</span>
	<span class="k">return</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_RESOURCE_SIZE ((resource_size_t)-1)</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">e820_reserve_resources_late</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">e820_res</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">insert_resource_expand_to_fit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">res</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to bump up RAM regions to reasonable boundaries to</span>
<span class="cm">	 * avoid stolen RAM:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RAM</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ram_alignment</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">MAX_RESOURCE_SIZE</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">MAX_RESOURCE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;e820: reserve RAM buffer [mem %#010llx-%#010llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">reserve_region_with_split</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
					  <span class="s">&quot;RAM buffer&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">default_machine_specific_memory_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">who</span> <span class="o">=</span> <span class="s">&quot;BIOS-e820&quot;</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_nr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Try to copy the BIOS-supplied E820-map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise fake a memory map; one section from 0k-&gt;640k,</span>
<span class="cm">	 * the next section from 1mb-&gt;appropriate_mem_k</span>
<span class="cm">	 */</span>
	<span class="n">new_nr</span> <span class="o">=</span> <span class="n">boot_params</span><span class="p">.</span><span class="n">e820_entries</span><span class="p">;</span>
	<span class="n">sanitize_e820_map</span><span class="p">(</span><span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">,</span>
			<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">new_nr</span><span class="p">);</span>
	<span class="n">boot_params</span><span class="p">.</span><span class="n">e820_entries</span> <span class="o">=</span> <span class="n">new_nr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">append_e820_map</span><span class="p">(</span><span class="n">boot_params</span><span class="p">.</span><span class="n">e820_map</span><span class="p">,</span> <span class="n">boot_params</span><span class="p">.</span><span class="n">e820_entries</span><span class="p">)</span>
	  <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">mem_size</span><span class="p">;</span>

		<span class="cm">/* compare results from other methods and take the greater */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_params</span><span class="p">.</span><span class="n">alt_mem_k</span>
		    <span class="o">&lt;</span> <span class="n">boot_params</span><span class="p">.</span><span class="n">screen_info</span><span class="p">.</span><span class="n">ext_mem_k</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_size</span> <span class="o">=</span> <span class="n">boot_params</span><span class="p">.</span><span class="n">screen_info</span><span class="p">.</span><span class="n">ext_mem_k</span><span class="p">;</span>
			<span class="n">who</span> <span class="o">=</span> <span class="s">&quot;BIOS-88&quot;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mem_size</span> <span class="o">=</span> <span class="n">boot_params</span><span class="p">.</span><span class="n">alt_mem_k</span><span class="p">;</span>
			<span class="n">who</span> <span class="o">=</span> <span class="s">&quot;BIOS-e801&quot;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">e820_add_region</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LOWMEMSIZE</span><span class="p">(),</span> <span class="n">E820_RAM</span><span class="p">);</span>
		<span class="n">e820_add_region</span><span class="p">(</span><span class="n">HIGH_MEMORY</span><span class="p">,</span> <span class="n">mem_size</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">E820_RAM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* In case someone cares... */</span>
	<span class="k">return</span> <span class="n">who</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_memory_map</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">who</span><span class="p">;</span>

	<span class="n">who</span> <span class="o">=</span> <span class="n">x86_init</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="n">memory_setup</span><span class="p">();</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e820_saved</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e820map</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e820: BIOS-provided physical RAM map:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">e820_print_map</span><span class="p">(</span><span class="n">who</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">memblock_x86_fill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * EFI may have more than 128 entries</span>
<span class="cm">	 * We are safe to enable resizing, beause memblock_x86_fill()</span>
<span class="cm">	 * is rather later for x86</span>
<span class="cm">	 */</span>
	<span class="n">memblock_allow_resize</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e820entry</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="p">(</span><span class="n">resource_size_t</span><span class="p">)</span><span class="n">end</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RAM</span> <span class="o">&amp;&amp;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RESERVED_KERN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">memblock_add</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memblock_dump_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">memblock_find_dma_reserve</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_64</span>
	<span class="n">u64</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_free_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="n">phys_addr_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">u</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * need to find out used area below MAX_DMA_PFN</span>
<span class="cm">	 * need to use memblock to get free size in [0, MAX_DMA_PFN]</span>
<span class="cm">	 * at first, and assume boot_mem will not take below MAX_DMA_PFN</span>
<span class="cm">	 */</span>
	<span class="n">for_each_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="n">MAX_DMA_PFN</span><span class="p">);</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">,</span> <span class="n">MAX_DMA_PFN</span><span class="p">);</span>
		<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_free_mem_range</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">MAX_NUMNODES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_pfn</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">MAX_DMA_PFN</span><span class="p">);</span>
		<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">MAX_DMA_PFN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="n">nr_free_pages</span> <span class="o">+=</span> <span class="n">end_pfn</span> <span class="o">-</span> <span class="n">start_pfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_dma_reserve</span><span class="p">(</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="n">nr_free_pages</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
