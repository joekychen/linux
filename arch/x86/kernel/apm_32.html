<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kernel › apm_32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>apm_32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- linux-c -*-</span>
<span class="cm"> * APM BIOS driver for Linux</span>
<span class="cm"> * Copyright 1994-2001 Stephen Rothwell (sfr@canb.auug.org.au)</span>
<span class="cm"> *</span>
<span class="cm"> * Initial development of this driver was funded by NEC Australia P/L</span>
<span class="cm"> *	and NEC Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * October 1995, Rik Faith (faith@cs.unc.edu):</span>
<span class="cm"> *    Minor enhancements and updates (to the patch set) for 1.3.x</span>
<span class="cm"> *    Documentation</span>
<span class="cm"> * January 1996, Rik Faith (faith@cs.unc.edu):</span>
<span class="cm"> *    Make /proc/apm easy to format (bump driver version)</span>
<span class="cm"> * March 1996, Rik Faith (faith@cs.unc.edu):</span>
<span class="cm"> *    Prohibit APM BIOS calls unless apm_enabled.</span>
<span class="cm"> *    (Thanks to Ulrich Windl &lt;Ulrich.Windl@rz.uni-regensburg.de&gt;)</span>
<span class="cm"> * April 1996, Stephen Rothwell (sfr@canb.auug.org.au)</span>
<span class="cm"> *    Version 1.0 and 1.1</span>
<span class="cm"> * May 1996, Version 1.2</span>
<span class="cm"> * Feb 1998, Version 1.3</span>
<span class="cm"> * Feb 1998, Version 1.4</span>
<span class="cm"> * Aug 1998, Version 1.5</span>
<span class="cm"> * Sep 1998, Version 1.6</span>
<span class="cm"> * Nov 1998, Version 1.7</span>
<span class="cm"> * Jan 1999, Version 1.8</span>
<span class="cm"> * Jan 1999, Version 1.9</span>
<span class="cm"> * Oct 1999, Version 1.10</span>
<span class="cm"> * Nov 1999, Version 1.11</span>
<span class="cm"> * Jan 2000, Version 1.12</span>
<span class="cm"> * Feb 2000, Version 1.13</span>
<span class="cm"> * Nov 2000, Version 1.14</span>
<span class="cm"> * Oct 2001, Version 1.15</span>
<span class="cm"> * Jan 2002, Version 1.16</span>
<span class="cm"> * Oct 2002, Version 1.16ac</span>
<span class="cm"> *</span>
<span class="cm"> * History:</span>
<span class="cm"> *    0.6b: first version in official kernel, Linux 1.3.46</span>
<span class="cm"> *    0.7: changed /proc/apm format, Linux 1.3.58</span>
<span class="cm"> *    0.8: fixed gcc 2.7.[12] compilation problems, Linux 1.3.59</span>
<span class="cm"> *    0.9: only call bios if bios is present, Linux 1.3.72</span>
<span class="cm"> *    1.0: use fixed device number, consolidate /proc/apm into this file,</span>
<span class="cm"> *         Linux 1.3.85</span>
<span class="cm"> *    1.1: support user-space standby and suspend, power off after system</span>
<span class="cm"> *         halted, Linux 1.3.98</span>
<span class="cm"> *    1.2: When resetting RTC after resume, take care so that the time</span>
<span class="cm"> *         is only incorrect by 30-60mS (vs. 1S previously) (Gabor J. Toth</span>
<span class="cm"> *         &lt;jtoth@princeton.edu&gt;); improve interaction between</span>
<span class="cm"> *         screen-blanking and gpm (Stephen Rothwell); Linux 1.99.4</span>
<span class="cm"> *    1.2a:Simple change to stop mysterious bug reports with SMP also added</span>
<span class="cm"> *	   levels to the printk calls. APM is not defined for SMP machines.</span>
<span class="cm"> *         The new replacement for it is, but Linux doesn&#39;t yet support this.</span>
<span class="cm"> *         Alan Cox Linux 2.1.55</span>
<span class="cm"> *    1.3: Set up a valid data descriptor 0x40 for buggy BIOS&#39;s</span>
<span class="cm"> *    1.4: Upgraded to support APM 1.2. Integrated ThinkPad suspend patch by</span>
<span class="cm"> *         Dean Gaudet &lt;dgaudet@arctic.org&gt;.</span>
<span class="cm"> *         C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt; Linux 2.1.87</span>
<span class="cm"> *    1.5: Fix segment register reloading (in case of bad segments saved</span>
<span class="cm"> *         across BIOS call).</span>
<span class="cm"> *         Stephen Rothwell</span>
<span class="cm"> *    1.6: Cope with compiler/assembler differences.</span>
<span class="cm"> *         Only try to turn off the first display device.</span>
<span class="cm"> *         Fix OOPS at power off with no APM BIOS by Jan Echternach</span>
<span class="cm"> *                   &lt;echter@informatik.uni-rostock.de&gt;</span>
<span class="cm"> *         Stephen Rothwell</span>
<span class="cm"> *    1.7: Modify driver&#39;s cached copy of the disabled/disengaged flags</span>
<span class="cm"> *         to reflect current state of APM BIOS.</span>
<span class="cm"> *         Chris Rankin &lt;rankinc@bellsouth.net&gt;</span>
<span class="cm"> *         Reset interrupt 0 timer to 100Hz after suspend</span>
<span class="cm"> *         Chad Miller &lt;cmiller@surfsouth.com&gt;</span>
<span class="cm"> *         Add CONFIG_APM_IGNORE_SUSPEND_BOUNCE</span>
<span class="cm"> *         Richard Gooch &lt;rgooch@atnf.csiro.au&gt;</span>
<span class="cm"> *         Allow boot time disabling of APM</span>
<span class="cm"> *         Make boot messages far less verbose by default</span>
<span class="cm"> *         Make asm safer</span>
<span class="cm"> *         Stephen Rothwell</span>
<span class="cm"> *    1.8: Add CONFIG_APM_RTC_IS_GMT</span>
<span class="cm"> *         Richard Gooch &lt;rgooch@atnf.csiro.au&gt;</span>
<span class="cm"> *         change APM_NOINTS to CONFIG_APM_ALLOW_INTS</span>
<span class="cm"> *         remove dependency on CONFIG_PROC_FS</span>
<span class="cm"> *         Stephen Rothwell</span>
<span class="cm"> *    1.9: Fix small typo.  &lt;laslo@wodip.opole.pl&gt;</span>
<span class="cm"> *         Try to cope with BIOS&#39;s that need to have all display</span>
<span class="cm"> *         devices blanked and not just the first one.</span>
<span class="cm"> *         Ross Paterson &lt;ross@soi.city.ac.uk&gt;</span>
<span class="cm"> *         Fix segment limit setting it has always been wrong as</span>
<span class="cm"> *         the segments needed to have byte granularity.</span>
<span class="cm"> *         Mark a few things __init.</span>
<span class="cm"> *         Add hack to allow power off of SMP systems by popular request.</span>
<span class="cm"> *         Use CONFIG_SMP instead of __SMP__</span>
<span class="cm"> *         Ignore BOUNCES for three seconds.</span>
<span class="cm"> *         Stephen Rothwell</span>
<span class="cm"> *   1.10: Fix for Thinkpad return code.</span>
<span class="cm"> *         Merge 2.2 and 2.3 drivers.</span>
<span class="cm"> *         Remove APM dependencies in arch/i386/kernel/process.c</span>
<span class="cm"> *         Remove APM dependencies in drivers/char/sysrq.c</span>
<span class="cm"> *         Reset time across standby.</span>
<span class="cm"> *         Allow more inititialisation on SMP.</span>
<span class="cm"> *         Remove CONFIG_APM_POWER_OFF and make it boot time</span>
<span class="cm"> *         configurable (default on).</span>
<span class="cm"> *         Make debug only a boot time parameter (remove APM_DEBUG).</span>
<span class="cm"> *         Try to blank all devices on any error.</span>
<span class="cm"> *   1.11: Remove APM dependencies in drivers/char/console.c</span>
<span class="cm"> *         Check nr_running to detect if we are idle (from</span>
<span class="cm"> *         Borislav Deianov &lt;borislav@lix.polytechnique.fr&gt;)</span>
<span class="cm"> *         Fix for bioses that don&#39;t zero the top part of the</span>
<span class="cm"> *         entrypoint offset (Mario Sitta &lt;sitta@al.unipmn.it&gt;)</span>
<span class="cm"> *         (reported by Panos Katsaloulis &lt;teras@writeme.com&gt;).</span>
<span class="cm"> *         Real mode power off patch (Walter Hofmann</span>
<span class="cm"> *         &lt;Walter.Hofmann@physik.stud.uni-erlangen.de&gt;).</span>
<span class="cm"> *   1.12: Remove CONFIG_SMP as the compiler will optimize</span>
<span class="cm"> *         the code away anyway (smp_num_cpus == 1 in UP)</span>
<span class="cm"> *         noted by Artur Skawina &lt;skawina@geocities.com&gt;.</span>
<span class="cm"> *         Make power off under SMP work again.</span>
<span class="cm"> *         Fix thinko with initial engaging of BIOS.</span>
<span class="cm"> *         Make sure power off only happens on CPU 0</span>
<span class="cm"> *         (Paul &quot;Rusty&quot; Russell &lt;rusty@rustcorp.com.au&gt;).</span>
<span class="cm"> *         Do error notification to user mode if BIOS calls fail.</span>
<span class="cm"> *         Move entrypoint offset fix to ...boot/setup.S</span>
<span class="cm"> *         where it belongs (Cosmos &lt;gis88564@cis.nctu.edu.tw&gt;).</span>
<span class="cm"> *         Remove smp-power-off. SMP users must now specify</span>
<span class="cm"> *         &quot;apm=power-off&quot; on the kernel command line. Suggested</span>
<span class="cm"> *         by Jim Avera &lt;jima@hal.com&gt;, modified by Alan Cox</span>
<span class="cm"> *         &lt;alan@lxorguk.ukuu.org.uk&gt;.</span>
<span class="cm"> *         Register the /proc/apm entry even on SMP so that</span>
<span class="cm"> *         scripts that check for it before doing power off</span>
<span class="cm"> *         work (Jim Avera &lt;jima@hal.com&gt;).</span>
<span class="cm"> *   1.13: Changes for new pm_ interfaces (Andy Henroid</span>
<span class="cm"> *         &lt;andy_henroid@yahoo.com&gt;).</span>
<span class="cm"> *         Modularize the code.</span>
<span class="cm"> *         Fix the Thinkpad (again) :-( (CONFIG_APM_IGNORE_MULTIPLE_SUSPENDS</span>
<span class="cm"> *         is now the way life works).</span>
<span class="cm"> *         Fix thinko in suspend() (wrong return).</span>
<span class="cm"> *         Notify drivers on critical suspend.</span>
<span class="cm"> *         Make kapmd absorb more idle time (Pavel Machek &lt;pavel@ucw.cz&gt;</span>
<span class="cm"> *         modified by sfr).</span>
<span class="cm"> *         Disable interrupts while we are suspended (Andy Henroid</span>
<span class="cm"> *         &lt;andy_henroid@yahoo.com&gt; fixed by sfr).</span>
<span class="cm"> *         Make power off work on SMP again (Tony Hoyle</span>
<span class="cm"> *         &lt;tmh@magenta-logic.com&gt; and &lt;zlatko@iskon.hr&gt;) modified by sfr.</span>
<span class="cm"> *         Remove CONFIG_APM_SUSPEND_BOUNCE.  The bounce ignore</span>
<span class="cm"> *         interval is now configurable.</span>
<span class="cm"> *   1.14: Make connection version persist across module unload/load.</span>
<span class="cm"> *         Enable and engage power management earlier.</span>
<span class="cm"> *         Disengage power management on module unload.</span>
<span class="cm"> *         Changed to use the sysrq-register hack for registering the</span>
<span class="cm"> *         power off function called by magic sysrq based upon discussions</span>
<span class="cm"> *         in irc://irc.openprojects.net/#kernelnewbies</span>
<span class="cm"> *         (Crutcher Dunnavant &lt;crutcher+kernel@datastacks.com&gt;).</span>
<span class="cm"> *         Make CONFIG_APM_REAL_MODE_POWER_OFF run time configurable.</span>
<span class="cm"> *         (Arjan van de Ven &lt;arjanv@redhat.com&gt;) modified by sfr.</span>
<span class="cm"> *         Work around byte swap bug in one of the Vaio&#39;s BIOS&#39;s</span>
<span class="cm"> *         (Marc Boucher &lt;marc@mbsi.ca&gt;).</span>
<span class="cm"> *         Exposed the disable flag to dmi so that we can handle known</span>
<span class="cm"> *         broken APM (Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;).</span>
<span class="cm"> *   1.14ac: If the BIOS says &quot;I slowed the CPU down&quot; then don&#39;t spin</span>
<span class="cm"> *         calling it - instead idle. (Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;)</span>
<span class="cm"> *         If an APM idle fails log it and idle sensibly</span>
<span class="cm"> *   1.15: Don&#39;t queue events to clients who open the device O_WRONLY.</span>
<span class="cm"> *         Don&#39;t expect replies from clients who open the device O_RDONLY.</span>
<span class="cm"> *         (Idea from Thomas Hood)</span>
<span class="cm"> *         Minor waitqueue cleanups. (John Fremlin &lt;chief@bandits.org&gt;)</span>
<span class="cm"> *   1.16: Fix idle calling. (Andreas Steinmetz &lt;ast@domdv.de&gt; et al.)</span>
<span class="cm"> *         Notify listeners of standby or suspend events before notifying</span>
<span class="cm"> *         drivers. Return EBUSY to ioctl() if suspend is rejected.</span>
<span class="cm"> *         (Russell King &lt;rmk@arm.linux.org.uk&gt; and Thomas Hood)</span>
<span class="cm"> *         Ignore first resume after we generate our own resume event</span>
<span class="cm"> *         after a suspend (Thomas Hood)</span>
<span class="cm"> *         Daemonize now gets rid of our controlling terminal (sfr).</span>
<span class="cm"> *         CONFIG_APM_CPU_IDLE now just affects the default value of</span>
<span class="cm"> *         idle_threshold (sfr).</span>
<span class="cm"> *         Change name of kernel apm daemon (as it no longer idles) (sfr).</span>
<span class="cm"> *   1.16ac: Fix up SMP support somewhat. You can now force SMP on and we</span>
<span class="cm"> *	   make _all_ APM calls on the CPU#0. Fix unsafe sign bug.</span>
<span class="cm"> *	   TODO: determine if its &quot;boot CPU&quot; or &quot;CPU0&quot; we want to lock to.</span>
<span class="cm"> *</span>
<span class="cm"> * APM 1.1 Reference:</span>
<span class="cm"> *</span>
<span class="cm"> *   Intel Corporation, Microsoft Corporation. Advanced Power Management</span>
<span class="cm"> *   (APM) BIOS Interface Specification, Revision 1.1, September 1993.</span>
<span class="cm"> *   Intel Order Number 241704-001.  Microsoft Part Number 781-110-X01.</span>
<span class="cm"> *</span>
<span class="cm"> * [This document is available free from Intel by calling 800.628.8686 (fax</span>
<span class="cm"> * 916.356.6100) or 800.548.4725; or from</span>
<span class="cm"> * http://www.microsoft.com/whdc/archive/amp_12.mspx  It is also</span>
<span class="cm"> * available from Microsoft by calling 206.882.8080.]</span>
<span class="cm"> *</span>
<span class="cm"> * APM 1.2 Reference:</span>
<span class="cm"> *   Intel Corporation, Microsoft Corporation. Advanced Power Management</span>
<span class="cm"> *   (APM) BIOS Interface Specification, Revision 1.2, February 1996.</span>
<span class="cm"> *</span>
<span class="cm"> * [This document is available from Microsoft at:</span>
<span class="cm"> *    http://www.microsoft.com/whdc/archive/amp_12.mspx]</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/apm_bios.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/i8253.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/desc.h&gt;</span>
<span class="cp">#include &lt;asm/olpc.h&gt;</span>
<span class="cp">#include &lt;asm/paravirt.h&gt;</span>
<span class="cp">#include &lt;asm/reboot.h&gt;</span>

<span class="cp">#if defined(CONFIG_APM_DISPLAY_BLANK) &amp;&amp; defined(CONFIG_VT)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">console_blank_hook</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The apm_bios device is one of the misc char devices.</span>
<span class="cm"> * This is its minor number.</span>
<span class="cm"> */</span>
<span class="cp">#define	APM_MINOR_DEV	134</span>

<span class="cm">/*</span>
<span class="cm"> * Various options can be changed at boot time as follows:</span>
<span class="cm"> * (We allow underscores for compatibility with the modules code)</span>
<span class="cm"> *	apm=on/off			enable/disable APM</span>
<span class="cm"> *	    [no-]allow[-_]ints		allow interrupts during BIOS calls</span>
<span class="cm"> *	    [no-]broken[-_]psr		BIOS has a broken GetPowerStatus call</span>
<span class="cm"> *	    [no-]realmode[-_]power[-_]off	switch to real mode before</span>
<span class="cm"> *	    					powering off</span>
<span class="cm"> *	    [no-]debug			log some debugging messages</span>
<span class="cm"> *	    [no-]power[-_]off		power off on shutdown</span>
<span class="cm"> *	    [no-]smp			Use apm even on an SMP box</span>
<span class="cm"> *	    bounce[-_]interval=&lt;n&gt;	number of ticks to ignore suspend</span>
<span class="cm"> *	    				bounces</span>
<span class="cm"> *          idle[-_]threshold=&lt;n&gt;       System idle percentage above which to</span>
<span class="cm"> *                                      make APM BIOS idle calls. Set it to</span>
<span class="cm"> *                                      100 to disable.</span>
<span class="cm"> *          idle[-_]period=&lt;n&gt;          Period (in 1/100s of a second) over</span>
<span class="cm"> *                                      which the idle percentage is</span>
<span class="cm"> *                                      calculated.</span>
<span class="cm"> */</span>

<span class="cm">/* KNOWN PROBLEM MACHINES:</span>
<span class="cm"> *</span>
<span class="cm"> * U: TI 4000M TravelMate: BIOS is *NOT* APM compliant</span>
<span class="cm"> *                         [Confirmed by TI representative]</span>
<span class="cm"> * ?: ACER 486DX4/75: uses dseg 0040, in violation of APM specification</span>
<span class="cm"> *                    [Confirmed by BIOS disassembly]</span>
<span class="cm"> *                    [This may work now ...]</span>
<span class="cm"> * P: Toshiba 1950S: battery life information only gets updated after resume</span>
<span class="cm"> * P: Midwest Micro Soundbook Elite DX2/66 monochrome: screen blanking</span>
<span class="cm"> * 	broken in BIOS [Reported by Garst R. Reese &lt;reese@isn.net&gt;]</span>
<span class="cm"> * ?: AcerNote-950: oops on reading /proc/apm - workaround is a WIP</span>
<span class="cm"> * 	Neale Banks &lt;neale@lowendale.com.au&gt; December 2000</span>
<span class="cm"> *</span>
<span class="cm"> * Legend: U = unusable with APM patches</span>
<span class="cm"> *         P = partially usable with APM patches</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Define as 1 to make the driver always call the APM BIOS busy</span>
<span class="cm"> * routine even if the clock was not reported as slowed by the</span>
<span class="cm"> * idle routine.  Otherwise, define as 0.</span>
<span class="cm"> */</span>
<span class="cp">#define ALWAYS_CALL_BUSY   1</span>

<span class="cm">/*</span>
<span class="cm"> * Define to make the APM BIOS calls zero all data segment registers (so</span>
<span class="cm"> * that an incorrect BIOS implementation will cause a kernel panic if it</span>
<span class="cm"> * tries to write to arbitrary memory).</span>
<span class="cm"> */</span>
<span class="cp">#define APM_ZERO_SEGS</span>

<span class="cp">#include &lt;asm/apm.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Define to re-initialize the interrupt 0 timer to 100 Hz after a suspend.</span>
<span class="cm"> * This patched by Chad Miller &lt;cmiller@surfsouth.com&gt;, original code by</span>
<span class="cm"> * David Chen &lt;chen@ctpa04.mit.edu&gt;</span>
<span class="cm"> */</span>
<span class="cp">#undef INIT_TIMER_AFTER_SUSPEND</span>

<span class="cp">#ifdef INIT_TIMER_AFTER_SUSPEND</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Need to poll the APM BIOS every second</span>
<span class="cm"> */</span>
<span class="cp">#define APM_CHECK_TIMEOUT	(HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * Ignore suspend events for this amount of time after a resume</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_BOUNCE_INTERVAL	(3 * HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of events stored</span>
<span class="cm"> */</span>
<span class="cp">#define APM_MAX_EVENTS		20</span>

<span class="cm">/*</span>
<span class="cm"> * The per-file APM data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">apm_user</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">suser</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">writer</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">reader</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">suspend_wait</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">suspend_result</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">suspends_pending</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">standbys_pending</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">suspends_read</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">standbys_read</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">event_head</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">event_tail</span><span class="p">;</span>
	<span class="n">apm_event_t</span>	<span class="n">events</span><span class="p">[</span><span class="n">APM_MAX_EVENTS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The magic number in apm_user</span>
<span class="cm"> */</span>
<span class="cp">#define APM_BIOS_MAGIC		0x4101</span>

<span class="cm">/*</span>
<span class="cm"> * idle percentage above which bios idle calls are done</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_APM_CPU_IDLE</span>
<span class="cp">#warning deprecated CONFIG_APM_CPU_IDLE will be deleted in 2012</span>
<span class="cp">#define DEFAULT_IDLE_THRESHOLD	95</span>
<span class="cp">#else</span>
<span class="cp">#define DEFAULT_IDLE_THRESHOLD	100</span>
<span class="cp">#endif</span>
<span class="cp">#define DEFAULT_IDLE_PERIOD	(100 / 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Local variables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">segment</span><span class="p">;</span>
<span class="p">}</span> <span class="n">apm_bios_entry</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">clock_slowed</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">idle_threshold</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">DEFAULT_IDLE_THRESHOLD</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">idle_period</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">DEFAULT_IDLE_PERIOD</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">set_pm_idle</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">suspends_pending</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">standbys_pending</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ignore_sys_suspend</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ignore_normal_resume</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bounce_interval</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">DEFAULT_BOUNCE_INTERVAL</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">debug</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">smp</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">apm_disabled</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">power_off</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">power_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">realmode_power_off</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_APM_ALLOW_INTS</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">allow_ints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">allow_ints</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">broken_psr</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">apm_waitqueue</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">apm_suspend_waitqueue</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">user_list</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">user_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">apm_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set up a segment that references the real mode segment 0x40</span>
<span class="cm"> * that extends up to the end of page zero (that we have reserved).</span>
<span class="cm"> * This is for buggy BIOS&#39;s that refer to (real mode) segment 0x40</span>
<span class="cm"> * even though they are called in protected mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">desc_struct</span> <span class="n">bad_bios_desc</span> <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x4092</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="mh">0x400UL</span><span class="p">),</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mh">0x400</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;1.16ac&quot;</span><span class="p">;</span>	<span class="cm">/* no spaces */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kapmd_task</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	APM event names taken from the APM 1.2 specification. These are</span>
<span class="cm"> *	the message codes that the BIOS uses to tell us about events</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">apm_event_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;system standby&quot;</span><span class="p">,</span>
	<span class="s">&quot;system suspend&quot;</span><span class="p">,</span>
	<span class="s">&quot;normal resume&quot;</span><span class="p">,</span>
	<span class="s">&quot;critical resume&quot;</span><span class="p">,</span>
	<span class="s">&quot;low battery&quot;</span><span class="p">,</span>
	<span class="s">&quot;power status change&quot;</span><span class="p">,</span>
	<span class="s">&quot;update time&quot;</span><span class="p">,</span>
	<span class="s">&quot;critical suspend&quot;</span><span class="p">,</span>
	<span class="s">&quot;user standby&quot;</span><span class="p">,</span>
	<span class="s">&quot;user suspend&quot;</span><span class="p">,</span>
	<span class="s">&quot;system standby resume&quot;</span><span class="p">,</span>
	<span class="s">&quot;capabilities change&quot;</span>
<span class="p">};</span>
<span class="cp">#define NR_APM_EVENT_NAME ARRAY_SIZE(apm_event_name)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">lookup_t</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">key</span><span class="p">;</span>
	<span class="kt">char</span> 	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lookup_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	The BIOS returns a set of standard error codes in AX when the</span>
<span class="cm"> *	carry flag is set.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">lookup_t</span> <span class="n">error_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* N/A	{ APM_SUCCESS,		&quot;Operation succeeded&quot; }, */</span>
	<span class="p">{</span> <span class="n">APM_DISABLED</span><span class="p">,</span>		<span class="s">&quot;Power management disabled&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_CONNECTED</span><span class="p">,</span>	<span class="s">&quot;Real mode interface already connected&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_NOT_CONNECTED</span><span class="p">,</span>	<span class="s">&quot;Interface not connected&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_16_CONNECTED</span><span class="p">,</span>	<span class="s">&quot;16 bit interface already connected&quot;</span> <span class="p">},</span>
<span class="cm">/* N/A	{ APM_16_UNSUPPORTED,	&quot;16 bit interface not supported&quot; }, */</span>
	<span class="p">{</span> <span class="n">APM_32_CONNECTED</span><span class="p">,</span>	<span class="s">&quot;32 bit interface already connected&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_32_UNSUPPORTED</span><span class="p">,</span>	<span class="s">&quot;32 bit interface not supported&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_BAD_DEVICE</span><span class="p">,</span>	<span class="s">&quot;Unrecognized device ID&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_BAD_PARAM</span><span class="p">,</span>	<span class="s">&quot;Parameter out of range&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_NOT_ENGAGED</span><span class="p">,</span>	<span class="s">&quot;Interface not engaged&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_BAD_FUNCTION</span><span class="p">,</span>     <span class="s">&quot;Function not supported&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_RESUME_DISABLED</span><span class="p">,</span>	<span class="s">&quot;Resume timer disabled&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_BAD_STATE</span><span class="p">,</span>	<span class="s">&quot;Unable to enter requested state&quot;</span> <span class="p">},</span>
<span class="cm">/* N/A	{ APM_NO_EVENTS,	&quot;No events pending&quot; }, */</span>
	<span class="p">{</span> <span class="n">APM_NO_ERROR</span><span class="p">,</span>		<span class="s">&quot;BIOS did not set a return code&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">APM_NOT_PRESENT</span><span class="p">,</span>	<span class="s">&quot;No APM present&quot;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define ERROR_COUNT	ARRAY_SIZE(error_table)</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_error	-	display an APM error</span>
<span class="cm"> *	@str: information string</span>
<span class="cm"> *	@err: APM BIOS return code</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a meaningful log entry to the kernel log in the event of</span>
<span class="cm"> *	an APM error.  Note that this also handles (negative) kernel errors.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_error</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ERROR_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ERROR_COUNT</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">error_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: %s: linux error code %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: %s: unknown error code %#2.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">str</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are the actual BIOS calls.  Depending on APM_ZERO_SEGS and</span>
<span class="cm"> * apm_info.allow_ints, we are being really paranoid here!  Not only</span>
<span class="cm"> * are interrupts disabled, but all the segment registers (except SS)</span>
<span class="cm"> * are saved and zeroed this means that if the BIOS tries to reference</span>
<span class="cm"> * any data without explicitly loading the segment registers, the kernel</span>
<span class="cm"> * will fault immediately rather than have some unforeseen circumstances</span>
<span class="cm"> * for the rest of the kernel.  And it will be very obvious!  :-) Doing</span>
<span class="cm"> * this depends on CS referring to the same physical memory as DS so that</span>
<span class="cm"> * DS can be zeroed before the call. Unfortunately, we can&#39;t do anything</span>
<span class="cm"> * about the stack segment/pointer.  Also, we tell the compiler that</span>
<span class="cm"> * everything could change.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, we KNOW that for the non error case of apm_bios_call, there</span>
<span class="cm"> * is no useful data returned in the low order 8 bits of eax.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__apm_irq_save</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">local_save_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">allow_ints</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define apm_irq_save(flags) \</span>
<span class="cp">	do { flags = __apm_irq_save(); } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">apm_irq_restore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef APM_ZERO_SEGS</span>
<span class="cp">#	define APM_DECL_SEGS \</span>
<span class="cp">		unsigned int saved_fs; unsigned int saved_gs;</span>
<span class="cp">#	define APM_DO_SAVE_SEGS \</span>
<span class="cp">		savesegment(fs, saved_fs); savesegment(gs, saved_gs)</span>
<span class="cp">#	define APM_DO_RESTORE_SEGS \</span>
<span class="cp">		loadsegment(fs, saved_fs); loadsegment(gs, saved_gs)</span>
<span class="cp">#else</span>
<span class="cp">#	define APM_DECL_SEGS</span>
<span class="cp">#	define APM_DO_SAVE_SEGS</span>
<span class="cp">#	define APM_DO_RESTORE_SEGS</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">func</span><span class="p">;</span>
	<span class="cm">/* In and out */</span>
	<span class="n">u32</span> <span class="n">ebx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ecx</span><span class="p">;</span>
	<span class="cm">/* Out only */</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">edx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">esi</span><span class="p">;</span>

	<span class="cm">/* Error: -ENOMEM, or bits 8-15 of eax */</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	__apm_bios_call - Make an APM BIOS 32bit call</span>
<span class="cm"> *	@_call: pointer to struct apm_bios_call.</span>
<span class="cm"> *</span>
<span class="cm"> *	Make an APM call using the 32bit protected mode interface. The</span>
<span class="cm"> *	caller is responsible for knowing if APM BIOS is configured and</span>
<span class="cm"> *	enabled. This call can disable interrupts for a long period of</span>
<span class="cm"> *	time on some laptops.  The return value is in AH and the carry</span>
<span class="cm"> *	flag is loaded into AL.  If there is an error, then the error</span>
<span class="cm"> *	code is returned in AH (bits 8-15 of eax) and this function</span>
<span class="cm"> *	returns non-zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this makes the call on the current CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">__apm_bios_call</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">APM_DECL_SEGS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span>	<span class="n">save_desc_40</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span>	<span class="o">*</span><span class="n">gdt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apm_bios_call</span>	<span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">_call</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gdt</span> <span class="o">=</span> <span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">save_desc_40</span> <span class="o">=</span> <span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_bios_desc</span><span class="p">;</span>

	<span class="n">apm_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">APM_DO_SAVE_SEGS</span><span class="p">;</span>
	<span class="n">apm_bios_call_asm</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">esi</span><span class="p">);</span>
	<span class="n">APM_DO_RESTORE_SEGS</span><span class="p">;</span>
	<span class="n">apm_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_desc_40</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">eax</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Run __apm_bios_call or __apm_bios_call_simple on CPU 0 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_cpu0</span><span class="p">(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t bother with work_on_cpu in the common case, so we don&#39;t</span>
<span class="cm">	 * have to worry about OOM or overhead. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_cpu</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">call</span><span class="p">);</span>
		<span class="n">put_cpu</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put_cpu</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">work_on_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">call</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* work_on_cpu can fail with -ENOMEM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">call</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">call</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">eax</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_bios_call	-	Make an APM BIOS 32bit call (on CPU 0)</span>
<span class="cm"> *	@call: the apm_bios_call registers.</span>
<span class="cm"> *</span>
<span class="cm"> *	If there is an error, it is returned in @call.err.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_bios_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="o">*</span><span class="n">call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">on_cpu0</span><span class="p">(</span><span class="n">__apm_bios_call</span><span class="p">,</span> <span class="n">call</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__apm_bios_call_simple - Make an APM BIOS 32bit call (on CPU 0)</span>
<span class="cm"> *	@_call: pointer to struct apm_bios_call.</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a BIOS call that returns one value only, or just status.</span>
<span class="cm"> *	If there is an error, then the error code is returned in AH</span>
<span class="cm"> *	(bits 8-15 of eax) and this function returns non-zero (it can</span>
<span class="cm"> *	also return -ENOMEM). This is used for simpler BIOS operations.</span>
<span class="cm"> *	This call may hold interrupts off for a long time on some laptops.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: this makes the call on the current CPU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">__apm_bios_call_simple</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_call</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">APM_DECL_SEGS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span>	<span class="n">save_desc_40</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">desc_struct</span>	<span class="o">*</span><span class="n">gdt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apm_bios_call</span>	<span class="o">*</span><span class="n">call</span> <span class="o">=</span> <span class="n">_call</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gdt</span> <span class="o">=</span> <span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">save_desc_40</span> <span class="o">=</span> <span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">];</span>
	<span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_bios_desc</span><span class="p">;</span>

	<span class="n">apm_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">APM_DO_SAVE_SEGS</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">apm_bios_call_simple_asm</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">,</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">);</span>
	<span class="n">APM_DO_RESTORE_SEGS</span><span class="p">;</span>
	<span class="n">apm_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">gdt</span><span class="p">[</span><span class="mh">0x40</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_desc_40</span><span class="p">;</span>
	<span class="n">put_cpu</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_bios_call_simple	-	make a simple APM BIOS 32bit call</span>
<span class="cm"> *	@func: APM function to invoke</span>
<span class="cm"> *	@ebx_in: EBX register value for BIOS call</span>
<span class="cm"> *	@ecx_in: ECX register value for BIOS call</span>
<span class="cm"> *	@eax: EAX register on return from the BIOS call</span>
<span class="cm"> *	@err: bits</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a BIOS call that returns one value only, or just status.</span>
<span class="cm"> *	If there is an error, then the error code is returned in @err</span>
<span class="cm"> *	and this function returns non-zero. This is used for simpler</span>
<span class="cm"> *	BIOS operations.  This call may hold interrupts off for a long</span>
<span class="cm"> *	time on some laptops.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_bios_call_simple</span><span class="p">(</span><span class="n">u32</span> <span class="n">func</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ebx_in</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ecx_in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="n">call</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">call</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">call</span><span class="p">.</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">ebx_in</span><span class="p">;</span>
	<span class="n">call</span><span class="p">.</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">ecx_in</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">on_cpu0</span><span class="p">(</span><span class="n">__apm_bios_call_simple</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">call</span><span class="p">);</span>
	<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">eax</span><span class="p">;</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_driver_version	-	APM driver version</span>
<span class="cm"> *	@val:	loaded with the APM version on return</span>
<span class="cm"> *</span>
<span class="cm"> *	Retrieve the APM version supported by the BIOS. This is only</span>
<span class="cm"> *	supported for APM 1.1 or higher. An error indicates APM 1.0 is</span>
<span class="cm"> *	probably present.</span>
<span class="cm"> *</span>
<span class="cm"> *	On entry val should point to a value indicating the APM driver</span>
<span class="cm"> *	version with the high byte being the major and the low byte the</span>
<span class="cm"> *	minor number both in BCD</span>
<span class="cm"> *</span>
<span class="cm"> *	On return it will hold the BIOS revision supported in the</span>
<span class="cm"> *	same format.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_driver_version</span><span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_VERSION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">eax</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_get_event	-	get an APM event from the BIOS</span>
<span class="cm"> *	@event: pointer to the event</span>
<span class="cm"> *	@info: point to the event information</span>
<span class="cm"> *</span>
<span class="cm"> *	The APM BIOS provides a polled information for event</span>
<span class="cm"> *	reporting. The BIOS expects to be polled at least every second</span>
<span class="cm"> *	when events are pending. When a message is found the caller should</span>
<span class="cm"> *	poll until no more messages are present.  However, this causes</span>
<span class="cm"> *	problems on some laptops where a suspend event notification is</span>
<span class="cm"> *	not cleared until it is acknowledged.</span>
<span class="cm"> *</span>
<span class="cm"> *	Additional information is returned in the info pointer, providing</span>
<span class="cm"> *	that APM 1.2 is in use. If no messges are pending the value 0x80</span>
<span class="cm"> *	is returned (No power management events pending).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_get_event</span><span class="p">(</span><span class="n">apm_event_t</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">apm_eventinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="n">call</span><span class="p">;</span>

	<span class="n">call</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">APM_FUNC_GET_EVENT</span><span class="p">;</span>
	<span class="n">call</span><span class="p">.</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">ecx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">call</span><span class="p">.</span><span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">ebx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&lt;</span> <span class="mh">0x0102</span><span class="p">)</span>
		<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* indicate info not valid */</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	set_power_state	-	set the power management state</span>
<span class="cm"> *	@what: which items to transition</span>
<span class="cm"> *	@state: state to transition to</span>
<span class="cm"> *</span>
<span class="cm"> *	Request an APM change of state for one or more system devices. The</span>
<span class="cm"> *	processor state must be transitioned last of all. what holds the</span>
<span class="cm"> *	class of device in the upper byte and the device number (0xFF for</span>
<span class="cm"> *	all) for the object to be transitioned.</span>
<span class="cm"> *</span>
<span class="cm"> *	The state holds the state to transition to, which may in fact</span>
<span class="cm"> *	be an acceptance of a BIOS requested state change.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_power_state</span><span class="p">(</span><span class="n">u_short</span> <span class="n">what</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_SET_STATE</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	set_system_power_state - set system wide power state</span>
<span class="cm"> *	@state: which state to enter</span>
<span class="cm"> *</span>
<span class="cm"> *	Transition the entire system into a new APM power state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_system_power_state</span><span class="p">(</span><span class="n">u_short</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_power_state</span><span class="p">(</span><span class="n">APM_DEVICE_ALL</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_do_idle	-	perform power saving</span>
<span class="cm"> *</span>
<span class="cm"> *	This function notifies the BIOS that the processor is (in the view</span>
<span class="cm"> *	of the OS) idle. It returns -1 in the event that the BIOS refuses</span>
<span class="cm"> *	to handle the idle request. On a success the function returns 1</span>
<span class="cm"> *	if the BIOS did clock slowing or 0 otherwise.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_do_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">polling</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">polling</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TS_POLLING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">polling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * TS_POLLING-cleared state must be visible before we</span>
<span class="cm">		 * test NEED_RESCHED:</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">idled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_IDLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">polling</span><span class="p">)</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

		<span class="cm">/* This always fails on some SMP boards running UP kernels.</span>
<span class="cm">		 * Only report the failure the first 5 times.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;apm_do_idle failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clock_slowed</span> <span class="o">=</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_IDLE_SLOWS_CLOCK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">clock_slowed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_do_busy	-	inform the BIOS the CPU is busy</span>
<span class="cm"> *</span>
<span class="cm"> *	Request that the BIOS brings the CPU back to full performance.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_do_busy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clock_slowed</span> <span class="o">||</span> <span class="n">ALWAYS_CALL_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_BUSY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="n">clock_slowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If no process has really been interested in</span>
<span class="cm"> * the CPU for some time, we want to call BIOS</span>
<span class="cm"> * power management - we probably want</span>
<span class="cm"> * to conserve power.</span>
<span class="cm"> */</span>
<span class="cp">#define IDLE_CALC_LIMIT	(HZ * 100)</span>
<span class="cp">#define IDLE_LEAKY_MAX	16</span>

<span class="k">static</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">original_pm_idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * apm_cpu_idle		-	cpu idling for APM capable Linux</span>
<span class="cm"> *</span>
<span class="cm"> * This is the idling function the kernel executes when APM is available. It</span>
<span class="cm"> * tries to do BIOS powermanagement based on the average system idle time.</span>
<span class="cm"> * Furthermore it calls the system default idle routine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_cpu_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">use_apm_idle</span><span class="p">;</span> <span class="cm">/* = 0 */</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_jiffies</span><span class="p">;</span> <span class="cm">/* = 0 */</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_stime</span><span class="p">;</span> <span class="cm">/* = 0 */</span>

	<span class="kt">int</span> <span class="n">apm_idle_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jiffies_since_last_check</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">last_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bucket</span><span class="p">;</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;deprecated apm_cpu_idle will be deleted in 2012&quot;</span><span class="p">);</span>
<span class="nl">recalc:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jiffies_since_last_check</span> <span class="o">&gt;</span> <span class="n">IDLE_CALC_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">use_apm_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">last_stime</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jiffies_since_last_check</span> <span class="o">&gt;</span> <span class="n">idle_period</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idle_percentage</span><span class="p">;</span>

		<span class="n">idle_percentage</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">-</span> <span class="n">last_stime</span><span class="p">;</span>
		<span class="n">idle_percentage</span> <span class="o">*=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="n">idle_percentage</span> <span class="o">/=</span> <span class="n">jiffies_since_last_check</span><span class="p">;</span>
		<span class="n">use_apm_idle</span> <span class="o">=</span> <span class="p">(</span><span class="n">idle_percentage</span> <span class="o">&gt;</span> <span class="n">idle_threshold</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">forbid_idle</span><span class="p">)</span>
			<span class="n">use_apm_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">last_stime</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">IDLE_LEAKY_MAX</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_apm_idle</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>

			<span class="n">t</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">apm_do_idle</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">apm_idle_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">bucket</span> <span class="o">=</span> <span class="n">IDLE_LEAKY_MAX</span><span class="p">;</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bucket</span><span class="o">--</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">apm_idle_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span> <span class="cm">/* BIOS refused */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">original_pm_idle</span><span class="p">)</span>
			<span class="n">original_pm_idle</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">default_idle</span><span class="p">();</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">jiffies_since_last_check</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">last_jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jiffies_since_last_check</span> <span class="o">&gt;</span> <span class="n">idle_period</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">recalc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_idle_done</span><span class="p">)</span>
		<span class="n">apm_do_busy</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_power_off	-	ask the BIOS to power off</span>
<span class="cm"> *</span>
<span class="cm"> *	Handle the power off sequence. This is the one piece of code we</span>
<span class="cm"> *	will execute even on SMP machines. In order to deal with BIOS</span>
<span class="cm"> *	bugs we support real mode APM BIOS power off calls. We also make</span>
<span class="cm"> *	the SMP call on CPU0 as some systems will only honour this call</span>
<span class="cm"> *	on their first cpu.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_power_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Some bioses don&#39;t like being called from CPU != 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">realmode_power_off</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">machine_real_restart</span><span class="p">(</span><span class="n">MRR_APM</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_OFF</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_APM_DO_ENABLE</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_enable_power_management - enable BIOS APM power management</span>
<span class="cm"> *	@enable: enable yes/no</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable or disable the APM BIOS power services.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_enable_power_management</span><span class="p">(</span><span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_BIOS_DISENGAGED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">APM_NOT_ENGAGED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_ENABLE_PM</span><span class="p">,</span> <span class="n">APM_DEVICE_BALL</span><span class="p">,</span>
				 <span class="n">enable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APM_BIOS_DISABLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">APM_BIOS_DISABLED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_get_power_status	-	get current power state</span>
<span class="cm"> *	@status: returned status</span>
<span class="cm"> *	@bat: battery info</span>
<span class="cm"> *	@life: estimated life</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain the current power status from the APM BIOS. We return a</span>
<span class="cm"> *	status which gives the rough battery status, and current power</span>
<span class="cm"> *	source. The bat value returned give an estimate as a percentage</span>
<span class="cm"> *	of life and a status value for the battery. The estimated life</span>
<span class="cm"> *	if reported is a lifetime in secodnds/minutes at current powwer</span>
<span class="cm"> *	consumption.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_get_power_status</span><span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="n">u_short</span> <span class="o">*</span><span class="n">bat</span><span class="p">,</span> <span class="n">u_short</span> <span class="o">*</span><span class="n">life</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_bios_call</span> <span class="n">call</span><span class="p">;</span>

	<span class="n">call</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">APM_FUNC_GET_STATUS</span><span class="p">;</span>
	<span class="n">call</span><span class="p">.</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">APM_DEVICE_ALL</span><span class="p">;</span>
	<span class="n">call</span><span class="p">.</span><span class="n">ecx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_broken</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">APM_32_UNSUPPORTED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">call</span><span class="p">.</span><span class="n">err</span><span class="p">;</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">ebx</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bat</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_swabinminutes</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">life</span> <span class="o">=</span> <span class="n">swab16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span><span class="n">call</span><span class="p">.</span><span class="n">edx</span><span class="p">);</span>
		<span class="o">*</span><span class="n">life</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">life</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">edx</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static int apm_get_battery_status(u_short which, u_short *status,</span>
<span class="c">				  u_short *bat, u_short *life, u_short *nbat)</span>
<span class="c">{</span>
<span class="c">	u32 eax;</span>
<span class="c">	u32 ebx;</span>
<span class="c">	u32 ecx;</span>
<span class="c">	u32 edx;</span>
<span class="c">	u32 esi;</span>

<span class="c">	if (apm_info.connection_version &lt; 0x0102) {</span>
<span class="c">		/* pretend we only have one battery. */</span>
<span class="c">		if (which != 1)</span>
<span class="c">			return APM_BAD_DEVICE;</span>
<span class="c">		*nbat = 1;</span>
<span class="c">		return apm_get_power_status(status, bat, life);</span>
<span class="c">	}</span>

<span class="c">	if (apm_bios_call(APM_FUNC_GET_STATUS, (0x8000 | (which)), 0, &amp;eax,</span>
<span class="c">			  &amp;ebx, &amp;ecx, &amp;edx, &amp;esi))</span>
<span class="c">		return (eax &gt;&gt; 8) &amp; 0xff;</span>
<span class="c">	*status = ebx;</span>
<span class="c">	*bat = ecx;</span>
<span class="c">	*life = edx;</span>
<span class="c">	*nbat = esi;</span>
<span class="c">	return APM_SUCCESS;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_engage_power_management	-	enable PM on a device</span>
<span class="cm"> *	@device: identity of device</span>
<span class="cm"> *	@enable: on/off</span>
<span class="cm"> *</span>
<span class="cm"> *	Activate or deactive power management on either a specific device</span>
<span class="cm"> *	or the entire system (%APM_DEVICE_ALL).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_engage_power_management</span><span class="p">(</span><span class="n">u_short</span> <span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">APM_DEVICE_ALL</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_BIOS_DISABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">APM_DISABLED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_bios_call_simple</span><span class="p">(</span><span class="n">APM_FUNC_ENGAGE_PM</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">APM_DEVICE_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">APM_BIOS_DISENGAGED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">APM_BIOS_DISENGAGED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_APM_DISPLAY_BLANK) &amp;&amp; defined(CONFIG_VT)</span>

<span class="cm">/**</span>
<span class="cm"> *	apm_console_blank	-	blank the display</span>
<span class="cm"> *	@blank: on/off</span>
<span class="cm"> *</span>
<span class="cm"> *	Attempt to blank the console, firstly by blanking just video device</span>
<span class="cm"> *	zero, and if that fails (some BIOSes don&#39;t support it) then it blanks</span>
<span class="cm"> *	all video devices. Typically the BIOS will do laptop backlight and</span>
<span class="cm"> *	monitor powerdown for us.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm_console_blank</span><span class="p">(</span><span class="kt">int</span> <span class="n">blank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">APM_NOT_ENGAGED</span><span class="p">;</span> <span class="cm">/* silence gcc */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u_short</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u_short</span> <span class="n">dev</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mh">0x1FF</span><span class="p">,</span> <span class="mh">0x101</span> <span class="p">};</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">blank</span> <span class="o">?</span> <span class="n">APM_STATE_STANDBY</span> <span class="o">:</span> <span class="n">APM_STATE_READY</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">state</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">==</span> <span class="n">APM_SUCCESS</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">APM_NO_ERROR</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">APM_NOT_ENGAGED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">APM_NOT_ENGAGED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">tried</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">eng_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tried</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eng_error</span> <span class="o">=</span> <span class="n">apm_engage_power_management</span><span class="p">(</span><span class="n">APM_DEVICE_ALL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eng_error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;set display&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
				<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;engage interface&quot;</span><span class="p">,</span> <span class="n">eng_error</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="n">apm_console_blank</span><span class="p">(</span><span class="n">blank</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;set display&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span> <span class="o">==</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">apm_event_t</span> <span class="nf">get_queued_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span> <span class="o">&gt;=</span> <span class="n">APM_MAX_EVENTS</span><span class="p">)</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_event</span><span class="p">(</span><span class="n">apm_event_t</span> <span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">sender</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">as</span> <span class="o">=</span> <span class="n">user_list</span><span class="p">;</span> <span class="n">as</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">as</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">as</span> <span class="o">==</span> <span class="n">sender</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span> <span class="o">&gt;=</span> <span class="n">APM_MAX_EVENTS</span><span class="p">)</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span> <span class="o">==</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">notified</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">notified</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;apm: an event queue overflowed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span> <span class="o">&gt;=</span> <span class="n">APM_MAX_EVENTS</span><span class="p">)</span>
				<span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">suser</span> <span class="o">||</span> <span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">writer</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">APM_SYS_SUSPEND</span>:
		<span class="k">case</span> <span class="n">APM_USER_SUSPEND</span>:
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_pending</span><span class="o">++</span><span class="p">;</span>
			<span class="n">suspends_pending</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_SYS_STANDBY</span>:
		<span class="k">case</span> <span class="n">APM_USER_STANDBY</span>:
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_pending</span><span class="o">++</span><span class="p">;</span>
			<span class="n">standbys_pending</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_waitqueue</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reinit_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef INIT_TIMER_AFTER_SUSPEND</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i8253_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* set the clock to HZ */</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="mh">0x34</span><span class="p">,</span> <span class="n">PIT_MODE</span><span class="p">);</span>		<span class="cm">/* binary, mode 2, LSB/MSB, ch 0 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">LATCH</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">PIT_CH0</span><span class="p">);</span>	<span class="cm">/* LSB */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">LATCH</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">PIT_CH0</span><span class="p">);</span>	<span class="cm">/* MSB */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i8253_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">suspend</span><span class="p">(</span><span class="kt">int</span> <span class="n">vetoable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">apm_user</span>	<span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">dpm_suspend_start</span><span class="p">(</span><span class="n">PMSG_SUSPEND</span><span class="p">);</span>
	<span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_SUSPEND</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">syscore_suspend</span><span class="p">();</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">save_processor_state</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_SUSPEND</span><span class="p">);</span>
	<span class="n">ignore_normal_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">restore_processor_state</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">reinit_timer</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">APM_NO_ERROR</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">APM_SUCCESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">APM_SUCCESS</span><span class="p">)</span>
		<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;suspend&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">APM_SUCCESS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">syscore_resume</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">PMSG_RESUME</span><span class="p">);</span>
	<span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">PMSG_RESUME</span><span class="p">);</span>

	<span class="n">queue_event</span><span class="p">(</span><span class="n">APM_NORMAL_RESUME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">as</span> <span class="o">=</span> <span class="n">user_list</span><span class="p">;</span> <span class="n">as</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">as</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspend_wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspend_result</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_suspend_waitqueue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">standby</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_SUSPEND</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">syscore_suspend</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_STANDBY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">!=</span> <span class="n">APM_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">APM_NO_ERROR</span><span class="p">))</span>
		<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;standby&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">syscore_resume</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">PMSG_RESUME</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">apm_event_t</span> <span class="nf">get_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">apm_event_t</span> <span class="n">event</span> <span class="o">=</span> <span class="n">APM_NO_EVENTS</span><span class="p">;</span> <span class="cm">/* silence gcc */</span>
	<span class="n">apm_eventinfo_t</span>	<span class="n">info</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">int</span> <span class="n">notified</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t use the eventinfo */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">apm_get_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">APM_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="n">APM_NO_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">notified</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;get_event&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_events</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apm_event_t</span> <span class="n">event</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_resume</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ignore_bounce</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">event</span> <span class="o">=</span> <span class="n">get_event</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="n">NR_APM_EVENT_NAME</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;apm: received %s notify</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">apm_event_name</span><span class="p">[</span><span class="n">event</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;apm: received unknown &quot;</span>
				       <span class="s">&quot;event 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ignore_bounce</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">last_resume</span> <span class="o">+</span> <span class="n">bounce_interval</span><span class="p">)))</span>
			<span class="n">ignore_bounce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">APM_SYS_STANDBY</span>:
		<span class="k">case</span> <span class="n">APM_USER_STANDBY</span>:
			<span class="n">queue_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">standbys_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">standby</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_USER_SUSPEND</span>:
<span class="cp">#ifdef CONFIG_APM_IGNORE_USER_SUSPEND</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span>
				<span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_REJECT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">case</span> <span class="n">APM_SYS_SUSPEND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ignore_bounce</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span>
					<span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_REJECT</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are already processing a SUSPEND,</span>
<span class="cm">			 * then further SUSPEND events from the BIOS</span>
<span class="cm">			 * will be ignored.  We also return here to</span>
<span class="cm">			 * cope with the fact that the Thinkpads keep</span>
<span class="cm">			 * sending a SUSPEND event until something else</span>
<span class="cm">			 * happens!</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ignore_sys_suspend</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">ignore_sys_suspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">queue_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">suspends_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">suspend</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_NORMAL_RESUME</span>:
		<span class="k">case</span> <span class="n">APM_CRITICAL_RESUME</span>:
		<span class="k">case</span> <span class="n">APM_STANDBY_RESUME</span>:
			<span class="n">ignore_sys_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">last_resume</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">ignore_bounce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">event</span> <span class="o">!=</span> <span class="n">APM_NORMAL_RESUME</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">ignore_normal_resume</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">PMSG_RESUME</span><span class="p">);</span>
				<span class="n">queue_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ignore_normal_resume</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_CAPABILITY_CHANGE</span>:
		<span class="k">case</span> <span class="n">APM_LOW_BATTERY</span>:
		<span class="k">case</span> <span class="n">APM_POWER_STATUS_CHANGE</span>:
			<span class="n">queue_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="cm">/* If needed, notify drivers here */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_UPDATE_TIME</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_CRITICAL_SUSPEND</span>:
			<span class="cm">/*</span>
<span class="cm">			 * We are not allowed to reject a critical suspend.</span>
<span class="cm">			 */</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">suspend</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_event_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">pending_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">standbys_pending</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">suspends_pending</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pending_count</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pending_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;apm: setting state busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">set_system_power_state</span><span class="p">(</span><span class="n">APM_STATE_BUSY</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;busy&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pending_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">check_events</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the APM thread main loop.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">apm_mainloop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_waitqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">APM_CHECK_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok, check all events, check for idle (and mark us sleeping</span>
<span class="cm">		 * so as not to count towards the load average)..</span>
<span class="cm">		 */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">apm_event_handler</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_waitqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_apm_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">APM_BIOS_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;apm: %s passed bad filp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">apm_event_t</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_apm_user</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="s">&quot;read&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">apm_event_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">as</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">apm_waitqueue</span><span class="p">,</span> <span class="o">!</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">as</span><span class="p">));</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">as</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">get_queued_event</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">APM_SYS_SUSPEND</span>:
		<span class="k">case</span> <span class="n">APM_USER_SUSPEND</span>:
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_read</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">APM_SYS_STANDBY</span>:
		<span class="k">case</span> <span class="n">APM_USER_STANDBY</span>:
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_read</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">count</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">do_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_apm_user</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="s">&quot;poll&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">apm_waitqueue</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">as</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_apm_user</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="s">&quot;ioctl&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">suser</span> <span class="o">||</span> <span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">writer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">APM_IOC_STANDBY</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_read</span><span class="o">--</span><span class="p">;</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_pending</span><span class="o">--</span><span class="p">;</span>
			<span class="n">standbys_pending</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">queue_event</span><span class="p">(</span><span class="n">APM_USER_STANDBY</span><span class="p">,</span> <span class="n">as</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">standbys_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">standby</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">APM_IOC_SUSPEND</span>:
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_read</span><span class="o">--</span><span class="p">;</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_pending</span><span class="o">--</span><span class="p">;</span>
			<span class="n">suspends_pending</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">queue_event</span><span class="p">(</span><span class="n">APM_USER_SUSPEND</span><span class="p">,</span> <span class="n">as</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">suspends_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">suspend</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_mutex</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspend_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_mutex</span><span class="p">);</span>
			<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">apm_suspend_waitqueue</span><span class="p">,</span>
					<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspend_wait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">suspend_result</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_apm_user</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="s">&quot;release&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_pending</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">standbys_pending</span> <span class="o">-=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_pending</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">standbys_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">standby</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_pending</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">suspends_pending</span> <span class="o">-=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_pending</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">suspends_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">suspend</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_list</span> <span class="o">==</span> <span class="n">as</span><span class="p">)</span>
		<span class="n">user_list</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">as1</span> <span class="o">=</span> <span class="n">user_list</span><span class="p">;</span>
		     <span class="p">(</span><span class="n">as1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">as1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">as</span><span class="p">);</span>
		     <span class="n">as1</span> <span class="o">=</span> <span class="n">as1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">as1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;apm: filp not in user list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">as1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">as</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">apm_user</span> <span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">as</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;apm: cannot allocate struct of size %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">as</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">APM_BIOS_MAGIC</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">event_tail</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">event_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_pending</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">suspends_read</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">standbys_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX - this is a tiny bit broken, when we consider BSD</span>
<span class="cm">	 * process accounting. If the device is opened by root, we</span>
<span class="cm">	 * instantly flag that we used superuser privs. Who knows,</span>
<span class="cm">	 * we might close the device immediately without doing a</span>
<span class="cm">	 * privileged operation -- cevans</span>
<span class="cm">	 */</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">suser</span> <span class="o">=</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">writer</span> <span class="o">=</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">==</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">reader</span> <span class="o">=</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">==</span> <span class="n">FMODE_READ</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">user_list</span><span class="p">;</span>
	<span class="n">user_list</span> <span class="o">=</span> <span class="n">as</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_list_lock</span><span class="p">);</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">as</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_apm_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">bx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">cx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">dx</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">ac_line_status</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">battery_status</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">battery_flag</span>   <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">percentage</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">time_units</span>     <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span>            <span class="o">*</span><span class="n">units</span>         <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">apm_get_power_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dx</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ac_line_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">bx</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">battery_status</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="n">percentage</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">battery_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dx</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;min&quot;</span> <span class="o">:</span> <span class="s">&quot;sec&quot;</span><span class="p">;</span>
				<span class="n">time_units</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Arguments, with symbols from linux/apm_bios.h.  Information is</span>
<span class="cm">	   from the Get Power Status (0x0a) call unless otherwise noted.</span>

<span class="cm">	   0) Linux driver version (this will change if format changes)</span>
<span class="cm">	   1) APM BIOS Version.  Usually 1.0, 1.1 or 1.2.</span>
<span class="cm">	   2) APM flags from APM Installation Check (0x00):</span>
<span class="cm">	      bit 0: APM_16_BIT_SUPPORT</span>
<span class="cm">	      bit 1: APM_32_BIT_SUPPORT</span>
<span class="cm">	      bit 2: APM_IDLE_SLOWS_CLOCK</span>
<span class="cm">	      bit 3: APM_BIOS_DISABLED</span>
<span class="cm">	      bit 4: APM_BIOS_DISENGAGED</span>
<span class="cm">	   3) AC line status</span>
<span class="cm">	      0x00: Off-line</span>
<span class="cm">	      0x01: On-line</span>
<span class="cm">	      0x02: On backup power (BIOS &gt;= 1.1 only)</span>
<span class="cm">	      0xff: Unknown</span>
<span class="cm">	   4) Battery status</span>
<span class="cm">	      0x00: High</span>
<span class="cm">	      0x01: Low</span>
<span class="cm">	      0x02: Critical</span>
<span class="cm">	      0x03: Charging</span>
<span class="cm">	      0x04: Selected battery not present (BIOS &gt;= 1.2 only)</span>
<span class="cm">	      0xff: Unknown</span>
<span class="cm">	   5) Battery flag</span>
<span class="cm">	      bit 0: High</span>
<span class="cm">	      bit 1: Low</span>
<span class="cm">	      bit 2: Critical</span>
<span class="cm">	      bit 3: Charging</span>
<span class="cm">	      bit 7: No system battery</span>
<span class="cm">	      0xff: Unknown</span>
<span class="cm">	   6) Remaining battery life (percentage of charge):</span>
<span class="cm">	      0-100: valid</span>
<span class="cm">	      -1: Unknown</span>
<span class="cm">	   7) Remaining battery life (time units):</span>
<span class="cm">	      Number of remaining minutes or seconds</span>
<span class="cm">	      -1: Unknown</span>
<span class="cm">	   8) min = minutes; sec = seconds */</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %d.%d 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">driver_version</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
		   <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
		   <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span>
		   <span class="n">ac_line_status</span><span class="p">,</span>
		   <span class="n">battery_status</span><span class="p">,</span>
		   <span class="n">battery_flag</span><span class="p">,</span>
		   <span class="n">percentage</span><span class="p">,</span>
		   <span class="n">time_units</span><span class="p">,</span>
		   <span class="n">units</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_apm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_apm_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">apm_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_apm_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">apm</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">bx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">cx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">dx</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> 		<span class="o">*</span><span class="n">power_stat</span><span class="p">;</span>
	<span class="kt">char</span> 		<span class="o">*</span><span class="n">bat_stat</span><span class="p">;</span>

	<span class="cm">/* 2002/08/01 - WT</span>
<span class="cm">	 * This is to avoid random crashes at boot time during initialization</span>
<span class="cm">	 * on SMP systems in case of &quot;apm=power-off&quot; mode. Seen on ASUS A7M266D.</span>
<span class="cm">	 * Some bioses don&#39;t like being called from CPU != 0.</span>
<span class="cm">	 * Method suggested by Ingo Molnar.</span>
<span class="cm">	 */</span>
	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">=</span> <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We only support BIOSs up to version 1.2</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x0102</span><span class="p">)</span>
				<span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">=</span> <span class="mh">0x0102</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">apm_driver_version</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">APM_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;driver version&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
				<span class="cm">/* Fall back to an APM 1.0 connection. */</span>
				<span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apm: Connection version %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_APM_DO_ENABLE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_BIOS_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This call causes my NEC UltraLite Versa 33/C to hang if it</span>
<span class="cm">		 * is booted with PM disabled but not in the docking station.</span>
<span class="cm">		 * Unfortunate ...</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">apm_enable_power_management</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;enable power management&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_BIOS_DISENGAGED</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x0100</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">apm_engage_power_management</span><span class="p">(</span><span class="n">APM_DEVICE_ALL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;engage power management&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">smp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">apm_get_power_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apm: power status not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">((</span><span class="n">bx</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">power_stat</span> <span class="o">=</span> <span class="s">&quot;off line&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">power_stat</span> <span class="o">=</span> <span class="s">&quot;on line&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">power_stat</span> <span class="o">=</span> <span class="s">&quot;on backup power&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">power_stat</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">bx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">bat_stat</span> <span class="o">=</span> <span class="s">&quot;high&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">bat_stat</span> <span class="o">=</span> <span class="s">&quot;low&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">bat_stat</span> <span class="o">=</span> <span class="s">&quot;critical&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">bat_stat</span> <span class="o">=</span> <span class="s">&quot;charging&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">bat_stat</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;apm: AC %s, battery status %s, battery life &quot;</span><span class="p">,</span>
			       <span class="n">power_stat</span><span class="p">,</span> <span class="n">bat_stat</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cx</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;apm: battery flag 0x%02x, battery life &quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">cx</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dx</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">dx</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">?</span>
					       <span class="s">&quot;minutes&quot;</span> <span class="o">:</span> <span class="s">&quot;seconds&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Install our power off handler.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_off</span><span class="p">)</span>
		<span class="n">pm_power_off</span> <span class="o">=</span> <span class="n">apm_power_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">smp</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_APM_DISPLAY_BLANK) &amp;&amp; defined(CONFIG_VT)</span>
		<span class="n">console_blank_hook</span> <span class="o">=</span> <span class="n">apm_console_blank</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">apm_mainloop</span><span class="p">();</span>
<span class="cp">#if defined(CONFIG_APM_DISPLAY_BLANK) &amp;&amp; defined(CONFIG_VT)</span>
		<span class="n">console_blank_hook</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef MODULE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apm_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">invert</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">str</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">apm_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">apm_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;bounce-interval=&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;bounce_interval=&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">bounce_interval</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;idle-threshold=&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;idle_threshold=&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">idle_threshold</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;idle-period=&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;idle_period=&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">idle_period</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">invert</span> <span class="o">=</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;no-&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;no_&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">invert</span><span class="p">)</span>
			<span class="n">str</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">debug</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;power-off&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;power_off&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">power_off</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;smp&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
			<span class="n">idle_threshold</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;allow-ints&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;allow_ints&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">allow_ints</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;broken-psr&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;broken_psr&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_broken</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;realmode-power-off&quot;</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;realmode_power_off&quot;</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">realmode_power_off</span> <span class="o">=</span> <span class="o">!</span><span class="n">invert</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">str</span> <span class="o">+=</span> <span class="n">strspn</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;, </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;apm=&quot;</span><span class="p">,</span> <span class="n">apm_setup</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">apm_bios_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">do_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">do_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">do_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">do_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">do_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">apm_device</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">APM_MINOR_DEV</span><span class="p">,</span>
	<span class="s">&quot;apm_bios&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">apm_bios_fops</span>
<span class="p">};</span>


<span class="cm">/* Simple &quot;print if true&quot; callback */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">print_if_true</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some Bioses enable the PS/2 mouse (touchpad) at resume, even if it was</span>
<span class="cm"> * disabled before the suspend. Linux used to get terribly confused by that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">broken_ps2_resume</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s machine detected. Mousepad Resume Bug &quot;</span>
	       <span class="s">&quot;workaround hopefully not needed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some bioses have a broken protected mode poweroff and need to use realmode */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_realmode_power_off</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">realmode_power_off</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">realmode_power_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s bios detected. &quot;</span>
		       <span class="s">&quot;Using realmode poweroff only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some laptops require interrupts to be enabled during APM calls */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_apm_ints</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">allow_ints</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">allow_ints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s machine detected. &quot;</span>
		       <span class="s">&quot;Enabling interrupts during APM calls.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some APM bioses corrupt memory or just plain do not work */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apm_is_horked</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s machine detected. &quot;</span>
		       <span class="s">&quot;Disabling APM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apm_is_horked_d850md</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s machine detected. &quot;</span>
		       <span class="s">&quot;Disabling APM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;This bug is fixed in bios P15 which is available for</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;download from support.intel.com</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Some APM bioses hang on APM idle calls */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apm_likes_to_melt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">forbid_idle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">forbid_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s machine detected. &quot;</span>
		       <span class="s">&quot;Disabling APM idle calls.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Check for clue free BIOS implementations who use</span>
<span class="cm"> *  the following QA technique</span>
<span class="cm"> *</span>
<span class="cm"> *      [ Write BIOS Code ]&lt;------</span>
<span class="cm"> *               |                ^</span>
<span class="cm"> *      &lt; Does it Compile &gt;----N--</span>
<span class="cm"> *               |Y               ^</span>
<span class="cm"> *	&lt; Does it Boot Win98 &gt;-N--</span>
<span class="cm"> *               |Y</span>
<span class="cm"> *           [Ship It]</span>
<span class="cm"> *</span>
<span class="cm"> *	Phoenix A04  08/24/2000 is known bad (Dell Inspiron 5000e)</span>
<span class="cm"> *	Phoenix A07  09/29/2000 is known good (Dell Inspiron 5000)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">broken_apm_power</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_broken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;BIOS strings suggest APM bugs, &quot;</span>
	       <span class="s">&quot;disabling power status reporting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This bios swaps the APM minute reporting bytes over (Many sony laptops</span>
<span class="cm"> * have this problem).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">swab_apm_power_in_minutes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_swabinminutes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;BIOS strings suggest APM reports battery life &quot;</span>
	       <span class="s">&quot;in minutes and wrong byte order.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__initdata</span> <span class="n">apm_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="n">print_if_true</span><span class="p">,</span>
		<span class="n">KERN_WARNING</span> <span class="s">&quot;IBM T23 - BIOS 1.03b+ and controller firmware 1.02+ may be needed for Linux APM.&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;IBM&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;1AET38WW (1.01b)&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on the C600 */</span>
		<span class="n">broken_ps2_resume</span><span class="p">,</span> <span class="s">&quot;Dell Latitude C600&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Latitude C600&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Allow interrupts during suspend on Dell Latitude laptops*/</span>
		<span class="n">set_apm_ints</span><span class="p">,</span> <span class="s">&quot;Dell Latitude&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell Computer Corporation&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Latitude C510&quot;</span><span class="p">),</span> <span class="p">}</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Dell Inspiron 2500&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell Computer Corporation&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Inspiron 2500&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A11&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Allow interrupts during suspend on Dell Inspiron laptops*/</span>
		<span class="n">set_apm_ints</span><span class="p">,</span> <span class="s">&quot;Dell Inspiron&quot;</span><span class="p">,</span> <span class="p">{</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell Computer Corporation&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Inspiron 4000&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Inspiron 5000e */</span>
		<span class="n">broken_apm_power</span><span class="p">,</span> <span class="s">&quot;Dell Inspiron 5000e&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A04&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;08/24/2000&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Inspiron 2500 */</span>
		<span class="n">broken_apm_power</span><span class="p">,</span> <span class="s">&quot;Dell Inspiron 2500&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A12&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;02/04/2002&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Dell Dimension 4100&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell Computer Corporation&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;XPS-Z&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Intel Corp.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A11&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Allow interrupts during suspend on Compaq Laptops*/</span>
		<span class="n">set_apm_ints</span><span class="p">,</span> <span class="s">&quot;Compaq 12XL125&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Compaq&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Compaq PC&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;4.06&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Allow interrupts during APM or the clock goes slow */</span>
		<span class="n">set_apm_ints</span><span class="p">,</span> <span class="s">&quot;ASUSTeK&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;ASUSTeK Computer Inc.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;L8400K series Notebook PC&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM blows on shutdown */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;ABIT KX7-333[R]&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BOARD_VENDOR</span><span class="p">,</span> <span class="s">&quot;ABIT&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">,</span> <span class="s">&quot;VT8367-8233A (KX7-333[R])&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Trigem Delhi3&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;TriGem Computer, Inc&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Delhi3&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Fujitsu-Siemens&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;hoenix/FUJITSU SIEMENS&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;Version1.01&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked_d850md</span><span class="p">,</span> <span class="s">&quot;Intel D850MD&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Intel Corp.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;MV85010A.86A.0016.P07.0201251536&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Intel D810EMO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Intel Corp.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;MO81010A.86A.0008.P04.0004170800&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Dell XPS-Z&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Intel Corp.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A11&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;XPS-Z&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Sharp PC-PJ/AX&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;SHARP&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;PC-PJ/AX&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;SystemSoft&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;Version R2.08&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM crashes */</span>
		<span class="n">apm_is_horked</span><span class="p">,</span> <span class="s">&quot;Dell Inspiron 2500&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Dell Computer Corporation&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span> <span class="s">&quot;Inspiron 2500&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;A11&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM idle hangs */</span>
		<span class="n">apm_likes_to_melt</span><span class="p">,</span> <span class="s">&quot;Jabil AMD&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;American Megatrends Inc.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;0AASNP06&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* APM idle hangs */</span>
		<span class="n">apm_likes_to_melt</span><span class="p">,</span> <span class="s">&quot;AMI Bios&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;American Megatrends Inc.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;0AASNP05&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-N505X(DE) */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0206H&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;08/23/99&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-N505VX */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;W2K06H0&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;02/03/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-XG29 */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0117A0&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;04/25/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z600NE */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0121Z1&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;05/11/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z600NE */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;WME01Z1&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;08/11/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z600LEK(DE) */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0206Z3&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;12/25/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z505LS */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0203D0&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;05/12/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z505LS */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0203Z3&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;08/25/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-Z505LS (with updated BIOS) */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0209Z3&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;05/12/01&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-F104K */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0204K2&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;08/28/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>

	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-C1VN/C1VE */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0208P1&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;11/09/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-C1VE */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;R0204P1&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;09/12/00&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* Handle problems with APM on Sony Vaio PCG-C1VE */</span>
		<span class="n">swab_apm_power_in_minutes</span><span class="p">,</span> <span class="s">&quot;Sony VAIO&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;WXPO1Z3&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;10/26/01&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* broken PM poweroff bios */</span>
		<span class="n">set_realmode_power_off</span><span class="p">,</span> <span class="s">&quot;Award Software v4.60 PGMA&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Award Software International, Inc.&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span> <span class="s">&quot;4.60 PGMA&quot;</span><span class="p">),</span>
			<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_DATE</span><span class="p">,</span> <span class="s">&quot;134526184&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>

	<span class="cm">/* Generic per vendor APM settings  */</span>

	<span class="p">{</span>	<span class="cm">/* Allow interrupts during suspend on IBM laptops */</span>
		<span class="n">set_apm_ints</span><span class="p">,</span> <span class="s">&quot;IBM&quot;</span><span class="p">,</span>
		<span class="p">{</span>	<span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;IBM&quot;</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">},</span>

	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Just start the APM thread. We do NOT want to do APM BIOS</span>
<span class="cm"> * calls from anything but the APM thread, if for no other reason</span>
<span class="cm"> * than the fact that we don&#39;t trust the APM BIOS. This way,</span>
<span class="cm"> * most common APM BIOS problems that lead to protection errors</span>
<span class="cm"> * etc will have at least some level of being contained...</span>
<span class="cm"> *</span>
<span class="cm"> * In short, if something bad happens, at least we have a choice</span>
<span class="cm"> * of just killing the apm thread..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">apm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">desc_struct</span> <span class="o">*</span><span class="n">gdt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dmi_check_system</span><span class="p">(</span><span class="n">apm_dmi_table</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">paravirt_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="n">machine_is_olpc</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apm: BIOS not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">((</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span>
	       <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span>
	       <span class="n">driver_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_32_BIT_SUPPORT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apm: no 32 bit BIOS support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">allow_ints</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">allow_ints</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">broken_psr</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">get_power_status_broken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realmode_power_off</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">realmode_power_off</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* User can override, but default is to trust DMI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_disabled</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="n">apm_disabled</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fix for the Compaq Contura 3/25c which reports BIOS version 0.1</span>
<span class="cm">	 * but is reportedly a 1.0 BIOS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">==</span> <span class="mh">0x001</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>

	<span class="cm">/* BIOS &lt; 1.2 doesn&#39;t set cseg_16_len */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&lt;</span> <span class="mh">0x102</span><span class="p">)</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg_16_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 64k */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;apm: entry %x:%x cseg16 %x dseg %x&quot;</span><span class="p">,</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg</span><span class="p">,</span> <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
			<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg_16</span><span class="p">,</span> <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">dseg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="mh">0x100</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; cseg len %x, dseg len %x&quot;</span><span class="p">,</span>
				<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg_len</span><span class="p">,</span>
				<span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">dseg_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="mh">0x101</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; cseg16 len %x&quot;</span><span class="p">,</span> <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg_16_len</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: disabled on user request.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">power_off</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">smp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: disabled - APM is not SMP safe.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;apm: overridden by ACPI.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">apm_info</span><span class="p">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the long jump entry point to the APM BIOS, which is called</span>
<span class="cm">	 * from inline assembly.</span>
<span class="cm">	 */</span>
	<span class="n">apm_bios_entry</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">apm_bios_entry</span><span class="p">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">APM_CS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The APM 1.1 BIOS is supposed to provide limit information that it</span>
<span class="cm">	 * recognizes.  Many machines do this correctly, but many others do</span>
<span class="cm">	 * not restrict themselves to their claimed limit.  When this happens,</span>
<span class="cm">	 * they will cause a segmentation violation in the kernel at boot time.</span>
<span class="cm">	 * Most BIOS&#39;s, however, will respect a 64k limit, so we use that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note we only set APM segments on CPU zero, since we pin the APM</span>
<span class="cm">	 * code to that CPU.</span>
<span class="cm">	 */</span>
	<span class="n">gdt</span> <span class="o">=</span> <span class="n">get_cpu_gdt_table</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">set_desc_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdt</span><span class="p">[</span><span class="n">APM_CS</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">],</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
	<span class="n">set_desc_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdt</span><span class="p">[</span><span class="n">APM_CS_16</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">],</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">cseg_16</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
	<span class="n">set_desc_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdt</span><span class="p">[</span><span class="n">APM_DS</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">],</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">dseg</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>

	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;apm&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">apm_file_ops</span><span class="p">);</span>

	<span class="n">kapmd_task</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">apm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;kapmd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kapmd_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;apm: disabled - Unable to start kernel &quot;</span>
				<span class="s">&quot;thread.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kapmd_task</span><span class="p">);</span>
		<span class="n">kapmd_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;apm&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">kapmd_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">smp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
		       <span class="s">&quot;apm: disabled - APM is not SMP safe (power off active).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note we don&#39;t actually care if the misc_device cannot be registered.</span>
<span class="cm">	 * this driver can do its job without it, even if userspace can&#39;t</span>
<span class="cm">	 * control it.  just log the error</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_device</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;apm: Could not register misc device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">idle_period</span> <span class="o">=</span> <span class="p">(</span><span class="n">idle_period</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idle_threshold</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">original_pm_idle</span> <span class="o">=</span> <span class="n">pm_idle</span><span class="p">;</span>
		<span class="n">pm_idle</span>  <span class="o">=</span> <span class="n">apm_cpu_idle</span><span class="p">;</span>
		<span class="n">set_pm_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">apm_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_pm_idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_idle</span> <span class="o">=</span> <span class="n">original_pm_idle</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are about to unload the current idle thread pm callback</span>
<span class="cm">		 * (pm_idle), Wait for all processors to update cached/local</span>
<span class="cm">		 * copies of pm_idle before proceeding.</span>
<span class="cm">		 */</span>
		<span class="n">kick_all_cpus_sync</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">apm_info</span><span class="p">.</span><span class="n">bios</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">APM_BIOS_DISENGAGED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">apm_info</span><span class="p">.</span><span class="n">connection_version</span> <span class="o">&gt;</span> <span class="mh">0x0100</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">apm_engage_power_management</span><span class="p">(</span><span class="n">APM_DEVICE_ALL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">apm_error</span><span class="p">(</span><span class="s">&quot;disengage power management&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apm_device</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;apm&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_off</span><span class="p">)</span>
		<span class="n">pm_power_off</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kapmd_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">kapmd_task</span><span class="p">);</span>
		<span class="n">kapmd_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">apm_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">apm_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Stephen Rothwell&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Advanced Power Management&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Enable debug mode&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">power_off</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">power_off</span><span class="p">,</span> <span class="s">&quot;Enable power off&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">bounce_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">bounce_interval</span><span class="p">,</span>
		<span class="s">&quot;Set the number of ticks to ignore suspend bounces&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">allow_ints</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">allow_ints</span><span class="p">,</span> <span class="s">&quot;Allow interrupts during BIOS calls&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">broken_psr</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">broken_psr</span><span class="p">,</span> <span class="s">&quot;BIOS has a broken GetPowerStatus call&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">realmode_power_off</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">realmode_power_off</span><span class="p">,</span>
		<span class="s">&quot;Switch to real mode before powering off&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">idle_threshold</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">idle_threshold</span><span class="p">,</span>
	<span class="s">&quot;System idle percentage above which to make APM BIOS idle calls&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">idle_period</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">idle_period</span><span class="p">,</span>
	<span class="s">&quot;Period (in sec/100) over which to caculate the idle percentage&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span>
	<span class="s">&quot;Set this to enable APM use on an SMP platform. Use with caution on older systems&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_MISCDEV</span><span class="p">(</span><span class="n">APM_MINOR_DEV</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
