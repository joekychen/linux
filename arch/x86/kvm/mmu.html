<!DOCTYPE html>
<html><head><title>joekychen/linux » arch › x86 › kvm › mmu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mmu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel-based Virtual Machine driver for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * This module enables machines with Intel VT-x extensions to run virtual</span>
<span class="cm"> * machines without emulation or binary translation.</span>
<span class="cm"> *</span>
<span class="cm"> * MMU support</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Qumranet, Inc.</span>
<span class="cm"> * Copyright 2010 Red Hat, Inc. and/or its affiliates.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Yaniv Kamay  &lt;yaniv@qumranet.com&gt;</span>
<span class="cm"> *   Avi Kivity   &lt;avi@qumranet.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.  See</span>
<span class="cm"> * the COPYING file in the top-level directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;irq.h&quot;</span>
<span class="cp">#include &quot;mmu.h&quot;</span>
<span class="cp">#include &quot;x86.h&quot;</span>
<span class="cp">#include &quot;kvm_cache_regs.h&quot;</span>

<span class="cp">#include &lt;linux/kvm_host.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/cmpxchg.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/vmx.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * When setting this variable to true it enables Two-Dimensional-Paging</span>
<span class="cm"> * where the hardware walks 2 page tables:</span>
<span class="cm"> * 1. the guest-virtual to guest-physical</span>
<span class="cm"> * 2. while doing 1. it walks guest-physical to host-physical</span>
<span class="cm"> * If the hardware supports that we don&#39;t need to do shadow paging.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">tdp_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">AUDIT_PRE_PAGE_FAULT</span><span class="p">,</span>
	<span class="n">AUDIT_POST_PAGE_FAULT</span><span class="p">,</span>
	<span class="n">AUDIT_PRE_PTE_WRITE</span><span class="p">,</span>
	<span class="n">AUDIT_POST_PTE_WRITE</span><span class="p">,</span>
	<span class="n">AUDIT_PRE_SYNC</span><span class="p">,</span>
	<span class="n">AUDIT_POST_SYNC</span>
<span class="p">};</span>

<span class="cp">#undef MMU_DEBUG</span>

<span class="cp">#ifdef MMU_DEBUG</span>

<span class="cp">#define pgprintk(x...) do { if (dbg) printk(x); } while (0)</span>
<span class="cp">#define rmap_printk(x...) do { if (dbg) printk(x); } while (0)</span>

<span class="cp">#else</span>

<span class="cp">#define pgprintk(x...) do { } while (0)</span>
<span class="cp">#define rmap_printk(x...) do { } while (0)</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef MMU_DEBUG</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">dbg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">dbg</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef MMU_DEBUG</span>
<span class="cp">#define ASSERT(x) do { } while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define ASSERT(x)							\</span>
<span class="cp">	if (!(x)) {							\</span>
<span class="cp">		printk(KERN_WARNING &quot;assertion failed %s:%d: %s\n&quot;,	\</span>
<span class="cp">		       __FILE__, __LINE__, #x);				\</span>
<span class="cp">	}</span>
<span class="cp">#endif</span>

<span class="cp">#define PTE_PREFETCH_NUM		8</span>

<span class="cp">#define PT_FIRST_AVAIL_BITS_SHIFT 9</span>
<span class="cp">#define PT64_SECOND_AVAIL_BITS_SHIFT 52</span>

<span class="cp">#define PT64_LEVEL_BITS 9</span>

<span class="cp">#define PT64_LEVEL_SHIFT(level) \</span>
<span class="cp">		(PAGE_SHIFT + (level - 1) * PT64_LEVEL_BITS)</span>

<span class="cp">#define PT64_INDEX(address, level)\</span>
<span class="cp">	(((address) &gt;&gt; PT64_LEVEL_SHIFT(level)) &amp; ((1 &lt;&lt; PT64_LEVEL_BITS) - 1))</span>


<span class="cp">#define PT32_LEVEL_BITS 10</span>

<span class="cp">#define PT32_LEVEL_SHIFT(level) \</span>
<span class="cp">		(PAGE_SHIFT + (level - 1) * PT32_LEVEL_BITS)</span>

<span class="cp">#define PT32_LVL_OFFSET_MASK(level) \</span>
<span class="cp">	(PT32_BASE_ADDR_MASK &amp; ((1ULL &lt;&lt; (PAGE_SHIFT + (((level) - 1) \</span>
<span class="cp">						* PT32_LEVEL_BITS))) - 1))</span>

<span class="cp">#define PT32_INDEX(address, level)\</span>
<span class="cp">	(((address) &gt;&gt; PT32_LEVEL_SHIFT(level)) &amp; ((1 &lt;&lt; PT32_LEVEL_BITS) - 1))</span>


<span class="cp">#define PT64_BASE_ADDR_MASK (((1ULL &lt;&lt; 52) - 1) &amp; ~(u64)(PAGE_SIZE-1))</span>
<span class="cp">#define PT64_DIR_BASE_ADDR_MASK \</span>
<span class="cp">	(PT64_BASE_ADDR_MASK &amp; ~((1ULL &lt;&lt; (PAGE_SHIFT + PT64_LEVEL_BITS)) - 1))</span>
<span class="cp">#define PT64_LVL_ADDR_MASK(level) \</span>
<span class="cp">	(PT64_BASE_ADDR_MASK &amp; ~((1ULL &lt;&lt; (PAGE_SHIFT + (((level) - 1) \</span>
<span class="cp">						* PT64_LEVEL_BITS))) - 1))</span>
<span class="cp">#define PT64_LVL_OFFSET_MASK(level) \</span>
<span class="cp">	(PT64_BASE_ADDR_MASK &amp; ((1ULL &lt;&lt; (PAGE_SHIFT + (((level) - 1) \</span>
<span class="cp">						* PT64_LEVEL_BITS))) - 1))</span>

<span class="cp">#define PT32_BASE_ADDR_MASK PAGE_MASK</span>
<span class="cp">#define PT32_DIR_BASE_ADDR_MASK \</span>
<span class="cp">	(PAGE_MASK &amp; ~((1ULL &lt;&lt; (PAGE_SHIFT + PT32_LEVEL_BITS)) - 1))</span>
<span class="cp">#define PT32_LVL_ADDR_MASK(level) \</span>
<span class="cp">	(PAGE_MASK &amp; ~((1ULL &lt;&lt; (PAGE_SHIFT + (((level) - 1) \</span>
<span class="cp">					    * PT32_LEVEL_BITS))) - 1))</span>

<span class="cp">#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | PT_USER_MASK \</span>
<span class="cp">			| PT64_NX_MASK)</span>

<span class="cp">#define ACC_EXEC_MASK    1</span>
<span class="cp">#define ACC_WRITE_MASK   PT_WRITABLE_MASK</span>
<span class="cp">#define ACC_USER_MASK    PT_USER_MASK</span>
<span class="cp">#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)</span>

<span class="cp">#include &lt;trace/events/kvm.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;mmutrace.h&quot;</span>

<span class="cp">#define SPTE_HOST_WRITEABLE (1ULL &lt;&lt; PT_FIRST_AVAIL_BITS_SHIFT)</span>

<span class="cp">#define SHADOW_PT_INDEX(addr, level) PT64_INDEX(addr, level)</span>

<span class="cm">/* make pte_list_desc fit well in cache line */</span>
<span class="cp">#define PTE_LIST_EXT 3</span>

<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptes</span><span class="p">[</span><span class="n">PTE_LIST_EXT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">more</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">hpa_t</span> <span class="n">shadow_addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define for_each_shadow_entry(_vcpu, _addr, _walker)    \</span>
<span class="cp">	for (shadow_walk_init(&amp;(_walker), _vcpu, _addr);	\</span>
<span class="cp">	     shadow_walk_okay(&amp;(_walker));			\</span>
<span class="cp">	     shadow_walk_next(&amp;(_walker)))</span>

<span class="cp">#define for_each_shadow_entry_lockless(_vcpu, _addr, _walker, spte)	\</span>
<span class="cp">	for (shadow_walk_init(&amp;(_walker), _vcpu, _addr);		\</span>
<span class="cp">	     shadow_walk_okay(&amp;(_walker)) &amp;&amp;				\</span>
<span class="cp">		({ spte = mmu_spte_get_lockless(_walker.sptep); 1; });	\</span>
<span class="cp">	     __shadow_walk_next(&amp;(_walker), spte))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">pte_list_desc_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mmu_page_header_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">kvm_total_used_mmu_pages</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_nx_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_x_mask</span><span class="p">;</span>	<span class="cm">/* mutual exclusive with nx_mask */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_user_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_accessed_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_dirty_mask</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">__read_mostly</span> <span class="n">shadow_mmio_mask</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_set_mmio_spte_mask</span><span class="p">(</span><span class="n">u64</span> <span class="n">mmio_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shadow_mmio_mask</span> <span class="o">=</span> <span class="n">mmio_mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_set_mmio_spte_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_mmio_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">access</span> <span class="o">&amp;=</span> <span class="n">ACC_WRITE_MASK</span> <span class="o">|</span> <span class="n">ACC_USER_MASK</span><span class="p">;</span>

	<span class="n">trace_mark_mmio_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
	<span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">shadow_mmio_mask</span> <span class="o">|</span> <span class="n">access</span> <span class="o">|</span> <span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_mmio_spte</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="n">shadow_mmio_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">shadow_mmio_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gfn_t</span> <span class="nf">get_mmio_spte_gfn</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">shadow_mmio_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">get_mmio_spte_access</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">shadow_mmio_mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">set_mmio_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_noslot_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mark_mmio_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">rsvd_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_set_mask_ptes</span><span class="p">(</span><span class="n">u64</span> <span class="n">user_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">accessed_mask</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dirty_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nx_mask</span><span class="p">,</span> <span class="n">u64</span> <span class="n">x_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shadow_user_mask</span> <span class="o">=</span> <span class="n">user_mask</span><span class="p">;</span>
	<span class="n">shadow_accessed_mask</span> <span class="o">=</span> <span class="n">accessed_mask</span><span class="p">;</span>
	<span class="n">shadow_dirty_mask</span> <span class="o">=</span> <span class="n">dirty_mask</span><span class="p">;</span>
	<span class="n">shadow_nx_mask</span> <span class="o">=</span> <span class="n">nx_mask</span><span class="p">;</span>
	<span class="n">shadow_x_mask</span> <span class="o">=</span> <span class="n">x_mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_set_mask_ptes</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_cpuid_PSE36</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_nx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">efer</span> <span class="o">&amp;</span> <span class="n">EFER_NX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_shadow_present_pte</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_large_pte</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT_PAGE_SIZE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_dirty_gpte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT_DIRTY_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_rmap_spte</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_last_spte</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_large_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfn_t</span> <span class="nf">spte_to_pfn</span><span class="p">(</span><span class="n">u64</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gfn_t</span> <span class="nf">pse36_gfn_delta</span><span class="p">(</span><span class="n">u32</span> <span class="n">gpte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">PT32_DIR_PSE36_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">gpte</span> <span class="o">&amp;</span> <span class="n">PT32_DIR_PSE36_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86_64</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__update_clear_spte_fast</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">__update_clear_spte_slow</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xchg</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">__get_spte_lockless</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__check_direct_spte_mmio_pf</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* It is valid if the spte is zapped. */</span>
	<span class="k">return</span> <span class="n">spte</span> <span class="o">==</span> <span class="mi">0ull</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">union</span> <span class="n">split_spte</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">spte_low</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">spte_high</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">u64</span> <span class="n">spte</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">count_spte_clear</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span>  <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">sptep</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Ensure the spte is completely set before we increase the count */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">clear_spte_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="n">ssptep</span><span class="p">,</span> <span class="n">sspte</span><span class="p">;</span>

	<span class="n">ssptep</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="p">)</span><span class="n">sptep</span><span class="p">;</span>
	<span class="n">sspte</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span><span class="p">)</span><span class="n">spte</span><span class="p">;</span>

	<span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_high</span> <span class="o">=</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_high</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we map the spte from nonpresent to present, We should store</span>
<span class="cm">	 * the high bits firstly, then set present bit, so cpu can not</span>
<span class="cm">	 * fetch this spte while we are setting the spte.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_low</span> <span class="o">=</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_low</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__update_clear_spte_fast</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="n">ssptep</span><span class="p">,</span> <span class="n">sspte</span><span class="p">;</span>

	<span class="n">ssptep</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="p">)</span><span class="n">sptep</span><span class="p">;</span>
	<span class="n">sspte</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span><span class="p">)</span><span class="n">spte</span><span class="p">;</span>

	<span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_low</span> <span class="o">=</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_low</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we map the spte from present to nonpresent, we should clear</span>
<span class="cm">	 * present bit firstly to avoid vcpu fetch the old high bits.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_high</span> <span class="o">=</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_high</span><span class="p">;</span>
	<span class="n">count_spte_clear</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">__update_clear_spte_slow</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="n">ssptep</span><span class="p">,</span> <span class="n">sspte</span><span class="p">,</span> <span class="n">orig</span><span class="p">;</span>

	<span class="n">ssptep</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="p">)</span><span class="n">sptep</span><span class="p">;</span>
	<span class="n">sspte</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span><span class="p">)</span><span class="n">spte</span><span class="p">;</span>

	<span class="cm">/* xchg acts as a barrier before the setting of the high bits */</span>
	<span class="n">orig</span><span class="p">.</span><span class="n">spte_low</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_low</span><span class="p">,</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_low</span><span class="p">);</span>
	<span class="n">orig</span><span class="p">.</span><span class="n">spte_high</span> <span class="o">=</span> <span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_high</span><span class="p">;</span>
	<span class="n">ssptep</span><span class="o">-&gt;</span><span class="n">spte_high</span> <span class="o">=</span> <span class="n">sspte</span><span class="p">.</span><span class="n">spte_high</span><span class="p">;</span>
	<span class="n">count_spte_clear</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">orig</span><span class="p">.</span><span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The idea using the light way get the spte on x86_32 guest is from</span>
<span class="cm"> * gup_get_pte(arch/x86/mm/gup.c).</span>
<span class="cm"> * The difference is we can not catch the spte tlb flush if we leave</span>
<span class="cm"> * guest mode, so we emulate it by increase clear_spte_count when spte</span>
<span class="cm"> * is cleared.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">__get_spte_lockless</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span>  <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">sptep</span><span class="p">));</span>
	<span class="k">union</span> <span class="n">split_spte</span> <span class="n">spte</span><span class="p">,</span> <span class="o">*</span><span class="n">orig</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span> <span class="o">*</span><span class="p">)</span><span class="n">sptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">clear_spte_count</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="n">spte</span><span class="p">.</span><span class="n">spte_low</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">spte_low</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="n">spte</span><span class="p">.</span><span class="n">spte_high</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">spte_high</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">spte</span><span class="p">.</span><span class="n">spte_low</span> <span class="o">!=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">spte_low</span> <span class="o">||</span>
	      <span class="n">count</span> <span class="o">!=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">clear_spte_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">spte</span><span class="p">.</span><span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__check_direct_spte_mmio_pf</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">split_spte</span> <span class="n">sspte</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">split_spte</span><span class="p">)</span><span class="n">spte</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">high_mmio_mask</span> <span class="o">=</span> <span class="n">shadow_mmio_mask</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/* It is valid if the spte is zapped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spte</span> <span class="o">==</span> <span class="mi">0ull</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* It is valid if the spte is being zapped. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sspte</span><span class="p">.</span><span class="n">spte_low</span> <span class="o">==</span> <span class="mi">0ull</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sspte</span><span class="p">.</span><span class="n">spte_high</span> <span class="o">&amp;</span> <span class="n">high_mmio_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">high_mmio_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">spte_has_volatile_bits</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="n">shadow_accessed_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="o">!</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">spte</span> <span class="o">&amp;</span> <span class="n">shadow_dirty_mask</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">spte_is_bit_cleared</span><span class="p">(</span><span class="n">u64</span> <span class="n">old_spte</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bit_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old_spte</span> <span class="o">&amp;</span> <span class="n">bit_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">new_spte</span> <span class="o">&amp;</span> <span class="n">bit_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Rules for using mmu_spte_set:</span>
<span class="cm"> * Set the sptep from nonpresent to present.</span>
<span class="cm"> * Note: the sptep being assigned *must* be either not present</span>
<span class="cm"> * or in a state where the hardware will not attempt to update</span>
<span class="cm"> * the spte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_spte_set</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">));</span>
	<span class="n">__set_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Rules for using mmu_spte_update:</span>
<span class="cm"> * Update the state bits, it means the mapped pfn is not changged.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_spte_update</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">,</span> <span class="n">old_spte</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_rmap_spte</span><span class="p">(</span><span class="n">new_spte</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>

	<span class="n">new_spte</span> <span class="o">|=</span> <span class="n">old_spte</span> <span class="o">&amp;</span> <span class="n">shadow_dirty_mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">shadow_accessed_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">shadow_dirty_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spte_has_volatile_bits</span><span class="p">(</span><span class="n">old_spte</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">new_spte</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">__update_clear_spte_fast</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">old_spte</span> <span class="o">=</span> <span class="n">__update_clear_spte_slow</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spte_is_bit_cleared</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">shadow_accessed_mask</span><span class="p">))</span>
		<span class="n">kvm_set_pfn_accessed</span><span class="p">(</span><span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">old_spte</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spte_is_bit_cleared</span><span class="p">(</span><span class="n">old_spte</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">,</span> <span class="n">shadow_dirty_mask</span><span class="p">))</span>
		<span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">old_spte</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rules for using mmu_spte_clear_track_bits:</span>
<span class="cm"> * It sets the sptep from present to nonpresent, and track the</span>
<span class="cm"> * state bits, it is used to clear the last level sptep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_spte_clear_track_bits</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_spte</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spte_has_volatile_bits</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
		<span class="n">__update_clear_spte_fast</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">old_spte</span> <span class="o">=</span> <span class="n">__update_clear_spte_slow</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_rmap_spte</span><span class="p">(</span><span class="n">old_spte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pfn</span> <span class="o">=</span> <span class="n">spte_to_pfn</span><span class="p">(</span><span class="n">old_spte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span> <span class="o">||</span> <span class="n">old_spte</span> <span class="o">&amp;</span> <span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="n">kvm_set_pfn_accessed</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_dirty_mask</span> <span class="o">||</span> <span class="p">(</span><span class="n">old_spte</span> <span class="o">&amp;</span> <span class="n">shadow_dirty_mask</span><span class="p">))</span>
		<span class="n">kvm_set_pfn_dirty</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rules for using mmu_spte_clear_no_track:</span>
<span class="cm"> * Directly clear spte without caring the state bits of sptep,</span>
<span class="cm"> * it is used to set the upper level spte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_spte_clear_no_track</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__update_clear_spte_fast</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="mi">0ull</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">mmu_spte_get_lockless</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__get_spte_lockless</span><span class="p">(</span><span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">walk_shadow_page_lockless_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Prevent page table teardown by making any free-er wait during</span>
<span class="cm">	 * kvm_flush_remote_tlbs() IPI to all active vcpus.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">READING_SHADOW_PAGE_TABLES</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure a following spte read is not reordered ahead of the write</span>
<span class="cm">	 * to vcpu-&gt;mode.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">walk_shadow_page_lockless_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure the write to vcpu-&gt;mode is not reordered in front of</span>
<span class="cm">	 * reads to sptes.  If it does, kvm_commit_zap_page() can see us</span>
<span class="cm">	 * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">OUTSIDE_GUEST_MODE</span><span class="p">;</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_topup_memory_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">base_cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">base_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_memory_cache_free_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_free_memory_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="o">--</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_topup_memory_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_free_memory_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="o">--</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_topup_memory_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_pte_list_desc_cache</span><span class="p">,</span>
				   <span class="n">pte_list_desc_cache</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">PTE_PREFETCH_NUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_cache_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_cache</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_header_cache</span><span class="p">,</span>
				   <span class="n">mmu_page_header_cache</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_free_memory_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_free_memory_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_pte_list_desc_cache</span><span class="p">,</span>
				<span class="n">pte_list_desc_cache</span><span class="p">);</span>
	<span class="n">mmu_free_memory_cache_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_cache</span><span class="p">);</span>
	<span class="n">mmu_free_memory_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_header_cache</span><span class="p">,</span>
				<span class="n">mmu_page_header_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">mmu_memory_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="o">--</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">nobjs</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="nf">mmu_alloc_pte_list_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_pte_list_desc_cache</span><span class="p">,</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_free_pte_list_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">pte_list_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pte_list_desc_cache</span><span class="p">,</span> <span class="n">pte_list_desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gfn_t</span> <span class="nf">kvm_mmu_page_get_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfns</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PT64_LEVEL_BITS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_page_set_gfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gfn</span> <span class="o">!=</span> <span class="n">kvm_mmu_page_get_gfn</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfns</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the pointer to the large page information for a given gfn,</span>
<span class="cm"> * handling slots that are not large page aligned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="nf">lpage_info_slot</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">gfn_to_index</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">lpage_info</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">2</span><span class="p">][</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">account_shadowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">linfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">+</span> <span class="n">KVM_NR_PAGE_SIZES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">linfo</span> <span class="o">=</span> <span class="n">lpage_info_slot</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">linfo</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">indirect_shadow_pages</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unaccount_shadowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">linfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">+</span> <span class="n">KVM_NR_PAGE_SIZES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">linfo</span> <span class="o">=</span> <span class="n">lpage_info_slot</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">linfo</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">linfo</span><span class="o">-&gt;</span><span class="n">write_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">indirect_shadow_pages</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">has_wrprotected_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">linfo</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">linfo</span> <span class="o">=</span> <span class="n">lpage_info_slot</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">linfo</span><span class="o">-&gt;</span><span class="n">write_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">host_mapping_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page_size</span> <span class="o">=</span> <span class="n">kvm_host_page_size</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">+</span> <span class="n">KVM_NR_PAGE_SIZES</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_size</span> <span class="o">&gt;=</span> <span class="n">KVM_HPAGE_SIZE</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span>
<span class="nf">gfn_to_memslot_dirty_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">no_dirty_log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span> <span class="o">||</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KVM_MEMSLOT_INVALID</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">no_dirty_log</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">dirty_bitmap</span><span class="p">))</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mapping_level_dirty_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">large_gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">gfn_to_memslot_dirty_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">large_gfn</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mapping_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">large_gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">host_level</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">;</span>

	<span class="n">host_level</span> <span class="o">=</span> <span class="n">host_mapping_level</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">large_gfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">host_level</span><span class="p">;</span>

	<span class="n">max_level</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_lpage_level</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">host_level</span> <span class="o">?</span>
		<span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_lpage_level</span><span class="p">()</span> <span class="o">:</span> <span class="n">host_level</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">max_level</span><span class="p">;</span> <span class="o">++</span><span class="n">level</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_wrprotected_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">large_gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pte mapping structures:</span>
<span class="cm"> *</span>
<span class="cm"> * If pte_list bit zero is zero, then pte_list point to the spte.</span>
<span class="cm"> *</span>
<span class="cm"> * If pte_list bit zero is one, (then pte_list &amp; ~1) points to a struct</span>
<span class="cm"> * pte_list_desc containing more mappings.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of pte entries before the spte was added or zero if</span>
<span class="cm"> * the spte was not added.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pte_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pte_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;pte_list_add: %p %llx 0-&gt;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="o">*</span><span class="n">spte</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pte_list</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">spte</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;pte_list_add: %p %llx 1-&gt;many</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="o">*</span><span class="n">spte</span><span class="p">);</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">mmu_alloc_pte_list_desc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">pte_list</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pte_list</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">desc</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;pte_list_add: %p %llx many-&gt;many</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="o">*</span><span class="n">spte</span><span class="p">);</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1ul</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">PTE_LIST_EXT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">PTE_LIST_EXT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">PTE_LIST_EXT</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span> <span class="o">=</span> <span class="n">mmu_alloc_pte_list_desc</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pte_list_desc_remove_entry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">prev_desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">PTE_LIST_EXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_desc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pte_list</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_desc</span><span class="p">)</span>
			<span class="n">prev_desc</span><span class="o">-&gt;</span><span class="n">more</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">pte_list</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mmu_free_pte_list_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pte_list_remove</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">prev_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pte_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pte_list_remove: %p 0-&gt;BUG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;pte_list_remove:  %p 1-&gt;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">!=</span> <span class="n">spte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;pte_list_remove:  %p 1-&gt;BUG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">pte_list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;pte_list_remove:  %p many-&gt;many</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1ul</span><span class="p">);</span>
		<span class="n">prev_desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTE_LIST_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">spte</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pte_list_desc_remove_entry</span><span class="p">(</span><span class="n">pte_list</span><span class="p">,</span>
							       <span class="n">desc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
							       <span class="n">prev_desc</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="n">prev_desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;pte_list_remove: %p many-&gt;many</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_list_walk_fn</span><span class="p">)</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pte_list_walk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pte_list</span><span class="p">,</span> <span class="n">pte_list_walk_fn</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pte_list</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fn</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">pte_list</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">pte_list</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1ul</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTE_LIST_EXT</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">fn</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">__gfn_to_rmap</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">linfo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">gfn</span> <span class="o">-</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">base_gfn</span><span class="p">];</span>

	<span class="n">linfo</span> <span class="o">=</span> <span class="n">lpage_info_slot</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">linfo</span><span class="o">-&gt;</span><span class="n">rmap_pde</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take gfn and return the reverse mapping to it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">gfn_to_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__gfn_to_rmap</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">rmap_can_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_memory_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_pte_list_desc_cache</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mmu_memory_cache_free_objects</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rmap_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">spte</span><span class="p">));</span>
	<span class="n">kvm_mmu_page_set_gfn</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">spte</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="n">rmapp</span> <span class="o">=</span> <span class="n">gfn_to_rmap</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte_list_add</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rmap_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">spte</span><span class="p">));</span>
	<span class="n">gfn</span> <span class="o">=</span> <span class="n">kvm_mmu_page_get_gfn</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">spte</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
	<span class="n">rmapp</span> <span class="o">=</span> <span class="n">gfn_to_rmap</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
	<span class="n">pte_list_remove</span><span class="p">(</span><span class="n">spte</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used by the following functions to iterate through the sptes linked by a</span>
<span class="cm"> * rmap.  All fields are private and not assumed to be used outside.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="p">{</span>
	<span class="cm">/* private fields */</span>
	<span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>	<span class="cm">/* holds the sptep if not NULL */</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>			<span class="cm">/* index of the sptep */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Iteration must be started by this function.  This should also be used after</span>
<span class="cm"> * removing/dropping sptes from the rmap link because in such cases the</span>
<span class="cm"> * information in the itererator may not be valid.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sptep if found, NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="o">*</span><span class="nf">rmap_get_first</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rmap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rmap</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">rmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span> <span class="o">*</span><span class="p">)(</span><span class="n">rmap</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1ul</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be used with a valid iterator: e.g. after rmap_get_first().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sptep if found, NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="o">*</span><span class="nf">rmap_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">PTE_LIST_EXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>

			<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sptep</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">sptep</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">more</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* desc-&gt;sptes[0] cannot be NULL */</span>
			<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">sptes</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_spte_clear_track_bits</span><span class="p">(</span><span class="n">sptep</span><span class="p">))</span>
		<span class="n">rmap_remove</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__rmap_write_protect</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_protected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span> <span class="n">sptep</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span><span class="p">));</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;rmap_write_protect: spte %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mmu_spte_update</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PT_WRITABLE_MASK</span><span class="p">);</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">));</span>
			<span class="n">drop_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
			<span class="o">--</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">lpages</span><span class="p">;</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">write_protected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">write_protected</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kvm_mmu_write_protect_pt_masked - write protect selected PT level pages</span>
<span class="cm"> * @kvm: kvm instance</span>
<span class="cm"> * @slot: slot to protect</span>
<span class="cm"> * @gfn_offset: start of the BITS_PER_LONG pages we care about</span>
<span class="cm"> * @mask: indicates which pages we should protect</span>
<span class="cm"> *</span>
<span class="cm"> * Used when we do not need to care about huge page mappings: e.g. during dirty</span>
<span class="cm"> * logging we do not have any such mappings.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kvm_mmu_write_protect_pt_masked</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span>
				     <span class="n">gfn_t</span> <span class="n">gfn_offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">gfn_offset</span> <span class="o">+</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">mask</span><span class="p">)];</span>
		<span class="n">__rmap_write_protect</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">,</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">);</span>

		<span class="cm">/* clear the first set bit */</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rmap_write_protect</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_protected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">+</span> <span class="n">KVM_NR_PAGE_SIZES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmapp</span> <span class="o">=</span> <span class="n">__gfn_to_rmap</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">write_protected</span> <span class="o">|=</span> <span class="n">__rmap_write_protect</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">write_protected</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_unmap_rmapp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_tlb_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span><span class="p">));</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;kvm_rmap_unmap_hva: spte %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span><span class="p">);</span>

		<span class="n">drop_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
		<span class="n">need_tlb_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">need_tlb_flush</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_set_pte_rmapp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_spte</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">pfn_t</span> <span class="n">new_pfn</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pte_huge</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
	<span class="n">new_pfn</span> <span class="o">=</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span> <span class="n">sptep</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">));</span>
		<span class="n">rmap_printk</span><span class="p">(</span><span class="s">&quot;kvm_set_pte_rmapp: spte %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span><span class="p">);</span>

		<span class="n">need_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pte_write</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">drop_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new_spte</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PT64_BASE_ADDR_MASK</span><span class="p">;</span>
			<span class="n">new_spte</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">new_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

			<span class="n">new_spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PT_WRITABLE_MASK</span><span class="p">;</span>
			<span class="n">new_spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SPTE_HOST_WRITEABLE</span><span class="p">;</span>
			<span class="n">new_spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">shadow_accessed_mask</span><span class="p">;</span>

			<span class="n">mmu_spte_clear_track_bits</span><span class="p">(</span><span class="n">sptep</span><span class="p">);</span>
			<span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">new_spte</span><span class="p">);</span>
			<span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_flush</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_handle_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">kvm_for_each_memslot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">userspace_addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hva</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">hva</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gfn_t</span> <span class="n">gfn_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">hva</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">base_gfn</span> <span class="o">+</span> <span class="n">gfn_offset</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memslot</span><span class="o">-&gt;</span><span class="n">rmap</span><span class="p">[</span><span class="n">gfn_offset</span><span class="p">],</span> <span class="n">data</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">KVM_NR_PAGE_SIZES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">kvm_lpage_info</span> <span class="o">*</span><span class="n">linfo</span><span class="p">;</span>

				<span class="n">linfo</span> <span class="o">=</span> <span class="n">lpage_info_slot</span><span class="p">(</span><span class="n">gfn</span><span class="p">,</span> <span class="n">memslot</span><span class="p">,</span>
							<span class="n">PT_DIRECTORY_LEVEL</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">|=</span> <span class="n">handler</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">linfo</span><span class="o">-&gt;</span><span class="n">rmap_pde</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">trace_kvm_age_page</span><span class="p">(</span><span class="n">hva</span><span class="p">,</span> <span class="n">memslot</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">|=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_unmap_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_handle_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">hva</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kvm_unmap_rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_set_spte_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_handle_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">hva</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pte</span><span class="p">,</span> <span class="n">kvm_set_pte_rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_age_rmapp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">young</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Emulate the accessed bit for EPT, by checking if this page has</span>
<span class="cm">	 * an EPT mapping, and clearing it if it does. On the next access,</span>
<span class="cm">	 * a new EPT mapping will be established.</span>
<span class="cm">	 * This has some overhead, but not as much as the cost of swapping</span>
<span class="cm">	 * out actively used pages or breaking up actively used hugepages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kvm_unmap_rmapp</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span> <span class="n">sptep</span><span class="p">;</span>
	     <span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_ACCESSED_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">young</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">PT_ACCESSED_SHIFT</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">sptep</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">young</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_test_age_rmapp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">young</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there&#39;s no access bit in the secondary pte set by the</span>
<span class="cm">	 * hardware it&#39;s up to gup-fast/gup to set the access bit in</span>
<span class="cm">	 * the primary pte or in the page structure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="o">*</span><span class="n">rmapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span> <span class="n">sptep</span><span class="p">;</span>
	     <span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_ACCESSED_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">young</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">young</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RMAP_RECYCLE_THRESHOLD 1000</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rmap_recycle</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rmapp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">spte</span><span class="p">));</span>

	<span class="n">rmapp</span> <span class="o">=</span> <span class="n">gfn_to_rmap</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>

	<span class="n">kvm_unmap_rmapp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">rmapp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_age_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_handle_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">hva</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kvm_age_rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_test_age_hva</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_handle_hva</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">hva</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kvm_test_age_rmapp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef MMU_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_empty_shadow_page</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">spt</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			       <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This value is the sum of all of the kvm instances&#39;s</span>
<span class="cm"> * kvm-&gt;arch.n_used_mmu_pages values.  We need a global,</span>
<span class="cm"> * aggregate version in order to make the slab shrinker</span>
<span class="cm"> * faster</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_mod_used_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_used_mmu_pages</span> <span class="o">+=</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_total_used_mmu_pages</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the sp from shadow page cache, after call it,</span>
<span class="cm"> * we can not find this sp from the cache, and the shadow</span>
<span class="cm"> * page table is still valid.</span>
<span class="cm"> * It should be under the protection of mmu lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_isolate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">is_empty_shadow_page</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">));</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">hash_link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the shadow page table and the sp, we can do it</span>
<span class="cm"> * out of the protection of mmu lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_free_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mmu_page_header_cache</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">kvm_page_table_hashfn</span><span class="p">(</span><span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gfn</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">KVM_MMU_HASH_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_page_add_parent_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_pte</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pte_list_add</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">parent_ptes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_page_remove_parent_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_list_remove</span><span class="p">(</span><span class="n">parent_pte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">parent_ptes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_parent_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_page_remove_parent_pte</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">);</span>
	<span class="n">mmu_spte_clear_no_track</span><span class="p">(</span><span class="n">parent_pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="nf">kvm_mmu_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_header_cache</span><span class="p">,</span>
					<span class="k">sizeof</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">=</span> <span class="n">mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_cache</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">direct</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfns</span> <span class="o">=</span> <span class="n">mmu_memory_cache_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_cache</span><span class="p">,</span>
						  <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">);</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot_bitmap</span><span class="p">,</span> <span class="n">KVM_MEM_SLOTS_NUM</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">parent_ptes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mmu_page_add_parent_pte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">);</span>
	<span class="n">kvm_mod_used_mmu_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mark_unsync</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_mark_parents_unsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_list_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">parent_ptes</span><span class="p">,</span> <span class="n">mark_unsync</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_unsync</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">spte</span><span class="p">));</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">spte</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_child_bitmap</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="o">++</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kvm_mmu_mark_parents_unsync</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nonpaging_sync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nonpaging_invlpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nonpaging_update_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define KVM_PAGE_ARRAY_NR 16</span>

<span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmu_page_and_offset</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">page</span><span class="p">[</span><span class="n">KVM_PAGE_ARRAY_NR</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_pages_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="o">*</span><span class="n">pvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sp</span> <span class="o">==</span> <span class="n">sp</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">].</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">].</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="n">KVM_PAGE_ARRAY_NR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mmu_unsync_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="o">*</span><span class="n">pvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nr_unsync_leaf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_child_bitmap</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ent</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_large_pte</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">clear_child_bitmap</span><span class="p">;</span>

		<span class="n">child</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">ent</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mmu_pages_add</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">__mmu_unsync_walk</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">pvec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">clear_child_bitmap</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">nr_unsync_leaf</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr_unsync_leaf</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mmu_pages_add</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			 <span class="k">goto</span> <span class="n">clear_child_bitmap</span><span class="p">;</span>

		<span class="k">continue</span><span class="p">;</span>

<span class="nl">clear_child_bitmap:</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_child_bitmap</span><span class="p">);</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="o">--</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="n">nr_unsync_leaf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_unsync_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="o">*</span><span class="n">pvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mmu_pages_add</span><span class="p">(</span><span class="n">pvec</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__mmu_unsync_walk</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">pvec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_unlink_unsync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">);</span>
	<span class="n">trace_kvm_mmu_sync_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">--</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_unsync</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">);</span>

<span class="cp">#define for_each_gfn_sp(kvm, sp, gfn, pos)				\</span>
<span class="cp">  hlist_for_each_entry(sp, pos,						\</span>
<span class="cp">   &amp;(kvm)-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)], hash_link)	\</span>
<span class="cp">	if ((sp)-&gt;gfn != (gfn)) {} else</span>

<span class="cp">#define for_each_gfn_indirect_valid_sp(kvm, sp, gfn, pos)		\</span>
<span class="cp">  hlist_for_each_entry(sp, pos,						\</span>
<span class="cp">   &amp;(kvm)-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)], hash_link)	\</span>
<span class="cp">		if ((sp)-&gt;gfn != (gfn) || (sp)-&gt;role.direct ||		\</span>
<span class="cp">			(sp)-&gt;role.invalid) {} else</span>

<span class="cm">/* @sp-&gt;gfn should be write-protected at the call site */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__kvm_sync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">,</span> <span class="n">bool</span> <span class="n">clear_unsync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">!=</span> <span class="o">!!</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_unsync</span><span class="p">)</span>
		<span class="n">kvm_unlink_unsync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">sync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_sync_page_transient</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__kvm_sync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KVM_MMU_AUDIT</span>
<span class="cp">#include &quot;mmu_audit.c&quot;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_audit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">point</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_audit_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_sync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__kvm_sync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* @gfn should be write-protected at the call site */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_sync_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>  <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">flush</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">for_each_gfn_indirect_valid_sp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">);</span>
		<span class="n">kvm_unlink_unsync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">!=</span> <span class="o">!!</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">sync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
		<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="n">PT64_ROOT_LEVEL</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">[</span><span class="n">PT64_ROOT_LEVEL</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define for_each_sp(pvec, sp, parents, i)			\</span>
<span class="cp">		for (i = mmu_pages_next(&amp;pvec, &amp;parents, -1),	\</span>
<span class="cp">			sp = pvec.page[i].sp;			\</span>
<span class="cp">			i &lt; pvec.nr &amp;&amp; ({ sp = pvec.page[i].sp; 1;});	\</span>
<span class="cp">			i = mmu_pages_next(&amp;pvec, &amp;parents, i))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_pages_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="o">*</span><span class="n">pvec</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">sp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parents</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">idx</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">parents</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
		<span class="n">parents</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvec</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_pages_clear_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="o">*</span><span class="n">parents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">parents</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

		<span class="n">sp</span> <span class="o">=</span> <span class="n">parents</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="o">--</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_child_bitmap</span><span class="p">);</span>
		<span class="n">level</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">PT64_ROOT_LEVEL</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_pages_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="o">*</span><span class="n">pvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parents</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pvec</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_sync_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="n">parents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>

	<span class="n">kvm_mmu_pages_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mmu_unsync_walk</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">protected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_sp</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">protected</span> <span class="o">|=</span> <span class="n">rmap_write_protect</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">protected</span><span class="p">)</span>
			<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>

		<span class="n">for_each_sp</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_sync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
			<span class="n">mmu_pages_clear_parents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parents</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">kvm_mmu_pages_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_shadow_page_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT64_ENT_PER_PAGE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_sp_write_flooding_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">write_flooding_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_sp_write_flooding_count</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span>  <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">spte</span><span class="p">));</span>

	<span class="n">__clear_sp_write_flooding_count</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="nf">kvm_mmu_get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					     <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
					     <span class="n">gva_t</span> <span class="n">gaddr</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="n">level</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="n">access</span><span class="p">,</span>
					     <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">quadrant</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_sync</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">role</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">;</span>
	<span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">role</span><span class="p">.</span><span class="n">direct</span> <span class="o">=</span> <span class="n">direct</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">)</span>
		<span class="n">role</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">role</span><span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">access</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span>
	    <span class="o">&amp;&amp;</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">&lt;=</span> <span class="n">PT32_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quadrant</span> <span class="o">=</span> <span class="n">gaddr</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="p">(</span><span class="n">PT64_PT_BITS</span> <span class="o">*</span> <span class="n">level</span><span class="p">));</span>
		<span class="n">quadrant</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">PT32_PT_BITS</span> <span class="o">-</span> <span class="n">PT64_PT_BITS</span><span class="p">)</span> <span class="o">*</span> <span class="n">level</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">role</span><span class="p">.</span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">quadrant</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">for_each_gfn_sp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_sync</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
			<span class="n">need_sync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">!=</span> <span class="n">role</span><span class="p">.</span><span class="n">word</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span> <span class="o">&amp;&amp;</span> <span class="n">kvm_sync_page_transient</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">mmu_page_add_parent_pte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync_children</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_MMU_SYNC</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="n">kvm_mmu_mark_parents_unsync</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
			<span class="n">kvm_mmu_mark_parents_unsync</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

		<span class="n">__clear_sp_write_flooding_count</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="n">trace_kvm_mmu_get_page</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_cache_miss</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_alloc_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">,</span> <span class="n">direct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span> <span class="o">=</span> <span class="n">role</span><span class="p">;</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">hash_link</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu_page_hash</span><span class="p">[</span><span class="n">kvm_page_table_hashfn</span><span class="p">(</span><span class="n">gfn</span><span class="p">)]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">direct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmap_write_protect</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">))</span>
			<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">&amp;&amp;</span> <span class="n">need_sync</span><span class="p">)</span>
			<span class="n">kvm_sync_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

		<span class="n">account_shadowed</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">init_shadow_page_table</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="n">trace_kvm_mmu_get_page</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shadow_walk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">;</span>
	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">&lt;</span> <span class="n">PT64_ROOT_LEVEL</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span>
		<span class="o">--</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span>
			<span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
		<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span> <span class="o">&amp;=</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">;</span>
		<span class="o">--</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span><span class="p">)</span>
			<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">shadow_walk_okay</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">SHADOW_PT_INDEX</span><span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">sptep</span>	<span class="o">=</span> <span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span><span class="p">))</span> <span class="o">+</span> <span class="n">iterator</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__shadow_walk_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_last_spte</span><span class="p">(</span><span class="n">spte</span><span class="p">,</span> <span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iterator</span><span class="o">-&gt;</span><span class="n">shadow_addr</span> <span class="o">=</span> <span class="n">spte</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">;</span>
	<span class="o">--</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shadow_walk_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="o">*</span><span class="n">iterator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__shadow_walk_next</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="o">*</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_shadow_page</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">spte</span><span class="p">;</span>

	<span class="n">spte</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">PT_PRESENT_MASK</span> <span class="o">|</span> <span class="n">PT_ACCESSED_MASK</span>
		<span class="o">|</span> <span class="n">PT_WRITABLE_MASK</span> <span class="o">|</span> <span class="n">PT_USER_MASK</span><span class="p">;</span>
	<span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_large_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">drop_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
		<span class="o">--</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">lpages</span><span class="p">;</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">validate_direct_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="n">direct_access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For the direct sp, if the guest pte&#39;s dirty bit</span>
<span class="cm">		 * changed form clean to dirty, it will corrupt the</span>
<span class="cm">		 * sp&#39;s access: allow writable in the read-only sp,</span>
<span class="cm">		 * so we should update the spte at this point to get</span>
<span class="cm">		 * a new sp with the correct access.</span>
<span class="cm">		 */</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">access</span> <span class="o">==</span> <span class="n">direct_access</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">drop_parent_pte</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mmu_page_zap_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">spte</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last_spte</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">drop_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_large_pte</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
				<span class="o">--</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">lpages</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">);</span>
			<span class="n">drop_parent_pte</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="n">mmu_spte_clear_no_track</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_page_unlink_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT64_ENT_PER_PAGE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">mmu_page_zap_pte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_put_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">parent_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_page_remove_parent_pte</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">parent_pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_unlink_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_iterator</span> <span class="n">iter</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">sptep</span> <span class="o">=</span> <span class="n">rmap_get_first</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">parent_ptes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span>
		<span class="n">drop_parent_pte</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_zap_unsync_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">zapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_page_path</span> <span class="n">parents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_pages</span> <span class="n">pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kvm_mmu_pages_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mmu_unsync_walk</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

		<span class="n">for_each_sp</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
			<span class="n">mmu_pages_clear_parents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parents</span><span class="p">);</span>
			<span class="n">zapped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kvm_mmu_pages_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">zapped</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trace_kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="o">++</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_shadow_zapped</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mmu_zap_unsync_children</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">kvm_mmu_page_unlink_children</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="n">kvm_mmu_unlink_parents</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">invalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">)</span>
		<span class="n">unaccount_shadowed</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
		<span class="n">kvm_unlink_unsync_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Count self */</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
		<span class="n">kvm_mod_used_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">);</span>
		<span class="n">kvm_reload_remote_mmus</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">invalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * wmb: make sure everyone sees our modifications to the page tables</span>
<span class="cm">	 * rmb: make sure we see changes to vcpu-&gt;mode</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for all vcpus to exit guest mode and/or lockless shadow</span>
<span class="cm">	 * page table walks.</span>
<span class="cm">	 */</span>
	<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">invalid</span> <span class="o">||</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">);</span>
		<span class="n">kvm_mmu_isolate_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
		<span class="n">kvm_mmu_free_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Changing the number of mmu pages allocated to the vm</span>
<span class="cm"> * Note: if goal_nr_mmu_pages is too small, you will get dead lock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kvm_mmu_change_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">goal_nr_mmu_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we set the number of mmu pages to be smaller be than the</span>
<span class="cm">	 * number of actived pages , we must to free some mmu pages before we</span>
<span class="cm">	 * change the value</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_used_mmu_pages</span> <span class="o">&gt;</span> <span class="n">goal_nr_mmu_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_used_mmu_pages</span> <span class="o">&gt;</span> <span class="n">goal_nr_mmu_pages</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

			<span class="n">page</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">kvm_mmu_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
			<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="n">goal_nr_mmu_pages</span> <span class="o">=</span> <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_used_mmu_pages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_max_mmu_pages</span> <span class="o">=</span> <span class="n">goal_nr_mmu_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_unprotect_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: looking for gfn %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">for_each_gfn_indirect_valid_sp</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: gfn %llx role %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
			 <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_unprotect_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">page_header_update_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">memslot_id</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot_bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The function is based on mtrr_type_lookup() in</span>
<span class="cm"> * arch/x86/kernel/cpu/mtrr/generic.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_mtrr_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtrr_state_type</span> <span class="o">*</span><span class="n">mtrr_state</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_match</span><span class="p">,</span> <span class="n">curr_match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_var_ranges</span> <span class="o">=</span> <span class="n">KVM_NR_VAR_MTRR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="cm">/* Make end inclusive end, instead of exclusive */</span>
	<span class="n">end</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Look in fixed ranges. Just return the type as per start */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">have_fixed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mh">0x100000</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mh">0x80000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">fixed_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mh">0xC0000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">+=</span> <span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="mh">0x80000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">fixed_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mh">0x1000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">+=</span> <span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="mh">0xC0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">fixed_ranges</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look in variable ranges</span>
<span class="cm">	 * Look of multiple ranges matching this address and pick type</span>
<span class="cm">	 * as per MTRR precedence</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">def_type</span><span class="p">;</span>

	<span class="n">prev_match</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_var_ranges</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">start_state</span><span class="p">,</span> <span class="n">end_state</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask_lo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span>
		       <span class="p">(</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_lo</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span>
		       <span class="p">(</span><span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask_lo</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">);</span>

		<span class="n">start_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
		<span class="n">end_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_state</span> <span class="o">!=</span> <span class="n">end_state</span><span class="p">)</span>
			<span class="k">return</span> <span class="mh">0xFE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">curr_match</span> <span class="o">=</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">var_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_lo</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_match</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev_match</span> <span class="o">=</span> <span class="n">curr_match</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_UNCACHABLE</span> <span class="o">||</span>
		    <span class="n">curr_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_UNCACHABLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">MTRR_TYPE_UNCACHABLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">prev_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_WRBACK</span> <span class="o">&amp;&amp;</span>
		     <span class="n">curr_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_WRTHROUGH</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">prev_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_WRTHROUGH</span> <span class="o">&amp;&amp;</span>
		     <span class="n">curr_match</span> <span class="o">==</span> <span class="n">MTRR_TYPE_WRBACK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">prev_match</span> <span class="o">=</span> <span class="n">MTRR_TYPE_WRTHROUGH</span><span class="p">;</span>
			<span class="n">curr_match</span> <span class="o">=</span> <span class="n">MTRR_TYPE_WRTHROUGH</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev_match</span> <span class="o">!=</span> <span class="n">curr_match</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">MTRR_TYPE_UNCACHABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev_match</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">prev_match</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mtrr_state</span><span class="o">-&gt;</span><span class="n">def_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u8</span> <span class="nf">kvm_get_guest_memory_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">mtrr</span><span class="p">;</span>

	<span class="n">mtrr</span> <span class="o">=</span> <span class="n">get_mtrr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mtrr_state</span><span class="p">,</span> <span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtrr</span> <span class="o">==</span> <span class="mh">0xfe</span> <span class="o">||</span> <span class="n">mtrr</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">mtrr</span> <span class="o">=</span> <span class="n">MTRR_TYPE_WRBACK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mtrr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_get_guest_memory_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__kvm_unsync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_kvm_mmu_unsync_page</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_unsync</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">unsync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">kvm_mmu_mark_parents_unsync</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_unsync_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>  <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_gfn_indirect_valid_sp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">);</span>
		<span class="n">__kvm_unsync_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_need_write_protect</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">can_unsync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_unsync</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">for_each_gfn_indirect_valid_sp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_unsync</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_unsync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">unsync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">need_unsync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_unsync</span><span class="p">)</span>
		<span class="n">kvm_unsync_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="n">pte_access</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_fault</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">write_fault</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		    <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">speculative</span><span class="p">,</span>
		    <span class="n">bool</span> <span class="n">can_unsync</span><span class="p">,</span> <span class="n">bool</span> <span class="n">host_writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">spte</span><span class="p">,</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_mmio_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">pte_access</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spte</span> <span class="o">=</span> <span class="n">PT_PRESENT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">speculative</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_accessed_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_EXEC_MASK</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_x_mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_nx_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_USER_MASK</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">shadow_user_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">PT_PAGE_SIZE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tdp_enabled</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_mt_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
			<span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_writable</span><span class="p">)</span>
		<span class="n">spte</span> <span class="o">|=</span> <span class="n">SPTE_HOST_WRITEABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pte_access</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ACC_WRITE_MASK</span><span class="p">;</span>

	<span class="n">spte</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span> <span class="o">&amp;&amp;</span> <span class="n">write_fault</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_write_protection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">user_fault</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">has_wrprotected_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">drop_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spte</span> <span class="o">|=</span> <span class="n">PT_WRITABLE_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PT_USER_MASK</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we converted a user page to a kernel page,</span>
<span class="cm">			 * so that the kernel can write to it when cr0.wp=0,</span>
<span class="cm">			 * then we should prevent the kernel from executing it</span>
<span class="cm">			 * if SMEP is enabled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_SMEP</span><span class="p">))</span>
				<span class="n">spte</span> <span class="o">|=</span> <span class="n">PT64_NX_MASK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Optimization: for pte sync, if spte was writable the hash</span>
<span class="cm">		 * lookup is unnecessary (and expensive). Write protection</span>
<span class="cm">		 * is responsibility of mmu_get_page / kvm_sync_page.</span>
<span class="cm">		 * Same reasoning can be applied to dirty page accounting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_unsync</span> <span class="o">&amp;&amp;</span> <span class="n">is_writable_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">set_pte</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mmu_need_write_protect</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">can_unsync</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: found shadow page for %llx, marking ro</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pte_access</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ACC_WRITE_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
				<span class="n">spte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PT_WRITABLE_MASK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">)</span>
		<span class="n">mark_page_dirty</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

<span class="nl">set_pte:</span>
	<span class="n">mmu_spte_update</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we overwrite a writable spte with a read-only one we</span>
<span class="cm">	 * should flush remote TLBs. Otherwise rmap_write_protect</span>
<span class="cm">	 * will find a read-only spte, even though the writable spte</span>
<span class="cm">	 * might be cached on a CPU&#39;s TLB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_set_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="n">pt_access</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pte_access</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">user_fault</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write_fault</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">emulate</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			 <span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">speculative</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="n">host_writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">was_rmapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rmap_count</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: spte %llx access %x write_fault %d&quot;</span>
		 <span class="s">&quot; user_fault %d gfn %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">pt_access</span><span class="p">,</span>
		 <span class="n">write_fault</span><span class="p">,</span> <span class="n">user_fault</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_rmap_spte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we overwrite a PTE page pointer with a 2MB PMD, unlink</span>
<span class="cm">		 * the parent of the now unreachable PTE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">sptep</span><span class="p">;</span>

			<span class="n">child</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">);</span>
			<span class="n">drop_parent_pte</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
			<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">!=</span> <span class="n">spte_to_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;hfn old %llx new %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">spte_to_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">),</span> <span class="n">pfn</span><span class="p">);</span>
			<span class="n">drop_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
			<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">was_rmapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="n">pte_access</span><span class="p">,</span> <span class="n">user_fault</span><span class="p">,</span> <span class="n">write_fault</span><span class="p">,</span>
		      <span class="n">level</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">speculative</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
		      <span class="n">host_writable</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_fault</span><span class="p">)</span>
			<span class="o">*</span><span class="n">emulate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">emulate</span><span class="p">))</span>
		<span class="o">*</span><span class="n">emulate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: setting spte %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">sptep</span><span class="p">);</span>
	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;instantiating %s PTE (%s) at %llx (%llx) addr %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">)</span><span class="o">?</span> <span class="s">&quot;2MB&quot;</span> <span class="o">:</span> <span class="s">&quot;4kB&quot;</span><span class="p">,</span>
		 <span class="o">*</span><span class="n">sptep</span> <span class="o">&amp;</span> <span class="n">PT_PRESENT_MASK</span> <span class="o">?</span><span class="s">&quot;RW&quot;</span><span class="o">:</span><span class="s">&quot;R&quot;</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
		 <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_rmapped</span> <span class="o">&amp;&amp;</span> <span class="n">is_large_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span>
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">lpages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_header_update_slot</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_rmapped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rmap_count</span> <span class="o">=</span> <span class="n">rmap_add</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmap_count</span> <span class="o">&gt;</span> <span class="n">RMAP_RECYCLE_THRESHOLD</span><span class="p">)</span>
				<span class="n">rmap_recycle</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nonpaging_new_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">pfn_t</span> <span class="nf">pte_prefetch_gfn_to_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">no_dirty_log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hva</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">gfn_to_memslot_dirty_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">no_dirty_log</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">fault_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hva</span> <span class="o">=</span> <span class="n">gfn_to_hva_memslot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hva_to_pfn_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">hva</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">direct_pte_prefetch_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">PTE_PREFETCH_NUM</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">access</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">access</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>

	<span class="n">gfn</span> <span class="o">=</span> <span class="n">kvm_mmu_page_get_gfn</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gfn_to_memslot_dirty_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span> <span class="o">&amp;</span> <span class="n">ACC_WRITE_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gfn_to_page_many_atomic</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">gfn</span><span class="o">++</span><span class="p">,</span> <span class="n">start</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mmu_set_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span>
			     <span class="n">access</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			     <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span>
			     <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__direct_pte_prefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">direct</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">sptep</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PTE_PREFETCH_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spte</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTE_PREFETCH_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">spte</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">spte</span><span class="p">)</span> <span class="o">||</span> <span class="n">spte</span> <span class="o">==</span> <span class="n">sptep</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">direct_pte_prefetch_many</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">spte</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">direct_pte_prefetch</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since it&#39;s no accessed bit on EPT, it&#39;s no way to</span>
<span class="cm">	 * distinguish between actually accessed translations</span>
<span class="cm">	 * and prefetched, so disable pte prefetch if EPT is</span>
<span class="cm">	 * enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shadow_accessed_mask</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">sptep</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__direct_pte_prefetch</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sptep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__direct_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">map_writable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">prefault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="n">iterator</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">emulate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">pseudo_gfn</span><span class="p">;</span>

	<span class="n">for_each_shadow_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">gfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">iterator</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">pte_access</span> <span class="o">=</span> <span class="n">ACC_ALL</span><span class="p">;</span>

			<span class="n">mmu_set_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iterator</span><span class="p">.</span><span class="n">sptep</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="n">pte_access</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emulate</span><span class="p">,</span>
				     <span class="n">level</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">);</span>
			<span class="n">direct_pte_prefetch</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">iterator</span><span class="p">.</span><span class="n">sptep</span><span class="p">);</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">pf_fixed</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="o">*</span><span class="n">iterator</span><span class="p">.</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>

			<span class="n">base_addr</span> <span class="o">&amp;=</span> <span class="n">PT64_LVL_ADDR_MASK</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
			<span class="n">pseudo_gfn</span> <span class="o">=</span> <span class="n">base_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">pseudo_gfn</span><span class="p">,</span> <span class="n">iterator</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
					      <span class="n">iterator</span><span class="p">.</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					      <span class="mi">1</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="n">iterator</span><span class="p">.</span><span class="n">sptep</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;nonpaging_map: ENOMEM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">mmu_spte_set</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">sptep</span><span class="p">,</span>
				     <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">)</span>
				     <span class="o">|</span> <span class="n">PT_PRESENT_MASK</span> <span class="o">|</span> <span class="n">PT_WRITABLE_MASK</span>
				     <span class="o">|</span> <span class="n">shadow_user_mask</span> <span class="o">|</span> <span class="n">shadow_x_mask</span>
				     <span class="o">|</span> <span class="n">shadow_accessed_mask</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">emulate</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_send_hwpoison_signal</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span>	<span class="o">=</span> <span class="n">SIGBUS</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span>	<span class="o">=</span> <span class="n">BUS_MCEERR_AR</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_addr_lsb</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">send_sig_info</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_handle_bad_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hwpoison_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_send_hwpoison_signal</span><span class="p">(</span><span class="n">gfn_to_hva</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">),</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transparent_hugepage_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="n">gfn_t</span> <span class="o">*</span><span class="n">gfnp</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="o">*</span><span class="n">pfnp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">levelp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span> <span class="o">=</span> <span class="o">*</span><span class="n">pfnp</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="o">*</span><span class="n">gfnp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="o">*</span><span class="n">levelp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if it&#39;s a transparent hugepage. If this would be an</span>
<span class="cm">	 * hugetlbfs page, level wouldn&#39;t be set to</span>
<span class="cm">	 * PT_PAGE_TABLE_LEVEL and there would be no adjustment done</span>
<span class="cm">	 * here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_error_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kvm_is_mmio_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">PageTransCompound</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">has_wrprotected_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * mmu_notifier_retry was successful and we hold the</span>
<span class="cm">		 * mmu_lock here, so the pmd can&#39;t become splitting</span>
<span class="cm">		 * from under us, and in turn</span>
<span class="cm">		 * __split_huge_page_refcount() can&#39;t run from under</span>
<span class="cm">		 * us and we can safely transfer the refcount from</span>
<span class="cm">		 * PG_tail to PG_head as we switch the pfn to tail to</span>
<span class="cm">		 * head.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">levelp</span> <span class="o">=</span> <span class="n">level</span> <span class="o">=</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">((</span><span class="n">gfn</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
			<span class="o">*</span><span class="n">gfnp</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
			<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="n">pfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
			<span class="n">kvm_get_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
			<span class="o">*</span><span class="n">pfnp</span> <span class="o">=</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mmu_invalid_pfn</span><span class="p">(</span><span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">is_invalid_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">handle_abnormal_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
				<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">access</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* The pfn is invalid, report the error! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_invalid_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret_val</span> <span class="o">=</span> <span class="n">kvm_handle_bad_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_noslot_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span>
		<span class="n">vcpu_cache_mmio_info</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">try_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			 <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nonpaging_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="n">prefault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">force_pt_level</span><span class="p">;</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu_seq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">map_writable</span><span class="p">;</span>

	<span class="n">force_pt_level</span> <span class="o">=</span> <span class="n">mapping_level_dirty_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">force_pt_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">mapping_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This path builds a PAE pagetable - so we can map</span>
<span class="cm">		 * 2mb pages at maximum. Therefore check if the level</span>
<span class="cm">		 * is larger than that.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">)</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">PT_DIRECTORY_LEVEL</span><span class="p">;</span>

		<span class="n">gfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">;</span>

	<span class="n">mmu_seq</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_writable</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle_abnormal_pfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_notifier_retry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mmu_seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">force_pt_level</span><span class="p">))</span>
		<span class="n">transparent_hugepage_adjust</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__direct_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span>
			 <span class="n">prefault</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>


	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_free_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span> <span class="o">||</span>
	     <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">;</span>

		<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="o">--</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">invalid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
			<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">&amp;=</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">;</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="o">--</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">invalid</span><span class="p">)</span>
				<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_check_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">root_gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_is_visible_gfn</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">root_gfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TRIPLE_FAULT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_direct_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">,</span>
				      <span class="mi">1</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
			<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span>
					      <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">,</span>
					      <span class="n">PT32_ROOT_LEVEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
			<span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span> <span class="o">|</span> <span class="n">PT_PRESENT_MASK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_shadow_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pdptr</span><span class="p">,</span> <span class="n">pm_mask</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">root_gfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">root_gfn</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">get_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_check_root</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_gfn</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we shadow a long mode page table? If so we need to</span>
<span class="cm">	 * write-protect the guests page table root.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_gfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">,</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We shadow a 32 bit page table. This may be a legacy 2-level</span>
<span class="cm">	 * or a PAE 3-level page table. In either case we need to be aware that</span>
<span class="cm">	 * the shadow page table may be a PAE or a long mode page table.</span>
<span class="cm">	 */</span>
	<span class="n">pm_mask</span> <span class="o">=</span> <span class="n">PT_PRESENT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span>
		<span class="n">pm_mask</span> <span class="o">|=</span> <span class="n">PT_ACCESSED_MASK</span> <span class="o">|</span> <span class="n">PT_WRITABLE_MASK</span> <span class="o">|</span> <span class="n">PT_USER_MASK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">==</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdptr</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">get_pdptr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_present_gpte</span><span class="p">(</span><span class="n">pdptr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">root_gfn</span> <span class="o">=</span> <span class="n">pdptr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mmu_check_root</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_gfn</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">kvm_mmu_get_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_gfn</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">,</span>
				      <span class="n">PT32_ROOT_LEVEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">ACC_ALL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">root_count</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span> <span class="o">|</span> <span class="n">pm_mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we shadow a 32 bit page table with a long mode page</span>
<span class="cm">	 * table we enter this path.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">shadow_root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">lm_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The additional page necessary for this is only</span>
<span class="cm">			 * allocated on demand.</span>
<span class="cm">			 */</span>

			<span class="n">u64</span> <span class="o">*</span><span class="n">lm_root</span><span class="p">;</span>

			<span class="n">lm_root</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lm_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">lm_root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">)</span> <span class="o">|</span> <span class="n">pm_mask</span><span class="p">;</span>

			<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">lm_root</span> <span class="o">=</span> <span class="n">lm_root</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">lm_root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mmu_alloc_direct_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">mmu_alloc_shadow_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_sync_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vcpu_clear_mmio_info</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">~</span><span class="mi">0ul</span><span class="p">);</span>
	<span class="n">kvm_mmu_audit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">AUDIT_PRE_SYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_level</span> <span class="o">==</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">;</span>
		<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">mmu_sync_children</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="n">kvm_mmu_audit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">AUDIT_POST_SYNC</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpa_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">&amp;=</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">;</span>
			<span class="n">sp</span> <span class="o">=</span> <span class="n">page_header</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="n">mmu_sync_children</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kvm_mmu_audit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">AUDIT_POST_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_sync_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">mmu_sync_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gpa_t</span> <span class="nf">nonpaging_gva_to_gpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">vaddr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">access</span><span class="p">,</span> <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span>
		<span class="n">exception</span><span class="o">-&gt;</span><span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gpa_t</span> <span class="nf">nonpaging_gva_to_gpa_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">vaddr</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">access</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span>
		<span class="n">exception</span><span class="o">-&gt;</span><span class="n">error_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nested_mmu</span><span class="p">.</span><span class="n">translate_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">quickly_check_mmio_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">direct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vcpu_match_mmio_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vcpu_match_mmio_gva</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * On direct hosts, the last spte is only allows two states</span>
<span class="cm"> * for mmio page fault:</span>
<span class="cm"> *   - It is the mmio spte</span>
<span class="cm"> *   - It is zapped or it is being zapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This function completely checks the spte when the last spte</span>
<span class="cm"> * is not the mmio spte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_direct_spte_mmio_pf</span><span class="p">(</span><span class="n">u64</span> <span class="n">spte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__check_direct_spte_mmio_pf</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">walk_shadow_page_get_mmio_spte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="n">iterator</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">spte</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">;</span>

	<span class="n">walk_shadow_page_lockless_begin</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">for_each_shadow_entry_lockless</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">spte</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">walk_shadow_page_lockless_end</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If it is a real mmio page fault, return 1 and emulat the instruction</span>
<span class="cm"> * directly, return 0 to let CPU fault again on the address, -1 is</span>
<span class="cm"> * returned if bug is detected.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">handle_mmio_page_fault_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">direct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">spte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quickly_check_mmio_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">direct</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spte</span> <span class="o">=</span> <span class="n">walk_shadow_page_get_mmio_spte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">get_mmio_spte_gfn</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">access</span> <span class="o">=</span> <span class="n">get_mmio_spte_access</span><span class="p">(</span><span class="n">spte</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">direct</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">trace_handle_mmio_page_fault</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
		<span class="n">vcpu_cache_mmio_info</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s ok if the gva is remapped by other cpus on shadow guest,</span>
<span class="cm">	 * it&#39;s a BUG if the gfn is not a mmio page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">check_direct_spte_mmio_pf</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the page table is zapped by other cpus, let CPU fault again on</span>
<span class="cm">	 * the address.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">handle_mmio_page_fault_common</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_mmio_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">bool</span> <span class="n">direct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mmio_page_fault_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">direct</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nonpaging_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">bool</span> <span class="n">prefault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: gva %lx error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_RSVD_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_mmio_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">));</span>

	<span class="n">gfn</span> <span class="o">=</span> <span class="n">gva</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonpaging_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
			     <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kvm_arch_setup_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_arch_async_pf</span> <span class="n">arch</span><span class="p">;</span>

	<span class="n">arch</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">apf</span><span class="p">.</span><span class="n">id</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">vcpu_id</span><span class="p">;</span>
	<span class="n">arch</span><span class="p">.</span><span class="n">gfn</span> <span class="o">=</span> <span class="n">gfn</span><span class="p">;</span>
	<span class="n">arch</span><span class="p">.</span><span class="n">direct_map</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">;</span>
	<span class="n">arch</span><span class="p">.</span><span class="n">cr3</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">get_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kvm_setup_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">can_do_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">irqchip_in_kernel</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">kvm_event_needs_reinjection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">interrupt_allowed</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">try_async_pf</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span>
			 <span class="n">gva_t</span> <span class="n">gva</span><span class="p">,</span> <span class="n">pfn_t</span> <span class="o">*</span><span class="n">pfn</span><span class="p">,</span> <span class="n">bool</span> <span class="n">write</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">async</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">gfn_to_pfn_async</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">async</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* *pfn has correct page already */</span>

	<span class="n">put_page</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="o">*</span><span class="n">pfn</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prefault</span> <span class="o">&amp;&amp;</span> <span class="n">can_do_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_kvm_try_async_get_page</span><span class="p">(</span><span class="n">gva</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_find_async_pf_gfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">trace_kvm_async_pf_doublefault</span><span class="p">(</span><span class="n">gva</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
			<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_APF_HALT</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kvm_arch_setup_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="n">gfn</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">gfn_to_pfn_prot</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tdp_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">prefault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pfn_t</span> <span class="n">pfn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">force_pt_level</span><span class="p">;</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmu_seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_WRITE_MASK</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">map_writable</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">PFERR_RSVD_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_mmio_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">force_pt_level</span> <span class="o">=</span> <span class="n">mapping_level_dirty_bitmap</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">force_pt_level</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">mapping_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gfn</span><span class="p">);</span>
		<span class="n">gfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">KVM_PAGES_PER_HPAGE</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">;</span>

	<span class="n">mmu_seq</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_seq</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_async_pf</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">prefault</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_writable</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle_abnormal_pfn</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">ACC_ALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_notifier_retry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">mmu_seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">kvm_mmu_free_some_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">force_pt_level</span><span class="p">))</span>
		<span class="n">transparent_hugepage_adjust</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__direct_map</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">map_writable</span><span class="p">,</span>
			 <span class="n">level</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">prefault</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">kvm_release_pfn_clean</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nonpaging_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_free_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nonpaging_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">new_cr3</span> <span class="o">=</span> <span class="n">nonpaging_new_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">page_fault</span> <span class="o">=</span> <span class="n">nonpaging_page_fault</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">nonpaging_gva_to_gpa</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">nonpaging_free</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">sync_page</span> <span class="o">=</span> <span class="n">nonpaging_sync_page</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">invlpg</span> <span class="o">=</span> <span class="n">nonpaging_invlpg</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">update_pte</span> <span class="o">=</span> <span class="n">nonpaging_update_pte</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span> <span class="o">=</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">direct_map</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">tlb_flush</span><span class="p">;</span>
	<span class="n">kvm_make_request</span><span class="p">(</span><span class="n">KVM_REQ_TLB_FLUSH</span><span class="p">,</span> <span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">paging_new_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: cr3 %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="n">mmu_free_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_cr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kvm_read_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inject_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">x86_exception</span> <span class="o">*</span><span class="n">fault</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">inject_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fault</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">paging_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nonpaging_free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_rsvd_bits_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">mmu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gpte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit7</span><span class="p">;</span>

	<span class="n">bit7</span> <span class="o">=</span> <span class="p">(</span><span class="n">gpte</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">gpte</span> <span class="o">&amp;</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="n">bit7</span><span class="p">][</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">sync_mmio_spte</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn_t</span> <span class="n">gfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">access</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="o">*</span><span class="n">nr_present</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_mmio_spte</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gfn</span> <span class="o">!=</span> <span class="n">get_mmio_spte_gfn</span><span class="p">(</span><span class="o">*</span><span class="n">sptep</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mmu_spte_clear_no_track</span><span class="p">(</span><span class="n">sptep</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="p">(</span><span class="o">*</span><span class="n">nr_present</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mark_mmio_spte</span><span class="p">(</span><span class="n">sptep</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">access</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PTTYPE 64</span>
<span class="cp">#include &quot;paging_tmpl.h&quot;</span>
<span class="cp">#undef PTTYPE</span>

<span class="cp">#define PTTYPE 32</span>
<span class="cp">#include &quot;paging_tmpl.h&quot;</span>
<span class="cp">#undef PTTYPE</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_rsvds_bits_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxphyaddr</span> <span class="o">=</span> <span class="n">cpuid_maxphyaddr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">exb_bit_rsvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">)</span>
		<span class="n">exb_bit_rsvd</span> <span class="o">=</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">63</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PT32_ROOT_LEVEL</span>:
		<span class="cm">/* no rsvd bits for 2 level 4K page table entries */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_pse</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_cpuid_PSE36</span><span class="p">())</span>
			<span class="cm">/* 36bits PSE 4MB page */</span>
			<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* 32 bits PSE 4MB page */</span>
			<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PT32E_ROOT_LEVEL</span>:
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">63</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* PDPTE */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>	<span class="cm">/* PDE */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span> 	<span class="cm">/* PTE */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">62</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>		<span class="cm">/* large page */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PT64_ROOT_LEVEL</span>:
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">|</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">|</span> <span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exb_bit_rsvd</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="n">maxphyaddr</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">rsvd_bits</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>		<span class="cm">/* large page */</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">rsvd_bits_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">paging64_init_context_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="n">is_nx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">));</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">new_cr3</span> <span class="o">=</span> <span class="n">paging_new_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">page_fault</span> <span class="o">=</span> <span class="n">paging64_page_fault</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging64_gva_to_gpa</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">sync_page</span> <span class="o">=</span> <span class="n">paging64_sync_page</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">invlpg</span> <span class="o">=</span> <span class="n">paging64_invlpg</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">update_pte</span> <span class="o">=</span> <span class="n">paging64_update_pte</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">paging_free</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">direct_map</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">paging64_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">paging64_init_context_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">paging32_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT32_ROOT_LEVEL</span><span class="p">;</span>

	<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="n">context</span><span class="o">-&gt;</span><span class="n">new_cr3</span> <span class="o">=</span> <span class="n">paging_new_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">page_fault</span> <span class="o">=</span> <span class="n">paging32_page_fault</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging32_gva_to_gpa</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">paging_free</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">sync_page</span> <span class="o">=</span> <span class="n">paging32_sync_page</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">invlpg</span> <span class="o">=</span> <span class="n">paging32_invlpg</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">update_pte</span> <span class="o">=</span> <span class="n">paging32_update_pte</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span> <span class="o">=</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">direct_map</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">paging32E_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">paging64_init_context_common</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_kvm_tdp_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">;</span>

	<span class="n">context</span><span class="o">-&gt;</span><span class="n">base_role</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">new_cr3</span> <span class="o">=</span> <span class="n">nonpaging_new_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">page_fault</span> <span class="o">=</span> <span class="n">tdp_page_fault</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">nonpaging_free</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">sync_page</span> <span class="o">=</span> <span class="n">nonpaging_sync_page</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">invlpg</span> <span class="o">=</span> <span class="n">nonpaging_invlpg</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">update_pte</span> <span class="o">=</span> <span class="n">nonpaging_update_pte</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">get_tdp_level</span><span class="p">();</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">direct_map</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">set_cr3</span> <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_tdp_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">get_cr3</span> <span class="o">=</span> <span class="n">get_cr3</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">get_pdptr</span> <span class="o">=</span> <span class="n">kvm_pdptr_read</span><span class="p">;</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">inject_page_fault</span> <span class="o">=</span> <span class="n">kvm_inject_page_fault</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">nonpaging_gva_to_gpa</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="n">is_nx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging64_gva_to_gpa</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="n">is_nx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging64_gva_to_gpa</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT32_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging32_gva_to_gpa</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_init_shadow_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">smep</span> <span class="o">=</span> <span class="n">kvm_read_cr4_bits</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">X86_CR4_SMEP</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">nonpaging_init_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">paging64_init_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">paging32E_init_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">paging32_init_context</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">=</span> <span class="o">!!</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">.</span><span class="n">cr0_wp</span>  <span class="o">=</span> <span class="n">is_write_protection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">.</span><span class="n">smep_andnot_wp</span>
		<span class="o">=</span> <span class="n">smep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_write_protection</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_init_shadow_mmu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_kvm_softmmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">kvm_init_shadow_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">set_cr3</span>           <span class="o">=</span> <span class="n">kvm_x86_ops</span><span class="o">-&gt;</span><span class="n">set_cr3</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">get_cr3</span>           <span class="o">=</span> <span class="n">get_cr3</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">get_pdptr</span>         <span class="o">=</span> <span class="n">kvm_pdptr_read</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span><span class="o">-&gt;</span><span class="n">inject_page_fault</span> <span class="o">=</span> <span class="n">kvm_inject_page_fault</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_kvm_nested_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu</span> <span class="o">*</span><span class="n">g_context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nested_mmu</span><span class="p">;</span>

	<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">get_cr3</span>           <span class="o">=</span> <span class="n">get_cr3</span><span class="p">;</span>
	<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">get_pdptr</span>         <span class="o">=</span> <span class="n">kvm_pdptr_read</span><span class="p">;</span>
	<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">inject_page_fault</span> <span class="o">=</span> <span class="n">kvm_inject_page_fault</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that arch.mmu.gva_to_gpa translates l2_gva to l1_gpa. The</span>
<span class="cm">	 * translation of l2_gpa to l1_gpa addresses is done using the</span>
<span class="cm">	 * arch.nested_mmu.gva_to_gpa function. Basically the gva_to_gpa</span>
<span class="cm">	 * functions between mmu and nested_mmu are swapped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_paging</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">nonpaging_gva_to_gpa_nested</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_long_mode</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="n">is_nx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT64_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">g_context</span><span class="p">);</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging64_gva_to_gpa_nested</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="n">is_nx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT32E_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">g_context</span><span class="p">);</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging64_gva_to_gpa_nested</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">root_level</span> <span class="o">=</span> <span class="n">PT32_ROOT_LEVEL</span><span class="p">;</span>
		<span class="n">reset_rsvds_bits_mask</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">g_context</span><span class="p">);</span>
		<span class="n">g_context</span><span class="o">-&gt;</span><span class="n">gva_to_gpa</span> <span class="o">=</span> <span class="n">paging32_gva_to_gpa_nested</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_kvm_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_is_nested</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">init_kvm_nested_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tdp_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">init_kvm_tdp_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">init_kvm_softmmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_kvm_mmu</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">))</span>
		<span class="cm">/* mmu.free() should set root_hpa = INVALID_PAGE */</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_reset_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_kvm_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">init_kvm_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_reset_context</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_topup_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">mmu_alloc_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="n">mmu_sync_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* set_cr3() should ensure TLB has been flushed */</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">set_cr3</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_load</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_unload</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_free_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_unload</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_pte_write_new_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_pde_zapped</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_pte_updated</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">update_pte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">need_remote_flush</span><span class="p">(</span><span class="n">u64</span> <span class="n">old</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old</span> <span class="o">^</span> <span class="n">new</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PT64_BASE_ADDR_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">^=</span> <span class="n">PT64_NX_MASK</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">^=</span> <span class="n">PT64_NX_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">new</span> <span class="o">&amp;</span> <span class="n">PT64_PERM_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_pte_write_flush_tlb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">zap_page</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">remote_flush</span><span class="p">,</span> <span class="n">bool</span> <span class="n">local_flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zap_page</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remote_flush</span><span class="p">)</span>
		<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">local_flush</span><span class="p">)</span>
		<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">mmu_pte_write_fetch_gpte</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="o">*</span><span class="n">gpa</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">gentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume that the pte write on a page table of the same type</span>
<span class="cm">	 * as the current vcpu paging mode since we update the sptes only</span>
<span class="cm">	 * when they have the same mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_pae</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Handle a 32-bit guest writing two halves of a 64-bit gpte */</span>
		<span class="o">*</span><span class="n">gpa</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">gpa_t</span><span class="p">)</span><span class="mi">7</span><span class="p">;</span>
		<span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_read_guest</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">*</span><span class="n">gpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gentry</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">gentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gentry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">gentry</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">new</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">gentry</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">new</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">gentry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">gentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we&#39;re seeing too many writes to a page, it may no longer be a page table,</span>
<span class="cm"> * or we may be forking, in which case it is better to unmap the page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">detect_write_flooding</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Skip write-flooding detected for the sp whose level is 1, because</span>
<span class="cm">	 * it can become unsync, then the guest page is not write-protected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT_PAGE_TABLE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">write_flooding_count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Misaligned accesses are too much trouble to fix up; also, they usually</span>
<span class="cm"> * indicate a page is not used as a page table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">detect_write_misaligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pte_size</span><span class="p">,</span> <span class="n">misaligned</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;misaligned: gpa %llx bytes %d role %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">gpa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="n">pte_size</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sometimes, the OS only writes the last one bytes to update status</span>
<span class="cm">	 * bits, for example, in linux, andb instruction is used in clear_bit().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">misaligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">^</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pte_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">misaligned</span> <span class="o">|=</span> <span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">misaligned</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="o">*</span><span class="nf">get_written_sptes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nspte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">quadrant</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">spte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">page_offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">;</span>
	<span class="o">*</span><span class="n">nspte</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">cr4_pae</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 32-&gt;64 */</span>
		<span class="cm">/*</span>
<span class="cm">		 * A 32-bit pde maps 4MB while the shadow pdes map</span>
<span class="cm">		 * only 2MB.  So we need to double the offset again</span>
<span class="cm">		 * and zap two pdes instead of one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">PT32_ROOT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span> <span class="cm">/* kill rounding error */</span>
			<span class="n">page_offset</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">nspte</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">quadrant</span> <span class="o">=</span> <span class="n">page_offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">page_offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">quadrant</span> <span class="o">!=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">quadrant</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">[</span><span class="n">page_offset</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">spte</span><span class="p">)];</span>
	<span class="k">return</span> <span class="n">spte</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_pte_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfn_t</span> <span class="n">gfn</span> <span class="o">=</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">entry</span><span class="p">,</span> <span class="n">gentry</span><span class="p">,</span> <span class="o">*</span><span class="n">spte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npte</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">remote_flush</span><span class="p">,</span> <span class="n">local_flush</span><span class="p">,</span> <span class="n">zap_page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have indirect shadow pages, it means no page is</span>
<span class="cm">	 * write-protected, so we can exit simply.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">indirect_shadow_pages</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">zap_page</span> <span class="o">=</span> <span class="n">remote_flush</span> <span class="o">=</span> <span class="n">local_flush</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">pgprintk</span><span class="p">(</span><span class="s">&quot;%s: gpa %llx bytes %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">gentry</span> <span class="o">=</span> <span class="n">mmu_pte_write_fetch_gpte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpa</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to care whether allocation memory is successful</span>
<span class="cm">	 * or not since pte prefetch is skiped if it does not have</span>
<span class="cm">	 * enough objects in the cache.</span>
<span class="cm">	 */</span>
	<span class="n">mmu_topup_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_pte_write</span><span class="p">;</span>
	<span class="n">kvm_mmu_audit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">AUDIT_PRE_PTE_WRITE</span><span class="p">);</span>

	<span class="n">mask</span><span class="p">.</span><span class="n">cr0_wp</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">cr4_pae</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">nxe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">for_each_gfn_indirect_valid_sp</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">gfn</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">detect_write_misaligned</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">||</span>
		      <span class="n">detect_write_flooding</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">zap_page</span> <span class="o">|=</span> <span class="o">!!</span><span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
			<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_flooded</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spte</span> <span class="o">=</span> <span class="n">get_written_sptes</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">npte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spte</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">local_flush</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">npte</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">spte</span><span class="p">;</span>
			<span class="n">mmu_page_zap_pte</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spte</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gentry</span> <span class="o">&amp;&amp;</span>
			      <span class="o">!</span><span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">^</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">base_role</span><span class="p">.</span><span class="n">word</span><span class="p">)</span>
			      <span class="o">&amp;</span> <span class="n">mask</span><span class="p">.</span><span class="n">word</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rmap_can_add</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
				<span class="n">mmu_pte_write_new_pte</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spte</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remote_flush</span> <span class="o">&amp;&amp;</span> <span class="n">need_remote_flush</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">spte</span><span class="p">))</span>
				<span class="n">remote_flush</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="o">++</span><span class="n">spte</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mmu_pte_write_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">zap_page</span><span class="p">,</span> <span class="n">remote_flush</span><span class="p">,</span> <span class="n">local_flush</span><span class="p">);</span>
	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">kvm_mmu_audit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">AUDIT_POST_PTE_WRITE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_unprotect_page_virt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpa_t</span> <span class="n">gpa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">gpa</span> <span class="o">=</span> <span class="n">kvm_mmu_gva_to_gpa_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kvm_mmu_unprotect_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">gpa</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_unprotect_page_virt</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__kvm_mmu_free_some_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">kvm_mmu_available_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">KVM_REFILL_PAGES</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

		<span class="n">sp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kvm_mmu_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmu_recycled</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_mmio_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">direct_map</span> <span class="o">||</span> <span class="n">mmu_is_nested</span><span class="p">(</span><span class="n">vcpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vcpu_match_mmio_gpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vcpu_match_mmio_gva</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">error_code</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">insn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insn_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">emulation_type</span> <span class="o">=</span> <span class="n">EMULTYPE_RETRY</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">emulation_result</span> <span class="n">er</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_mmio_page_fault</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">))</span>
		<span class="n">emulation_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">er</span> <span class="o">=</span> <span class="n">x86_emulate_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">cr2</span><span class="p">,</span> <span class="n">emulation_type</span><span class="p">,</span> <span class="n">insn</span><span class="p">,</span> <span class="n">insn_len</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">er</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EMULATE_DONE</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EMULATE_DO_MMIO</span>:
		<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">mmio_exits</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">EMULATE_FAIL</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_page_fault</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_invlpg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva_t</span> <span class="n">gva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">invlpg</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">gva</span><span class="p">);</span>
	<span class="n">kvm_mmu_flush_tlb</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="o">++</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">invlpg</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_invlpg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_enable_tdp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tdp_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_enable_tdp</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_disable_tdp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tdp_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_disable_tdp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">lm_root</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">lm_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.</span>
<span class="cm">	 * Therefore we need to allocate shadow page tables in the first</span>
<span class="cm">	 * 4GB of memory, which happens to fit the DMA32 zone.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">pae_root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">walk_mmu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">INVALID_PAGE</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">translate_gpa</span> <span class="o">=</span> <span class="n">translate_gpa</span><span class="p">;</span>
	<span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">nested_mmu</span><span class="p">.</span><span class="n">translate_gpa</span> <span class="o">=</span> <span class="n">translate_nested_gpa</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">alloc_mmu_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="p">.</span><span class="n">root_hpa</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">init_kvm_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_slot_remove_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u64</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot_bitmap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PT64_ENT_PER_PAGE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">||</span>
			      <span class="o">!</span><span class="n">is_last_spte</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">level</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_large_pte</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">drop_spte</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="o">--</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">lpages</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* avoid RMW */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_writable_pte</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="n">mmu_spte_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						<span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PT_WRITABLE_MASK</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kvm_flush_remote_tlbs</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_zap_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>

	<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kvm_mmu_remove_some_alloc_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">invalid_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">active_mmu_pages</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kvm_mmu_page</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">kvm_mmu_prepare_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">invalid_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm_freed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_to_scan</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_to_scan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">,</span> <span class="n">vm_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">invalid_list</span><span class="p">);</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvm_freed</span> <span class="o">&amp;&amp;</span> <span class="n">nr_to_scan</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">n_used_mmu_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kvm_mmu_remove_some_alloc_mmu_pages</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
			<span class="n">kvm_freed</span> <span class="o">=</span> <span class="n">kvm</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nr_to_scan</span><span class="o">--</span><span class="p">;</span>

		<span class="n">kvm_mmu_commit_zap_page</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">invalid_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>
		<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kvm_freed</span><span class="p">)</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_freed</span><span class="o">-&gt;</span><span class="n">vm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_list</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_total_used_mmu_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">shrinker</span> <span class="n">mmu_shrinker</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">shrink</span> <span class="o">=</span> <span class="n">mmu_shrink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">seeks</span> <span class="o">=</span> <span class="n">DEFAULT_SEEKS</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mmu_destroy_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_list_desc_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">pte_list_desc_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mmu_page_header_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">mmu_page_header_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_list_desc_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;pte_list_desc&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pte_list_desc</span><span class="p">),</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_list_desc_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">mmu_page_header_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;kvm_mmu_page_header&quot;</span><span class="p">,</span>
						  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_mmu_page</span><span class="p">),</span>
						  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmu_page_header_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_total_used_mmu_pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">register_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmu_shrinker</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">mmu_destroy_caches</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caculate mmu pages needed for kvm.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">kvm_mmu_calculate_mmu_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_mmu_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memslots</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_memory_slot</span> <span class="o">*</span><span class="n">memslot</span><span class="p">;</span>

	<span class="n">slots</span> <span class="o">=</span> <span class="n">kvm_memslots</span><span class="p">(</span><span class="n">kvm</span><span class="p">);</span>

	<span class="n">kvm_for_each_memslot</span><span class="p">(</span><span class="n">memslot</span><span class="p">,</span> <span class="n">slots</span><span class="p">)</span>
		<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">memslot</span><span class="o">-&gt;</span><span class="n">npages</span><span class="p">;</span>

	<span class="n">nr_mmu_pages</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">KVM_PERMILLE_MMU_PAGES</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">nr_mmu_pages</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nr_mmu_pages</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">KVM_MIN_ALLOC_MMU_PAGES</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_mmu_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_mmu_get_spte_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sptes</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvm_shadow_walk_iterator</span> <span class="n">iterator</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">spte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_sptes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">walk_shadow_page_lockless_begin</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">for_each_shadow_entry_lockless</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">spte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sptes</span><span class="p">[</span><span class="n">iterator</span><span class="p">.</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spte</span><span class="p">;</span>
		<span class="n">nr_sptes</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_shadow_present_pte</span><span class="p">(</span><span class="n">spte</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">walk_shadow_page_lockless_end</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_sptes</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kvm_mmu_get_spte_hierarchy</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

	<span class="n">destroy_kvm_mmu</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">free_mmu_pages</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">mmu_free_memory_caches</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kvm_mmu_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mmu_destroy_caches</span><span class="p">();</span>
	<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm_total_used_mmu_pages</span><span class="p">);</span>
	<span class="n">unregister_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmu_shrinker</span><span class="p">);</span>
	<span class="n">mmu_audit_disable</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
